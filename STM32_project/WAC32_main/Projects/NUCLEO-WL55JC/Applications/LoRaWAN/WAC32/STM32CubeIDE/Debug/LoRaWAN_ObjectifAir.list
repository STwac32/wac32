
LoRaWAN_ObjectifAir.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000138  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00010218  08000140  08000140  00010140  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000e54  08010358  08010358  00020358  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080111ac  080111ac  00030140  2**0
                  CONTENTS
  4 .ARM          00000008  080111ac  080111ac  000211ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080111b4  080111b4  00030140  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080111b4  080111b4  000211b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080111b8  080111b8  000211b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000140  20000000  080111bc  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001a4c  20000140  080112fc  00030140  2**2
                  ALLOC
 10 ._user_heap_stack 00000a04  20001b8c  080112fc  00031b8c  2**0
                  ALLOC
 11 .ARM.attributes 0000002a  00000000  00000000  00030140  2**0
                  CONTENTS, READONLY
 12 .debug_info   0007f6d3  00000000  00000000  0003016a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000fb1b  00000000  00000000  000af83d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    000260ca  00000000  00000000  000bf358  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00002ae8  00000000  00000000  000e5428  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00004a18  00000000  00000000  000e7f10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0002ce89  00000000  00000000  000ec928  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0004fd56  00000000  00000000  001197b1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    000e2b78  00000000  00000000  00169507  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000053  00000000  00000000  0024c07f  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00007f74  00000000  00000000  0024c0d4  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000140 <__do_global_dtors_aux>:
 8000140:	b510      	push	{r4, lr}
 8000142:	4c05      	ldr	r4, [pc, #20]	; (8000158 <__do_global_dtors_aux+0x18>)
 8000144:	7823      	ldrb	r3, [r4, #0]
 8000146:	b933      	cbnz	r3, 8000156 <__do_global_dtors_aux+0x16>
 8000148:	4b04      	ldr	r3, [pc, #16]	; (800015c <__do_global_dtors_aux+0x1c>)
 800014a:	b113      	cbz	r3, 8000152 <__do_global_dtors_aux+0x12>
 800014c:	4804      	ldr	r0, [pc, #16]	; (8000160 <__do_global_dtors_aux+0x20>)
 800014e:	f3af 8000 	nop.w
 8000152:	2301      	movs	r3, #1
 8000154:	7023      	strb	r3, [r4, #0]
 8000156:	bd10      	pop	{r4, pc}
 8000158:	20000140 	.word	0x20000140
 800015c:	00000000 	.word	0x00000000
 8000160:	08010340 	.word	0x08010340

08000164 <frame_dummy>:
 8000164:	b508      	push	{r3, lr}
 8000166:	4b03      	ldr	r3, [pc, #12]	; (8000174 <frame_dummy+0x10>)
 8000168:	b11b      	cbz	r3, 8000172 <frame_dummy+0xe>
 800016a:	4903      	ldr	r1, [pc, #12]	; (8000178 <frame_dummy+0x14>)
 800016c:	4803      	ldr	r0, [pc, #12]	; (800017c <frame_dummy+0x18>)
 800016e:	f3af 8000 	nop.w
 8000172:	bd08      	pop	{r3, pc}
 8000174:	00000000 	.word	0x00000000
 8000178:	20000144 	.word	0x20000144
 800017c:	08010340 	.word	0x08010340

08000180 <strlen>:
 8000180:	4603      	mov	r3, r0
 8000182:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000186:	2a00      	cmp	r2, #0
 8000188:	d1fb      	bne.n	8000182 <strlen+0x2>
 800018a:	1a18      	subs	r0, r3, r0
 800018c:	3801      	subs	r0, #1
 800018e:	4770      	bx	lr

08000190 <memchr>:
 8000190:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000194:	2a10      	cmp	r2, #16
 8000196:	db2b      	blt.n	80001f0 <memchr+0x60>
 8000198:	f010 0f07 	tst.w	r0, #7
 800019c:	d008      	beq.n	80001b0 <memchr+0x20>
 800019e:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001a2:	3a01      	subs	r2, #1
 80001a4:	428b      	cmp	r3, r1
 80001a6:	d02d      	beq.n	8000204 <memchr+0x74>
 80001a8:	f010 0f07 	tst.w	r0, #7
 80001ac:	b342      	cbz	r2, 8000200 <memchr+0x70>
 80001ae:	d1f6      	bne.n	800019e <memchr+0xe>
 80001b0:	b4f0      	push	{r4, r5, r6, r7}
 80001b2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80001b6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80001ba:	f022 0407 	bic.w	r4, r2, #7
 80001be:	f07f 0700 	mvns.w	r7, #0
 80001c2:	2300      	movs	r3, #0
 80001c4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80001c8:	3c08      	subs	r4, #8
 80001ca:	ea85 0501 	eor.w	r5, r5, r1
 80001ce:	ea86 0601 	eor.w	r6, r6, r1
 80001d2:	fa85 f547 	uadd8	r5, r5, r7
 80001d6:	faa3 f587 	sel	r5, r3, r7
 80001da:	fa86 f647 	uadd8	r6, r6, r7
 80001de:	faa5 f687 	sel	r6, r5, r7
 80001e2:	b98e      	cbnz	r6, 8000208 <memchr+0x78>
 80001e4:	d1ee      	bne.n	80001c4 <memchr+0x34>
 80001e6:	bcf0      	pop	{r4, r5, r6, r7}
 80001e8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001ec:	f002 0207 	and.w	r2, r2, #7
 80001f0:	b132      	cbz	r2, 8000200 <memchr+0x70>
 80001f2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001f6:	3a01      	subs	r2, #1
 80001f8:	ea83 0301 	eor.w	r3, r3, r1
 80001fc:	b113      	cbz	r3, 8000204 <memchr+0x74>
 80001fe:	d1f8      	bne.n	80001f2 <memchr+0x62>
 8000200:	2000      	movs	r0, #0
 8000202:	4770      	bx	lr
 8000204:	3801      	subs	r0, #1
 8000206:	4770      	bx	lr
 8000208:	2d00      	cmp	r5, #0
 800020a:	bf06      	itte	eq
 800020c:	4635      	moveq	r5, r6
 800020e:	3803      	subeq	r0, #3
 8000210:	3807      	subne	r0, #7
 8000212:	f015 0f01 	tst.w	r5, #1
 8000216:	d107      	bne.n	8000228 <memchr+0x98>
 8000218:	3001      	adds	r0, #1
 800021a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800021e:	bf02      	ittt	eq
 8000220:	3001      	addeq	r0, #1
 8000222:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000226:	3001      	addeq	r0, #1
 8000228:	bcf0      	pop	{r4, r5, r6, r7}
 800022a:	3801      	subs	r0, #1
 800022c:	4770      	bx	lr
 800022e:	bf00      	nop

08000230 <__aeabi_drsub>:
 8000230:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000234:	e002      	b.n	800023c <__adddf3>
 8000236:	bf00      	nop

08000238 <__aeabi_dsub>:
 8000238:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800023c <__adddf3>:
 800023c:	b530      	push	{r4, r5, lr}
 800023e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000242:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000246:	ea94 0f05 	teq	r4, r5
 800024a:	bf08      	it	eq
 800024c:	ea90 0f02 	teqeq	r0, r2
 8000250:	bf1f      	itttt	ne
 8000252:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000256:	ea55 0c02 	orrsne.w	ip, r5, r2
 800025a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800025e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000262:	f000 80e2 	beq.w	800042a <__adddf3+0x1ee>
 8000266:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800026a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800026e:	bfb8      	it	lt
 8000270:	426d      	neglt	r5, r5
 8000272:	dd0c      	ble.n	800028e <__adddf3+0x52>
 8000274:	442c      	add	r4, r5
 8000276:	ea80 0202 	eor.w	r2, r0, r2
 800027a:	ea81 0303 	eor.w	r3, r1, r3
 800027e:	ea82 0000 	eor.w	r0, r2, r0
 8000282:	ea83 0101 	eor.w	r1, r3, r1
 8000286:	ea80 0202 	eor.w	r2, r0, r2
 800028a:	ea81 0303 	eor.w	r3, r1, r3
 800028e:	2d36      	cmp	r5, #54	; 0x36
 8000290:	bf88      	it	hi
 8000292:	bd30      	pophi	{r4, r5, pc}
 8000294:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000298:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800029c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80002a0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002a4:	d002      	beq.n	80002ac <__adddf3+0x70>
 80002a6:	4240      	negs	r0, r0
 80002a8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002ac:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002b0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002b4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002b8:	d002      	beq.n	80002c0 <__adddf3+0x84>
 80002ba:	4252      	negs	r2, r2
 80002bc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002c0:	ea94 0f05 	teq	r4, r5
 80002c4:	f000 80a7 	beq.w	8000416 <__adddf3+0x1da>
 80002c8:	f1a4 0401 	sub.w	r4, r4, #1
 80002cc:	f1d5 0e20 	rsbs	lr, r5, #32
 80002d0:	db0d      	blt.n	80002ee <__adddf3+0xb2>
 80002d2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80002d6:	fa22 f205 	lsr.w	r2, r2, r5
 80002da:	1880      	adds	r0, r0, r2
 80002dc:	f141 0100 	adc.w	r1, r1, #0
 80002e0:	fa03 f20e 	lsl.w	r2, r3, lr
 80002e4:	1880      	adds	r0, r0, r2
 80002e6:	fa43 f305 	asr.w	r3, r3, r5
 80002ea:	4159      	adcs	r1, r3
 80002ec:	e00e      	b.n	800030c <__adddf3+0xd0>
 80002ee:	f1a5 0520 	sub.w	r5, r5, #32
 80002f2:	f10e 0e20 	add.w	lr, lr, #32
 80002f6:	2a01      	cmp	r2, #1
 80002f8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002fc:	bf28      	it	cs
 80002fe:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000302:	fa43 f305 	asr.w	r3, r3, r5
 8000306:	18c0      	adds	r0, r0, r3
 8000308:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800030c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000310:	d507      	bpl.n	8000322 <__adddf3+0xe6>
 8000312:	f04f 0e00 	mov.w	lr, #0
 8000316:	f1dc 0c00 	rsbs	ip, ip, #0
 800031a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800031e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000322:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000326:	d31b      	bcc.n	8000360 <__adddf3+0x124>
 8000328:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800032c:	d30c      	bcc.n	8000348 <__adddf3+0x10c>
 800032e:	0849      	lsrs	r1, r1, #1
 8000330:	ea5f 0030 	movs.w	r0, r0, rrx
 8000334:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000338:	f104 0401 	add.w	r4, r4, #1
 800033c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000340:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000344:	f080 809a 	bcs.w	800047c <__adddf3+0x240>
 8000348:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800034c:	bf08      	it	eq
 800034e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000352:	f150 0000 	adcs.w	r0, r0, #0
 8000356:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800035a:	ea41 0105 	orr.w	r1, r1, r5
 800035e:	bd30      	pop	{r4, r5, pc}
 8000360:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000364:	4140      	adcs	r0, r0
 8000366:	eb41 0101 	adc.w	r1, r1, r1
 800036a:	3c01      	subs	r4, #1
 800036c:	bf28      	it	cs
 800036e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 8000372:	d2e9      	bcs.n	8000348 <__adddf3+0x10c>
 8000374:	f091 0f00 	teq	r1, #0
 8000378:	bf04      	itt	eq
 800037a:	4601      	moveq	r1, r0
 800037c:	2000      	moveq	r0, #0
 800037e:	fab1 f381 	clz	r3, r1
 8000382:	bf08      	it	eq
 8000384:	3320      	addeq	r3, #32
 8000386:	f1a3 030b 	sub.w	r3, r3, #11
 800038a:	f1b3 0220 	subs.w	r2, r3, #32
 800038e:	da0c      	bge.n	80003aa <__adddf3+0x16e>
 8000390:	320c      	adds	r2, #12
 8000392:	dd08      	ble.n	80003a6 <__adddf3+0x16a>
 8000394:	f102 0c14 	add.w	ip, r2, #20
 8000398:	f1c2 020c 	rsb	r2, r2, #12
 800039c:	fa01 f00c 	lsl.w	r0, r1, ip
 80003a0:	fa21 f102 	lsr.w	r1, r1, r2
 80003a4:	e00c      	b.n	80003c0 <__adddf3+0x184>
 80003a6:	f102 0214 	add.w	r2, r2, #20
 80003aa:	bfd8      	it	le
 80003ac:	f1c2 0c20 	rsble	ip, r2, #32
 80003b0:	fa01 f102 	lsl.w	r1, r1, r2
 80003b4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003b8:	bfdc      	itt	le
 80003ba:	ea41 010c 	orrle.w	r1, r1, ip
 80003be:	4090      	lslle	r0, r2
 80003c0:	1ae4      	subs	r4, r4, r3
 80003c2:	bfa2      	ittt	ge
 80003c4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003c8:	4329      	orrge	r1, r5
 80003ca:	bd30      	popge	{r4, r5, pc}
 80003cc:	ea6f 0404 	mvn.w	r4, r4
 80003d0:	3c1f      	subs	r4, #31
 80003d2:	da1c      	bge.n	800040e <__adddf3+0x1d2>
 80003d4:	340c      	adds	r4, #12
 80003d6:	dc0e      	bgt.n	80003f6 <__adddf3+0x1ba>
 80003d8:	f104 0414 	add.w	r4, r4, #20
 80003dc:	f1c4 0220 	rsb	r2, r4, #32
 80003e0:	fa20 f004 	lsr.w	r0, r0, r4
 80003e4:	fa01 f302 	lsl.w	r3, r1, r2
 80003e8:	ea40 0003 	orr.w	r0, r0, r3
 80003ec:	fa21 f304 	lsr.w	r3, r1, r4
 80003f0:	ea45 0103 	orr.w	r1, r5, r3
 80003f4:	bd30      	pop	{r4, r5, pc}
 80003f6:	f1c4 040c 	rsb	r4, r4, #12
 80003fa:	f1c4 0220 	rsb	r2, r4, #32
 80003fe:	fa20 f002 	lsr.w	r0, r0, r2
 8000402:	fa01 f304 	lsl.w	r3, r1, r4
 8000406:	ea40 0003 	orr.w	r0, r0, r3
 800040a:	4629      	mov	r1, r5
 800040c:	bd30      	pop	{r4, r5, pc}
 800040e:	fa21 f004 	lsr.w	r0, r1, r4
 8000412:	4629      	mov	r1, r5
 8000414:	bd30      	pop	{r4, r5, pc}
 8000416:	f094 0f00 	teq	r4, #0
 800041a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800041e:	bf06      	itte	eq
 8000420:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000424:	3401      	addeq	r4, #1
 8000426:	3d01      	subne	r5, #1
 8000428:	e74e      	b.n	80002c8 <__adddf3+0x8c>
 800042a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800042e:	bf18      	it	ne
 8000430:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000434:	d029      	beq.n	800048a <__adddf3+0x24e>
 8000436:	ea94 0f05 	teq	r4, r5
 800043a:	bf08      	it	eq
 800043c:	ea90 0f02 	teqeq	r0, r2
 8000440:	d005      	beq.n	800044e <__adddf3+0x212>
 8000442:	ea54 0c00 	orrs.w	ip, r4, r0
 8000446:	bf04      	itt	eq
 8000448:	4619      	moveq	r1, r3
 800044a:	4610      	moveq	r0, r2
 800044c:	bd30      	pop	{r4, r5, pc}
 800044e:	ea91 0f03 	teq	r1, r3
 8000452:	bf1e      	ittt	ne
 8000454:	2100      	movne	r1, #0
 8000456:	2000      	movne	r0, #0
 8000458:	bd30      	popne	{r4, r5, pc}
 800045a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800045e:	d105      	bne.n	800046c <__adddf3+0x230>
 8000460:	0040      	lsls	r0, r0, #1
 8000462:	4149      	adcs	r1, r1
 8000464:	bf28      	it	cs
 8000466:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800046a:	bd30      	pop	{r4, r5, pc}
 800046c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000470:	bf3c      	itt	cc
 8000472:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000476:	bd30      	popcc	{r4, r5, pc}
 8000478:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800047c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000480:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000484:	f04f 0000 	mov.w	r0, #0
 8000488:	bd30      	pop	{r4, r5, pc}
 800048a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800048e:	bf1a      	itte	ne
 8000490:	4619      	movne	r1, r3
 8000492:	4610      	movne	r0, r2
 8000494:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000498:	bf1c      	itt	ne
 800049a:	460b      	movne	r3, r1
 800049c:	4602      	movne	r2, r0
 800049e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80004a2:	bf06      	itte	eq
 80004a4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004a8:	ea91 0f03 	teqeq	r1, r3
 80004ac:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004b0:	bd30      	pop	{r4, r5, pc}
 80004b2:	bf00      	nop

080004b4 <__aeabi_ui2d>:
 80004b4:	f090 0f00 	teq	r0, #0
 80004b8:	bf04      	itt	eq
 80004ba:	2100      	moveq	r1, #0
 80004bc:	4770      	bxeq	lr
 80004be:	b530      	push	{r4, r5, lr}
 80004c0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004c4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004c8:	f04f 0500 	mov.w	r5, #0
 80004cc:	f04f 0100 	mov.w	r1, #0
 80004d0:	e750      	b.n	8000374 <__adddf3+0x138>
 80004d2:	bf00      	nop

080004d4 <__aeabi_i2d>:
 80004d4:	f090 0f00 	teq	r0, #0
 80004d8:	bf04      	itt	eq
 80004da:	2100      	moveq	r1, #0
 80004dc:	4770      	bxeq	lr
 80004de:	b530      	push	{r4, r5, lr}
 80004e0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004e4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004e8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80004ec:	bf48      	it	mi
 80004ee:	4240      	negmi	r0, r0
 80004f0:	f04f 0100 	mov.w	r1, #0
 80004f4:	e73e      	b.n	8000374 <__adddf3+0x138>
 80004f6:	bf00      	nop

080004f8 <__aeabi_f2d>:
 80004f8:	0042      	lsls	r2, r0, #1
 80004fa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004fe:	ea4f 0131 	mov.w	r1, r1, rrx
 8000502:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000506:	bf1f      	itttt	ne
 8000508:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800050c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000510:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000514:	4770      	bxne	lr
 8000516:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800051a:	bf08      	it	eq
 800051c:	4770      	bxeq	lr
 800051e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000522:	bf04      	itt	eq
 8000524:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000528:	4770      	bxeq	lr
 800052a:	b530      	push	{r4, r5, lr}
 800052c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000530:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000534:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000538:	e71c      	b.n	8000374 <__adddf3+0x138>
 800053a:	bf00      	nop

0800053c <__aeabi_ul2d>:
 800053c:	ea50 0201 	orrs.w	r2, r0, r1
 8000540:	bf08      	it	eq
 8000542:	4770      	bxeq	lr
 8000544:	b530      	push	{r4, r5, lr}
 8000546:	f04f 0500 	mov.w	r5, #0
 800054a:	e00a      	b.n	8000562 <__aeabi_l2d+0x16>

0800054c <__aeabi_l2d>:
 800054c:	ea50 0201 	orrs.w	r2, r0, r1
 8000550:	bf08      	it	eq
 8000552:	4770      	bxeq	lr
 8000554:	b530      	push	{r4, r5, lr}
 8000556:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800055a:	d502      	bpl.n	8000562 <__aeabi_l2d+0x16>
 800055c:	4240      	negs	r0, r0
 800055e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000562:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000566:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800056a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800056e:	f43f aed8 	beq.w	8000322 <__adddf3+0xe6>
 8000572:	f04f 0203 	mov.w	r2, #3
 8000576:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800057a:	bf18      	it	ne
 800057c:	3203      	addne	r2, #3
 800057e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000582:	bf18      	it	ne
 8000584:	3203      	addne	r2, #3
 8000586:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800058a:	f1c2 0320 	rsb	r3, r2, #32
 800058e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000592:	fa20 f002 	lsr.w	r0, r0, r2
 8000596:	fa01 fe03 	lsl.w	lr, r1, r3
 800059a:	ea40 000e 	orr.w	r0, r0, lr
 800059e:	fa21 f102 	lsr.w	r1, r1, r2
 80005a2:	4414      	add	r4, r2
 80005a4:	e6bd      	b.n	8000322 <__adddf3+0xe6>
 80005a6:	bf00      	nop

080005a8 <__gedf2>:
 80005a8:	f04f 3cff 	mov.w	ip, #4294967295
 80005ac:	e006      	b.n	80005bc <__cmpdf2+0x4>
 80005ae:	bf00      	nop

080005b0 <__ledf2>:
 80005b0:	f04f 0c01 	mov.w	ip, #1
 80005b4:	e002      	b.n	80005bc <__cmpdf2+0x4>
 80005b6:	bf00      	nop

080005b8 <__cmpdf2>:
 80005b8:	f04f 0c01 	mov.w	ip, #1
 80005bc:	f84d cd04 	str.w	ip, [sp, #-4]!
 80005c0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80005c4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80005c8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80005cc:	bf18      	it	ne
 80005ce:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80005d2:	d01b      	beq.n	800060c <__cmpdf2+0x54>
 80005d4:	b001      	add	sp, #4
 80005d6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80005da:	bf0c      	ite	eq
 80005dc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80005e0:	ea91 0f03 	teqne	r1, r3
 80005e4:	bf02      	ittt	eq
 80005e6:	ea90 0f02 	teqeq	r0, r2
 80005ea:	2000      	moveq	r0, #0
 80005ec:	4770      	bxeq	lr
 80005ee:	f110 0f00 	cmn.w	r0, #0
 80005f2:	ea91 0f03 	teq	r1, r3
 80005f6:	bf58      	it	pl
 80005f8:	4299      	cmppl	r1, r3
 80005fa:	bf08      	it	eq
 80005fc:	4290      	cmpeq	r0, r2
 80005fe:	bf2c      	ite	cs
 8000600:	17d8      	asrcs	r0, r3, #31
 8000602:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000606:	f040 0001 	orr.w	r0, r0, #1
 800060a:	4770      	bx	lr
 800060c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000610:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000614:	d102      	bne.n	800061c <__cmpdf2+0x64>
 8000616:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800061a:	d107      	bne.n	800062c <__cmpdf2+0x74>
 800061c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000620:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000624:	d1d6      	bne.n	80005d4 <__cmpdf2+0x1c>
 8000626:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800062a:	d0d3      	beq.n	80005d4 <__cmpdf2+0x1c>
 800062c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000630:	4770      	bx	lr
 8000632:	bf00      	nop

08000634 <__aeabi_cdrcmple>:
 8000634:	4684      	mov	ip, r0
 8000636:	4610      	mov	r0, r2
 8000638:	4662      	mov	r2, ip
 800063a:	468c      	mov	ip, r1
 800063c:	4619      	mov	r1, r3
 800063e:	4663      	mov	r3, ip
 8000640:	e000      	b.n	8000644 <__aeabi_cdcmpeq>
 8000642:	bf00      	nop

08000644 <__aeabi_cdcmpeq>:
 8000644:	b501      	push	{r0, lr}
 8000646:	f7ff ffb7 	bl	80005b8 <__cmpdf2>
 800064a:	2800      	cmp	r0, #0
 800064c:	bf48      	it	mi
 800064e:	f110 0f00 	cmnmi.w	r0, #0
 8000652:	bd01      	pop	{r0, pc}

08000654 <__aeabi_dcmpeq>:
 8000654:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000658:	f7ff fff4 	bl	8000644 <__aeabi_cdcmpeq>
 800065c:	bf0c      	ite	eq
 800065e:	2001      	moveq	r0, #1
 8000660:	2000      	movne	r0, #0
 8000662:	f85d fb08 	ldr.w	pc, [sp], #8
 8000666:	bf00      	nop

08000668 <__aeabi_dcmplt>:
 8000668:	f84d ed08 	str.w	lr, [sp, #-8]!
 800066c:	f7ff ffea 	bl	8000644 <__aeabi_cdcmpeq>
 8000670:	bf34      	ite	cc
 8000672:	2001      	movcc	r0, #1
 8000674:	2000      	movcs	r0, #0
 8000676:	f85d fb08 	ldr.w	pc, [sp], #8
 800067a:	bf00      	nop

0800067c <__aeabi_dcmple>:
 800067c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000680:	f7ff ffe0 	bl	8000644 <__aeabi_cdcmpeq>
 8000684:	bf94      	ite	ls
 8000686:	2001      	movls	r0, #1
 8000688:	2000      	movhi	r0, #0
 800068a:	f85d fb08 	ldr.w	pc, [sp], #8
 800068e:	bf00      	nop

08000690 <__aeabi_dcmpge>:
 8000690:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000694:	f7ff ffce 	bl	8000634 <__aeabi_cdrcmple>
 8000698:	bf94      	ite	ls
 800069a:	2001      	movls	r0, #1
 800069c:	2000      	movhi	r0, #0
 800069e:	f85d fb08 	ldr.w	pc, [sp], #8
 80006a2:	bf00      	nop

080006a4 <__aeabi_dcmpgt>:
 80006a4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80006a8:	f7ff ffc4 	bl	8000634 <__aeabi_cdrcmple>
 80006ac:	bf34      	ite	cc
 80006ae:	2001      	movcc	r0, #1
 80006b0:	2000      	movcs	r0, #0
 80006b2:	f85d fb08 	ldr.w	pc, [sp], #8
 80006b6:	bf00      	nop

080006b8 <__aeabi_d2iz>:
 80006b8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80006bc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80006c0:	d215      	bcs.n	80006ee <__aeabi_d2iz+0x36>
 80006c2:	d511      	bpl.n	80006e8 <__aeabi_d2iz+0x30>
 80006c4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80006c8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80006cc:	d912      	bls.n	80006f4 <__aeabi_d2iz+0x3c>
 80006ce:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80006d2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80006d6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80006da:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80006de:	fa23 f002 	lsr.w	r0, r3, r2
 80006e2:	bf18      	it	ne
 80006e4:	4240      	negne	r0, r0
 80006e6:	4770      	bx	lr
 80006e8:	f04f 0000 	mov.w	r0, #0
 80006ec:	4770      	bx	lr
 80006ee:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80006f2:	d105      	bne.n	8000700 <__aeabi_d2iz+0x48>
 80006f4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80006f8:	bf08      	it	eq
 80006fa:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80006fe:	4770      	bx	lr
 8000700:	f04f 0000 	mov.w	r0, #0
 8000704:	4770      	bx	lr
 8000706:	bf00      	nop

08000708 <__aeabi_frsub>:
 8000708:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 800070c:	e002      	b.n	8000714 <__addsf3>
 800070e:	bf00      	nop

08000710 <__aeabi_fsub>:
 8000710:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000714 <__addsf3>:
 8000714:	0042      	lsls	r2, r0, #1
 8000716:	bf1f      	itttt	ne
 8000718:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 800071c:	ea92 0f03 	teqne	r2, r3
 8000720:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000724:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000728:	d06a      	beq.n	8000800 <__addsf3+0xec>
 800072a:	ea4f 6212 	mov.w	r2, r2, lsr #24
 800072e:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000732:	bfc1      	itttt	gt
 8000734:	18d2      	addgt	r2, r2, r3
 8000736:	4041      	eorgt	r1, r0
 8000738:	4048      	eorgt	r0, r1
 800073a:	4041      	eorgt	r1, r0
 800073c:	bfb8      	it	lt
 800073e:	425b      	neglt	r3, r3
 8000740:	2b19      	cmp	r3, #25
 8000742:	bf88      	it	hi
 8000744:	4770      	bxhi	lr
 8000746:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 800074a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800074e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000752:	bf18      	it	ne
 8000754:	4240      	negne	r0, r0
 8000756:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800075a:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 800075e:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000762:	bf18      	it	ne
 8000764:	4249      	negne	r1, r1
 8000766:	ea92 0f03 	teq	r2, r3
 800076a:	d03f      	beq.n	80007ec <__addsf3+0xd8>
 800076c:	f1a2 0201 	sub.w	r2, r2, #1
 8000770:	fa41 fc03 	asr.w	ip, r1, r3
 8000774:	eb10 000c 	adds.w	r0, r0, ip
 8000778:	f1c3 0320 	rsb	r3, r3, #32
 800077c:	fa01 f103 	lsl.w	r1, r1, r3
 8000780:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000784:	d502      	bpl.n	800078c <__addsf3+0x78>
 8000786:	4249      	negs	r1, r1
 8000788:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800078c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000790:	d313      	bcc.n	80007ba <__addsf3+0xa6>
 8000792:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000796:	d306      	bcc.n	80007a6 <__addsf3+0x92>
 8000798:	0840      	lsrs	r0, r0, #1
 800079a:	ea4f 0131 	mov.w	r1, r1, rrx
 800079e:	f102 0201 	add.w	r2, r2, #1
 80007a2:	2afe      	cmp	r2, #254	; 0xfe
 80007a4:	d251      	bcs.n	800084a <__addsf3+0x136>
 80007a6:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80007aa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80007ae:	bf08      	it	eq
 80007b0:	f020 0001 	biceq.w	r0, r0, #1
 80007b4:	ea40 0003 	orr.w	r0, r0, r3
 80007b8:	4770      	bx	lr
 80007ba:	0049      	lsls	r1, r1, #1
 80007bc:	eb40 0000 	adc.w	r0, r0, r0
 80007c0:	3a01      	subs	r2, #1
 80007c2:	bf28      	it	cs
 80007c4:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 80007c8:	d2ed      	bcs.n	80007a6 <__addsf3+0x92>
 80007ca:	fab0 fc80 	clz	ip, r0
 80007ce:	f1ac 0c08 	sub.w	ip, ip, #8
 80007d2:	ebb2 020c 	subs.w	r2, r2, ip
 80007d6:	fa00 f00c 	lsl.w	r0, r0, ip
 80007da:	bfaa      	itet	ge
 80007dc:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80007e0:	4252      	neglt	r2, r2
 80007e2:	4318      	orrge	r0, r3
 80007e4:	bfbc      	itt	lt
 80007e6:	40d0      	lsrlt	r0, r2
 80007e8:	4318      	orrlt	r0, r3
 80007ea:	4770      	bx	lr
 80007ec:	f092 0f00 	teq	r2, #0
 80007f0:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80007f4:	bf06      	itte	eq
 80007f6:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80007fa:	3201      	addeq	r2, #1
 80007fc:	3b01      	subne	r3, #1
 80007fe:	e7b5      	b.n	800076c <__addsf3+0x58>
 8000800:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000804:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000808:	bf18      	it	ne
 800080a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800080e:	d021      	beq.n	8000854 <__addsf3+0x140>
 8000810:	ea92 0f03 	teq	r2, r3
 8000814:	d004      	beq.n	8000820 <__addsf3+0x10c>
 8000816:	f092 0f00 	teq	r2, #0
 800081a:	bf08      	it	eq
 800081c:	4608      	moveq	r0, r1
 800081e:	4770      	bx	lr
 8000820:	ea90 0f01 	teq	r0, r1
 8000824:	bf1c      	itt	ne
 8000826:	2000      	movne	r0, #0
 8000828:	4770      	bxne	lr
 800082a:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 800082e:	d104      	bne.n	800083a <__addsf3+0x126>
 8000830:	0040      	lsls	r0, r0, #1
 8000832:	bf28      	it	cs
 8000834:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000838:	4770      	bx	lr
 800083a:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 800083e:	bf3c      	itt	cc
 8000840:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000844:	4770      	bxcc	lr
 8000846:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 800084a:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 800084e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000852:	4770      	bx	lr
 8000854:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000858:	bf16      	itet	ne
 800085a:	4608      	movne	r0, r1
 800085c:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000860:	4601      	movne	r1, r0
 8000862:	0242      	lsls	r2, r0, #9
 8000864:	bf06      	itte	eq
 8000866:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 800086a:	ea90 0f01 	teqeq	r0, r1
 800086e:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000872:	4770      	bx	lr

08000874 <__aeabi_ui2f>:
 8000874:	f04f 0300 	mov.w	r3, #0
 8000878:	e004      	b.n	8000884 <__aeabi_i2f+0x8>
 800087a:	bf00      	nop

0800087c <__aeabi_i2f>:
 800087c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000880:	bf48      	it	mi
 8000882:	4240      	negmi	r0, r0
 8000884:	ea5f 0c00 	movs.w	ip, r0
 8000888:	bf08      	it	eq
 800088a:	4770      	bxeq	lr
 800088c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000890:	4601      	mov	r1, r0
 8000892:	f04f 0000 	mov.w	r0, #0
 8000896:	e01c      	b.n	80008d2 <__aeabi_l2f+0x2a>

08000898 <__aeabi_ul2f>:
 8000898:	ea50 0201 	orrs.w	r2, r0, r1
 800089c:	bf08      	it	eq
 800089e:	4770      	bxeq	lr
 80008a0:	f04f 0300 	mov.w	r3, #0
 80008a4:	e00a      	b.n	80008bc <__aeabi_l2f+0x14>
 80008a6:	bf00      	nop

080008a8 <__aeabi_l2f>:
 80008a8:	ea50 0201 	orrs.w	r2, r0, r1
 80008ac:	bf08      	it	eq
 80008ae:	4770      	bxeq	lr
 80008b0:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80008b4:	d502      	bpl.n	80008bc <__aeabi_l2f+0x14>
 80008b6:	4240      	negs	r0, r0
 80008b8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80008bc:	ea5f 0c01 	movs.w	ip, r1
 80008c0:	bf02      	ittt	eq
 80008c2:	4684      	moveq	ip, r0
 80008c4:	4601      	moveq	r1, r0
 80008c6:	2000      	moveq	r0, #0
 80008c8:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80008cc:	bf08      	it	eq
 80008ce:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80008d2:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80008d6:	fabc f28c 	clz	r2, ip
 80008da:	3a08      	subs	r2, #8
 80008dc:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80008e0:	db10      	blt.n	8000904 <__aeabi_l2f+0x5c>
 80008e2:	fa01 fc02 	lsl.w	ip, r1, r2
 80008e6:	4463      	add	r3, ip
 80008e8:	fa00 fc02 	lsl.w	ip, r0, r2
 80008ec:	f1c2 0220 	rsb	r2, r2, #32
 80008f0:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80008f4:	fa20 f202 	lsr.w	r2, r0, r2
 80008f8:	eb43 0002 	adc.w	r0, r3, r2
 80008fc:	bf08      	it	eq
 80008fe:	f020 0001 	biceq.w	r0, r0, #1
 8000902:	4770      	bx	lr
 8000904:	f102 0220 	add.w	r2, r2, #32
 8000908:	fa01 fc02 	lsl.w	ip, r1, r2
 800090c:	f1c2 0220 	rsb	r2, r2, #32
 8000910:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000914:	fa21 f202 	lsr.w	r2, r1, r2
 8000918:	eb43 0002 	adc.w	r0, r3, r2
 800091c:	bf08      	it	eq
 800091e:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000922:	4770      	bx	lr

08000924 <__aeabi_f2iz>:
 8000924:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000928:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 800092c:	d30f      	bcc.n	800094e <__aeabi_f2iz+0x2a>
 800092e:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000932:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000936:	d90d      	bls.n	8000954 <__aeabi_f2iz+0x30>
 8000938:	ea4f 2300 	mov.w	r3, r0, lsl #8
 800093c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000940:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000944:	fa23 f002 	lsr.w	r0, r3, r2
 8000948:	bf18      	it	ne
 800094a:	4240      	negne	r0, r0
 800094c:	4770      	bx	lr
 800094e:	f04f 0000 	mov.w	r0, #0
 8000952:	4770      	bx	lr
 8000954:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000958:	d101      	bne.n	800095e <__aeabi_f2iz+0x3a>
 800095a:	0242      	lsls	r2, r0, #9
 800095c:	d105      	bne.n	800096a <__aeabi_f2iz+0x46>
 800095e:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8000962:	bf08      	it	eq
 8000964:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000968:	4770      	bx	lr
 800096a:	f04f 0000 	mov.w	r0, #0
 800096e:	4770      	bx	lr

08000970 <__aeabi_f2uiz>:
 8000970:	0042      	lsls	r2, r0, #1
 8000972:	d20e      	bcs.n	8000992 <__aeabi_f2uiz+0x22>
 8000974:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000978:	d30b      	bcc.n	8000992 <__aeabi_f2uiz+0x22>
 800097a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 800097e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000982:	d409      	bmi.n	8000998 <__aeabi_f2uiz+0x28>
 8000984:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000988:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800098c:	fa23 f002 	lsr.w	r0, r3, r2
 8000990:	4770      	bx	lr
 8000992:	f04f 0000 	mov.w	r0, #0
 8000996:	4770      	bx	lr
 8000998:	f112 0f61 	cmn.w	r2, #97	; 0x61
 800099c:	d101      	bne.n	80009a2 <__aeabi_f2uiz+0x32>
 800099e:	0242      	lsls	r2, r0, #9
 80009a0:	d102      	bne.n	80009a8 <__aeabi_f2uiz+0x38>
 80009a2:	f04f 30ff 	mov.w	r0, #4294967295
 80009a6:	4770      	bx	lr
 80009a8:	f04f 0000 	mov.w	r0, #0
 80009ac:	4770      	bx	lr
 80009ae:	bf00      	nop

080009b0 <__aeabi_uldivmod>:
 80009b0:	b953      	cbnz	r3, 80009c8 <__aeabi_uldivmod+0x18>
 80009b2:	b94a      	cbnz	r2, 80009c8 <__aeabi_uldivmod+0x18>
 80009b4:	2900      	cmp	r1, #0
 80009b6:	bf08      	it	eq
 80009b8:	2800      	cmpeq	r0, #0
 80009ba:	bf1c      	itt	ne
 80009bc:	f04f 31ff 	movne.w	r1, #4294967295
 80009c0:	f04f 30ff 	movne.w	r0, #4294967295
 80009c4:	f000 b96c 	b.w	8000ca0 <__aeabi_idiv0>
 80009c8:	f1ad 0c08 	sub.w	ip, sp, #8
 80009cc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80009d0:	f000 f806 	bl	80009e0 <__udivmoddi4>
 80009d4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80009d8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80009dc:	b004      	add	sp, #16
 80009de:	4770      	bx	lr

080009e0 <__udivmoddi4>:
 80009e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80009e4:	9e08      	ldr	r6, [sp, #32]
 80009e6:	460d      	mov	r5, r1
 80009e8:	4604      	mov	r4, r0
 80009ea:	468e      	mov	lr, r1
 80009ec:	2b00      	cmp	r3, #0
 80009ee:	f040 8082 	bne.w	8000af6 <__udivmoddi4+0x116>
 80009f2:	428a      	cmp	r2, r1
 80009f4:	4617      	mov	r7, r2
 80009f6:	d946      	bls.n	8000a86 <__udivmoddi4+0xa6>
 80009f8:	fab2 f282 	clz	r2, r2
 80009fc:	b14a      	cbz	r2, 8000a12 <__udivmoddi4+0x32>
 80009fe:	f1c2 0120 	rsb	r1, r2, #32
 8000a02:	fa05 f302 	lsl.w	r3, r5, r2
 8000a06:	fa20 f101 	lsr.w	r1, r0, r1
 8000a0a:	4097      	lsls	r7, r2
 8000a0c:	ea41 0e03 	orr.w	lr, r1, r3
 8000a10:	4094      	lsls	r4, r2
 8000a12:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000a16:	0c23      	lsrs	r3, r4, #16
 8000a18:	fbbe fcf8 	udiv	ip, lr, r8
 8000a1c:	b2b9      	uxth	r1, r7
 8000a1e:	fb08 ee1c 	mls	lr, r8, ip, lr
 8000a22:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 8000a26:	fb0c f001 	mul.w	r0, ip, r1
 8000a2a:	4298      	cmp	r0, r3
 8000a2c:	d90a      	bls.n	8000a44 <__udivmoddi4+0x64>
 8000a2e:	18fb      	adds	r3, r7, r3
 8000a30:	f10c 35ff 	add.w	r5, ip, #4294967295
 8000a34:	f080 8116 	bcs.w	8000c64 <__udivmoddi4+0x284>
 8000a38:	4298      	cmp	r0, r3
 8000a3a:	f240 8113 	bls.w	8000c64 <__udivmoddi4+0x284>
 8000a3e:	f1ac 0c02 	sub.w	ip, ip, #2
 8000a42:	443b      	add	r3, r7
 8000a44:	1a1b      	subs	r3, r3, r0
 8000a46:	b2a4      	uxth	r4, r4
 8000a48:	fbb3 f0f8 	udiv	r0, r3, r8
 8000a4c:	fb08 3310 	mls	r3, r8, r0, r3
 8000a50:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000a54:	fb00 f101 	mul.w	r1, r0, r1
 8000a58:	42a1      	cmp	r1, r4
 8000a5a:	d909      	bls.n	8000a70 <__udivmoddi4+0x90>
 8000a5c:	193c      	adds	r4, r7, r4
 8000a5e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000a62:	f080 8101 	bcs.w	8000c68 <__udivmoddi4+0x288>
 8000a66:	42a1      	cmp	r1, r4
 8000a68:	f240 80fe 	bls.w	8000c68 <__udivmoddi4+0x288>
 8000a6c:	3802      	subs	r0, #2
 8000a6e:	443c      	add	r4, r7
 8000a70:	1a64      	subs	r4, r4, r1
 8000a72:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000a76:	2100      	movs	r1, #0
 8000a78:	b11e      	cbz	r6, 8000a82 <__udivmoddi4+0xa2>
 8000a7a:	40d4      	lsrs	r4, r2
 8000a7c:	2300      	movs	r3, #0
 8000a7e:	e9c6 4300 	strd	r4, r3, [r6]
 8000a82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000a86:	b902      	cbnz	r2, 8000a8a <__udivmoddi4+0xaa>
 8000a88:	deff      	udf	#255	; 0xff
 8000a8a:	fab2 f282 	clz	r2, r2
 8000a8e:	2a00      	cmp	r2, #0
 8000a90:	d14f      	bne.n	8000b32 <__udivmoddi4+0x152>
 8000a92:	1bcb      	subs	r3, r1, r7
 8000a94:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000a98:	fa1f f887 	uxth.w	r8, r7
 8000a9c:	2101      	movs	r1, #1
 8000a9e:	fbb3 fcfe 	udiv	ip, r3, lr
 8000aa2:	0c25      	lsrs	r5, r4, #16
 8000aa4:	fb0e 331c 	mls	r3, lr, ip, r3
 8000aa8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000aac:	fb08 f30c 	mul.w	r3, r8, ip
 8000ab0:	42ab      	cmp	r3, r5
 8000ab2:	d907      	bls.n	8000ac4 <__udivmoddi4+0xe4>
 8000ab4:	197d      	adds	r5, r7, r5
 8000ab6:	f10c 30ff 	add.w	r0, ip, #4294967295
 8000aba:	d202      	bcs.n	8000ac2 <__udivmoddi4+0xe2>
 8000abc:	42ab      	cmp	r3, r5
 8000abe:	f200 80e7 	bhi.w	8000c90 <__udivmoddi4+0x2b0>
 8000ac2:	4684      	mov	ip, r0
 8000ac4:	1aed      	subs	r5, r5, r3
 8000ac6:	b2a3      	uxth	r3, r4
 8000ac8:	fbb5 f0fe 	udiv	r0, r5, lr
 8000acc:	fb0e 5510 	mls	r5, lr, r0, r5
 8000ad0:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000ad4:	fb08 f800 	mul.w	r8, r8, r0
 8000ad8:	45a0      	cmp	r8, r4
 8000ada:	d907      	bls.n	8000aec <__udivmoddi4+0x10c>
 8000adc:	193c      	adds	r4, r7, r4
 8000ade:	f100 33ff 	add.w	r3, r0, #4294967295
 8000ae2:	d202      	bcs.n	8000aea <__udivmoddi4+0x10a>
 8000ae4:	45a0      	cmp	r8, r4
 8000ae6:	f200 80d7 	bhi.w	8000c98 <__udivmoddi4+0x2b8>
 8000aea:	4618      	mov	r0, r3
 8000aec:	eba4 0408 	sub.w	r4, r4, r8
 8000af0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000af4:	e7c0      	b.n	8000a78 <__udivmoddi4+0x98>
 8000af6:	428b      	cmp	r3, r1
 8000af8:	d908      	bls.n	8000b0c <__udivmoddi4+0x12c>
 8000afa:	2e00      	cmp	r6, #0
 8000afc:	f000 80af 	beq.w	8000c5e <__udivmoddi4+0x27e>
 8000b00:	2100      	movs	r1, #0
 8000b02:	e9c6 0500 	strd	r0, r5, [r6]
 8000b06:	4608      	mov	r0, r1
 8000b08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b0c:	fab3 f183 	clz	r1, r3
 8000b10:	2900      	cmp	r1, #0
 8000b12:	d14b      	bne.n	8000bac <__udivmoddi4+0x1cc>
 8000b14:	42ab      	cmp	r3, r5
 8000b16:	d302      	bcc.n	8000b1e <__udivmoddi4+0x13e>
 8000b18:	4282      	cmp	r2, r0
 8000b1a:	f200 80b7 	bhi.w	8000c8c <__udivmoddi4+0x2ac>
 8000b1e:	1a84      	subs	r4, r0, r2
 8000b20:	eb65 0303 	sbc.w	r3, r5, r3
 8000b24:	2001      	movs	r0, #1
 8000b26:	469e      	mov	lr, r3
 8000b28:	2e00      	cmp	r6, #0
 8000b2a:	d0aa      	beq.n	8000a82 <__udivmoddi4+0xa2>
 8000b2c:	e9c6 4e00 	strd	r4, lr, [r6]
 8000b30:	e7a7      	b.n	8000a82 <__udivmoddi4+0xa2>
 8000b32:	f1c2 0c20 	rsb	ip, r2, #32
 8000b36:	fa01 f302 	lsl.w	r3, r1, r2
 8000b3a:	4097      	lsls	r7, r2
 8000b3c:	fa20 f00c 	lsr.w	r0, r0, ip
 8000b40:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000b44:	fa21 fc0c 	lsr.w	ip, r1, ip
 8000b48:	4318      	orrs	r0, r3
 8000b4a:	fbbc f1fe 	udiv	r1, ip, lr
 8000b4e:	0c05      	lsrs	r5, r0, #16
 8000b50:	fb0e cc11 	mls	ip, lr, r1, ip
 8000b54:	fa1f f887 	uxth.w	r8, r7
 8000b58:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000b5c:	fb01 f308 	mul.w	r3, r1, r8
 8000b60:	42ab      	cmp	r3, r5
 8000b62:	fa04 f402 	lsl.w	r4, r4, r2
 8000b66:	d909      	bls.n	8000b7c <__udivmoddi4+0x19c>
 8000b68:	197d      	adds	r5, r7, r5
 8000b6a:	f101 3cff 	add.w	ip, r1, #4294967295
 8000b6e:	f080 808b 	bcs.w	8000c88 <__udivmoddi4+0x2a8>
 8000b72:	42ab      	cmp	r3, r5
 8000b74:	f240 8088 	bls.w	8000c88 <__udivmoddi4+0x2a8>
 8000b78:	3902      	subs	r1, #2
 8000b7a:	443d      	add	r5, r7
 8000b7c:	1aeb      	subs	r3, r5, r3
 8000b7e:	b285      	uxth	r5, r0
 8000b80:	fbb3 f0fe 	udiv	r0, r3, lr
 8000b84:	fb0e 3310 	mls	r3, lr, r0, r3
 8000b88:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000b8c:	fb00 f308 	mul.w	r3, r0, r8
 8000b90:	42ab      	cmp	r3, r5
 8000b92:	d907      	bls.n	8000ba4 <__udivmoddi4+0x1c4>
 8000b94:	197d      	adds	r5, r7, r5
 8000b96:	f100 3cff 	add.w	ip, r0, #4294967295
 8000b9a:	d271      	bcs.n	8000c80 <__udivmoddi4+0x2a0>
 8000b9c:	42ab      	cmp	r3, r5
 8000b9e:	d96f      	bls.n	8000c80 <__udivmoddi4+0x2a0>
 8000ba0:	3802      	subs	r0, #2
 8000ba2:	443d      	add	r5, r7
 8000ba4:	1aeb      	subs	r3, r5, r3
 8000ba6:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000baa:	e778      	b.n	8000a9e <__udivmoddi4+0xbe>
 8000bac:	f1c1 0c20 	rsb	ip, r1, #32
 8000bb0:	408b      	lsls	r3, r1
 8000bb2:	fa22 f70c 	lsr.w	r7, r2, ip
 8000bb6:	431f      	orrs	r7, r3
 8000bb8:	fa20 f40c 	lsr.w	r4, r0, ip
 8000bbc:	fa05 f301 	lsl.w	r3, r5, r1
 8000bc0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000bc4:	fa25 f50c 	lsr.w	r5, r5, ip
 8000bc8:	431c      	orrs	r4, r3
 8000bca:	0c23      	lsrs	r3, r4, #16
 8000bcc:	fbb5 f9fe 	udiv	r9, r5, lr
 8000bd0:	fa1f f887 	uxth.w	r8, r7
 8000bd4:	fb0e 5519 	mls	r5, lr, r9, r5
 8000bd8:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
 8000bdc:	fb09 fa08 	mul.w	sl, r9, r8
 8000be0:	45aa      	cmp	sl, r5
 8000be2:	fa02 f201 	lsl.w	r2, r2, r1
 8000be6:	fa00 f301 	lsl.w	r3, r0, r1
 8000bea:	d908      	bls.n	8000bfe <__udivmoddi4+0x21e>
 8000bec:	197d      	adds	r5, r7, r5
 8000bee:	f109 30ff 	add.w	r0, r9, #4294967295
 8000bf2:	d247      	bcs.n	8000c84 <__udivmoddi4+0x2a4>
 8000bf4:	45aa      	cmp	sl, r5
 8000bf6:	d945      	bls.n	8000c84 <__udivmoddi4+0x2a4>
 8000bf8:	f1a9 0902 	sub.w	r9, r9, #2
 8000bfc:	443d      	add	r5, r7
 8000bfe:	eba5 050a 	sub.w	r5, r5, sl
 8000c02:	b2a4      	uxth	r4, r4
 8000c04:	fbb5 f0fe 	udiv	r0, r5, lr
 8000c08:	fb0e 5510 	mls	r5, lr, r0, r5
 8000c0c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000c10:	fb00 f808 	mul.w	r8, r0, r8
 8000c14:	45a0      	cmp	r8, r4
 8000c16:	d907      	bls.n	8000c28 <__udivmoddi4+0x248>
 8000c18:	193c      	adds	r4, r7, r4
 8000c1a:	f100 35ff 	add.w	r5, r0, #4294967295
 8000c1e:	d22d      	bcs.n	8000c7c <__udivmoddi4+0x29c>
 8000c20:	45a0      	cmp	r8, r4
 8000c22:	d92b      	bls.n	8000c7c <__udivmoddi4+0x29c>
 8000c24:	3802      	subs	r0, #2
 8000c26:	443c      	add	r4, r7
 8000c28:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000c2c:	eba4 0408 	sub.w	r4, r4, r8
 8000c30:	fba0 8902 	umull	r8, r9, r0, r2
 8000c34:	454c      	cmp	r4, r9
 8000c36:	46c6      	mov	lr, r8
 8000c38:	464d      	mov	r5, r9
 8000c3a:	d319      	bcc.n	8000c70 <__udivmoddi4+0x290>
 8000c3c:	d016      	beq.n	8000c6c <__udivmoddi4+0x28c>
 8000c3e:	b15e      	cbz	r6, 8000c58 <__udivmoddi4+0x278>
 8000c40:	ebb3 020e 	subs.w	r2, r3, lr
 8000c44:	eb64 0405 	sbc.w	r4, r4, r5
 8000c48:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000c4c:	40ca      	lsrs	r2, r1
 8000c4e:	ea4c 0202 	orr.w	r2, ip, r2
 8000c52:	40cc      	lsrs	r4, r1
 8000c54:	e9c6 2400 	strd	r2, r4, [r6]
 8000c58:	2100      	movs	r1, #0
 8000c5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c5e:	4631      	mov	r1, r6
 8000c60:	4630      	mov	r0, r6
 8000c62:	e70e      	b.n	8000a82 <__udivmoddi4+0xa2>
 8000c64:	46ac      	mov	ip, r5
 8000c66:	e6ed      	b.n	8000a44 <__udivmoddi4+0x64>
 8000c68:	4618      	mov	r0, r3
 8000c6a:	e701      	b.n	8000a70 <__udivmoddi4+0x90>
 8000c6c:	4543      	cmp	r3, r8
 8000c6e:	d2e6      	bcs.n	8000c3e <__udivmoddi4+0x25e>
 8000c70:	ebb8 0e02 	subs.w	lr, r8, r2
 8000c74:	eb69 0507 	sbc.w	r5, r9, r7
 8000c78:	3801      	subs	r0, #1
 8000c7a:	e7e0      	b.n	8000c3e <__udivmoddi4+0x25e>
 8000c7c:	4628      	mov	r0, r5
 8000c7e:	e7d3      	b.n	8000c28 <__udivmoddi4+0x248>
 8000c80:	4660      	mov	r0, ip
 8000c82:	e78f      	b.n	8000ba4 <__udivmoddi4+0x1c4>
 8000c84:	4681      	mov	r9, r0
 8000c86:	e7ba      	b.n	8000bfe <__udivmoddi4+0x21e>
 8000c88:	4661      	mov	r1, ip
 8000c8a:	e777      	b.n	8000b7c <__udivmoddi4+0x19c>
 8000c8c:	4608      	mov	r0, r1
 8000c8e:	e74b      	b.n	8000b28 <__udivmoddi4+0x148>
 8000c90:	f1ac 0c02 	sub.w	ip, ip, #2
 8000c94:	443d      	add	r5, r7
 8000c96:	e715      	b.n	8000ac4 <__udivmoddi4+0xe4>
 8000c98:	3802      	subs	r0, #2
 8000c9a:	443c      	add	r4, r7
 8000c9c:	e726      	b.n	8000aec <__udivmoddi4+0x10c>
 8000c9e:	bf00      	nop

08000ca0 <__aeabi_idiv0>:
 8000ca0:	4770      	bx	lr
 8000ca2:	bf00      	nop

08000ca4 <MX_ADC_Init>:
  /* USER CODE BEGIN ADC_Init 1 */

  /* USER CODE END ADC_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
  */
  hadc.Instance = ADC;
 8000ca4:	4813      	ldr	r0, [pc, #76]	; (8000cf4 <MX_ADC_Init+0x50>)
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8000ca6:	4a14      	ldr	r2, [pc, #80]	; (8000cf8 <MX_ADC_Init+0x54>)
{
 8000ca8:	b508      	push	{r3, lr}
  hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8000caa:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8000cae:	e9c0 2300 	strd	r2, r3, [r0]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000cb2:	2204      	movs	r2, #4
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8000cb4:	2300      	movs	r3, #0
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000cb6:	6142      	str	r2, [r0, #20]
  hadc.Init.LowPowerAutoWait = DISABLE;
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
  hadc.Init.ContinuousConvMode = DISABLE;
  hadc.Init.NbrOfConversion = 1;
 8000cb8:	2201      	movs	r2, #1
 8000cba:	61c2      	str	r2, [r0, #28]
  hadc.Init.DiscontinuousConvMode = DISABLE;
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc.Init.DMAContinuousRequests = DISABLE;
  hadc.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 8000cbc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000cc0:	2207      	movs	r2, #7
  hadc.Init.LowPowerAutoWait = DISABLE;
 8000cc2:	8303      	strh	r3, [r0, #24]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000cc4:	e9c0 3302 	strd	r3, r3, [r0, #8]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000cc8:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  hadc.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;
 8000ccc:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30
  hadc.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000cd0:	6103      	str	r3, [r0, #16]
  hadc.Init.ContinuousConvMode = DISABLE;
 8000cd2:	7683      	strb	r3, [r0, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 8000cd4:	f880 3020 	strb.w	r3, [r0, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 8000cd8:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
  hadc.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_160CYCLES_5;
 8000cdc:	6382      	str	r2, [r0, #56]	; 0x38
  hadc.Init.OversamplingMode = DISABLE;
 8000cde:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  hadc.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 8000ce2:	64c3      	str	r3, [r0, #76]	; 0x4c
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8000ce4:	f001 fe70 	bl	80029c8 <HAL_ADC_Init>
 8000ce8:	b118      	cbz	r0, 8000cf2 <MX_ADC_Init+0x4e>
  }
  /* USER CODE BEGIN ADC_Init 2 */

  /* USER CODE END ADC_Init 2 */

}
 8000cea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8000cee:	f000 b92b 	b.w	8000f48 <Error_Handler>
}
 8000cf2:	bd08      	pop	{r3, pc}
 8000cf4:	200018e0 	.word	0x200018e0
 8000cf8:	40012400 	.word	0x40012400

08000cfc <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 8000cfc:	6802      	ldr	r2, [r0, #0]
 8000cfe:	4b08      	ldr	r3, [pc, #32]	; (8000d20 <HAL_ADC_MspInit+0x24>)
 8000d00:	429a      	cmp	r2, r3
{
 8000d02:	b082      	sub	sp, #8
  if(adcHandle->Instance==ADC)
 8000d04:	d10a      	bne.n	8000d1c <HAL_ADC_MspInit+0x20>
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB2ENR, Periphs);
 8000d06:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8000d0a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000d0c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000d10:	661a      	str	r2, [r3, #96]	; 0x60
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
 8000d12:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000d14:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8000d18:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8000d1a:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_ADC_CLK_ENABLE();
  /* USER CODE BEGIN ADC_MspInit 1 */

  /* USER CODE END ADC_MspInit 1 */
  }
}
 8000d1c:	b002      	add	sp, #8
 8000d1e:	4770      	bx	lr
 8000d20:	40012400 	.word	0x40012400

08000d24 <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC)
 8000d24:	6802      	ldr	r2, [r0, #0]
 8000d26:	4b05      	ldr	r3, [pc, #20]	; (8000d3c <HAL_ADC_MspDeInit+0x18>)
 8000d28:	429a      	cmp	r2, r3
  *         @arg @ref LL_APB2_GRP1_PERIPH_TIM17
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APB2ENR, Periphs);
 8000d2a:	bf01      	itttt	eq
 8000d2c:	f04f 42b0 	moveq.w	r2, #1476395008	; 0x58000000
 8000d30:	6e13      	ldreq	r3, [r2, #96]	; 0x60
 8000d32:	f423 7300 	biceq.w	r3, r3, #512	; 0x200
 8000d36:	6613      	streq	r3, [r2, #96]	; 0x60
    __HAL_RCC_ADC_CLK_DISABLE();
  /* USER CODE BEGIN ADC_MspDeInit 1 */

  /* USER CODE END ADC_MspDeInit 1 */
  }
}
 8000d38:	4770      	bx	lr
 8000d3a:	bf00      	nop
 8000d3c:	40012400 	.word	0x40012400

08000d40 <ADC_ReadChannels>:
/* USER CODE BEGIN PrFD */

/* USER CODE END PrFD */

static uint32_t ADC_ReadChannels(uint32_t channel)
{
 8000d40:	b530      	push	{r4, r5, lr}
 8000d42:	b085      	sub	sp, #20
  /* USER CODE BEGIN ADC_ReadChannels_1 */

  /* USER CODE END ADC_ReadChannels_1 */
  uint32_t ADCxConvertedValues = 0;
  ADC_ChannelConfTypeDef sConfig = {0};
 8000d44:	2400      	movs	r4, #0
{
 8000d46:	4605      	mov	r5, r0
  ADC_ChannelConfTypeDef sConfig = {0};
 8000d48:	e9cd 4401 	strd	r4, r4, [sp, #4]
 8000d4c:	9403      	str	r4, [sp, #12]

  MX_ADC_Init();
 8000d4e:	f7ff ffa9 	bl	8000ca4 <MX_ADC_Init>

  /* Start Calibration */
  if (HAL_ADCEx_Calibration_Start(&hadc) != HAL_OK)
 8000d52:	4814      	ldr	r0, [pc, #80]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d54:	f002 f9e0 	bl	8003118 <HAL_ADCEx_Calibration_Start>
 8000d58:	b108      	cbz	r0, 8000d5e <ADC_ReadChannels+0x1e>
  {
    Error_Handler();
 8000d5a:	f000 f8f5 	bl	8000f48 <Error_Handler>

  /* Configure Regular Channel */
  sConfig.Channel = channel;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d5e:	4811      	ldr	r0, [pc, #68]	; (8000da4 <ADC_ReadChannels+0x64>)
  sConfig.SamplingTime = ADC_SAMPLINGTIME_COMMON_1;
 8000d60:	9403      	str	r4, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d62:	a901      	add	r1, sp, #4
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000d64:	e9cd 5401 	strd	r5, r4, [sp, #4]
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000d68:	f001 ffb0 	bl	8002ccc <HAL_ADC_ConfigChannel>
 8000d6c:	b108      	cbz	r0, 8000d72 <ADC_ReadChannels+0x32>
  {
    Error_Handler();
 8000d6e:	f000 f8eb 	bl	8000f48 <Error_Handler>
  }

  if (HAL_ADC_Start(&hadc) != HAL_OK)
 8000d72:	480c      	ldr	r0, [pc, #48]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d74:	f002 f904 	bl	8002f80 <HAL_ADC_Start>
 8000d78:	b108      	cbz	r0, 8000d7e <ADC_ReadChannels+0x3e>
  {
    /* Start Error */
    Error_Handler();
 8000d7a:	f000 f8e5 	bl	8000f48 <Error_Handler>
  }
  /** Wait for end of conversion */
  HAL_ADC_PollForConversion(&hadc, HAL_MAX_DELAY);
 8000d7e:	f04f 31ff 	mov.w	r1, #4294967295
 8000d82:	4808      	ldr	r0, [pc, #32]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d84:	f001 ff44 	bl	8002c10 <HAL_ADC_PollForConversion>

  /** Wait for end of conversion */
  HAL_ADC_Stop(&hadc) ;   /* it calls also ADC_Disable() */
 8000d88:	4806      	ldr	r0, [pc, #24]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d8a:	f002 f9a7 	bl	80030dc <HAL_ADC_Stop>

  ADCxConvertedValues = HAL_ADC_GetValue(&hadc);
 8000d8e:	4805      	ldr	r0, [pc, #20]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d90:	f001 ff99 	bl	8002cc6 <HAL_ADC_GetValue>
 8000d94:	4604      	mov	r4, r0

  HAL_ADC_DeInit(&hadc);
 8000d96:	4803      	ldr	r0, [pc, #12]	; (8000da4 <ADC_ReadChannels+0x64>)
 8000d98:	f002 f954 	bl	8003044 <HAL_ADC_DeInit>

  return ADCxConvertedValues;
  /* USER CODE BEGIN ADC_ReadChannels_2 */

  /* USER CODE END ADC_ReadChannels_2 */
}
 8000d9c:	4620      	mov	r0, r4
 8000d9e:	b005      	add	sp, #20
 8000da0:	bd30      	pop	{r4, r5, pc}
 8000da2:	bf00      	nop
 8000da4:	200018e0 	.word	0x200018e0

08000da8 <SYS_InitMeasurement>:
  hadc.Instance = ADC;
 8000da8:	4b01      	ldr	r3, [pc, #4]	; (8000db0 <SYS_InitMeasurement+0x8>)
 8000daa:	4a02      	ldr	r2, [pc, #8]	; (8000db4 <SYS_InitMeasurement+0xc>)
 8000dac:	601a      	str	r2, [r3, #0]
}
 8000dae:	4770      	bx	lr
 8000db0:	200018e0 	.word	0x200018e0
 8000db4:	40012400 	.word	0x40012400

08000db8 <SYS_GetBatteryLevel>:
{
 8000db8:	b508      	push	{r3, lr}
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_VREFINT);
 8000dba:	4809      	ldr	r0, [pc, #36]	; (8000de0 <SYS_GetBatteryLevel+0x28>)
 8000dbc:	f7ff ffc0 	bl	8000d40 <ADC_ReadChannels>
  if (measuredLevel == 0)
 8000dc0:	b160      	cbz	r0, 8000ddc <SYS_GetBatteryLevel+0x24>
    if ((uint32_t)*VREFINT_CAL_ADDR != (uint32_t)0xFFFFU)
 8000dc2:	4b08      	ldr	r3, [pc, #32]	; (8000de4 <SYS_GetBatteryLevel+0x2c>)
 8000dc4:	881a      	ldrh	r2, [r3, #0]
 8000dc6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000dca:	429a      	cmp	r2, r3
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000dcc:	bf16      	itet	ne
 8000dce:	f640 43e4 	movwne	r3, #3300	; 0xce4
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000dd2:	4b05      	ldreq	r3, [pc, #20]	; (8000de8 <SYS_GetBatteryLevel+0x30>)
      batteryLevelmV = __LL_ADC_CALC_VREFANALOG_VOLTAGE(measuredLevel,
 8000dd4:	4353      	mulne	r3, r2
      batteryLevelmV = (VREFINT_CAL_VREF * 1510) / measuredLevel;
 8000dd6:	fbb3 f0f0 	udiv	r0, r3, r0
 8000dda:	b280      	uxth	r0, r0
}
 8000ddc:	bd08      	pop	{r3, pc}
 8000dde:	bf00      	nop
 8000de0:	b4002000 	.word	0xb4002000
 8000de4:	1fff75aa 	.word	0x1fff75aa
 8000de8:	004c08d8 	.word	0x004c08d8

08000dec <SYS_GetTemperatureLevel>:
{
 8000dec:	b513      	push	{r0, r1, r4, lr}
  uint16_t batteryLevelmV = SYS_GetBatteryLevel();
 8000dee:	f7ff ffe3 	bl	8000db8 <SYS_GetBatteryLevel>
 8000df2:	4604      	mov	r4, r0
  measuredLevel = ADC_ReadChannels(ADC_CHANNEL_TEMPSENSOR);
 8000df4:	4818      	ldr	r0, [pc, #96]	; (8000e58 <SYS_GetTemperatureLevel+0x6c>)
 8000df6:	f7ff ffa3 	bl	8000d40 <ADC_ReadChannels>
  if (((int32_t)*TEMPSENSOR_CAL2_ADDR - (int32_t)*TEMPSENSOR_CAL1_ADDR) != 0)
 8000dfa:	4b18      	ldr	r3, [pc, #96]	; (8000e5c <SYS_GetTemperatureLevel+0x70>)
 8000dfc:	4a18      	ldr	r2, [pc, #96]	; (8000e60 <SYS_GetTemperatureLevel+0x74>)
 8000dfe:	881b      	ldrh	r3, [r3, #0]
 8000e00:	8812      	ldrh	r2, [r2, #0]
 8000e02:	4293      	cmp	r3, r2
 8000e04:	fb00 f004 	mul.w	r0, r0, r4
 8000e08:	d016      	beq.n	8000e38 <SYS_GetTemperatureLevel+0x4c>
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE(batteryLevelmV,
 8000e0a:	f640 44e4 	movw	r4, #3300	; 0xce4
 8000e0e:	fbb0 f0f4 	udiv	r0, r0, r4
 8000e12:	2464      	movs	r4, #100	; 0x64
 8000e14:	1a80      	subs	r0, r0, r2
 8000e16:	4344      	muls	r4, r0
 8000e18:	1a9b      	subs	r3, r3, r2
 8000e1a:	fb94 f4f3 	sdiv	r4, r4, r3
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 8000e1e:	341e      	adds	r4, #30
 8000e20:	b224      	sxth	r4, r4
  APP_LOG(TS_ON, VLEVEL_L, "temp= %d\n\r", temperatureDegreeC);
 8000e22:	2201      	movs	r2, #1
 8000e24:	4b0f      	ldr	r3, [pc, #60]	; (8000e64 <SYS_GetTemperatureLevel+0x78>)
 8000e26:	9400      	str	r4, [sp, #0]
 8000e28:	2100      	movs	r1, #0
 8000e2a:	4610      	mov	r0, r2
 8000e2c:	f00e f86c 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  temperatureDegreeC <<= 8;
 8000e30:	0220      	lsls	r0, r4, #8
}
 8000e32:	b200      	sxth	r0, r0
 8000e34:	b002      	add	sp, #8
 8000e36:	bd10      	pop	{r4, pc}
    temperatureDegreeC = __LL_ADC_CALC_TEMPERATURE_TYP_PARAMS(TEMPSENSOR_TYP_AVGSLOPE,
 8000e38:	f640 74ff 	movw	r4, #4095	; 0xfff
 8000e3c:	fbb0 f0f4 	udiv	r0, r0, r4
 8000e40:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
 8000e44:	4344      	muls	r4, r0
 8000e46:	f5a4 2439 	sub.w	r4, r4, #757760	; 0xb9000
 8000e4a:	f5a4 640c 	sub.w	r4, r4, #2240	; 0x8c0
 8000e4e:	f640 10c4 	movw	r0, #2500	; 0x9c4
 8000e52:	fb94 f4f0 	sdiv	r4, r4, r0
 8000e56:	e7e2      	b.n	8000e1e <SYS_GetTemperatureLevel+0x32>
 8000e58:	b0001000 	.word	0xb0001000
 8000e5c:	1fff75c8 	.word	0x1fff75c8
 8000e60:	1fff75a8 	.word	0x1fff75a8
 8000e64:	080103d9 	.word	0x080103d9

08000e68 <MX_DMA_Init>:
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000e68:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8000e6c:	b507      	push	{r0, r1, r2, lr}
 8000e6e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000e70:	f042 0204 	orr.w	r2, r2, #4
 8000e74:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000e76:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000e78:	f002 0204 	and.w	r2, r2, #4
 8000e7c:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8000e7e:	9a01      	ldr	r2, [sp, #4]
  SET_BIT(RCC->AHB1ENR, Periphs);
 8000e80:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8000e82:	f042 0201 	orr.w	r2, r2, #1
 8000e86:	649a      	str	r2, [r3, #72]	; 0x48
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 8000e88:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8000e8a:	f003 0301 	and.w	r3, r3, #1
 8000e8e:	9300      	str	r3, [sp, #0]
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 2, 0);
 8000e90:	2200      	movs	r2, #0
 8000e92:	2102      	movs	r1, #2
 8000e94:	200f      	movs	r0, #15
  (void)tmpreg;
 8000e96:	9b00      	ldr	r3, [sp, #0]
 8000e98:	f002 f99c 	bl	80031d4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 8000e9c:	200f      	movs	r0, #15

}
 8000e9e:	b003      	add	sp, #12
 8000ea0:	f85d eb04 	ldr.w	lr, [sp], #4
  HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
 8000ea4:	f002 b9c8 	b.w	8003238 <HAL_NVIC_EnableIRQ>

08000ea8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000ea8:	b500      	push	{lr}
 8000eaa:	b09b      	sub	sp, #108	; 0x6c
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000eac:	2248      	movs	r2, #72	; 0x48
 8000eae:	2100      	movs	r1, #0
 8000eb0:	a808      	add	r0, sp, #32
 8000eb2:	f00e fd8f 	bl	800f9d4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000eb6:	221c      	movs	r2, #28
 8000eb8:	2100      	movs	r1, #0
 8000eba:	a801      	add	r0, sp, #4
 8000ebc:	f00e fd8a 	bl	800f9d4 <memset>

  /** Configure LSE Drive Capability
  */
  HAL_PWR_EnableBkUpAccess();
 8000ec0:	f003 f844 	bl	8003f4c <HAL_PWR_EnableBkUpAccess>
  *         @arg @ref LL_RCC_LSEDRIVE_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_RCC_LSE_SetDriveCapability(uint32_t LSEDrive)
{
  MODIFY_REG(RCC->BDCR, RCC_BDCR_LSEDRV, LSEDrive);
 8000ec4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  /** Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8000ec8:	2001      	movs	r0, #1
 8000eca:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8000ece:	f023 0318 	bic.w	r3, r3, #24
 8000ed2:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000ed6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 8000eda:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8000ede:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000ee2:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
 8000ee6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
 8000eea:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8000eee:	9300      	str	r3, [sp, #0]
 8000ef0:	9b00      	ldr	r3, [sp, #0]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8000ef2:	2324      	movs	r3, #36	; 0x24
 8000ef4:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8000ef6:	2381      	movs	r3, #129	; 0x81
 8000ef8:	930b      	str	r3, [sp, #44]	; 0x2c
  RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
 8000efa:	2300      	movs	r3, #0
 8000efc:	e9cd 0310 	strd	r0, r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
 8000f00:	22b0      	movs	r2, #176	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000f02:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000f04:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000f08:	f003 f9a0 	bl	800424c <HAL_RCC_OscConfig>
 8000f0c:	b108      	cbz	r0, 8000f12 <SystemClock_Config+0x6a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f0e:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000f10:	e7fe      	b.n	8000f10 <SystemClock_Config+0x68>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
 8000f12:	234f      	movs	r3, #79	; 0x4f
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
 8000f14:	e9cd 3001 	strd	r3, r0, [sp, #4]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000f18:	e9cd 0003 	strd	r0, r0, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000f1c:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
 8000f1e:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8000f20:	2102      	movs	r1, #2
 8000f22:	a801      	add	r0, sp, #4
 8000f24:	f003 fc32 	bl	800478c <HAL_RCC_ClockConfig>
 8000f28:	b108      	cbz	r0, 8000f2e <SystemClock_Config+0x86>
 8000f2a:	b672      	cpsid	i
  while (1)
 8000f2c:	e7fe      	b.n	8000f2c <SystemClock_Config+0x84>
}
 8000f2e:	b01b      	add	sp, #108	; 0x6c
 8000f30:	f85d fb04 	ldr.w	pc, [sp], #4

08000f34 <main>:
int main(void){
 8000f34:	b508      	push	{r3, lr}
  HAL_Init();
 8000f36:	f001 fcdb 	bl	80028f0 <HAL_Init>
  SystemClock_Config();
 8000f3a:	f7ff ffb5 	bl	8000ea8 <SystemClock_Config>
  MX_LoRaWAN_Init();
 8000f3e:	f000 fd9d 	bl	8001a7c <MX_LoRaWAN_Init>
    MX_LoRaWAN_Process();
 8000f42:	f000 fda2 	bl	8001a8a <MX_LoRaWAN_Process>
  while (1)
 8000f46:	e7fc      	b.n	8000f42 <main+0xe>

08000f48 <Error_Handler>:
 8000f48:	b672      	cpsid	i
  while (1)
 8000f4a:	e7fe      	b.n	8000f4a <Error_Handler+0x2>

08000f4c <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 8000f4c:	b500      	push	{lr}
 8000f4e:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 8000f50:	222c      	movs	r2, #44	; 0x2c
 8000f52:	2100      	movs	r1, #0
 8000f54:	a801      	add	r0, sp, #4
 8000f56:	f00e fd3d 	bl	800f9d4 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 8000f5a:	4817      	ldr	r0, [pc, #92]	; (8000fb8 <MX_RTC_Init+0x6c>)
 8000f5c:	4b17      	ldr	r3, [pc, #92]	; (8000fbc <MX_RTC_Init+0x70>)
 8000f5e:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 8000f60:	231f      	movs	r3, #31
 8000f62:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8000f64:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8000f68:	2300      	movs	r3, #0
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8000f6a:	e9c0 3304 	strd	r3, r3, [r0, #16]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 8000f6e:	e9c0 2307 	strd	r2, r3, [r0, #28]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 8000f72:	6183      	str	r3, [r0, #24]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 8000f74:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000f78:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8000f7a:	f003 fed3 	bl	8004d24 <HAL_RTC_Init>
 8000f7e:	b108      	cbz	r0, 8000f84 <MX_RTC_Init+0x38>
  {
    Error_Handler();
 8000f80:	f7ff ffe2 	bl	8000f48 <Error_Handler>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 8000f84:	480c      	ldr	r0, [pc, #48]	; (8000fb8 <MX_RTC_Init+0x6c>)
 8000f86:	f003 fff1 	bl	8004f6c <HAL_RTCEx_SetSSRU_IT>
 8000f8a:	b108      	cbz	r0, 8000f90 <MX_RTC_Init+0x44>
  {
    Error_Handler();
 8000f8c:	f7ff ffdc 	bl	8000f48 <Error_Handler>
  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
  sAlarm.AlarmTime.SubSeconds = 0x0;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8000f90:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8000f94:	2200      	movs	r2, #0
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8000f96:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8000f98:	4807      	ldr	r0, [pc, #28]	; (8000fb8 <MX_RTC_Init+0x6c>)
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8000f9a:	9208      	str	r2, [sp, #32]
  sAlarm.Alarm = RTC_ALARM_A;
 8000f9c:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8000fa0:	a901      	add	r1, sp, #4
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8000fa2:	9202      	str	r2, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8000fa4:	9206      	str	r2, [sp, #24]
  sAlarm.Alarm = RTC_ALARM_A;
 8000fa6:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8000fa8:	f003 ff18 	bl	8004ddc <HAL_RTC_SetAlarm_IT>
 8000fac:	b108      	cbz	r0, 8000fb2 <MX_RTC_Init+0x66>
  {
    Error_Handler();
 8000fae:	f7ff ffcb 	bl	8000f48 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 8000fb2:	b00d      	add	sp, #52	; 0x34
 8000fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000fb8:	20001944 	.word	0x20001944
 8000fbc:	40002800 	.word	0x40002800

08000fc0 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8000fc0:	b510      	push	{r4, lr}
 8000fc2:	4604      	mov	r4, r0
 8000fc4:	b090      	sub	sp, #64	; 0x40

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8000fc6:	2238      	movs	r2, #56	; 0x38
 8000fc8:	2100      	movs	r1, #0
 8000fca:	a802      	add	r0, sp, #8
 8000fcc:	f00e fd02 	bl	800f9d4 <memset>
  if(rtcHandle->Instance==RTC)
 8000fd0:	6822      	ldr	r2, [r4, #0]
 8000fd2:	4b19      	ldr	r3, [pc, #100]	; (8001038 <HAL_RTC_MspInit+0x78>)
 8000fd4:	429a      	cmp	r2, r3
 8000fd6:	d12c      	bne.n	8001032 <HAL_RTC_MspInit+0x72>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8000fd8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8000fdc:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;

    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000fde:	a802      	add	r0, sp, #8
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 8000fe0:	f44f 7380 	mov.w	r3, #256	; 0x100
 8000fe4:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8000fe6:	f003 fd0d 	bl	8004a04 <HAL_RCCEx_PeriphCLKConfig>
 8000fea:	b108      	cbz	r0, 8000ff0 <HAL_RTC_MspInit+0x30>
    {
      Error_Handler();
 8000fec:	f7ff ffac 	bl	8000f48 <Error_Handler>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 8000ff0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
    __HAL_RCC_RTCAPB_CLK_ENABLE();

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(TAMP_STAMP_LSECSS_SSRU_IRQn, 0, 0);
 8000ff4:	2002      	movs	r0, #2
 8000ff6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8000ffa:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000ffe:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  SET_BIT(RCC->APB1ENR1, Periphs);
 8001002:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001004:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001008:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800100a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800100c:	2200      	movs	r2, #0
 800100e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8001012:	4611      	mov	r1, r2
 8001014:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 8001016:	9b01      	ldr	r3, [sp, #4]
 8001018:	f002 f8dc 	bl	80031d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TAMP_STAMP_LSECSS_SSRU_IRQn);
 800101c:	2002      	movs	r0, #2
 800101e:	f002 f90b 	bl	8003238 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 8001022:	2200      	movs	r2, #0
 8001024:	202a      	movs	r0, #42	; 0x2a
 8001026:	4611      	mov	r1, r2
 8001028:	f002 f8d4 	bl	80031d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 800102c:	202a      	movs	r0, #42	; 0x2a
 800102e:	f002 f903 	bl	8003238 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 8001032:	b010      	add	sp, #64	; 0x40
 8001034:	bd10      	pop	{r4, pc}
 8001036:	bf00      	nop
 8001038:	40002800 	.word	0x40002800

0800103c <sensirion_i2c_init>:
/**
 * Initialize all hard- and software components that are needed for the I2C
 * communication.
 */
void sensirion_i2c_init(void) {
	BSP_I2C2_Init();
 800103c:	f000 b8e2 	b.w	8001204 <BSP_I2C2_Init>

08001040 <sensirion_i2c_release>:

/**
 * Release all resources initialized by sensirion_i2c_init().
 */
void sensirion_i2c_release(void) {
	BSP_I2C2_DeInit();
 8001040:	f000 b868 	b.w	8001114 <BSP_I2C2_DeInit>

08001044 <sensirion_i2c_read>:
 * @param address 7-bit I2C address to read from
 * @param data    pointer to the buffer where the data is to be stored
 * @param count   number of bytes to read from I2C and store in the buffer
 * @returns 0 on success, error code otherwise
 */
int8_t sensirion_i2c_read(uint8_t address, uint8_t* data, uint16_t count) {
 8001044:	b508      	push	{r3, lr}
	return (int8_t)BSP_I2C2_Recv((uint16_t)(address << 1), data, count);
 8001046:	0040      	lsls	r0, r0, #1
 8001048:	f000 f89a 	bl	8001180 <BSP_I2C2_Recv>
}
 800104c:	b240      	sxtb	r0, r0
 800104e:	bd08      	pop	{r3, pc}

08001050 <sensirion_i2c_write>:
 * @param data    pointer to the buffer containing the data to write
 * @param count   number of bytes to read from the buffer and send over I2C
 * @returns 0 on success, error code otherwise
 */
int8_t sensirion_i2c_write(uint8_t address, const uint8_t* data,
                           uint16_t count) {
 8001050:	b508      	push	{r3, lr}
   return (int8_t)BSP_I2C2_Send((uint16_t)(address << 1),(uint8_t*)data, count);
 8001052:	0040      	lsls	r0, r0, #1
 8001054:	f000 f87a 	bl	800114c <BSP_I2C2_Send>
}
 8001058:	b240      	sxtb	r0, r0
 800105a:	bd08      	pop	{r3, pc}

0800105c <sensirion_sleep_usec>:
 * Sleep for a given number of microseconds. The function should delay the
 * execution for at least the given time, but may also sleep longer.
 *
 * @param useconds the sleep time in microseconds
 */
void sensirion_sleep_usec(uint32_t useconds) {
 800105c:	4602      	mov	r2, r0
    uint32_t msec = useconds / 1000;
 800105e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001062:	fbb0 f0f3 	udiv	r0, r0, r3
    if (useconds % 1000 > 0) {
 8001066:	fb03 2310 	mls	r3, r3, r0, r2
 800106a:	b103      	cbz	r3, 800106e <sensirion_sleep_usec+0x12>
        msec++;
 800106c:	3001      	adds	r0, #1
    }
    HAL_Delay(msec);
 800106e:	f000 ba33 	b.w	80014d8 <HAL_Delay>

08001072 <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 8001072:	4770      	bx	lr

08001074 <PWR_EnterStopMode>:

  /* USER CODE END ExitOffMode_1 */
}

void PWR_EnterStopMode(void)
{
 8001074:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 8001076:	f001 fc51 	bl	800291c <HAL_SuspendTick>
  * @rmtoll EXTSCR       C1CSSF        LL_PWR_ClearFlag_C1STOP_C1STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C1STOP_C1STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C1CSSF);
 800107a:	4b04      	ldr	r3, [pc, #16]	; (800108c <PWR_EnterStopMode+0x18>)
 800107c:	2001      	movs	r0, #1
 800107e:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 8001082:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 8001086:	f002 bfbb 	b.w	8004000 <HAL_PWREx_EnterSTOP2Mode>
 800108a:	bf00      	nop
 800108c:	58000400 	.word	0x58000400

08001090 <PWR_ExitSleepMode>:
{
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Suspend sysTick */
  HAL_ResumeTick();
 8001090:	f001 bc4c 	b.w	800292c <HAL_ResumeTick>

08001094 <PWR_ExitStopMode>:
{
 8001094:	b508      	push	{r3, lr}
  HAL_ResumeTick();
 8001096:	f001 fc49 	bl	800292c <HAL_ResumeTick>
}
 800109a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  vcom_Resume();
 800109e:	f000 bcbd 	b.w	8001a1c <vcom_Resume>

080010a2 <PWR_EnterSleepMode>:
{
 80010a2:	b508      	push	{r3, lr}
  HAL_SuspendTick();
 80010a4:	f001 fc3a 	bl	800291c <HAL_SuspendTick>
}
 80010a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 80010ac:	2101      	movs	r1, #1
 80010ae:	2000      	movs	r0, #0
 80010b0:	f002 bf54 	b.w	8003f5c <HAL_PWR_EnterSLEEPMode>

080010b4 <PWR_ExitOffMode>:
 80010b4:	4770      	bx	lr

080010b6 <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80010b6:	4770      	bx	lr

080010b8 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 80010b8:	e7fe      	b.n	80010b8 <NMI_Handler>

080010ba <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80010ba:	e7fe      	b.n	80010ba <HardFault_Handler>

080010bc <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80010bc:	e7fe      	b.n	80010bc <MemManage_Handler>

080010be <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80010be:	e7fe      	b.n	80010be <BusFault_Handler>

080010c0 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80010c0:	e7fe      	b.n	80010c0 <UsageFault_Handler>

080010c2 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80010c2:	4770      	bx	lr

080010c4 <DebugMon_Handler>:
 80010c4:	4770      	bx	lr

080010c6 <PendSV_Handler>:
 80010c6:	4770      	bx	lr

080010c8 <SysTick_Handler>:
 80010c8:	4770      	bx	lr
	...

080010cc <TAMP_STAMP_LSECSS_SSRU_IRQHandler>:
void TAMP_STAMP_LSECSS_SSRU_IRQHandler(void)
{
  /* USER CODE BEGIN TAMP_STAMP_LSECSS_SSRU_IRQn 0 */

  /* USER CODE END TAMP_STAMP_LSECSS_SSRU_IRQn 0 */
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 80010cc:	4801      	ldr	r0, [pc, #4]	; (80010d4 <TAMP_STAMP_LSECSS_SSRU_IRQHandler+0x8>)
 80010ce:	f003 bf73 	b.w	8004fb8 <HAL_RTCEx_SSRUIRQHandler>
 80010d2:	bf00      	nop
 80010d4:	20001944 	.word	0x20001944

080010d8 <EXTI0_IRQHandler>:
void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 80010d8:	2001      	movs	r0, #1
 80010da:	f002 bc25 	b.w	8003928 <HAL_GPIO_EXTI_IRQHandler>

080010de <EXTI1_IRQHandler>:
void EXTI1_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI1_IRQn 0 */

  /* USER CODE END EXTI1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 80010de:	2002      	movs	r0, #2
 80010e0:	f002 bc22 	b.w	8003928 <HAL_GPIO_EXTI_IRQHandler>

080010e4 <DMA1_Channel5_IRQHandler>:
void DMA1_Channel5_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel5_IRQn 0 */

  /* USER CODE END DMA1_Channel5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 80010e4:	4801      	ldr	r0, [pc, #4]	; (80010ec <DMA1_Channel5_IRQHandler+0x8>)
 80010e6:	f002 ba85 	b.w	80035f4 <HAL_DMA_IRQHandler>
 80010ea:	bf00      	nop
 80010ec:	200019d4 	.word	0x200019d4

080010f0 <USART2_IRQHandler>:
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 80010f0:	4801      	ldr	r0, [pc, #4]	; (80010f8 <USART2_IRQHandler+0x8>)
 80010f2:	f004 bb31 	b.w	8005758 <HAL_UART_IRQHandler>
 80010f6:	bf00      	nop
 80010f8:	20001a34 	.word	0x20001a34

080010fc <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 80010fc:	4801      	ldr	r0, [pc, #4]	; (8001104 <RTC_Alarm_IRQHandler+0x8>)
 80010fe:	f003 bd93 	b.w	8004c28 <HAL_RTC_AlarmIRQHandler>
 8001102:	bf00      	nop
 8001104:	20001944 	.word	0x20001944

08001108 <SUBGHZ_Radio_IRQHandler>:
void SUBGHZ_Radio_IRQHandler(void)
{
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 8001108:	4801      	ldr	r0, [pc, #4]	; (8001110 <SUBGHZ_Radio_IRQHandler+0x8>)
 800110a:	f004 b9e6 	b.w	80054da <HAL_SUBGHZ_IRQHandler>
 800110e:	bf00      	nop
 8001110:	200019c8 	.word	0x200019c8

08001114 <BSP_I2C2_DeInit>:
  */
int32_t BSP_I2C2_DeInit(void)
{
  int32_t ret = BSP_ERROR_NONE;

  if (I2C2InitCounter > 0)
 8001114:	4a0b      	ldr	r2, [pc, #44]	; (8001144 <BSP_I2C2_DeInit+0x30>)
{
 8001116:	b508      	push	{r3, lr}
  if (I2C2InitCounter > 0)
 8001118:	6813      	ldr	r3, [r2, #0]
 800111a:	b90b      	cbnz	r3, 8001120 <BSP_I2C2_DeInit+0xc>
  int32_t ret = BSP_ERROR_NONE;
 800111c:	2000      	movs	r0, #0
        ret = BSP_ERROR_BUS_FAILURE;
      }
    }
  }
  return ret;
}
 800111e:	bd08      	pop	{r3, pc}
    if (--I2C2InitCounter == 0)
 8001120:	3b01      	subs	r3, #1
 8001122:	6013      	str	r3, [r2, #0]
 8001124:	2b00      	cmp	r3, #0
 8001126:	d1f9      	bne.n	800111c <BSP_I2C2_DeInit+0x8>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8001128:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
      if (HAL_I2C_DeInit(&hi2c2) != HAL_OK)
 800112c:	4806      	ldr	r0, [pc, #24]	; (8001148 <BSP_I2C2_DeInit+0x34>)
 800112e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001130:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001134:	6593      	str	r3, [r2, #88]	; 0x58
 8001136:	f002 fd71 	bl	8003c1c <HAL_I2C_DeInit>
 800113a:	2800      	cmp	r0, #0
 800113c:	d0ee      	beq.n	800111c <BSP_I2C2_DeInit+0x8>
        ret = BSP_ERROR_BUS_FAILURE;
 800113e:	f06f 0007 	mvn.w	r0, #7
  return ret;
 8001142:	e7ec      	b.n	800111e <BSP_I2C2_DeInit+0xa>
 8001144:	2000015c 	.word	0x2000015c
 8001148:	2000197c 	.word	0x2000197c

0800114c <BSP_I2C2_Send>:
  * @param  DevAddr: Device address on Bus.
  * @param  pData: Data pointer
  * @param  Length: Data length
  * @retval BSP status
  */
int32_t BSP_I2C2_Send(uint16_t DevAddr, uint8_t *pData, uint16_t Length) {
 800114c:	b507      	push	{r0, r1, r2, lr}
 800114e:	4613      	mov	r3, r2
  int32_t ret = BSP_ERROR_NONE;

  if (HAL_I2C_Master_Transmit(&hi2c2, DevAddr, pData, Length, BUS_I2C2_POLL_TIMEOUT) != HAL_OK)
 8001150:	f242 7210 	movw	r2, #10000	; 0x2710
 8001154:	9200      	str	r2, [sp, #0]
 8001156:	460a      	mov	r2, r1
 8001158:	4601      	mov	r1, r0
 800115a:	4808      	ldr	r0, [pc, #32]	; (800117c <BSP_I2C2_Send+0x30>)
 800115c:	f002 fd78 	bl	8003c50 <HAL_I2C_Master_Transmit>
 8001160:	b140      	cbz	r0, 8001174 <BSP_I2C2_Send+0x28>
  {
    if (HAL_I2C_GetError(&hi2c2) != HAL_I2C_ERROR_AF)
 8001162:	4806      	ldr	r0, [pc, #24]	; (800117c <BSP_I2C2_Send+0x30>)
 8001164:	f002 fea5 	bl	8003eb2 <HAL_I2C_GetError>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 8001168:	2804      	cmp	r0, #4
 800116a:	bf14      	ite	ne
 800116c:	f06f 0065 	mvnne.w	r0, #101	; 0x65
 8001170:	f06f 0003 	mvneq.w	r0, #3
    }
  }

  return ret;
}
 8001174:	b003      	add	sp, #12
 8001176:	f85d fb04 	ldr.w	pc, [sp], #4
 800117a:	bf00      	nop
 800117c:	2000197c 	.word	0x2000197c

08001180 <BSP_I2C2_Recv>:
  * @param  DevAddr: Device address on Bus.
  * @param  pData: Data pointer
  * @param  Length: Data length
  * @retval BSP status
  */
int32_t BSP_I2C2_Recv(uint16_t DevAddr, uint8_t *pData, uint16_t Length) {
 8001180:	b507      	push	{r0, r1, r2, lr}
 8001182:	4613      	mov	r3, r2
  int32_t ret = BSP_ERROR_NONE;

  if (HAL_I2C_Master_Receive(&hi2c2, DevAddr, pData, Length, BUS_I2C2_POLL_TIMEOUT) != HAL_OK)
 8001184:	f242 7210 	movw	r2, #10000	; 0x2710
 8001188:	9200      	str	r2, [sp, #0]
 800118a:	460a      	mov	r2, r1
 800118c:	4601      	mov	r1, r0
 800118e:	4808      	ldr	r0, [pc, #32]	; (80011b0 <BSP_I2C2_Recv+0x30>)
 8001190:	f002 fdf4 	bl	8003d7c <HAL_I2C_Master_Receive>
 8001194:	b140      	cbz	r0, 80011a8 <BSP_I2C2_Recv+0x28>
  {
    if (HAL_I2C_GetError(&hi2c2) != HAL_I2C_ERROR_AF)
 8001196:	4806      	ldr	r0, [pc, #24]	; (80011b0 <BSP_I2C2_Recv+0x30>)
 8001198:	f002 fe8b 	bl	8003eb2 <HAL_I2C_GetError>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
 800119c:	2804      	cmp	r0, #4
 800119e:	bf14      	ite	ne
 80011a0:	f06f 0065 	mvnne.w	r0, #101	; 0x65
 80011a4:	f06f 0003 	mvneq.w	r0, #3
    }
  }
  return ret;
}
 80011a8:	b003      	add	sp, #12
 80011aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80011ae:	bf00      	nop
 80011b0:	2000197c 	.word	0x2000197c

080011b4 <MX_I2C2_Init>:
__weak HAL_StatusTypeDef MX_I2C2_Init(I2C_HandleTypeDef* hi2c)
{
  HAL_StatusTypeDef ret = HAL_OK;

  hi2c->Instance = I2C2;
  hi2c->Init.Timing = 0x10f06e6c; /* got calling I2C_GetTiming(SystemCoreClock, BUS_I2C2_FREQUENCY); */
 80011b4:	4a11      	ldr	r2, [pc, #68]	; (80011fc <MX_I2C2_Init+0x48>)
 80011b6:	4b12      	ldr	r3, [pc, #72]	; (8001200 <MX_I2C2_Init+0x4c>)
{
 80011b8:	b570      	push	{r4, r5, r6, lr}
  hi2c->Init.OwnAddress1 = 0;
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80011ba:	2600      	movs	r6, #0
  hi2c->Init.Timing = 0x10f06e6c; /* got calling I2C_GetTiming(SystemCoreClock, BUS_I2C2_FREQUENCY); */
 80011bc:	e9c0 2300 	strd	r2, r3, [r0]
  hi2c->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80011c0:	2301      	movs	r3, #1
 80011c2:	e9c0 6302 	strd	r6, r3, [r0, #8]
  hi2c->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c->Init.OwnAddress2 = 0;
 80011c6:	e9c0 6604 	strd	r6, r6, [r0, #16]
  hi2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80011ca:	e9c0 6606 	strd	r6, r6, [r0, #24]
  hi2c->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80011ce:	6206      	str	r6, [r0, #32]
{
 80011d0:	4604      	mov	r4, r0
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 80011d2:	f002 fcd1 	bl	8003b78 <HAL_I2C_Init>
  {
    ret = HAL_ERROR;
  }

  if (HAL_I2CEx_ConfigAnalogFilter(hi2c, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80011d6:	4631      	mov	r1, r6
  if (HAL_I2C_Init(hi2c) != HAL_OK)
 80011d8:	4605      	mov	r5, r0
  if (HAL_I2CEx_ConfigAnalogFilter(hi2c, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80011da:	4620      	mov	r0, r4
 80011dc:	f002 fe6b 	bl	8003eb6 <HAL_I2CEx_ConfigAnalogFilter>
 80011e0:	4305      	orrs	r5, r0
 80011e2:	b2ed      	uxtb	r5, r5
  {
    ret = HAL_ERROR;
 80011e4:	1bad      	subs	r5, r5, r6
  }

  if (HAL_I2CEx_ConfigDigitalFilter(hi2c, 0) != HAL_OK)
 80011e6:	4631      	mov	r1, r6
 80011e8:	4620      	mov	r0, r4
    ret = HAL_ERROR;
 80011ea:	bf18      	it	ne
 80011ec:	2501      	movne	r5, #1
  if (HAL_I2CEx_ConfigDigitalFilter(hi2c, 0) != HAL_OK)
 80011ee:	f002 fe88 	bl	8003f02 <HAL_I2CEx_ConfigDigitalFilter>
 80011f2:	42b0      	cmp	r0, r6
  {
    ret = HAL_ERROR;
  }

  return ret;
}
 80011f4:	bf0c      	ite	eq
 80011f6:	4628      	moveq	r0, r5
 80011f8:	2001      	movne	r0, #1
 80011fa:	bd70      	pop	{r4, r5, r6, pc}
 80011fc:	40005800 	.word	0x40005800
 8001200:	10f06e6c 	.word	0x10f06e6c

08001204 <BSP_I2C2_Init>:
{
 8001204:	b510      	push	{r4, lr}
  if(I2C2InitCounter++ == 0)
 8001206:	4a21      	ldr	r2, [pc, #132]	; (800128c <BSP_I2C2_Init+0x88>)
 8001208:	6813      	ldr	r3, [r2, #0]
 800120a:	1c59      	adds	r1, r3, #1
{
 800120c:	b088      	sub	sp, #32
  if(I2C2InitCounter++ == 0)
 800120e:	6011      	str	r1, [r2, #0]
 8001210:	2b00      	cmp	r3, #0
 8001212:	d139      	bne.n	8001288 <BSP_I2C2_Init+0x84>
    if (HAL_I2C_GetState(&hi2c2) == HAL_I2C_STATE_RESET)
 8001214:	481e      	ldr	r0, [pc, #120]	; (8001290 <BSP_I2C2_Init+0x8c>)
 8001216:	f002 fe49 	bl	8003eac <HAL_I2C_GetState>
 800121a:	2800      	cmp	r0, #0
 800121c:	d134      	bne.n	8001288 <BSP_I2C2_Init+0x84>
  SET_BIT(RCC->AHB2ENR, Periphs);
 800121e:	f04f 44b0 	mov.w	r4, #1476395008	; 0x58000000

  /* USER CODE END I2C2_MspInit 0 */
    BUS_I2C2_GPIO_CLK_ENABLE();
    /* I2C2 GPIO Configuration */
    GPIO_InitStruct.Pin = BUS_I2C2_SCL_GPIO_PIN | BUS_I2C2_SDA_GPIO_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8001222:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 8001226:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8001228:	f043 0301 	orr.w	r3, r3, #1
 800122c:	64e3      	str	r3, [r4, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800122e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001230:	9005      	str	r0, [sp, #20]
 8001232:	f003 0301 	and.w	r3, r3, #1
 8001236:	9302      	str	r3, [sp, #8]
  (void)tmpreg;
 8001238:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800123a:	2312      	movs	r3, #18
 800123c:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = BUS_I2C2_GPIO_AF;
 8001240:	2103      	movs	r1, #3
 8001242:	2304      	movs	r3, #4
 8001244:	e9cd 1306 	strd	r1, r3, [sp, #24]
    HAL_GPIO_Init(BUS_I2C2_GPIO_PORT, &GPIO_InitStruct);
 8001248:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800124c:	a903      	add	r1, sp, #12
 800124e:	f002 fa45 	bl	80036dc <HAL_GPIO_Init>
  CLEAR_BIT(RCC->AHB2ENR, Periphs);
 8001252:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
        if(MX_I2C2_Init(&hi2c2) != HAL_OK)
 8001254:	480e      	ldr	r0, [pc, #56]	; (8001290 <BSP_I2C2_Init+0x8c>)
 8001256:	f023 0301 	bic.w	r3, r3, #1
 800125a:	64e3      	str	r3, [r4, #76]	; 0x4c
  SET_BIT(RCC->APB1ENR1, Periphs);
 800125c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800125e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001262:	65a3      	str	r3, [r4, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8001264:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001266:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800126a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 800126c:	9b01      	ldr	r3, [sp, #4]
 800126e:	f7ff ffa1 	bl	80011b4 <MX_I2C2_Init>
 8001272:	4601      	mov	r1, r0
 8001274:	b118      	cbz	r0, 800127e <BSP_I2C2_Init+0x7a>
          ret = BSP_ERROR_BUS_FAILURE;
 8001276:	f06f 0007 	mvn.w	r0, #7
}
 800127a:	b008      	add	sp, #32
 800127c:	bd10      	pop	{r4, pc}
        else if(HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800127e:	4804      	ldr	r0, [pc, #16]	; (8001290 <BSP_I2C2_Init+0x8c>)
 8001280:	f002 fe19 	bl	8003eb6 <HAL_I2CEx_ConfigAnalogFilter>
 8001284:	2800      	cmp	r0, #0
 8001286:	d1f6      	bne.n	8001276 <BSP_I2C2_Init+0x72>
          ret = BSP_ERROR_NONE;
 8001288:	2000      	movs	r0, #0
  return ret;
 800128a:	e7f6      	b.n	800127a <BSP_I2C2_Init+0x76>
 800128c:	2000015c 	.word	0x2000015c
 8001290:	2000197c 	.word	0x2000197c

08001294 <MX_SUBGHZ_Init>:
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 8001294:	4805      	ldr	r0, [pc, #20]	; (80012ac <MX_SUBGHZ_Init+0x18>)
{
 8001296:	b508      	push	{r3, lr}
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 8001298:	2308      	movs	r3, #8
 800129a:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 800129c:	f003 fed2 	bl	8005044 <HAL_SUBGHZ_Init>
 80012a0:	b118      	cbz	r0, 80012aa <MX_SUBGHZ_Init+0x16>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 80012a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 80012a6:	f7ff be4f 	b.w	8000f48 <Error_Handler>
}
 80012aa:	bd08      	pop	{r3, pc}
 80012ac:	200019c8 	.word	0x200019c8

080012b0 <HAL_SUBGHZ_MspInit>:
  * @retval None
  */
__STATIC_INLINE void LL_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB3ENR, Periphs);
 80012b0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 80012b4:	b507      	push	{r0, r1, r2, lr}
 80012b6:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80012b8:	f042 0201 	orr.w	r2, r2, #1
 80012bc:	665a      	str	r2, [r3, #100]	; 0x64
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB3ENR, Periphs);
 80012be:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 80012c0:	2200      	movs	r2, #0
 80012c2:	f003 0301 	and.w	r3, r3, #1
 80012c6:	9301      	str	r3, [sp, #4]
 80012c8:	4611      	mov	r1, r2
 80012ca:	2032      	movs	r0, #50	; 0x32
  (void)tmpreg;
 80012cc:	9b01      	ldr	r3, [sp, #4]
 80012ce:	f001 ff81 	bl	80031d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 80012d2:	2032      	movs	r0, #50	; 0x32
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 80012d4:	b003      	add	sp, #12
 80012d6:	f85d eb04 	ldr.w	lr, [sp], #4
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 80012da:	f001 bfad 	b.w	8003238 <HAL_NVIC_EnableIRQ>
	...

080012e0 <tiny_snprintf_like.constprop.0>:
  /* USER CODE BEGIN UTIL_LPM_SetStopMode_2 */

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
 80012e0:	b40c      	push	{r2, r3}
 80012e2:	b507      	push	{r0, r1, r2, lr}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 80012e4:	4a05      	ldr	r2, [pc, #20]	; (80012fc <tiny_snprintf_like.constprop.0+0x1c>)
  va_start(vaArgs, strFormat);
 80012e6:	ab05      	add	r3, sp, #20
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 80012e8:	2110      	movs	r1, #16
  va_start(vaArgs, strFormat);
 80012ea:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 80012ec:	f00e fa2e 	bl	800f74c <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 80012f0:	b003      	add	sp, #12
 80012f2:	f85d eb04 	ldr.w	lr, [sp], #4
 80012f6:	b002      	add	sp, #8
 80012f8:	4770      	bx	lr
 80012fa:	bf00      	nop
 80012fc:	080103fc 	.word	0x080103fc

08001300 <TimestampNow>:
{
 8001300:	b530      	push	{r4, r5, lr}
 8001302:	b085      	sub	sp, #20
 8001304:	4604      	mov	r4, r0
  SysTime_t curtime = SysTimeGet();
 8001306:	a802      	add	r0, sp, #8
{
 8001308:	460d      	mov	r5, r1
  SysTime_t curtime = SysTimeGet();
 800130a:	f00e f84b 	bl	800f3a4 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 800130e:	f9bd 300c 	ldrsh.w	r3, [sp, #12]
 8001312:	4a06      	ldr	r2, [pc, #24]	; (800132c <TimestampNow+0x2c>)
 8001314:	9300      	str	r3, [sp, #0]
 8001316:	2110      	movs	r1, #16
 8001318:	9b02      	ldr	r3, [sp, #8]
 800131a:	4620      	mov	r0, r4
 800131c:	f7ff ffe0 	bl	80012e0 <tiny_snprintf_like.constprop.0>
  *size = strlen((char *)buff);
 8001320:	4620      	mov	r0, r4
 8001322:	f7fe ff2d 	bl	8000180 <strlen>
 8001326:	8028      	strh	r0, [r5, #0]
}
 8001328:	b005      	add	sp, #20
 800132a:	bd30      	pop	{r4, r5, pc}
 800132c:	080103fc 	.word	0x080103fc

08001330 <i2c_send_byteS>:
uint32_t i2c_send_byteS(unsigned char* dta, unsigned char len) {
 8001330:	460a      	mov	r2, r1
	return BSP_I2C2_Send(LCD_ADDRESS, dta, len);
 8001332:	4601      	mov	r1, r0
 8001334:	207c      	movs	r0, #124	; 0x7c
 8001336:	f7ff bf09 	b.w	800114c <BSP_I2C2_Send>
	...

0800133c <SystemApp_Init>:
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 800133c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
{
 8001340:	b508      	push	{r3, lr}
 8001342:	6893      	ldr	r3, [r2, #8]
 8001344:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001348:	6093      	str	r3, [r2, #8]
  UTIL_TIMER_Init();
 800134a:	f00e f8b1 	bl	800f4b0 <UTIL_TIMER_Init>
  DBG_Disable();
 800134e:	f000 f8dc 	bl	800150a <DBG_Disable>
  DBG_ProbesInit();
 8001352:	f000 f8dd 	bl	8001510 <DBG_ProbesInit>
  UTIL_ADV_TRACE_Init();
 8001356:	f00d fd6f 	bl	800ee38 <UTIL_ADV_TRACE_Init>
  UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 800135a:	4819      	ldr	r0, [pc, #100]	; (80013c0 <SystemApp_Init+0x84>)
 800135c:	f00d fd86 	bl	800ee6c <UTIL_ADV_TRACE_RegisterTimeStampFunction>
  UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
 8001360:	2002      	movs	r0, #2
 8001362:	f00d fd89 	bl	800ee78 <UTIL_ADV_TRACE_SetVerboseLevel>
  SYS_InitMeasurement();
 8001366:	f7ff fd1f 	bl	8000da8 <SYS_InitMeasurement>
  BSP_I2C2_Init();
 800136a:	f7ff ff4b 	bl	8001204 <BSP_I2C2_Init>
  if(EnvSensors_Init() != BSP_ERROR_NONE){
 800136e:	f000 f90b 	bl	8001588 <EnvSensors_Init>
 8001372:	b128      	cbz	r0, 8001380 <SystemApp_Init+0x44>
    APP_LOG(TS_ON, VLEVEL_M, "Error: Failed to initialize sensor!!!\r\n");
 8001374:	4b13      	ldr	r3, [pc, #76]	; (80013c4 <SystemApp_Init+0x88>)
 8001376:	2201      	movs	r2, #1
 8001378:	2100      	movs	r1, #0
 800137a:	2002      	movs	r0, #2
 800137c:	f00d fdc4 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  rgb_lcd_begin(16,2,LCD_5x8DOTS);
 8001380:	2200      	movs	r2, #0
 8001382:	2102      	movs	r1, #2
 8001384:	2010      	movs	r0, #16
 8001386:	f000 ffc1 	bl	800230c <rgb_lcd_begin>
  rgb_lcd_createChar(0, heart);
 800138a:	490f      	ldr	r1, [pc, #60]	; (80013c8 <SystemApp_Init+0x8c>)
 800138c:	2000      	movs	r0, #0
 800138e:	f001 f803 	bl	8002398 <rgb_lcd_createChar>
  rgb_lcd_createChar(1, antenna);
 8001392:	490e      	ldr	r1, [pc, #56]	; (80013cc <SystemApp_Init+0x90>)
 8001394:	2001      	movs	r0, #1
 8001396:	f000 ffff 	bl	8002398 <rgb_lcd_createChar>
  rgb_lcd_createChar(2, degre);
 800139a:	490d      	ldr	r1, [pc, #52]	; (80013d0 <SystemApp_Init+0x94>)
 800139c:	2002      	movs	r0, #2
 800139e:	f000 fffb 	bl	8002398 <rgb_lcd_createChar>
  BSP_I2C2_DeInit();
 80013a2:	f7ff feb7 	bl	8001114 <BSP_I2C2_DeInit>
  UTIL_LPM_Init();
 80013a6:	f00d fe63 	bl	800f070 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 80013aa:	2101      	movs	r1, #1
 80013ac:	4608      	mov	r0, r1
 80013ae:	f00d fe7f 	bl	800f0b0 <UTIL_LPM_SetOffMode>
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 80013b2:	2101      	movs	r1, #1
}
 80013b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 80013b8:	4608      	mov	r0, r1
 80013ba:	f00d be63 	b.w	800f084 <UTIL_LPM_SetStopMode>
 80013be:	bf00      	nop
 80013c0:	08001301 	.word	0x08001301
 80013c4:	08010405 	.word	0x08010405
 80013c8:	08010448 	.word	0x08010448
 80013cc:	08010438 	.word	0x08010438
 80013d0:	08010440 	.word	0x08010440

080013d4 <UTIL_SEQ_Idle>:
  UTIL_LPM_EnterLowPower();
 80013d4:	f00d be82 	b.w	800f0dc <UTIL_LPM_EnterLowPower>

080013d8 <GetBatteryLevel>:
{
 80013d8:	b513      	push	{r0, r1, r4, lr}
  batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
 80013da:	f7ff fced 	bl	8000db8 <SYS_GetBatteryLevel>
  if (batteryLevelmV > VDD_BAT)
 80013de:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80013e2:	4298      	cmp	r0, r3
 80013e4:	d815      	bhi.n	8001412 <GetBatteryLevel+0x3a>
  else if (batteryLevelmV < VDD_MIN)
 80013e6:	f5b0 6fe1 	cmp.w	r0, #1800	; 0x708
 80013ea:	d314      	bcc.n	8001416 <GetBatteryLevel+0x3e>
    batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
 80013ec:	f5a0 60e1 	sub.w	r0, r0, #1800	; 0x708
 80013f0:	24fe      	movs	r4, #254	; 0xfe
 80013f2:	4344      	muls	r4, r0
 80013f4:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 80013f8:	fbb4 f4f3 	udiv	r4, r4, r3
 80013fc:	b2e4      	uxtb	r4, r4
  APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\r\n", batteryLevel);
 80013fe:	4b07      	ldr	r3, [pc, #28]	; (800141c <GetBatteryLevel+0x44>)
 8001400:	9400      	str	r4, [sp, #0]
 8001402:	2201      	movs	r2, #1
 8001404:	2100      	movs	r1, #0
 8001406:	2002      	movs	r0, #2
 8001408:	f00d fd7e 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 800140c:	4620      	mov	r0, r4
 800140e:	b002      	add	sp, #8
 8001410:	bd10      	pop	{r4, pc}
    batteryLevel = LORAWAN_MAX_BAT;
 8001412:	24fe      	movs	r4, #254	; 0xfe
 8001414:	e7f3      	b.n	80013fe <GetBatteryLevel+0x26>
    batteryLevel = 0;
 8001416:	2400      	movs	r4, #0
 8001418:	e7f1      	b.n	80013fe <GetBatteryLevel+0x26>
 800141a:	bf00      	nop
 800141c:	0801042d 	.word	0x0801042d

08001420 <GetTemperatureLevel>:
{
 8001420:	b508      	push	{r3, lr}
  temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
 8001422:	f7ff fce3 	bl	8000dec <SYS_GetTemperatureLevel>
 8001426:	2800      	cmp	r0, #0
 8001428:	bfb8      	it	lt
 800142a:	30ff      	addlt	r0, #255	; 0xff
}
 800142c:	f3c0 200f 	ubfx	r0, r0, #8, #16
 8001430:	bd08      	pop	{r3, pc}
	...

08001434 <GetUniqueId>:
{
 8001434:	b538      	push	{r3, r4, r5, lr}
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8001436:	4b17      	ldr	r3, [pc, #92]	; (8001494 <GetUniqueId+0x60>)
 8001438:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 800143a:	1c5a      	adds	r2, r3, #1
{
 800143c:	4604      	mov	r4, r0
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 800143e:	d116      	bne.n	800146e <GetUniqueId+0x3a>
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 8001440:	f001 fa7c 	bl	800293c <HAL_GetUIDw0>
 8001444:	4605      	mov	r5, r0
 8001446:	f001 fa85 	bl	8002954 <HAL_GetUIDw2>
 800144a:	4405      	add	r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 800144c:	f001 fa7c 	bl	8002948 <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 8001450:	0e2b      	lsrs	r3, r5, #24
 8001452:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 8001454:	0c2b      	lsrs	r3, r5, #16
 8001456:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 8001458:	0a2b      	lsrs	r3, r5, #8
 800145a:	7163      	strb	r3, [r4, #5]
    id[3] = (ID_2_val) >> 24;
 800145c:	0e03      	lsrs	r3, r0, #24
 800145e:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 8001460:	0c03      	lsrs	r3, r0, #16
 8001462:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 8001464:	0a03      	lsrs	r3, r0, #8
    id[4] = (ID_1_3_val);
 8001466:	7125      	strb	r5, [r4, #4]
    id[1] = (ID_2_val) >> 8;
 8001468:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 800146a:	7020      	strb	r0, [r4, #0]
}
 800146c:	bd38      	pop	{r3, r4, r5, pc}
    id[6] = (val >> 8) & 0xFF;
 800146e:	0a1a      	lsrs	r2, r3, #8
    id[7] = val & 0xFF;
 8001470:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 8001472:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 8001474:	0c1a      	lsrs	r2, r3, #16
    id[4] = (val >> 24) & 0xFF;
 8001476:	0e1b      	lsrs	r3, r3, #24
 8001478:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 800147a:	4b07      	ldr	r3, [pc, #28]	; (8001498 <GetUniqueId+0x64>)
    id[5] = (val >> 16) & 0xFF;
 800147c:	7142      	strb	r2, [r0, #5]
    id[3] = val & 0xFF;
 800147e:	681a      	ldr	r2, [r3, #0]
 8001480:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 8001482:	681b      	ldr	r3, [r3, #0]
 8001484:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 8001486:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 8001488:	0c1a      	lsrs	r2, r3, #16
    id[0] = (val >> 16) & 0xFF;
 800148a:	0e1b      	lsrs	r3, r3, #24
    id[1] = (val >> 8) & 0xFF;
 800148c:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 800148e:	7003      	strb	r3, [r0, #0]
}
 8001490:	e7ec      	b.n	800146c <GetUniqueId+0x38>
 8001492:	bf00      	nop
 8001494:	1fff7580 	.word	0x1fff7580
 8001498:	1fff7584 	.word	0x1fff7584

0800149c <GetDevAddr>:
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 800149c:	4b07      	ldr	r3, [pc, #28]	; (80014bc <GetDevAddr+0x20>)
 800149e:	6818      	ldr	r0, [r3, #0]
  if (val == 0xFFFFFFFF)
 80014a0:	1c43      	adds	r3, r0, #1
{
 80014a2:	b510      	push	{r4, lr}
  if (val == 0xFFFFFFFF)
 80014a4:	d108      	bne.n	80014b8 <GetDevAddr+0x1c>
    val = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 80014a6:	f001 fa49 	bl	800293c <HAL_GetUIDw0>
 80014aa:	4604      	mov	r4, r0
 80014ac:	f001 fa4c 	bl	8002948 <HAL_GetUIDw1>
 80014b0:	4044      	eors	r4, r0
 80014b2:	f001 fa4f 	bl	8002954 <HAL_GetUIDw2>
 80014b6:	4060      	eors	r0, r4
}
 80014b8:	bd10      	pop	{r4, pc}
 80014ba:	bf00      	nop
 80014bc:	1fff7580 	.word	0x1fff7580

080014c0 <UTIL_ADV_TRACE_PreSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 80014c0:	2101      	movs	r1, #1
 80014c2:	2002      	movs	r0, #2
 80014c4:	f00d bdde 	b.w	800f084 <UTIL_LPM_SetStopMode>

080014c8 <UTIL_ADV_TRACE_PostSendHook>:
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 80014c8:	2100      	movs	r1, #0
 80014ca:	2002      	movs	r0, #2
 80014cc:	f00d bdda 	b.w	800f084 <UTIL_LPM_SetStopMode>

080014d0 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 80014d0:	2000      	movs	r0, #0
 80014d2:	4770      	bx	lr

080014d4 <HAL_GetTick>:
{
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  return TIMER_IF_GetTimerValue();
 80014d4:	f000 b8a6 	b.w	8001624 <TIMER_IF_GetTimerValue>

080014d8 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 80014d8:	b082      	sub	sp, #8
 80014da:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 80014dc:	9801      	ldr	r0, [sp, #4]
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 80014de:	b002      	add	sp, #8
  TIMER_IF_DelayMs(Delay);
 80014e0:	f000 b95a 	b.w	8001798 <TIMER_IF_DelayMs>

080014e4 <DBG_ConfigForLpm>:
  enable_dbg = 0;
#elif !defined (DEBUGGER_ENABLED)
#error "DEBUGGER_ENABLED not defined or out of range <0,1>"
#endif /* DEBUGGER_OFF */

  if (enable_dbg == 1)
 80014e4:	2801      	cmp	r0, #1
{
 80014e6:	b508      	push	{r3, lr}
  if (enable_dbg == 1)
 80014e8:	d107      	bne.n	80014fa <DBG_ConfigForLpm+0x16>
  {
    HAL_DBGMCU_EnableDBGSleepMode();
 80014ea:	f001 fa39 	bl	8002960 <HAL_DBGMCU_EnableDBGSleepMode>
    HAL_DBGMCU_EnableDBGStopMode();
 80014ee:	f001 fa47 	bl	8002980 <HAL_DBGMCU_EnableDBGStopMode>
  }

  /* USER CODE BEGIN DBG_ConfigForLpm_Last */

  /* USER CODE END DBG_ConfigForLpm_Last */
}
 80014f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_EnableDBGStandbyMode();
 80014f6:	f001 ba53 	b.w	80029a0 <HAL_DBGMCU_EnableDBGStandbyMode>
    HAL_DBGMCU_DisableDBGSleepMode();
 80014fa:	f001 fa39 	bl	8002970 <HAL_DBGMCU_DisableDBGSleepMode>
    HAL_DBGMCU_DisableDBGStopMode();
 80014fe:	f001 fa47 	bl	8002990 <HAL_DBGMCU_DisableDBGStopMode>
}
 8001502:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_DBGMCU_DisableDBGStandbyMode();
 8001506:	f001 ba53 	b.w	80029b0 <HAL_DBGMCU_DisableDBGStandbyMode>

0800150a <DBG_Disable>:
  DBG_ConfigForLpm(0);
 800150a:	2000      	movs	r0, #0
 800150c:	f7ff bfea 	b.w	80014e4 <DBG_ConfigForLpm>

08001510 <DBG_ProbesInit>:
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->IMR2, ExtiLine);
 8001510:	4a03      	ldr	r2, [pc, #12]	; (8001520 <DBG_ProbesInit+0x10>)
 8001512:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8001516:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800151a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
#endif /* CORE_CM4 */

  /* USER CODE BEGIN DBG_ProbesInit_Last */

  /* USER CODE END DBG_ProbesInit_Last */
}
 800151e:	4770      	bx	lr
 8001520:	58000800 	.word	0x58000800

08001524 <EnvSensors_Read>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t  EnvSensors_Read(sensor_t *sensor_data)
{
 8001524:	b513      	push	{r0, r1, r4, lr}
 8001526:	4604      	mov	r4, r0
  static float TEMPERATURE_Value = TEMPERATURE_DEFAULT_VAL;
  static float PRESSURE_Value = PRESSURE_DEFAULT_VAL;
  static float CO2_Value = CO2_DEFAULT_VAL;

  /*Init I2C Bus */
  BSP_I2C2_Init();
 8001528:	f7ff fe6c 	bl	8001204 <BSP_I2C2_Init>
  IKS01A3_ENV_SENSOR_GetValue(IKS01A3_LPS22HH_0, ENV_PRESSURE, &PRESSURE_Value);
  IKS01A3_ENV_SENSOR_GetValue(IKS01A3_LPS22HH_0, ENV_TEMPERATURE, &TEMPERATURE_Value);
#endif /* USE_IKS01A3_ENV_SENSOR_LPS22HH_0 */
#if (USE_ENV_SENSOR_SCD30 == 1)
  // Wait for data to be ready
  uint16_t data_ready = 0;
 800152c:	2300      	movs	r3, #0
  int16_t ret = scd30_get_data_ready(&data_ready);
 800152e:	f10d 0006 	add.w	r0, sp, #6
  uint16_t data_ready = 0;
 8001532:	f8ad 3006 	strh.w	r3, [sp, #6]
  int16_t ret = scd30_get_data_ready(&data_ready);
 8001536:	f000 ffc2 	bl	80024be <scd30_get_data_ready>
  if(data_ready){
 800153a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 800153e:	b123      	cbz	r3, 800154a <EnvSensors_Read+0x26>
	  ret = scd30_read_measurement(&CO2_Value, &TEMPERATURE_Value, &HUMIDITY_Value);
 8001540:	4a0c      	ldr	r2, [pc, #48]	; (8001574 <EnvSensors_Read+0x50>)
 8001542:	490d      	ldr	r1, [pc, #52]	; (8001578 <EnvSensors_Read+0x54>)
 8001544:	480d      	ldr	r0, [pc, #52]	; (800157c <EnvSensors_Read+0x58>)
 8001546:	f000 ff7c 	bl	8002442 <scd30_read_measurement>
#endif
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif  /* SENSOR_ENABLED */

  sensor_data->humidity    = HUMIDITY_Value;
 800154a:	4b0a      	ldr	r3, [pc, #40]	; (8001574 <EnvSensors_Read+0x50>)
  sensor_data->temperature = TEMPERATURE_Value;
  sensor_data->pressure    = PRESSURE_Value;
  sensor_data->co2         = CO2_Value;

  sensor_data->latitude  = (int32_t)((STSOP_LATTITUDE  * MAX_GPS_POS) / 90);
  sensor_data->longitude = (int32_t)((STSOP_LONGITUDE  * MAX_GPS_POS) / 180);
 800154c:	4a0c      	ldr	r2, [pc, #48]	; (8001580 <EnvSensors_Read+0x5c>)
  sensor_data->humidity    = HUMIDITY_Value;
 800154e:	681b      	ldr	r3, [r3, #0]
 8001550:	60a3      	str	r3, [r4, #8]
  sensor_data->temperature = TEMPERATURE_Value;
 8001552:	4b09      	ldr	r3, [pc, #36]	; (8001578 <EnvSensors_Read+0x54>)
 8001554:	681b      	ldr	r3, [r3, #0]
 8001556:	6063      	str	r3, [r4, #4]
  sensor_data->pressure    = PRESSURE_Value;
 8001558:	2300      	movs	r3, #0
 800155a:	6023      	str	r3, [r4, #0]
  sensor_data->co2         = CO2_Value;
 800155c:	4b07      	ldr	r3, [pc, #28]	; (800157c <EnvSensors_Read+0x58>)
 800155e:	681b      	ldr	r3, [r3, #0]
 8001560:	60e3      	str	r3, [r4, #12]
  sensor_data->longitude = (int32_t)((STSOP_LONGITUDE  * MAX_GPS_POS) / 180);
 8001562:	4b08      	ldr	r3, [pc, #32]	; (8001584 <EnvSensors_Read+0x60>)
 8001564:	e9c4 2304 	strd	r2, r3, [r4, #16]

  /* Initialize for LCD */
  BSP_I2C2_DeInit();
 8001568:	f7ff fdd4 	bl	8001114 <BSP_I2C2_DeInit>

  return 0;
  /* USER CODE END EnvSensors_Read */
}
 800156c:	2000      	movs	r0, #0
 800156e:	b002      	add	sp, #8
 8001570:	bd10      	pop	{r4, pc}
 8001572:	bf00      	nop
 8001574:	20000164 	.word	0x20000164
 8001578:	20000168 	.word	0x20000168
 800157c:	20000160 	.word	0x20000160
 8001580:	003e090d 	.word	0x003e090d
 8001584:	000503ab 	.word	0x000503ab

08001588 <EnvSensors_Init>:

int32_t  EnvSensors_Init(void)
{
 8001588:	b510      	push	{r4, lr}
#endif /* USE_IKS01A3_ENV_SENSOR_HTS221_0 */
#if (USE_IKS01A3_ENV_SENSOR_LPS22HH_0 == 1)
  ret |= IKS01A3_ENV_SENSOR_Init(IKS01A3_LPS22HH_0, ENV_TEMPERATURE | ENV_PRESSURE);
#endif /* USE_IKS01A3_ENV_SENSOR_LPS22HH_0 */
#if (USE_ENV_SENSOR_SCD30 == 1)
  sensirion_i2c_init();
 800158a:	f7ff fd57 	bl	800103c <sensirion_i2c_init>
  ret = scd30_probe();
 800158e:	f000 ffa4 	bl	80024da <scd30_probe>
#endif
  if(ret != BSP_ERROR_NONE){
 8001592:	4604      	mov	r4, r0
 8001594:	b940      	cbnz	r0, 80015a8 <EnvSensors_Init+0x20>
#if (USE_IKS01A3_ENV_SENSOR_LPS22HH_0 == 1)
  IKS01A3_ENV_SENSOR_Enable(IKS01A3_LPS22HH_0, ENV_PRESSURE);
  IKS01A3_ENV_SENSOR_Enable(IKS01A3_LPS22HH_0, ENV_TEMPERATURE);
#endif /* USE_IKS01A3_ENV_SENSOR_LPS22HH_0 */
#if (USE_ENV_SENSOR_SCD30 == 1)
  scd30_set_measurement_interval(APP_SENSOR_CYCLE /* value in seconds */);
 8001596:	f242 7010 	movw	r0, #10000	; 0x2710
 800159a:	f000 ff74 	bl	8002486 <scd30_set_measurement_interval>
  uint16_t ambient_pressure_mbar = 0;
  scd30_start_periodic_measurement(ambient_pressure_mbar);
 800159e:	4620      	mov	r0, r4
 80015a0:	f000 ff39 	bl	8002416 <scd30_start_periodic_measurement>
  sensirion_i2c_release();
 80015a4:	f7ff fd4c 	bl	8001040 <sensirion_i2c_release>
#elif !defined (SENSOR_ENABLED)
#error SENSOR_ENABLED not defined
#endif /* SENSOR_ENABLED  */
  return 0;
  /* USER CODE END EnvSensors_Init */
}
 80015a8:	4620      	mov	r0, r4
 80015aa:	bd10      	pop	{r4, pc}

080015ac <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80015ac:	4b0b      	ldr	r3, [pc, #44]	; (80015dc <_sbrk+0x30>)
 80015ae:	6819      	ldr	r1, [r3, #0]
{
 80015b0:	b510      	push	{r4, lr}
 80015b2:	4602      	mov	r2, r0
  if (NULL == __sbrk_heap_end)
 80015b4:	b909      	cbnz	r1, 80015ba <_sbrk+0xe>
  {
    __sbrk_heap_end = &_end;
 80015b6:	490a      	ldr	r1, [pc, #40]	; (80015e0 <_sbrk+0x34>)
 80015b8:	6019      	str	r1, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80015ba:	6818      	ldr	r0, [r3, #0]
 80015bc:	4909      	ldr	r1, [pc, #36]	; (80015e4 <_sbrk+0x38>)
 80015be:	4c0a      	ldr	r4, [pc, #40]	; (80015e8 <_sbrk+0x3c>)
 80015c0:	4402      	add	r2, r0
 80015c2:	1b09      	subs	r1, r1, r4
 80015c4:	428a      	cmp	r2, r1
 80015c6:	d906      	bls.n	80015d6 <_sbrk+0x2a>
  {
    errno = ENOMEM;
 80015c8:	f00e f9da 	bl	800f980 <__errno>
 80015cc:	230c      	movs	r3, #12
 80015ce:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 80015d0:	f04f 30ff 	mov.w	r0, #4294967295

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 80015d4:	bd10      	pop	{r4, pc}
  __sbrk_heap_end += incr;
 80015d6:	601a      	str	r2, [r3, #0]
  return (void *)prev_heap_end;
 80015d8:	e7fc      	b.n	80015d4 <_sbrk+0x28>
 80015da:	bf00      	nop
 80015dc:	2000016c 	.word	0x2000016c
 80015e0:	20001b90 	.word	0x20001b90
 80015e4:	20008000 	.word	0x20008000
 80015e8:	00000800 	.word	0x00000800

080015ec <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 80015ec:	4b02      	ldr	r3, [pc, #8]	; (80015f8 <TIMER_IF_SetTimerContext+0xc>)
 80015ee:	6898      	ldr	r0, [r3, #8]
}

uint32_t TIMER_IF_SetTimerContext(void)
{
  /*store time context*/
  RtcTimerContext = GetTimerTicks();
 80015f0:	4b02      	ldr	r3, [pc, #8]	; (80015fc <TIMER_IF_SetTimerContext+0x10>)
static inline uint32_t GetTimerTicks(void)
{
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 80015f2:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 80015f4:	6018      	str	r0, [r3, #0]
}
 80015f6:	4770      	bx	lr
 80015f8:	40002800 	.word	0x40002800
 80015fc:	20000174 	.word	0x20000174

08001600 <TIMER_IF_GetTimerContext>:
}
 8001600:	4b01      	ldr	r3, [pc, #4]	; (8001608 <TIMER_IF_GetTimerContext+0x8>)
 8001602:	6818      	ldr	r0, [r3, #0]
 8001604:	4770      	bx	lr
 8001606:	bf00      	nop
 8001608:	20000174 	.word	0x20000174

0800160c <TIMER_IF_GetTimerElapsedTime>:
 800160c:	4b03      	ldr	r3, [pc, #12]	; (800161c <TIMER_IF_GetTimerElapsedTime+0x10>)
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 800160e:	4a04      	ldr	r2, [pc, #16]	; (8001620 <TIMER_IF_GetTimerElapsedTime+0x14>)
 8001610:	689b      	ldr	r3, [r3, #8]
 8001612:	6810      	ldr	r0, [r2, #0]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 8001614:	43db      	mvns	r3, r3
}
 8001616:	1a18      	subs	r0, r3, r0
 8001618:	4770      	bx	lr
 800161a:	bf00      	nop
 800161c:	40002800 	.word	0x40002800
 8001620:	20000174 	.word	0x20000174

08001624 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8001624:	4b03      	ldr	r3, [pc, #12]	; (8001634 <TIMER_IF_GetTimerValue+0x10>)
 8001626:	7818      	ldrb	r0, [r3, #0]
 8001628:	b110      	cbz	r0, 8001630 <TIMER_IF_GetTimerValue+0xc>
 800162a:	4b03      	ldr	r3, [pc, #12]	; (8001638 <TIMER_IF_GetTimerValue+0x14>)
 800162c:	6898      	ldr	r0, [r3, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 800162e:	43c0      	mvns	r0, r0
}
 8001630:	4770      	bx	lr
 8001632:	bf00      	nop
 8001634:	20000170 	.word	0x20000170
 8001638:	40002800 	.word	0x40002800

0800163c <TIMER_IF_GetMinimumTimeout>:
}
 800163c:	2003      	movs	r0, #3
 800163e:	4770      	bx	lr

08001640 <TIMER_IF_Convert_ms2Tick>:
{
 8001640:	b508      	push	{r3, lr}
 8001642:	4601      	mov	r1, r0
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8001644:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001648:	2300      	movs	r3, #0
 800164a:	0280      	lsls	r0, r0, #10
 800164c:	0d89      	lsrs	r1, r1, #22
 800164e:	f7ff f9af 	bl	80009b0 <__aeabi_uldivmod>
}
 8001652:	bd08      	pop	{r3, pc}

08001654 <TIMER_IF_Convert_Tick2ms>:
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8001654:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001658:	fba0 2302 	umull	r2, r3, r0, r2
 800165c:	0a90      	lsrs	r0, r2, #10
}
 800165e:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 8001662:	4770      	bx	lr

08001664 <TIMER_IF_StopTimer>:
{
 8001664:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 8001666:	4b07      	ldr	r3, [pc, #28]	; (8001684 <TIMER_IF_StopTimer+0x20>)
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001668:	4c07      	ldr	r4, [pc, #28]	; (8001688 <TIMER_IF_StopTimer+0x24>)
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRAF);
 800166a:	2201      	movs	r2, #1
 800166c:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 800166e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001672:	4620      	mov	r0, r4
 8001674:	f003 fa9c 	bl	8004bb0 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001678:	f04f 33ff 	mov.w	r3, #4294967295
 800167c:	6323      	str	r3, [r4, #48]	; 0x30
}
 800167e:	2000      	movs	r0, #0
 8001680:	bd10      	pop	{r4, pc}
 8001682:	bf00      	nop
 8001684:	40002800 	.word	0x40002800
 8001688:	20001944 	.word	0x20001944

0800168c <TIMER_IF_BkUp_Write_Seconds>:
{
 800168c:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 800168e:	2100      	movs	r1, #0
 8001690:	4801      	ldr	r0, [pc, #4]	; (8001698 <TIMER_IF_BkUp_Write_Seconds+0xc>)
 8001692:	f003 bca2 	b.w	8004fda <HAL_RTCEx_BKUPWrite>
 8001696:	bf00      	nop
 8001698:	20001944 	.word	0x20001944

0800169c <TIMER_IF_BkUp_Write_SubSeconds>:
{
 800169c:	4602      	mov	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 800169e:	2101      	movs	r1, #1
 80016a0:	4801      	ldr	r0, [pc, #4]	; (80016a8 <TIMER_IF_BkUp_Write_SubSeconds+0xc>)
 80016a2:	f003 bc9a 	b.w	8004fda <HAL_RTCEx_BKUPWrite>
 80016a6:	bf00      	nop
 80016a8:	20001944 	.word	0x20001944

080016ac <TIMER_IF_StartTimer>:
{
 80016ac:	b510      	push	{r4, lr}
 80016ae:	b08c      	sub	sp, #48	; 0x30
  RTC_AlarmTypeDef sAlarm = {0};
 80016b0:	222c      	movs	r2, #44	; 0x2c
 80016b2:	2100      	movs	r1, #0
{
 80016b4:	4604      	mov	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 80016b6:	a801      	add	r0, sp, #4
 80016b8:	f00e f98c 	bl	800f9d4 <memset>
  TIMER_IF_StopTimer();
 80016bc:	f7ff ffd2 	bl	8001664 <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 80016c0:	4b0c      	ldr	r3, [pc, #48]	; (80016f4 <TIMER_IF_StartTimer+0x48>)
 80016c2:	6818      	ldr	r0, [r3, #0]
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 80016c4:	2300      	movs	r3, #0
  timeout += RtcTimerContext;
 80016c6:	4404      	add	r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 80016c8:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 80016ca:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 80016cc:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 80016d0:	43e4      	mvns	r4, r4
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 80016d2:	9307      	str	r3, [sp, #28]
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80016d4:	4808      	ldr	r0, [pc, #32]	; (80016f8 <TIMER_IF_StartTimer+0x4c>)
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 80016d6:	9402      	str	r4, [sp, #8]
  sAlarm.Alarm = RTC_ALARM_A;
 80016d8:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80016dc:	2201      	movs	r2, #1
 80016de:	a901      	add	r1, sp, #4
  sAlarm.Alarm = RTC_ALARM_A;
 80016e0:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80016e2:	f003 fb7b 	bl	8004ddc <HAL_RTC_SetAlarm_IT>
 80016e6:	b108      	cbz	r0, 80016ec <TIMER_IF_StartTimer+0x40>
    Error_Handler();
 80016e8:	f7ff fc2e 	bl	8000f48 <Error_Handler>
}
 80016ec:	2000      	movs	r0, #0
 80016ee:	b00c      	add	sp, #48	; 0x30
 80016f0:	bd10      	pop	{r4, pc}
 80016f2:	bf00      	nop
 80016f4:	20000174 	.word	0x20000174
 80016f8:	20001944 	.word	0x20001944

080016fc <TIMER_IF_GetTime>:
 80016fc:	4b0c      	ldr	r3, [pc, #48]	; (8001730 <TIMER_IF_GetTime+0x34>)
{
 80016fe:	b570      	push	{r4, r5, r6, lr}
 8001700:	689c      	ldr	r4, [r3, #8]
 8001702:	4606      	mov	r6, r0
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8001704:	2102      	movs	r1, #2
 8001706:	480b      	ldr	r0, [pc, #44]	; (8001734 <TIMER_IF_GetTime+0x38>)
 8001708:	f003 fc6e 	bl	8004fe8 <HAL_RTCEx_BKUPRead>
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 800170c:	43e4      	mvns	r4, r4
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 800170e:	2200      	movs	r2, #0
 8001710:	1912      	adds	r2, r2, r4
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 8001712:	f3c2 0409 	ubfx	r4, r2, #0, #10
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8001716:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800171a:	fba4 4501 	umull	r4, r5, r4, r1
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 800171e:	f140 0300 	adc.w	r3, r0, #0
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8001722:	0aa4      	lsrs	r4, r4, #10
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8001724:	0a90      	lsrs	r0, r2, #10
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8001726:	8034      	strh	r4, [r6, #0]
}
 8001728:	ea40 5083 	orr.w	r0, r0, r3, lsl #22
 800172c:	bd70      	pop	{r4, r5, r6, pc}
 800172e:	bf00      	nop
 8001730:	40002800 	.word	0x40002800
 8001734:	20001944 	.word	0x20001944

08001738 <TIMER_IF_BkUp_Read_Seconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8001738:	4801      	ldr	r0, [pc, #4]	; (8001740 <TIMER_IF_BkUp_Read_Seconds+0x8>)
 800173a:	2100      	movs	r1, #0
 800173c:	f003 bc54 	b.w	8004fe8 <HAL_RTCEx_BKUPRead>
 8001740:	20001944 	.word	0x20001944

08001744 <TIMER_IF_BkUp_Read_SubSeconds>:
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8001744:	4801      	ldr	r0, [pc, #4]	; (800174c <TIMER_IF_BkUp_Read_SubSeconds+0x8>)
 8001746:	2101      	movs	r1, #1
 8001748:	f003 bc4e 	b.w	8004fe8 <HAL_RTCEx_BKUPRead>
 800174c:	20001944 	.word	0x20001944

08001750 <TIMER_IF_Init>:
{
 8001750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Initialized == false)
 8001752:	4d0f      	ldr	r5, [pc, #60]	; (8001790 <TIMER_IF_Init+0x40>)
 8001754:	782e      	ldrb	r6, [r5, #0]
 8001756:	b9ce      	cbnz	r6, 800178c <TIMER_IF_Init+0x3c>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001758:	4c0e      	ldr	r4, [pc, #56]	; (8001794 <TIMER_IF_Init+0x44>)
 800175a:	f04f 37ff 	mov.w	r7, #4294967295
 800175e:	6327      	str	r7, [r4, #48]	; 0x30
    MX_RTC_Init();
 8001760:	f7ff fbf4 	bl	8000f4c <MX_RTC_Init>
    TIMER_IF_StopTimer();
 8001764:	f7ff ff7e 	bl	8001664 <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
 8001768:	f44f 7180 	mov.w	r1, #256	; 0x100
 800176c:	4620      	mov	r0, r4
 800176e:	f003 fa1f 	bl	8004bb0 <HAL_RTC_DeactivateAlarm>
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8001772:	4620      	mov	r0, r4
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8001774:	6327      	str	r7, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8001776:	f003 fbdb 	bl	8004f30 <HAL_RTCEx_EnableBypassShadow>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 800177a:	4632      	mov	r2, r6
 800177c:	2102      	movs	r1, #2
 800177e:	4620      	mov	r0, r4
 8001780:	f003 fc2b 	bl	8004fda <HAL_RTCEx_BKUPWrite>
    TIMER_IF_SetTimerContext();
 8001784:	f7ff ff32 	bl	80015ec <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 8001788:	2301      	movs	r3, #1
 800178a:	702b      	strb	r3, [r5, #0]
}
 800178c:	2000      	movs	r0, #0
 800178e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001790:	20000170 	.word	0x20000170
 8001794:	20001944 	.word	0x20001944

08001798 <TIMER_IF_DelayMs>:
{
 8001798:	4601      	mov	r1, r0
 800179a:	b508      	push	{r3, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 800179c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80017a0:	2300      	movs	r3, #0
 80017a2:	0280      	lsls	r0, r0, #10
 80017a4:	0d89      	lsrs	r1, r1, #22
 80017a6:	f7ff f903 	bl	80009b0 <__aeabi_uldivmod>
 80017aa:	4a05      	ldr	r2, [pc, #20]	; (80017c0 <TIMER_IF_DelayMs+0x28>)
 80017ac:	6891      	ldr	r1, [r2, #8]
  return (UINT32_MAX - LL_RTC_TIME_GetSubSecond(RTC));
 80017ae:	43c9      	mvns	r1, r1
 80017b0:	6893      	ldr	r3, [r2, #8]
 80017b2:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 80017b4:	1a5b      	subs	r3, r3, r1
 80017b6:	4283      	cmp	r3, r0
 80017b8:	d300      	bcc.n	80017bc <TIMER_IF_DelayMs+0x24>
}
 80017ba:	bd08      	pop	{r3, pc}
    __NOP();
 80017bc:	bf00      	nop
 80017be:	e7f7      	b.n	80017b0 <TIMER_IF_DelayMs+0x18>
 80017c0:	40002800 	.word	0x40002800

080017c4 <HAL_RTC_AlarmAEventCallback>:
  UTIL_TIMER_IRQ_MAP_PROCESS();
 80017c4:	f00d bf7e 	b.w	800f6c4 <UTIL_TIMER_IRQ_Handler>

080017c8 <HAL_RTCEx_SSRUEventCallback>:
{
 80017c8:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 80017ca:	4c06      	ldr	r4, [pc, #24]	; (80017e4 <HAL_RTCEx_SSRUEventCallback+0x1c>)
 80017cc:	2102      	movs	r1, #2
 80017ce:	4620      	mov	r0, r4
 80017d0:	f003 fc0a 	bl	8004fe8 <HAL_RTCEx_BKUPRead>
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 80017d4:	2102      	movs	r1, #2
 80017d6:	1c42      	adds	r2, r0, #1
 80017d8:	4620      	mov	r0, r4
}
 80017da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 80017de:	f003 bbfc 	b.w	8004fda <HAL_RTCEx_BKUPWrite>
 80017e2:	bf00      	nop
 80017e4:	20001944 	.word	0x20001944

080017e8 <MX_USART2_UART_Init>:
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 80017e8:	4816      	ldr	r0, [pc, #88]	; (8001844 <MX_USART2_UART_Init+0x5c>)
  huart2.Init.BaudRate = 115200;
 80017ea:	4a17      	ldr	r2, [pc, #92]	; (8001848 <MX_USART2_UART_Init+0x60>)
{
 80017ec:	b508      	push	{r3, lr}
  huart2.Init.BaudRate = 115200;
 80017ee:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80017f2:	e9c0 2300 	strd	r2, r3, [r0]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 80017f6:	2300      	movs	r3, #0
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
 80017f8:	220c      	movs	r2, #12
  huart2.Init.StopBits = UART_STOPBITS_1;
 80017fa:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80017fe:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001802:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001806:	e9c0 3309 	strd	r3, r3, [r0, #36]	; 0x24
  huart2.Init.Parity = UART_PARITY_NONE;
 800180a:	6103      	str	r3, [r0, #16]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800180c:	f004 fd0a 	bl	8006224 <HAL_UART_Init>
 8001810:	b108      	cbz	r0, 8001816 <MX_USART2_UART_Init+0x2e>
  {
    Error_Handler();
 8001812:	f7ff fb99 	bl	8000f48 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001816:	480b      	ldr	r0, [pc, #44]	; (8001844 <MX_USART2_UART_Init+0x5c>)
 8001818:	2100      	movs	r1, #0
 800181a:	f004 fe8a 	bl	8006532 <HAL_UARTEx_SetTxFifoThreshold>
 800181e:	b108      	cbz	r0, 8001824 <MX_USART2_UART_Init+0x3c>
  {
    Error_Handler();
 8001820:	f7ff fb92 	bl	8000f48 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001824:	4807      	ldr	r0, [pc, #28]	; (8001844 <MX_USART2_UART_Init+0x5c>)
 8001826:	2100      	movs	r1, #0
 8001828:	f004 fea7 	bl	800657a <HAL_UARTEx_SetRxFifoThreshold>
 800182c:	b108      	cbz	r0, 8001832 <MX_USART2_UART_Init+0x4a>
  {
    Error_Handler();
 800182e:	f7ff fb8b 	bl	8000f48 <Error_Handler>
  }
  if (HAL_UARTEx_EnableFifoMode(&huart2) != HAL_OK)
 8001832:	4804      	ldr	r0, [pc, #16]	; (8001844 <MX_USART2_UART_Init+0x5c>)
 8001834:	f004 fe5a 	bl	80064ec <HAL_UARTEx_EnableFifoMode>
 8001838:	b118      	cbz	r0, 8001842 <MX_USART2_UART_Init+0x5a>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800183a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 800183e:	f7ff bb83 	b.w	8000f48 <Error_Handler>
}
 8001842:	bd08      	pop	{r3, pc}
 8001844:	20001a34 	.word	0x20001a34
 8001848:	40004400 	.word	0x40004400

0800184c <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800184c:	b570      	push	{r4, r5, r6, lr}
 800184e:	b096      	sub	sp, #88	; 0x58
 8001850:	4606      	mov	r6, r0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001852:	2214      	movs	r2, #20
 8001854:	2100      	movs	r1, #0
 8001856:	a803      	add	r0, sp, #12
 8001858:	f00e f8bc 	bl	800f9d4 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 800185c:	2238      	movs	r2, #56	; 0x38
 800185e:	2100      	movs	r1, #0
 8001860:	a808      	add	r0, sp, #32
 8001862:	f00e f8b7 	bl	800f9d4 <memset>
  if(uartHandle->Instance==USART2)
 8001866:	6832      	ldr	r2, [r6, #0]
 8001868:	4b2b      	ldr	r3, [pc, #172]	; (8001918 <HAL_UART_MspInit+0xcc>)
 800186a:	429a      	cmp	r2, r3
 800186c:	d151      	bne.n	8001912 <HAL_UART_MspInit+0xc6>
  /* USER CODE BEGIN USART2_MspInit 0 */

  /* USER CODE END USART2_MspInit 0 */
  /** Initializes the peripherals clocks
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 800186e:	2302      	movs	r3, #2
 8001870:	9308      	str	r3, [sp, #32]
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001872:	a808      	add	r0, sp, #32
    PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_SYSCLK;
 8001874:	4b29      	ldr	r3, [pc, #164]	; (800191c <HAL_UART_MspInit+0xd0>)
 8001876:	930a      	str	r3, [sp, #40]	; 0x28
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001878:	f003 f8c4 	bl	8004a04 <HAL_RCCEx_PeriphCLKConfig>
 800187c:	b108      	cbz	r0, 8001882 <HAL_UART_MspInit+0x36>
    {
      Error_Handler();
 800187e:	f7ff fb63 	bl	8000f48 <Error_Handler>
  SET_BIT(RCC->APB1ENR1, Periphs);
 8001882:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    PA2     ------> USART2_TX
    */
    GPIO_InitStruct.Pin = USARTx_RX_Pin|USARTx_TX_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001886:	2500      	movs	r5, #0
 8001888:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init */
    /* USART2_TX Init */
    hdma_usart2_tx.Instance = DMA1_Channel5;
 800188a:	4c25      	ldr	r4, [pc, #148]	; (8001920 <HAL_UART_MspInit+0xd4>)
 800188c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001890:	659a      	str	r2, [r3, #88]	; 0x58
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8001892:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001894:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8001898:	9202      	str	r2, [sp, #8]
  (void)tmpreg;
 800189a:	9a02      	ldr	r2, [sp, #8]
  SET_BIT(RCC->AHB2ENR, Periphs);
 800189c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800189e:	f042 0201 	orr.w	r2, r2, #1
 80018a2:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 80018a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80018a6:	f003 0301 	and.w	r3, r3, #1
 80018aa:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80018ac:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80018ae:	220c      	movs	r2, #12
 80018b0:	2302      	movs	r3, #2
 80018b2:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80018b6:	2303      	movs	r3, #3
 80018b8:	e9cd 5305 	strd	r5, r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80018bc:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80018be:	2307      	movs	r3, #7
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80018c0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 80018c4:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80018c6:	f001 ff09 	bl	80036dc <HAL_GPIO_Init>
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 80018ca:	4916      	ldr	r1, [pc, #88]	; (8001924 <HAL_UART_MspInit+0xd8>)
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_LOW;
 80018cc:	6225      	str	r5, [r4, #32]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 80018ce:	2314      	movs	r3, #20
 80018d0:	e9c4 1300 	strd	r1, r3, [r4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80018d4:	2310      	movs	r3, #16
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80018d6:	e9c4 3502 	strd	r3, r5, [r4, #8]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 80018da:	4620      	mov	r0, r4
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 80018dc:	2380      	movs	r3, #128	; 0x80
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80018de:	e9c4 3504 	strd	r3, r5, [r4, #16]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 80018e2:	e9c4 5506 	strd	r5, r5, [r4, #24]
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 80018e6:	f001 fd09 	bl	80032fc <HAL_DMA_Init>
 80018ea:	b108      	cbz	r0, 80018f0 <HAL_UART_MspInit+0xa4>
    {
      Error_Handler();
 80018ec:	f7ff fb2c 	bl	8000f48 <Error_Handler>
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_usart2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
 80018f0:	480b      	ldr	r0, [pc, #44]	; (8001920 <HAL_UART_MspInit+0xd4>)
 80018f2:	2110      	movs	r1, #16
 80018f4:	f001 fed4 	bl	80036a0 <HAL_DMA_ConfigChannelAttributes>
 80018f8:	b108      	cbz	r0, 80018fe <HAL_UART_MspInit+0xb2>
    {
      Error_Handler();
 80018fa:	f7ff fb25 	bl	8000f48 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);

    /* USART2 interrupt Init */
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 80018fe:	2025      	movs	r0, #37	; 0x25
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 8001900:	67b4      	str	r4, [r6, #120]	; 0x78
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 8001902:	2200      	movs	r2, #0
 8001904:	2102      	movs	r1, #2
    __HAL_LINKDMA(uartHandle,hdmatx,hdma_usart2_tx);
 8001906:	62a6      	str	r6, [r4, #40]	; 0x28
    HAL_NVIC_SetPriority(USART2_IRQn, 2, 0);
 8001908:	f001 fc64 	bl	80031d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 800190c:	2025      	movs	r0, #37	; 0x25
 800190e:	f001 fc93 	bl	8003238 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }
}
 8001912:	b016      	add	sp, #88	; 0x58
 8001914:	bd70      	pop	{r4, r5, r6, pc}
 8001916:	bf00      	nop
 8001918:	40004400 	.word	0x40004400
 800191c:	000c0004 	.word	0x000c0004
 8001920:	200019d4 	.word	0x200019d4
 8001924:	40020058 	.word	0x40020058

08001928 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==USART2)
 8001928:	6802      	ldr	r2, [r0, #0]
 800192a:	4b0c      	ldr	r3, [pc, #48]	; (800195c <HAL_UART_MspDeInit+0x34>)
 800192c:	429a      	cmp	r2, r3
{
 800192e:	b510      	push	{r4, lr}
 8001930:	4604      	mov	r4, r0
  if(uartHandle->Instance==USART2)
 8001932:	d112      	bne.n	800195a <HAL_UART_MspDeInit+0x32>
  CLEAR_BIT(RCC->APB1ENR1, Periphs);
 8001934:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000

    /**USART2 GPIO Configuration
    PA3     ------> USART2_RX
    PA2     ------> USART2_TX
    */
    HAL_GPIO_DeInit(GPIOA, USARTx_RX_Pin|USARTx_TX_Pin);
 8001938:	210c      	movs	r1, #12
 800193a:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800193c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001940:	6593      	str	r3, [r2, #88]	; 0x58
 8001942:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001946:	f001 ff75 	bl	8003834 <HAL_GPIO_DeInit>

    /* USART2 DMA DeInit */
    HAL_DMA_DeInit(uartHandle->hdmatx);
 800194a:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 800194c:	f001 fd48 	bl	80033e0 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
}
 8001950:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8001954:	2025      	movs	r0, #37	; 0x25
 8001956:	f001 bc7d 	b.w	8003254 <HAL_NVIC_DisableIRQ>
}
 800195a:	bd10      	pop	{r4, pc}
 800195c:	40004400 	.word	0x40004400

08001960 <vcom_Trace_DMA>:

  /* USER CODE END vcom_Trace_2 */
}

UTIL_ADV_TRACE_Status_t vcom_Trace_DMA(uint8_t *p_data, uint16_t size)
{
 8001960:	b508      	push	{r3, lr}
 8001962:	460a      	mov	r2, r1
  /* USER CODE BEGIN vcom_Trace_DMA_1 */

  /* USER CODE END vcom_Trace_DMA_1 */
  HAL_UART_Transmit_DMA(&huart2, p_data, size);
 8001964:	4601      	mov	r1, r0
 8001966:	4802      	ldr	r0, [pc, #8]	; (8001970 <vcom_Trace_DMA+0x10>)
 8001968:	f003 fe48 	bl	80055fc <HAL_UART_Transmit_DMA>
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_Trace_DMA_2 */

  /* USER CODE END vcom_Trace_DMA_2 */
}
 800196c:	2000      	movs	r0, #0
 800196e:	bd08      	pop	{r3, pc}
 8001970:	20001a34 	.word	0x20001a34

08001974 <vcom_ReceiveInit>:

UTIL_ADV_TRACE_Status_t vcom_ReceiveInit(void (*RxCb)(uint8_t *rxChar, uint16_t size, uint8_t error))
{
 8001974:	b513      	push	{r0, r1, r4, lr}

  /* USER CODE END vcom_ReceiveInit_1 */
  UART_WakeUpTypeDef WakeUpSelection;

  /*record call back*/
  RxCpltCallback = RxCb;
 8001976:	4b11      	ldr	r3, [pc, #68]	; (80019bc <vcom_ReceiveInit+0x48>)

  /*Set wakeUp event on start bit*/
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;

  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 8001978:	4c11      	ldr	r4, [pc, #68]	; (80019c0 <vcom_ReceiveInit+0x4c>)
  RxCpltCallback = RxCb;
 800197a:	6018      	str	r0, [r3, #0]
  WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_STARTBIT;
 800197c:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8001980:	9300      	str	r3, [sp, #0]
  HAL_UARTEx_StopModeWakeUpSourceConfig(&huart2, WakeUpSelection);
 8001982:	ab02      	add	r3, sp, #8
 8001984:	e913 0006 	ldmdb	r3, {r1, r2}
 8001988:	4620      	mov	r0, r4
 800198a:	f004 fd52 	bl	8006432 <HAL_UARTEx_StopModeWakeUpSourceConfig>

  /* Make sure that no UART transfer is on-going */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_BUSY) == SET);
 800198e:	6823      	ldr	r3, [r4, #0]
 8001990:	69da      	ldr	r2, [r3, #28]
 8001992:	03d1      	lsls	r1, r2, #15
 8001994:	d4fc      	bmi.n	8001990 <vcom_ReceiveInit+0x1c>

  /* Make sure that UART is ready to receive)   */
  while (__HAL_UART_GET_FLAG(&huart2, USART_ISR_REACK) == RESET);
 8001996:	69da      	ldr	r2, [r3, #28]
 8001998:	0252      	lsls	r2, r2, #9
 800199a:	d5fc      	bpl.n	8001996 <vcom_ReceiveInit+0x22>

  /* Enable USART interrupt */
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 800199c:	689a      	ldr	r2, [r3, #8]

  /*Enable wakeup from stop mode*/
  HAL_UARTEx_EnableStopMode(&huart2);
 800199e:	4808      	ldr	r0, [pc, #32]	; (80019c0 <vcom_ReceiveInit+0x4c>)
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_WUF);
 80019a0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80019a4:	609a      	str	r2, [r3, #8]
  HAL_UARTEx_EnableStopMode(&huart2);
 80019a6:	f004 fd8b 	bl	80064c0 <HAL_UARTEx_EnableStopMode>

  /*Start LPUART receive on IT*/
  HAL_UART_Receive_IT(&huart2, &charRx, 1);
 80019aa:	4906      	ldr	r1, [pc, #24]	; (80019c4 <vcom_ReceiveInit+0x50>)
 80019ac:	4804      	ldr	r0, [pc, #16]	; (80019c0 <vcom_ReceiveInit+0x4c>)
 80019ae:	2201      	movs	r2, #1
 80019b0:	f004 fcf0 	bl	8006394 <HAL_UART_Receive_IT>

  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN vcom_ReceiveInit_2 */

  /* USER CODE END vcom_ReceiveInit_2 */
}
 80019b4:	2000      	movs	r0, #0
 80019b6:	b002      	add	sp, #8
 80019b8:	bd10      	pop	{r4, pc}
 80019ba:	bf00      	nop
 80019bc:	20000178 	.word	0x20000178
 80019c0:	20001a34 	.word	0x20001a34
 80019c4:	20001ac4 	.word	0x20001ac4

080019c8 <vcom_Init>:
{
 80019c8:	b508      	push	{r3, lr}
  TxCpltCallback = cb;
 80019ca:	4b07      	ldr	r3, [pc, #28]	; (80019e8 <vcom_Init+0x20>)
 80019cc:	6018      	str	r0, [r3, #0]
  MX_DMA_Init();
 80019ce:	f7ff fa4b 	bl	8000e68 <MX_DMA_Init>
  MX_USART2_UART_Init();
 80019d2:	f7ff ff09 	bl	80017e8 <MX_USART2_UART_Init>
  SET_BIT(EXTI->IMR1, ExtiLine);
 80019d6:	4a05      	ldr	r2, [pc, #20]	; (80019ec <vcom_Init+0x24>)
 80019d8:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 80019dc:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 80019e0:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
}
 80019e4:	2000      	movs	r0, #0
 80019e6:	bd08      	pop	{r3, pc}
 80019e8:	2000017c 	.word	0x2000017c
 80019ec:	58000800 	.word	0x58000800

080019f0 <vcom_DeInit>:
{
 80019f0:	b508      	push	{r3, lr}
  SET_BIT(RCC->APB1RSTR1, Periphs);
 80019f2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  HAL_UART_MspDeInit(&huart2);
 80019f6:	4808      	ldr	r0, [pc, #32]	; (8001a18 <vcom_DeInit+0x28>)
 80019f8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80019fa:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80019fe:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(RCC->APB1RSTR1, Periphs);
 8001a00:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001a02:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8001a06:	639a      	str	r2, [r3, #56]	; 0x38
 8001a08:	f7ff ff8e 	bl	8001928 <HAL_UART_MspDeInit>
  HAL_NVIC_DisableIRQ(DMA1_Channel5_IRQn);
 8001a0c:	200f      	movs	r0, #15
 8001a0e:	f001 fc21 	bl	8003254 <HAL_NVIC_DisableIRQ>
}
 8001a12:	2000      	movs	r0, #0
 8001a14:	bd08      	pop	{r3, pc}
 8001a16:	bf00      	nop
 8001a18:	20001a34 	.word	0x20001a34

08001a1c <vcom_Resume>:

void vcom_Resume(void)
{
 8001a1c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN vcom_Resume_1 */

  /* USER CODE END vcom_Resume_1 */
  /*to re-enable lost UART settings*/
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001a1e:	4807      	ldr	r0, [pc, #28]	; (8001a3c <vcom_Resume+0x20>)
 8001a20:	f004 fc00 	bl	8006224 <HAL_UART_Init>
 8001a24:	b108      	cbz	r0, 8001a2a <vcom_Resume+0xe>
  {
    Error_Handler();
 8001a26:	f7ff fa8f 	bl	8000f48 <Error_Handler>
  }

  /*to re-enable lost DMA settings*/
  if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8001a2a:	4805      	ldr	r0, [pc, #20]	; (8001a40 <vcom_Resume+0x24>)
 8001a2c:	f001 fc66 	bl	80032fc <HAL_DMA_Init>
 8001a30:	b118      	cbz	r0, 8001a3a <vcom_Resume+0x1e>
    Error_Handler();
  }
  /* USER CODE BEGIN vcom_Resume_2 */

  /* USER CODE END vcom_Resume_2 */
}
 8001a32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 8001a36:	f7ff ba87 	b.w	8000f48 <Error_Handler>
}
 8001a3a:	bd08      	pop	{r3, pc}
 8001a3c:	20001a34 	.word	0x20001a34
 8001a40:	200019d4 	.word	0x200019d4

08001a44 <HAL_UART_TxCpltCallback>:
{
  /* USER CODE BEGIN HAL_UART_TxCpltCallback_1 */

  /* USER CODE END HAL_UART_TxCpltCallback_1 */
  /* buffer transmission complete*/
  TxCpltCallback(NULL);
 8001a44:	4b01      	ldr	r3, [pc, #4]	; (8001a4c <HAL_UART_TxCpltCallback+0x8>)
 8001a46:	2000      	movs	r0, #0
 8001a48:	681b      	ldr	r3, [r3, #0]
 8001a4a:	4718      	bx	r3
 8001a4c:	2000017c 	.word	0x2000017c

08001a50 <HAL_UART_RxCpltCallback>:
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart2)
{
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_1 */

  /* USER CODE END HAL_UART_RxCpltCallback_1 */
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 8001a50:	4b08      	ldr	r3, [pc, #32]	; (8001a74 <HAL_UART_RxCpltCallback+0x24>)
 8001a52:	681b      	ldr	r3, [r3, #0]
{
 8001a54:	b510      	push	{r4, lr}
 8001a56:	4604      	mov	r4, r0
  if ((NULL != RxCpltCallback) && (HAL_UART_ERROR_NONE == huart2->ErrorCode))
 8001a58:	b12b      	cbz	r3, 8001a66 <HAL_UART_RxCpltCallback+0x16>
 8001a5a:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
 8001a5e:	b912      	cbnz	r2, 8001a66 <HAL_UART_RxCpltCallback+0x16>
  {
    RxCpltCallback(&charRx, 1, 0);
 8001a60:	4805      	ldr	r0, [pc, #20]	; (8001a78 <HAL_UART_RxCpltCallback+0x28>)
 8001a62:	2101      	movs	r1, #1
 8001a64:	4798      	blx	r3
  }
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 8001a66:	4620      	mov	r0, r4
 8001a68:	4903      	ldr	r1, [pc, #12]	; (8001a78 <HAL_UART_RxCpltCallback+0x28>)
  /* USER CODE BEGIN HAL_UART_RxCpltCallback_2 */

  /* USER CODE END HAL_UART_RxCpltCallback_2 */
}
 8001a6a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Receive_IT(huart2, &charRx, 1);
 8001a6e:	2201      	movs	r2, #1
 8001a70:	f004 bc90 	b.w	8006394 <HAL_UART_Receive_IT>
 8001a74:	20000178 	.word	0x20000178
 8001a78:	20001ac4 	.word	0x20001ac4

08001a7c <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 8001a7c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 8001a7e:	f7ff fc5d 	bl	800133c <SystemApp_Init>
  /* USER CODE END MX_LoRaWAN_Init_2 */
  LoRaWAN_Init();
  /* USER CODE BEGIN MX_LoRaWAN_Init_3 */

  /* USER CODE END MX_LoRaWAN_Init_3 */
}
 8001a82:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  LoRaWAN_Init();
 8001a86:	f000 ba95 	b.w	8001fb4 <LoRaWAN_Init>

08001a8a <MX_LoRaWAN_Process>:
void MX_LoRaWAN_Process(void)
{
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 8001a8a:	f04f 30ff 	mov.w	r0, #4294967295
 8001a8e:	f00d bb8f 	b.w	800f1b0 <UTIL_SEQ_Run>
	...

08001a94 <OnTxTimerEvent>:

  /* USER CODE END SendTxData_1 */
}

static void OnTxTimerEvent(void *context)
{
 8001a94:	b508      	push	{r3, lr}
  /* USER CODE BEGIN OnTxTimerEvent_1 */

  /* USER CODE END OnTxTimerEvent_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 8001a96:	2002      	movs	r0, #2
 8001a98:	2100      	movs	r1, #0
 8001a9a:	f00d fb51 	bl	800f140 <UTIL_SEQ_SetTask>
  /*Wait for next tx slot*/
  UTIL_TIMER_Start(&TxTimer);
  /* USER CODE BEGIN OnTxTimerEvent_2 */

  /* USER CODE END OnTxTimerEvent_2 */
}
 8001a9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  UTIL_TIMER_Start(&TxTimer);
 8001aa2:	4801      	ldr	r0, [pc, #4]	; (8001aa8 <OnTxTimerEvent+0x14>)
 8001aa4:	f00d bdbc 	b.w	800f620 <UTIL_TIMER_Start>
 8001aa8:	200002d8 	.word	0x200002d8

08001aac <OnMacProcessNotify>:
static void OnMacProcessNotify(void)
{
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 8001aac:	2100      	movs	r1, #0
 8001aae:	2001      	movs	r0, #1
 8001ab0:	f00d bb46 	b.w	800f140 <UTIL_SEQ_SetTask>

08001ab4 <OnRxData>:
{
 8001ab4:	b530      	push	{r4, r5, lr}
 8001ab6:	460d      	mov	r5, r1
 8001ab8:	b087      	sub	sp, #28
  if ((appData != NULL) || (params != NULL))
 8001aba:	4604      	mov	r4, r0
 8001abc:	b908      	cbnz	r0, 8001ac2 <OnRxData+0xe>
 8001abe:	2900      	cmp	r1, #0
 8001ac0:	d059      	beq.n	8001b76 <OnRxData+0xc2>
    BSP_LED_On(LED_BLUE) ;
 8001ac2:	2000      	movs	r0, #0
 8001ac4:	f000 fe12 	bl	80026ec <BSP_LED_On>
    UTIL_TIMER_Start(&RxLedTimer);
 8001ac8:	482c      	ldr	r0, [pc, #176]	; (8001b7c <OnRxData+0xc8>)
 8001aca:	f00d fda9 	bl	800f620 <UTIL_TIMER_Start>
    APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Indication ==========\r\n");
 8001ace:	2200      	movs	r2, #0
 8001ad0:	4611      	mov	r1, r2
 8001ad2:	4b2b      	ldr	r3, [pc, #172]	; (8001b80 <OnRxData+0xcc>)
 8001ad4:	2002      	movs	r0, #2
 8001ad6:	f00d fa17 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    APP_LOG(TS_OFF, VLEVEL_H, "###### D/L FRAME:%04d | SLOT:%s | PORT:%d | DR:%d | RSSI:%d | SNR:%d\r\n",
 8001ada:	f995 3004 	ldrsb.w	r3, [r5, #4]
 8001ade:	9305      	str	r3, [sp, #20]
 8001ae0:	f995 3003 	ldrsb.w	r3, [r5, #3]
 8001ae4:	9304      	str	r3, [sp, #16]
 8001ae6:	f995 3002 	ldrsb.w	r3, [r5, #2]
 8001aea:	9303      	str	r3, [sp, #12]
 8001aec:	7823      	ldrb	r3, [r4, #0]
 8001aee:	9302      	str	r3, [sp, #8]
 8001af0:	f995 200c 	ldrsb.w	r2, [r5, #12]
 8001af4:	4b23      	ldr	r3, [pc, #140]	; (8001b84 <OnRxData+0xd0>)
 8001af6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001afa:	9301      	str	r3, [sp, #4]
 8001afc:	68ab      	ldr	r3, [r5, #8]
 8001afe:	9300      	str	r3, [sp, #0]
 8001b00:	2200      	movs	r2, #0
 8001b02:	4b21      	ldr	r3, [pc, #132]	; (8001b88 <OnRxData+0xd4>)
 8001b04:	4611      	mov	r1, r2
 8001b06:	2003      	movs	r0, #3
 8001b08:	f00d f9fe 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    switch (appData->Port)
 8001b0c:	7825      	ldrb	r5, [r4, #0]
 8001b0e:	2d02      	cmp	r5, #2
 8001b10:	d010      	beq.n	8001b34 <OnRxData+0x80>
 8001b12:	2d03      	cmp	r5, #3
 8001b14:	d12f      	bne.n	8001b76 <OnRxData+0xc2>
        if (appData->BufferSize == 1)
 8001b16:	7863      	ldrb	r3, [r4, #1]
 8001b18:	2b01      	cmp	r3, #1
 8001b1a:	d12c      	bne.n	8001b76 <OnRxData+0xc2>
          switch (appData->Buffer[0])
 8001b1c:	6863      	ldr	r3, [r4, #4]
 8001b1e:	7818      	ldrb	r0, [r3, #0]
 8001b20:	2801      	cmp	r0, #1
 8001b22:	d002      	beq.n	8001b2a <OnRxData+0x76>
 8001b24:	2802      	cmp	r0, #2
 8001b26:	d000      	beq.n	8001b2a <OnRxData+0x76>
 8001b28:	bb28      	cbnz	r0, 8001b76 <OnRxData+0xc2>
}
 8001b2a:	b007      	add	sp, #28
 8001b2c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
              LmHandlerRequestClass(CLASS_C);
 8001b30:	f004 be86 	b.w	8006840 <LmHandlerRequestClass>
        if (appData->BufferSize == 1)
 8001b34:	7863      	ldrb	r3, [r4, #1]
 8001b36:	2b01      	cmp	r3, #1
 8001b38:	d11d      	bne.n	8001b76 <OnRxData+0xc2>
          AppLedStateOn = appData->Buffer[0] & 0x01;
 8001b3a:	6863      	ldr	r3, [r4, #4]
 8001b3c:	781a      	ldrb	r2, [r3, #0]
 8001b3e:	4b13      	ldr	r3, [pc, #76]	; (8001b8c <OnRxData+0xd8>)
 8001b40:	f002 0201 	and.w	r2, r2, #1
 8001b44:	701a      	strb	r2, [r3, #0]
          if (AppLedStateOn == RESET)
 8001b46:	b952      	cbnz	r2, 8001b5e <OnRxData+0xaa>
            APP_LOG(TS_OFF, VLEVEL_M, "LED RED OFF\r\n");
 8001b48:	4b11      	ldr	r3, [pc, #68]	; (8001b90 <OnRxData+0xdc>)
 8001b4a:	4611      	mov	r1, r2
 8001b4c:	4628      	mov	r0, r5
 8001b4e:	f00d f9db 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_Off(LED_RED) ;
 8001b52:	4628      	mov	r0, r5
}
 8001b54:	b007      	add	sp, #28
 8001b56:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_Off(LED_RED) ;
 8001b5a:	f000 bdd7 	b.w	800270c <BSP_LED_Off>
            APP_LOG(TS_OFF, VLEVEL_M, "LED RED ON\r\n");
 8001b5e:	2200      	movs	r2, #0
 8001b60:	4b0c      	ldr	r3, [pc, #48]	; (8001b94 <OnRxData+0xe0>)
 8001b62:	4611      	mov	r1, r2
 8001b64:	4628      	mov	r0, r5
 8001b66:	f00d f9cf 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
            BSP_LED_On(LED_RED) ;
 8001b6a:	4628      	mov	r0, r5
}
 8001b6c:	b007      	add	sp, #28
 8001b6e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
            BSP_LED_On(LED_RED) ;
 8001b72:	f000 bdbb 	b.w	80026ec <BSP_LED_On>
}
 8001b76:	b007      	add	sp, #28
 8001b78:	bd30      	pop	{r4, r5, pc}
 8001b7a:	bf00      	nop
 8001b7c:	20000274 	.word	0x20000274
 8001b80:	080104a0 	.word	0x080104a0
 8001b84:	08010788 	.word	0x08010788
 8001b88:	080104d1 	.word	0x080104d1
 8001b8c:	20000272 	.word	0x20000272
 8001b90:	08010518 	.word	0x08010518
 8001b94:	08010526 	.word	0x08010526

08001b98 <OnRxTimerLedEvent>:
  BSP_LED_Off(LED_BLUE) ;
 8001b98:	2000      	movs	r0, #0
 8001b9a:	f000 bdb7 	b.w	800270c <BSP_LED_Off>
	...

08001ba0 <OnJoinRequest>:
{
 8001ba0:	b538      	push	{r3, r4, r5, lr}
  if(onlyonce){
 8001ba2:	4c18      	ldr	r4, [pc, #96]	; (8001c04 <OnJoinRequest+0x64>)
{
 8001ba4:	4605      	mov	r5, r0
  BSP_I2C2_Init();
 8001ba6:	f7ff fb2d 	bl	8001204 <BSP_I2C2_Init>
  if(onlyonce){
 8001baa:	7823      	ldrb	r3, [r4, #0]
 8001bac:	b11b      	cbz	r3, 8001bb6 <OnJoinRequest+0x16>
     rgb_lcd_clear();
 8001bae:	f000 fb85 	bl	80022bc <rgb_lcd_clear>
     onlyonce = 0;
 8001bb2:	2300      	movs	r3, #0
 8001bb4:	7023      	strb	r3, [r4, #0]
  if (joinParams != NULL)
 8001bb6:	b1e5      	cbz	r5, 8001bf2 <OnJoinRequest+0x52>
	rgb_lcd_setCursor(13,0);
 8001bb8:	2100      	movs	r1, #0
 8001bba:	200d      	movs	r0, #13
 8001bbc:	f000 fb87 	bl	80022ce <rgb_lcd_setCursor>
    if (joinParams->Status == LORAMAC_HANDLER_SUCCESS)
 8001bc0:	f995 4001 	ldrsb.w	r4, [r5, #1]
 8001bc4:	b9cc      	cbnz	r4, 8001bfa <OnJoinRequest+0x5a>
      BSP_LED_Off(LED_RED) ;
 8001bc6:	2002      	movs	r0, #2
 8001bc8:	f000 fda0 	bl	800270c <BSP_LED_Off>
      rgb_lcd_print("\1Ok");
 8001bcc:	480e      	ldr	r0, [pc, #56]	; (8001c08 <OnJoinRequest+0x68>)
 8001bce:	f000 fc05 	bl	80023dc <rgb_lcd_print>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOINED = ");
 8001bd2:	4b0e      	ldr	r3, [pc, #56]	; (8001c0c <OnJoinRequest+0x6c>)
 8001bd4:	4622      	mov	r2, r4
 8001bd6:	4621      	mov	r1, r4
 8001bd8:	2002      	movs	r0, #2
 8001bda:	f00d f995 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
      if (joinParams->Mode == ACTIVATION_TYPE_ABP)
 8001bde:	78ab      	ldrb	r3, [r5, #2]
 8001be0:	2b01      	cmp	r3, #1
        APP_LOG(TS_OFF, VLEVEL_M, "ABP ======================\r\n");
 8001be2:	bf0c      	ite	eq
 8001be4:	4b0a      	ldreq	r3, [pc, #40]	; (8001c10 <OnJoinRequest+0x70>)
        APP_LOG(TS_OFF, VLEVEL_M, "OTAA =====================\r\n");
 8001be6:	4b0b      	ldrne	r3, [pc, #44]	; (8001c14 <OnJoinRequest+0x74>)
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 8001be8:	2200      	movs	r2, #0
 8001bea:	4611      	mov	r1, r2
 8001bec:	2002      	movs	r0, #2
 8001bee:	f00d f98b 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 8001bf2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  BSP_I2C2_DeInit();
 8001bf6:	f7ff ba8d 	b.w	8001114 <BSP_I2C2_DeInit>
	  rgb_lcd_print("\1Ko");
 8001bfa:	4807      	ldr	r0, [pc, #28]	; (8001c18 <OnJoinRequest+0x78>)
 8001bfc:	f000 fbee 	bl	80023dc <rgb_lcd_print>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### = JOIN FAILED\r\n");
 8001c00:	4b06      	ldr	r3, [pc, #24]	; (8001c1c <OnJoinRequest+0x7c>)
 8001c02:	e7f1      	b.n	8001be8 <OnJoinRequest+0x48>
 8001c04:	2000004c 	.word	0x2000004c
 8001c08:	08010533 	.word	0x08010533
 8001c0c:	08010537 	.word	0x08010537
 8001c10:	0801054c 	.word	0x0801054c
 8001c14:	08010569 	.word	0x08010569
 8001c18:	08010586 	.word	0x08010586
 8001c1c:	0801058a 	.word	0x0801058a

08001c20 <OnTxTimerLedEvent>:
{
 8001c20:	b508      	push	{r3, lr}
	BSP_I2C2_Init();
 8001c22:	f7ff faef 	bl	8001204 <BSP_I2C2_Init>
	rgb_lcd_setCursor(15,1);
 8001c26:	2101      	movs	r1, #1
 8001c28:	200f      	movs	r0, #15
 8001c2a:	f000 fb50 	bl	80022ce <rgb_lcd_setCursor>
	rgb_lcd_write(' ');
 8001c2e:	2020      	movs	r0, #32
 8001c30:	f000 fb34 	bl	800229c <rgb_lcd_write>
	BSP_I2C2_DeInit();
 8001c34:	f7ff fa6e 	bl	8001114 <BSP_I2C2_DeInit>
}
 8001c38:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	BSP_LED_Off(LED_GREEN);
 8001c3c:	2001      	movs	r0, #1
 8001c3e:	f000 bd65 	b.w	800270c <BSP_LED_Off>
	...

08001c44 <SendTxData>:
{
 8001c44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c46:	b085      	sub	sp, #20
  UTIL_TIMER_Time_t nextTxIn = 0;
 8001c48:	2500      	movs	r5, #0
 8001c4a:	9503      	str	r5, [sp, #12]
  BSP_I2C2_Init();
 8001c4c:	f7ff fada 	bl	8001204 <BSP_I2C2_Init>
  rgb_lcd_setCursor(15,1);
 8001c50:	2101      	movs	r1, #1
 8001c52:	200f      	movs	r0, #15
 8001c54:	f000 fb3b 	bl	80022ce <rgb_lcd_setCursor>
  rgb_lcd_write('\0');
 8001c58:	4628      	mov	r0, r5
 8001c5a:	f000 fb1f 	bl	800229c <rgb_lcd_write>
  BSP_I2C2_DeInit();
 8001c5e:	f7ff fa59 	bl	8001114 <BSP_I2C2_DeInit>
  temperature = (SYS_GetTemperatureLevel() >> 8);
 8001c62:	f7ff f8c3 	bl	8000dec <SYS_GetTemperatureLevel>
  temperature = (int8_t)SensorData.temperature;
 8001c66:	4c23      	ldr	r4, [pc, #140]	; (8001cf4 <SendTxData+0xb0>)
  APP_LOG(TS_ON, VLEVEL_M, "mcu temp= %d\n", temperature);
 8001c68:	4b23      	ldr	r3, [pc, #140]	; (8001cf8 <SendTxData+0xb4>)
 8001c6a:	f340 200f 	sbfx	r0, r0, #8, #16
 8001c6e:	2201      	movs	r2, #1
 8001c70:	4629      	mov	r1, r5
 8001c72:	9000      	str	r0, [sp, #0]
 8001c74:	2002      	movs	r0, #2
 8001c76:	f00d f947 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  temperature = (int8_t)SensorData.temperature;
 8001c7a:	6860      	ldr	r0, [r4, #4]
 8001c7c:	f7fe fe52 	bl	8000924 <__aeabi_f2iz>
 8001c80:	b247      	sxtb	r7, r0
  humidity    = (uint8_t)SensorData.humidity;
 8001c82:	68a0      	ldr	r0, [r4, #8]
 8001c84:	f7fe fe74 	bl	8000970 <__aeabi_f2uiz>
 8001c88:	b2c6      	uxtb	r6, r0
  co2         = (int16_t)SensorData.co2;
 8001c8a:	68e0      	ldr	r0, [r4, #12]
  AppData.Port = LORAWAN_USER_APP_PORT;
 8001c8c:	4c1b      	ldr	r4, [pc, #108]	; (8001cfc <SendTxData+0xb8>)
  co2         = (int16_t)SensorData.co2;
 8001c8e:	f7fe fe49 	bl	8000924 <__aeabi_f2iz>
  AppData.Port = LORAWAN_USER_APP_PORT;
 8001c92:	2302      	movs	r3, #2
 8001c94:	7023      	strb	r3, [r4, #0]
  AppData.Buffer[i++] = (uint8_t)((co2 >> 8) & 0xFF);
 8001c96:	6863      	ldr	r3, [r4, #4]
 8001c98:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8001c9c:	701a      	strb	r2, [r3, #0]
  AppData.Buffer[i++] = (uint8_t)(co2 & 0xFF);
 8001c9e:	6863      	ldr	r3, [r4, #4]
  AppData.Buffer[i++] = AppLedStateOn;
 8001ca0:	4a17      	ldr	r2, [pc, #92]	; (8001d00 <SendTxData+0xbc>)
  AppData.Buffer[i++] = (uint8_t)(co2 & 0xFF);
 8001ca2:	7058      	strb	r0, [r3, #1]
  AppData.Buffer[i++] = (uint8_t)temperature;
 8001ca4:	6863      	ldr	r3, [r4, #4]
  AppData.Buffer[i++] = AppLedStateOn;
 8001ca6:	7812      	ldrb	r2, [r2, #0]
  AppData.Buffer[i++] = (uint8_t)temperature;
 8001ca8:	709f      	strb	r7, [r3, #2]
  AppData.Buffer[i++] = (uint8_t)humidity;
 8001caa:	6863      	ldr	r3, [r4, #4]
 8001cac:	70de      	strb	r6, [r3, #3]
  AppData.Buffer[i++] = AppLedStateOn;
 8001cae:	6863      	ldr	r3, [r4, #4]
 8001cb0:	711a      	strb	r2, [r3, #4]
  AppData.BufferSize = i;
 8001cb2:	2305      	movs	r3, #5
 8001cb4:	7063      	strb	r3, [r4, #1]
  if (LORAMAC_HANDLER_SUCCESS == LmHandlerSend(&AppData, LORAWAN_DEFAULT_CONFIRMED_MSG_STATE, &nextTxIn, false))
 8001cb6:	4629      	mov	r1, r5
 8001cb8:	462b      	mov	r3, r5
 8001cba:	aa03      	add	r2, sp, #12
 8001cbc:	4620      	mov	r0, r4
 8001cbe:	f004 fe5f 	bl	8006980 <LmHandlerSend>
 8001cc2:	4601      	mov	r1, r0
 8001cc4:	b930      	cbnz	r0, 8001cd4 <SendTxData+0x90>
    APP_LOG(TS_ON, VLEVEL_L, "SEND REQUEST\r\n");
 8001cc6:	2201      	movs	r2, #1
 8001cc8:	4b0e      	ldr	r3, [pc, #56]	; (8001d04 <SendTxData+0xc0>)
 8001cca:	4610      	mov	r0, r2
 8001ccc:	f00d f91c 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 8001cd0:	b005      	add	sp, #20
 8001cd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  else if (nextTxIn > 0)
 8001cd4:	9b03      	ldr	r3, [sp, #12]
 8001cd6:	2b00      	cmp	r3, #0
 8001cd8:	d0fa      	beq.n	8001cd0 <SendTxData+0x8c>
    APP_LOG(TS_ON, VLEVEL_L, "Next Tx in  : ~%d second(s)\r\n", (nextTxIn / 1000));
 8001cda:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8001cde:	fbb3 f3f2 	udiv	r3, r3, r2
 8001ce2:	2201      	movs	r2, #1
 8001ce4:	9300      	str	r3, [sp, #0]
 8001ce6:	4629      	mov	r1, r5
 8001ce8:	4b07      	ldr	r3, [pc, #28]	; (8001d08 <SendTxData+0xc4>)
 8001cea:	4610      	mov	r0, r2
 8001cec:	f00d f90c 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 8001cf0:	e7ee      	b.n	8001cd0 <SendTxData+0x8c>
 8001cf2:	bf00      	nop
 8001cf4:	2000028c 	.word	0x2000028c
 8001cf8:	080105a3 	.word	0x080105a3
 8001cfc:	20000000 	.word	0x20000000
 8001d00:	20000272 	.word	0x20000272
 8001d04:	080105b1 	.word	0x080105b1
 8001d08:	080105c0 	.word	0x080105c0

08001d0c <OnTxData>:
{
 8001d0c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if ((params != NULL))
 8001d0e:	4604      	mov	r4, r0
 8001d10:	2800      	cmp	r0, #0
 8001d12:	d034      	beq.n	8001d7e <OnTxData+0x72>
    if (params->IsMcpsConfirm != 0)
 8001d14:	7803      	ldrb	r3, [r0, #0]
 8001d16:	2b00      	cmp	r3, #0
 8001d18:	d031      	beq.n	8001d7e <OnTxData+0x72>
      BSP_LED_On(LED_GREEN) ;
 8001d1a:	2001      	movs	r0, #1
 8001d1c:	f000 fce6 	bl	80026ec <BSP_LED_On>
      UTIL_TIMER_Start(&TxLedTimer);
 8001d20:	481c      	ldr	r0, [pc, #112]	; (8001d94 <OnTxData+0x88>)
 8001d22:	f00d fc7d 	bl	800f620 <UTIL_TIMER_Start>
      APP_LOG(TS_OFF, VLEVEL_M, "\r\n###### ========== MCPS-Confirm =============\r\n");
 8001d26:	2200      	movs	r2, #0
 8001d28:	4611      	mov	r1, r2
 8001d2a:	4b1b      	ldr	r3, [pc, #108]	; (8001d98 <OnTxData+0x8c>)
 8001d2c:	2002      	movs	r0, #2
 8001d2e:	f00d f8eb 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, "###### U/L FRAME:%04d | PORT:%d | DR:%d | PWR:%d", params->UplinkCounter,
 8001d32:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8001d36:	9303      	str	r3, [sp, #12]
 8001d38:	f994 3004 	ldrsb.w	r3, [r4, #4]
 8001d3c:	9302      	str	r3, [sp, #8]
 8001d3e:	7b23      	ldrb	r3, [r4, #12]
 8001d40:	9301      	str	r3, [sp, #4]
 8001d42:	68a3      	ldr	r3, [r4, #8]
 8001d44:	9300      	str	r3, [sp, #0]
 8001d46:	2200      	movs	r2, #0
 8001d48:	4611      	mov	r1, r2
 8001d4a:	4b14      	ldr	r3, [pc, #80]	; (8001d9c <OnTxData+0x90>)
 8001d4c:	2003      	movs	r0, #3
 8001d4e:	f00d f8db 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
      APP_LOG(TS_OFF, VLEVEL_H, " | MSG TYPE:");
 8001d52:	2200      	movs	r2, #0
 8001d54:	4b12      	ldr	r3, [pc, #72]	; (8001da0 <OnTxData+0x94>)
 8001d56:	4611      	mov	r1, r2
 8001d58:	2003      	movs	r0, #3
 8001d5a:	f00d f8d5 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
      if (params->MsgType == LORAMAC_HANDLER_CONFIRMED_MSG)
 8001d5e:	78a3      	ldrb	r3, [r4, #2]
 8001d60:	2b01      	cmp	r3, #1
 8001d62:	d10e      	bne.n	8001d82 <OnTxData+0x76>
        APP_LOG(TS_OFF, VLEVEL_H, "CONFIRMED [%s]\r\n", (params->AckReceived != 0) ? "ACK" : "NACK");
 8001d64:	78e1      	ldrb	r1, [r4, #3]
 8001d66:	4a0f      	ldr	r2, [pc, #60]	; (8001da4 <OnTxData+0x98>)
 8001d68:	4b0f      	ldr	r3, [pc, #60]	; (8001da8 <OnTxData+0x9c>)
 8001d6a:	2900      	cmp	r1, #0
 8001d6c:	bf08      	it	eq
 8001d6e:	4613      	moveq	r3, r2
 8001d70:	2200      	movs	r2, #0
 8001d72:	9300      	str	r3, [sp, #0]
 8001d74:	4611      	mov	r1, r2
 8001d76:	4b0d      	ldr	r3, [pc, #52]	; (8001dac <OnTxData+0xa0>)
 8001d78:	2003      	movs	r0, #3
 8001d7a:	f00d f8c5 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 8001d7e:	b004      	add	sp, #16
 8001d80:	bd10      	pop	{r4, pc}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 8001d82:	2200      	movs	r2, #0
 8001d84:	4b0a      	ldr	r3, [pc, #40]	; (8001db0 <OnTxData+0xa4>)
 8001d86:	4611      	mov	r1, r2
 8001d88:	2003      	movs	r0, #3
}
 8001d8a:	b004      	add	sp, #16
 8001d8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        APP_LOG(TS_OFF, VLEVEL_H, "UNCONFIRMED\r\n");
 8001d90:	f00d b8ba 	b.w	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 8001d94:	200002c0 	.word	0x200002c0
 8001d98:	080105e3 	.word	0x080105e3
 8001d9c:	08010614 	.word	0x08010614
 8001da0:	08010645 	.word	0x08010645
 8001da4:	080105de 	.word	0x080105de
 8001da8:	080105df 	.word	0x080105df
 8001dac:	08010652 	.word	0x08010652
 8001db0:	08010663 	.word	0x08010663

08001db4 <machine_bitstream_high_low.constprop.0>:
static void machine_bitstream_high_low(GPIO_TypeDef* GPIOx, uint32_t Pin, const uint8_t *buf, size_t len) {
 8001db4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t timing_ns[4] = {400, 850, 800, 450}; /* 800KHz */
 8001db8:	4b37      	ldr	r3, [pc, #220]	; (8001e98 <machine_bitstream_high_low.constprop.0+0xe4>)
 8001dba:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
static void machine_bitstream_high_low(GPIO_TypeDef* GPIOx, uint32_t Pin, const uint8_t *buf, size_t len) {
 8001dbc:	b085      	sub	sp, #20
    uint32_t timing_ns[4] = {400, 850, 800, 450}; /* 800KHz */
 8001dbe:	466c      	mov	r4, sp
 8001dc0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        timing_ns[i] = SystemCoreClock / 1000000 * timing_ns[i] / 1000;
 8001dc4:	4b35      	ldr	r3, [pc, #212]	; (8001e9c <machine_bitstream_high_low.constprop.0+0xe8>)
    for (size_t i = 0; i < 4; ++i) {
 8001dc6:	2200      	movs	r2, #0
        timing_ns[i] = SystemCoreClock / 1000000 * timing_ns[i] / 1000;
 8001dc8:	681d      	ldr	r5, [r3, #0]
 8001dca:	4b35      	ldr	r3, [pc, #212]	; (8001ea0 <machine_bitstream_high_low.constprop.0+0xec>)
 8001dcc:	fbb5 f5f3 	udiv	r5, r5, r3
 8001dd0:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
 8001dd4:	4623      	mov	r3, r4
        if (timing_ns[i] > NS_CYCLES_OVERHEAD) {
 8001dd6:	f641 3757 	movw	r7, #6999	; 0x1b57
        timing_ns[i] = SystemCoreClock / 1000000 * timing_ns[i] / 1000;
 8001dda:	f853 0b04 	ldr.w	r0, [r3], #4
 8001dde:	4368      	muls	r0, r5
        if (timing_ns[i] > NS_CYCLES_OVERHEAD) {
 8001de0:	42b8      	cmp	r0, r7
        timing_ns[i] = SystemCoreClock / 1000000 * timing_ns[i] / 1000;
 8001de2:	fbb0 f1f6 	udiv	r1, r0, r6
            timing_ns[i] -= NS_CYCLES_OVERHEAD;
 8001de6:	bf88      	it	hi
 8001de8:	3906      	subhi	r1, #6
 8001dea:	f843 1c04 	str.w	r1, [r3, #-4]
        if (i % 2 == 1) {
 8001dee:	07d1      	lsls	r1, r2, #31
            timing_ns[i] += timing_ns[i - 1];
 8001df0:	bf48      	it	mi
 8001df2:	e953 0102 	ldrdmi	r0, r1, [r3, #-8]
    for (size_t i = 0; i < 4; ++i) {
 8001df6:	f102 0201 	add.w	r2, r2, #1
            timing_ns[i] += timing_ns[i - 1];
 8001dfa:	bf44      	itt	mi
 8001dfc:	1809      	addmi	r1, r1, r0
 8001dfe:	f843 1c04 	strmi.w	r1, [r3, #-4]
    for (size_t i = 0; i < 4; ++i) {
 8001e02:	2a04      	cmp	r2, #4
 8001e04:	d1e9      	bne.n	8001dda <machine_bitstream_high_low.constprop.0+0x26>
    HAL_Delay(1);
 8001e06:	2001      	movs	r0, #1
 8001e08:	f7ff fb66 	bl	80014d8 <HAL_Delay>
    if (!(DWT->CTRL & DWT_CTRL_CYCCNTENA_Msk)) {
 8001e0c:	4b25      	ldr	r3, [pc, #148]	; (8001ea4 <machine_bitstream_high_low.constprop.0+0xf0>)
 8001e0e:	681a      	ldr	r2, [r3, #0]
 8001e10:	f012 0201 	ands.w	r2, r2, #1
 8001e14:	d109      	bne.n	8001e2a <machine_bitstream_high_low.constprop.0+0x76>
        CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001e16:	4824      	ldr	r0, [pc, #144]	; (8001ea8 <machine_bitstream_high_low.constprop.0+0xf4>)
 8001e18:	68c1      	ldr	r1, [r0, #12]
 8001e1a:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8001e1e:	60c1      	str	r1, [r0, #12]
        DWT->CYCCNT = 0;
 8001e20:	605a      	str	r2, [r3, #4]
        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001e22:	681a      	ldr	r2, [r3, #0]
 8001e24:	f042 0201 	orr.w	r2, r2, #1
 8001e28:	601a      	str	r2, [r3, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8001e2a:	f3ef 8e10 	mrs	lr, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8001e2e:	b672      	cpsid	i
            *bsrr = high_mask;
 8001e30:	4e1e      	ldr	r6, [pc, #120]	; (8001eac <machine_bitstream_high_low.constprop.0+0xf8>)
 8001e32:	4d1f      	ldr	r5, [pc, #124]	; (8001eb0 <machine_bitstream_high_low.constprop.0+0xfc>)
            DWT->CYCCNT = 0;
 8001e34:	491b      	ldr	r1, [pc, #108]	; (8001ea4 <machine_bitstream_high_low.constprop.0+0xf0>)
    for (size_t i = 0; i < len; ++i) {
 8001e36:	2200      	movs	r2, #0
            *bsrr = high_mask;
 8001e38:	f44f 5880 	mov.w	r8, #4096	; 0x1000
 8001e3c:	46b4      	mov	ip, r6
        uint8_t b = buf[i];
 8001e3e:	f815 3b01 	ldrb.w	r3, [r5], #1
 8001e42:	2008      	movs	r0, #8
            DWT->CYCCNT = 0;
 8001e44:	2700      	movs	r7, #0
            uint32_t *t = &timing_ns[b >> 6 & 2];
 8001e46:	ea4f 1a93 	mov.w	sl, r3, lsr #6
            DWT->CYCCNT = 0;
 8001e4a:	604f      	str	r7, [r1, #4]
            *bsrr = high_mask;
 8001e4c:	f00a 0a02 	and.w	sl, sl, #2
            while (DWT->CYCCNT < t[0]) {
 8001e50:	af04      	add	r7, sp, #16
            uint32_t *t = &timing_ns[b >> 6 & 2];
 8001e52:	eb04 098a 	add.w	r9, r4, sl, lsl #2
            while (DWT->CYCCNT < t[0]) {
 8001e56:	eb07 0a8a 	add.w	sl, r7, sl, lsl #2
            *bsrr = high_mask;
 8001e5a:	f8c6 8018 	str.w	r8, [r6, #24]
            while (DWT->CYCCNT < t[0]) {
 8001e5e:	f85a ac10 	ldr.w	sl, [sl, #-16]
 8001e62:	4f10      	ldr	r7, [pc, #64]	; (8001ea4 <machine_bitstream_high_low.constprop.0+0xf0>)
 8001e64:	f8d7 b004 	ldr.w	fp, [r7, #4]
 8001e68:	45d3      	cmp	fp, sl
 8001e6a:	d3fa      	bcc.n	8001e62 <machine_bitstream_high_low.constprop.0+0xae>
            *bsrr = low_mask;
 8001e6c:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
 8001e70:	f8cc 7018 	str.w	r7, [ip, #24]
            b <<= 1;
 8001e74:	005b      	lsls	r3, r3, #1
            while (DWT->CYCCNT < t[1]) {
 8001e76:	f8d9 9004 	ldr.w	r9, [r9, #4]
            b <<= 1;
 8001e7a:	b2db      	uxtb	r3, r3
            while (DWT->CYCCNT < t[1]) {
 8001e7c:	f8d1 a004 	ldr.w	sl, [r1, #4]
 8001e80:	45ca      	cmp	sl, r9
 8001e82:	d3fb      	bcc.n	8001e7c <machine_bitstream_high_low.constprop.0+0xc8>
        for (size_t j = 0; j < 8; ++j) {
 8001e84:	3801      	subs	r0, #1
 8001e86:	d1dd      	bne.n	8001e44 <machine_bitstream_high_low.constprop.0+0x90>
    for (size_t i = 0; i < len; ++i) {
 8001e88:	3201      	adds	r2, #1
 8001e8a:	2a24      	cmp	r2, #36	; 0x24
 8001e8c:	d1d7      	bne.n	8001e3e <machine_bitstream_high_low.constprop.0+0x8a>
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8001e8e:	f38e 8810 	msr	PRIMASK, lr
}
 8001e92:	b005      	add	sp, #20
 8001e94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001e98:	08010358 	.word	0x08010358
 8001e9c:	20000050 	.word	0x20000050
 8001ea0:	000f4240 	.word	0x000f4240
 8001ea4:	e0001000 	.word	0xe0001000
 8001ea8:	e000edf0 	.word	0xe000edf0
 8001eac:	48000400 	.word	0x48000400
 8001eb0:	200002f0 	.word	0x200002f0

08001eb4 <neopixel_fill>:
void neopixel_fill(uint8_t buff[][3], uint8_t cnt, uint8_t r,uint8_t g,uint8_t b){
 8001eb4:	b570      	push	{r4, r5, r6, lr}
 8001eb6:	f89d 6010 	ldrb.w	r6, [sp, #16]
	  for(j=0; j<cnt; j++){
 8001eba:	2400      	movs	r4, #0
 8001ebc:	b2e5      	uxtb	r5, r4
 8001ebe:	42a9      	cmp	r1, r5
 8001ec0:	f100 0003 	add.w	r0, r0, #3
 8001ec4:	d800      	bhi.n	8001ec8 <neopixel_fill+0x14>
}
 8001ec6:	bd70      	pop	{r4, r5, r6, pc}
		  buff[j][0] = g;
 8001ec8:	f800 3c03 	strb.w	r3, [r0, #-3]
		  buff[j][1] = r;
 8001ecc:	f800 2c02 	strb.w	r2, [r0, #-2]
		  buff[j][2] = b;
 8001ed0:	f800 6c01 	strb.w	r6, [r0, #-1]
	  for(j=0; j<cnt; j++){
 8001ed4:	3401      	adds	r4, #1
 8001ed6:	e7f1      	b.n	8001ebc <neopixel_fill+0x8>

08001ed8 <OnSensorTimerEvent>:
{
 8001ed8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  EnvSensors_Read(&SensorData);
 8001eda:	4c2e      	ldr	r4, [pc, #184]	; (8001f94 <OnSensorTimerEvent+0xbc>)
  BSP_I2C2_Init();
 8001edc:	f7ff f992 	bl	8001204 <BSP_I2C2_Init>
  EnvSensors_Read(&SensorData);
 8001ee0:	4620      	mov	r0, r4
 8001ee2:	f7ff fb1f 	bl	8001524 <EnvSensors_Read>
  temperature = (int8_t)SensorData.temperature;
 8001ee6:	6860      	ldr	r0, [r4, #4]
 8001ee8:	f7fe fd1c 	bl	8000924 <__aeabi_f2iz>
 8001eec:	b245      	sxtb	r5, r0
  humidity    = (uint8_t)SensorData.humidity;
 8001eee:	68a0      	ldr	r0, [r4, #8]
 8001ef0:	f7fe fd3e 	bl	8000970 <__aeabi_f2uiz>
 8001ef4:	b2c6      	uxtb	r6, r0
  co2         = (int16_t)SensorData.co2;
 8001ef6:	68e0      	ldr	r0, [r4, #12]
 8001ef8:	f7fe fd14 	bl	8000924 <__aeabi_f2iz>
  rgb_lcd_setCursor(0,0);
 8001efc:	2100      	movs	r1, #0
  co2         = (int16_t)SensorData.co2;
 8001efe:	b284      	uxth	r4, r0
  rgb_lcd_setCursor(0,0);
 8001f00:	4608      	mov	r0, r1
 8001f02:	f000 f9e4 	bl	80022ce <rgb_lcd_setCursor>
  rgb_lcd_print("CO2 %3d ppm", co2);
 8001f06:	4621      	mov	r1, r4
 8001f08:	4823      	ldr	r0, [pc, #140]	; (8001f98 <OnSensorTimerEvent+0xc0>)
 8001f0a:	f000 fa67 	bl	80023dc <rgb_lcd_print>
  rgb_lcd_setCursor(0,1);
 8001f0e:	2101      	movs	r1, #1
 8001f10:	2000      	movs	r0, #0
 8001f12:	f000 f9dc 	bl	80022ce <rgb_lcd_setCursor>
  rgb_lcd_print("T\2%2d\2C - H %2d%c ", temperature, humidity,'%');
 8001f16:	2325      	movs	r3, #37	; 0x25
 8001f18:	4632      	mov	r2, r6
 8001f1a:	4820      	ldr	r0, [pc, #128]	; (8001f9c <OnSensorTimerEvent+0xc4>)
 8001f1c:	4629      	mov	r1, r5
 8001f1e:	f000 fa5d 	bl	80023dc <rgb_lcd_print>
  if((co2>800)&&(co2<1000))
 8001f22:	f46f 7348 	mvn.w	r3, #800	; 0x320
 8001f26:	18e3      	adds	r3, r4, r3
 8001f28:	2200      	movs	r2, #0
 8001f2a:	2bc6      	cmp	r3, #198	; 0xc6
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,PIXEL_MAX_VALUE,PIXEL_MAX_VALUE/2,0);
 8001f2c:	9200      	str	r2, [sp, #0]
  if((co2>800)&&(co2<1000))
 8001f2e:	d82a      	bhi.n	8001f86 <OnSensorTimerEvent+0xae>
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,PIXEL_MAX_VALUE,PIXEL_MAX_VALUE/2,0);
 8001f30:	237f      	movs	r3, #127	; 0x7f
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,PIXEL_MAX_VALUE,0,0);
 8001f32:	22fe      	movs	r2, #254	; 0xfe
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,0,PIXEL_MAX_VALUE,0);
 8001f34:	481a      	ldr	r0, [pc, #104]	; (8001fa0 <OnSensorTimerEvent+0xc8>)
 8001f36:	210c      	movs	r1, #12
 8001f38:	f7ff ffbc 	bl	8001eb4 <neopixel_fill>
  machine_bitstream_high_low(PIXEL_PORT,PIXEL_PIN,neopixel_buf,sizeof(neopixel_buf));
 8001f3c:	f7ff ff3a 	bl	8001db4 <machine_bitstream_high_low.constprop.0>
  APP_LOG(TS_ON, VLEVEL_M, "temp= %d\n", temperature);
 8001f40:	4b18      	ldr	r3, [pc, #96]	; (8001fa4 <OnSensorTimerEvent+0xcc>)
 8001f42:	9500      	str	r5, [sp, #0]
 8001f44:	2201      	movs	r2, #1
 8001f46:	2100      	movs	r1, #0
 8001f48:	2002      	movs	r0, #2
 8001f4a:	f00c ffdd 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "humidity= %d\n", humidity);
 8001f4e:	4b16      	ldr	r3, [pc, #88]	; (8001fa8 <OnSensorTimerEvent+0xd0>)
 8001f50:	9600      	str	r6, [sp, #0]
 8001f52:	2201      	movs	r2, #1
 8001f54:	2100      	movs	r1, #0
 8001f56:	2002      	movs	r0, #2
 8001f58:	f00c ffd6 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "co2= %d\n", co2);
 8001f5c:	4b13      	ldr	r3, [pc, #76]	; (8001fac <OnSensorTimerEvent+0xd4>)
 8001f5e:	9400      	str	r4, [sp, #0]
 8001f60:	2201      	movs	r2, #1
 8001f62:	2100      	movs	r1, #0
 8001f64:	2002      	movs	r0, #2
 8001f66:	f00c ffcf 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "@Graph:CO2:%d|T:%d|Hum:%d|\r", co2, temperature, humidity);
 8001f6a:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8001f6e:	4b10      	ldr	r3, [pc, #64]	; (8001fb0 <OnSensorTimerEvent+0xd8>)
 8001f70:	9400      	str	r4, [sp, #0]
 8001f72:	2201      	movs	r2, #1
 8001f74:	2100      	movs	r1, #0
 8001f76:	2002      	movs	r0, #2
 8001f78:	f00c ffc6 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 8001f7c:	b004      	add	sp, #16
 8001f7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  BSP_I2C2_DeInit();
 8001f82:	f7ff b8c7 	b.w	8001114 <BSP_I2C2_DeInit>
  else if(co2>1000)
 8001f86:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
 8001f8a:	d901      	bls.n	8001f90 <OnSensorTimerEvent+0xb8>
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,PIXEL_MAX_VALUE,0,0);
 8001f8c:	4613      	mov	r3, r2
 8001f8e:	e7d0      	b.n	8001f32 <OnSensorTimerEvent+0x5a>
	  neopixel_fill(neopixel_buf,PIXEL_COUNT,0,PIXEL_MAX_VALUE,0);
 8001f90:	23fe      	movs	r3, #254	; 0xfe
 8001f92:	e7cf      	b.n	8001f34 <OnSensorTimerEvent+0x5c>
 8001f94:	2000028c 	.word	0x2000028c
 8001f98:	08010671 	.word	0x08010671
 8001f9c:	0801067d 	.word	0x0801067d
 8001fa0:	200002f0 	.word	0x200002f0
 8001fa4:	080105a7 	.word	0x080105a7
 8001fa8:	08010690 	.word	0x08010690
 8001fac:	0801069e 	.word	0x0801069e
 8001fb0:	080106a7 	.word	0x080106a7

08001fb4 <LoRaWAN_Init>:
{
 8001fb4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001fb8:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef  gpio_init_structure = {0};
 8001fba:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001fbc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8001fc0:	940b      	str	r4, [sp, #44]	; 0x2c
 8001fc2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(PIXEL_PORT, &gpio_init_structure);
 8001fc4:	4875      	ldr	r0, [pc, #468]	; (800219c <LoRaWAN_Init+0x1e8>)
	  neopixel_fill(neopixel_buf, PIXEL_COUNT, (j==0)?PIXEL_MAX_VALUE:0,(j==2)?PIXEL_MAX_VALUE:0,(j==1)?PIXEL_MAX_VALUE:0);
 8001fc6:	4f76      	ldr	r7, [pc, #472]	; (80021a0 <LoRaWAN_Init+0x1ec>)
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 8001fc8:	f8df 9218 	ldr.w	r9, [pc, #536]	; 80021e4 <LoRaWAN_Init+0x230>
 8001fcc:	f042 0202 	orr.w	r2, r2, #2
 8001fd0:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001fd2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull = GPIO_NOPULL;
 8001fd4:	9409      	str	r4, [sp, #36]	; 0x24
 8001fd6:	f003 0302 	and.w	r3, r3, #2
 8001fda:	9304      	str	r3, [sp, #16]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
 8001fdc:	2501      	movs	r5, #1
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8001fde:	2602      	movs	r6, #2
  HAL_GPIO_Init(PIXEL_PORT, &gpio_init_structure);
 8001fe0:	a907      	add	r1, sp, #28
  (void)tmpreg;
 8001fe2:	9b04      	ldr	r3, [sp, #16]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8001fe4:	960a      	str	r6, [sp, #40]	; 0x28
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
 8001fe6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001fea:	e9cd 3507 	strd	r3, r5, [sp, #28]
  HAL_GPIO_Init(PIXEL_PORT, &gpio_init_structure);
 8001fee:	f001 fb75 	bl	80036dc <HAL_GPIO_Init>
  BSP_LED_Init(LED_BLUE);
 8001ff2:	4620      	mov	r0, r4
 8001ff4:	f000 fb52 	bl	800269c <BSP_LED_Init>
  BSP_LED_Init(LED_GREEN);
 8001ff8:	4628      	mov	r0, r5
 8001ffa:	f000 fb4f 	bl	800269c <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 8001ffe:	4630      	mov	r0, r6
 8002000:	f000 fb4c 	bl	800269c <BSP_LED_Init>
  BSP_PB_Init(BUTTON_SW2, BUTTON_MODE_EXTI);
 8002004:	4629      	mov	r1, r5
 8002006:	4628      	mov	r0, r5
 8002008:	f000 fb90 	bl	800272c <BSP_PB_Init>
  machine_bitstream_high_low(PIXEL_PORT,PIXEL_PIN,neopixel_buf,sizeof(neopixel_buf));
 800200c:	f7ff fed2 	bl	8001db4 <machine_bitstream_high_low.constprop.0>
	  neopixel_fill(neopixel_buf, PIXEL_COUNT, (j==0)?PIXEL_MAX_VALUE:0,(j==2)?PIXEL_MAX_VALUE:0,(j==1)?PIXEL_MAX_VALUE:0);
 8002010:	4623      	mov	r3, r4
 8002012:	22fe      	movs	r2, #254	; 0xfe
 8002014:	210c      	movs	r1, #12
 8002016:	4638      	mov	r0, r7
 8002018:	9400      	str	r4, [sp, #0]
 800201a:	f7ff ff4b 	bl	8001eb4 <neopixel_fill>
 800201e:	f04f 08fe 	mov.w	r8, #254	; 0xfe
	  HAL_Delay(500);
 8002022:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002026:	f7ff fa57 	bl	80014d8 <HAL_Delay>
	  machine_bitstream_high_low(PIXEL_PORT,PIXEL_PIN,neopixel_buf,sizeof(neopixel_buf));
 800202a:	f7ff fec3 	bl	8001db4 <machine_bitstream_high_low.constprop.0>
	  neopixel_fill(neopixel_buf, PIXEL_COUNT, (j==0)?PIXEL_MAX_VALUE:0,(j==2)?PIXEL_MAX_VALUE:0,(j==1)?PIXEL_MAX_VALUE:0);
 800202e:	4623      	mov	r3, r4
 8002030:	4622      	mov	r2, r4
 8002032:	210c      	movs	r1, #12
 8002034:	f8cd 8000 	str.w	r8, [sp]
 8002038:	4638      	mov	r0, r7
 800203a:	f7ff ff3b 	bl	8001eb4 <neopixel_fill>
	  HAL_Delay(500);
 800203e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002042:	f7ff fa49 	bl	80014d8 <HAL_Delay>
	  machine_bitstream_high_low(PIXEL_PORT,PIXEL_PIN,neopixel_buf,sizeof(neopixel_buf));
 8002046:	f7ff feb5 	bl	8001db4 <machine_bitstream_high_low.constprop.0>
	  neopixel_fill(neopixel_buf, PIXEL_COUNT, (j==0)?PIXEL_MAX_VALUE:0,(j==2)?PIXEL_MAX_VALUE:0,(j==1)?PIXEL_MAX_VALUE:0);
 800204a:	4643      	mov	r3, r8
 800204c:	4622      	mov	r2, r4
 800204e:	210c      	movs	r1, #12
 8002050:	4638      	mov	r0, r7
 8002052:	9400      	str	r4, [sp, #0]
 8002054:	f7ff ff2e 	bl	8001eb4 <neopixel_fill>
	  HAL_Delay(500);
 8002058:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800205c:	f7ff fa3c 	bl	80014d8 <HAL_Delay>
	  machine_bitstream_high_low(PIXEL_PORT,PIXEL_PIN,neopixel_buf,sizeof(neopixel_buf));
 8002060:	f7ff fea8 	bl	8001db4 <machine_bitstream_high_low.constprop.0>
  APP_LOG(TS_OFF, VLEVEL_M, "APP_VERSION:        V%X.%X.%X\r\n",
 8002064:	4622      	mov	r2, r4
 8002066:	4621      	mov	r1, r4
 8002068:	e9cd 5401 	strd	r5, r4, [sp, #4]
 800206c:	4b4d      	ldr	r3, [pc, #308]	; (80021a4 <LoRaWAN_Init+0x1f0>)
 800206e:	9500      	str	r5, [sp, #0]
 8002070:	4630      	mov	r0, r6
 8002072:	f00c ff49 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_OFF, VLEVEL_M, "MW_LORAWAN_VERSION: V%X.%X.%X\r\n",
 8002076:	2303      	movs	r3, #3
 8002078:	e9cd 6300 	strd	r6, r3, [sp]
 800207c:	4622      	mov	r2, r4
 800207e:	4621      	mov	r1, r4
 8002080:	4b49      	ldr	r3, [pc, #292]	; (80021a8 <LoRaWAN_Init+0x1f4>)
 8002082:	9402      	str	r4, [sp, #8]
 8002084:	4630      	mov	r0, r6
 8002086:	f00c ff3f 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 800208a:	f8df 815c 	ldr.w	r8, [pc, #348]	; 80021e8 <LoRaWAN_Init+0x234>
  APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\r\n",
 800208e:	4b47      	ldr	r3, [pc, #284]	; (80021ac <LoRaWAN_Init+0x1f8>)
 8002090:	9500      	str	r5, [sp, #0]
 8002092:	4622      	mov	r2, r4
 8002094:	4621      	mov	r1, r4
 8002096:	e9cd 5401 	strd	r5, r4, [sp, #4]
 800209a:	4630      	mov	r0, r6
 800209c:	f00c ff34 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
  UTIL_TIMER_Create(&SensorsTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnSensorTimerEvent, NULL);
 80020a0:	4f43      	ldr	r7, [pc, #268]	; (80021b0 <LoRaWAN_Init+0x1fc>)
  UTIL_TIMER_Create(&TxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerLedEvent, NULL);
 80020a2:	4b44      	ldr	r3, [pc, #272]	; (80021b4 <LoRaWAN_Init+0x200>)
 80020a4:	9400      	str	r4, [sp, #0]
 80020a6:	4622      	mov	r2, r4
 80020a8:	f04f 31ff 	mov.w	r1, #4294967295
 80020ac:	4648      	mov	r0, r9
 80020ae:	f00d fa09 	bl	800f4c4 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&RxLedTimer, 0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnRxTimerLedEvent, NULL);
 80020b2:	4622      	mov	r2, r4
 80020b4:	4b40      	ldr	r3, [pc, #256]	; (80021b8 <LoRaWAN_Init+0x204>)
 80020b6:	9400      	str	r4, [sp, #0]
 80020b8:	f04f 31ff 	mov.w	r1, #4294967295
 80020bc:	4640      	mov	r0, r8
 80020be:	f00d fa01 	bl	800f4c4 <UTIL_TIMER_Create>
  UTIL_TIMER_Create(&SensorsTimer, 0xFFFFFFFFU, UTIL_TIMER_PERIODIC, OnSensorTimerEvent, NULL);
 80020c2:	4b3e      	ldr	r3, [pc, #248]	; (80021bc <LoRaWAN_Init+0x208>)
 80020c4:	9400      	str	r4, [sp, #0]
 80020c6:	462a      	mov	r2, r5
 80020c8:	f04f 31ff 	mov.w	r1, #4294967295
 80020cc:	4638      	mov	r0, r7
 80020ce:	f00d f9f9 	bl	800f4c4 <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxLedTimer, 500);
 80020d2:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80020d6:	4648      	mov	r0, r9
 80020d8:	f00d fadc 	bl	800f694 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&RxLedTimer, 500);
 80020dc:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80020e0:	4640      	mov	r0, r8
 80020e2:	f00d fad7 	bl	800f694 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_SetPeriod(&SensorsTimer, APP_SENSOR_CYCLE);
 80020e6:	f242 7110 	movw	r1, #10000	; 0x2710
 80020ea:	4638      	mov	r0, r7
 80020ec:	f00d fad2 	bl	800f694 <UTIL_TIMER_SetPeriod>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 80020f0:	4621      	mov	r1, r4
 80020f2:	4628      	mov	r0, r5
 80020f4:	4a32      	ldr	r2, [pc, #200]	; (80021c0 <LoRaWAN_Init+0x20c>)
 80020f6:	f00d f8e5 	bl	800f2c4 <UTIL_SEQ_RegTask>
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), UTIL_SEQ_RFU, SendTxData);
 80020fa:	4621      	mov	r1, r4
 80020fc:	4a31      	ldr	r2, [pc, #196]	; (80021c4 <LoRaWAN_Init+0x210>)
 80020fe:	4630      	mov	r0, r6
 8002100:	f00d f8e0 	bl	800f2c4 <UTIL_SEQ_RegTask>
  LoraInfo_Init();
 8002104:	f000 f87a 	bl	80021fc <LoraInfo_Init>
  LmHandlerInit(&LmHandlerCallbacks);
 8002108:	482f      	ldr	r0, [pc, #188]	; (80021c8 <LoRaWAN_Init+0x214>)
 800210a:	f004 fde3 	bl	8006cd4 <LmHandlerInit>
  LmHandlerConfigure(&LmHandlerParams);
 800210e:	482f      	ldr	r0, [pc, #188]	; (80021cc <LoRaWAN_Init+0x218>)
 8002110:	f004 fa90 	bl	8006634 <LmHandlerConfigure>
  UTIL_TIMER_Start(&SensorsTimer);
 8002114:	4638      	mov	r0, r7
 8002116:	f00d fa83 	bl	800f620 <UTIL_TIMER_Start>
  LmHandlerJoin(ActivationType);
 800211a:	4630      	mov	r0, r6
  UTIL_TIMER_Create(&TxTimer,  0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerEvent, NULL);
 800211c:	4e2c      	ldr	r6, [pc, #176]	; (80021d0 <LoRaWAN_Init+0x21c>)
  LmHandlerJoin(ActivationType);
 800211e:	f004 fbed 	bl	80068fc <LmHandlerJoin>
  UTIL_TIMER_Create(&TxTimer,  0xFFFFFFFFU, UTIL_TIMER_ONESHOT, OnTxTimerEvent, NULL);
 8002122:	4622      	mov	r2, r4
 8002124:	4b2b      	ldr	r3, [pc, #172]	; (80021d4 <LoRaWAN_Init+0x220>)
 8002126:	9400      	str	r4, [sp, #0]
 8002128:	f04f 31ff 	mov.w	r1, #4294967295
 800212c:	4630      	mov	r0, r6
 800212e:	f00d f9c9 	bl	800f4c4 <UTIL_TIMER_Create>
  UTIL_TIMER_SetPeriod(&TxTimer,  APP_TX_DUTYCYCLE);
 8002132:	4929      	ldr	r1, [pc, #164]	; (80021d8 <LoRaWAN_Init+0x224>)
 8002134:	4630      	mov	r0, r6
 8002136:	f00d faad 	bl	800f694 <UTIL_TIMER_SetPeriod>
  UTIL_TIMER_Start(&TxTimer);
 800213a:	4630      	mov	r0, r6
 800213c:	f00d fa70 	bl	800f620 <UTIL_TIMER_Start>
  BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
 8002140:	4629      	mov	r1, r5
 8002142:	4620      	mov	r0, r4
 8002144:	f000 faf2 	bl	800272c <BSP_PB_Init>
  LmHandlerGetDevEUI(devEUI);
 8002148:	a805      	add	r0, sp, #20
 800214a:	f004 fdf5 	bl	8006d38 <LmHandlerGetDevEUI>
  BSP_I2C2_Init();
 800214e:	f7ff f859 	bl	8001204 <BSP_I2C2_Init>
  rgb_lcd_setCursor(0,0);
 8002152:	4621      	mov	r1, r4
 8002154:	4620      	mov	r0, r4
 8002156:	f000 f8ba 	bl	80022ce <rgb_lcd_setCursor>
  rgb_lcd_print("EUI %02X:%02X:%02X:%02X", HEX4(devEUI,0));
 800215a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 800215e:	f89d 2015 	ldrb.w	r2, [sp, #21]
 8002162:	f89d 1014 	ldrb.w	r1, [sp, #20]
 8002166:	9300      	str	r3, [sp, #0]
 8002168:	481c      	ldr	r0, [pc, #112]	; (80021dc <LoRaWAN_Init+0x228>)
 800216a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 800216e:	f000 f935 	bl	80023dc <rgb_lcd_print>
  rgb_lcd_setCursor(0,1);
 8002172:	4629      	mov	r1, r5
 8002174:	4620      	mov	r0, r4
 8002176:	f000 f8aa 	bl	80022ce <rgb_lcd_setCursor>
  rgb_lcd_print("    %02X:%02X:%02X:%02X", HEX4(devEUI,4));
 800217a:	f89d 301b 	ldrb.w	r3, [sp, #27]
 800217e:	f89d 2019 	ldrb.w	r2, [sp, #25]
 8002182:	f89d 1018 	ldrb.w	r1, [sp, #24]
 8002186:	9300      	str	r3, [sp, #0]
 8002188:	4815      	ldr	r0, [pc, #84]	; (80021e0 <LoRaWAN_Init+0x22c>)
 800218a:	f89d 301a 	ldrb.w	r3, [sp, #26]
 800218e:	f000 f925 	bl	80023dc <rgb_lcd_print>
  BSP_I2C2_DeInit();
 8002192:	f7fe ffbf 	bl	8001114 <BSP_I2C2_DeInit>
}
 8002196:	b00d      	add	sp, #52	; 0x34
 8002198:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800219c:	48000400 	.word	0x48000400
 80021a0:	200002f0 	.word	0x200002f0
 80021a4:	080106c3 	.word	0x080106c3
 80021a8:	080106e3 	.word	0x080106e3
 80021ac:	08010703 	.word	0x08010703
 80021b0:	200002a8 	.word	0x200002a8
 80021b4:	08001c21 	.word	0x08001c21
 80021b8:	08001b99 	.word	0x08001b99
 80021bc:	08001ed9 	.word	0x08001ed9
 80021c0:	080067dd 	.word	0x080067dd
 80021c4:	08001c45 	.word	0x08001c45
 80021c8:	20000008 	.word	0x20000008
 80021cc:	2000003c 	.word	0x2000003c
 80021d0:	200002d8 	.word	0x200002d8
 80021d4:	08001a95 	.word	0x08001a95
 80021d8:	0001d4c0 	.word	0x0001d4c0
 80021dc:	08010723 	.word	0x08010723
 80021e0:	0801073b 	.word	0x0801073b
 80021e4:	200002c0 	.word	0x200002c0
 80021e8:	20000274 	.word	0x20000274

080021ec <HAL_GPIO_EXTI_Callback>:
  switch (GPIO_Pin)
 80021ec:	2801      	cmp	r0, #1
 80021ee:	d103      	bne.n	80021f8 <HAL_GPIO_EXTI_Callback+0xc>
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LoRaSendOnTxTimerOrButtonEvent), CFG_SEQ_Prio_0);
 80021f0:	2100      	movs	r1, #0
 80021f2:	2002      	movs	r0, #2
 80021f4:	f00c bfa4 	b.w	800f140 <UTIL_SEQ_SetTask>
}
 80021f8:	4770      	bx	lr
	...

080021fc <LoraInfo_Init>:
/* Exported functions --------------------------------------------------------*/
void LoraInfo_Init(void)
{
  loraInfo.ActivationMode = 0;
  loraInfo.Region = 0;
  loraInfo.ClassB = 0;
 80021fc:	4b04      	ldr	r3, [pc, #16]	; (8002210 <LoraInfo_Init+0x14>)
 80021fe:	2200      	movs	r2, #0
  loraInfo.Kms = 0;
 8002200:	e9c3 2202 	strd	r2, r2, [r3, #8]
#error LORAMAC_CLASSB_ENABLED not defined ( shall be <0 or 1> )
#endif /* LORAMAC_CLASSB_ENABLED */

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
  loraInfo.Kms = 0;
  loraInfo.ActivationMode = 3;
 8002204:	f44f 7190 	mov.w	r1, #288	; 0x120
 8002208:	2203      	movs	r2, #3
 800220a:	e9c3 2100 	strd	r2, r1, [r3]
  loraInfo.ActivationMode = ACTIVATION_BY_PERSONALIZATION + (OVER_THE_AIR_ACTIVATION << 1);
#endif /* LORAWAN_KMS */
  /* USER CODE BEGIN LoraInfo_Init_2 */

  /* USER CODE END LoraInfo_Init_2 */
}
 800220e:	4770      	bx	lr
 8002210:	20000314 	.word	0x20000314

08002214 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 8002214:	4800      	ldr	r0, [pc, #0]	; (8002218 <LoraInfo_GetPtr+0x4>)
 8002216:	4770      	bx	lr
 8002218:	20000314 	.word	0x20000314

0800221c <RBI_Init>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_Init();
 800221c:	f000 baec 	b.w	80027f8 <BSP_RADIO_Init>

08002220 <RBI_ConfigRFSwitch>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 8002220:	f000 bb2a 	b.w	8002878 <BSP_RADIO_ConfigRFSwitch>

08002224 <RBI_GetTxConfig>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_GetTxConfig();
 8002224:	f000 bb5c 	b.w	80028e0 <BSP_RADIO_GetTxConfig>

08002228 <RBI_IsTCXO>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsTCXO();
 8002228:	f000 bb5c 	b.w	80028e4 <BSP_RADIO_IsTCXO>

0800222c <RBI_IsDCDC>:
   *       or at https://github.com/STMicroelectronics/STM32CubeWL/tree/main/Drivers/BSP/STM32WLxx_Nucleo/
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration */
  return BSP_RADIO_IsDCDC();
 800222c:	f000 bb5c 	b.w	80028e8 <BSP_RADIO_IsDCDC>

08002230 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8002230:	480d      	ldr	r0, [pc, #52]	; (8002268 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8002232:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8002234:	f000 fb5a 	bl	80028ec <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8002238:	480c      	ldr	r0, [pc, #48]	; (800226c <LoopForever+0x6>)
  ldr r1, =_edata
 800223a:	490d      	ldr	r1, [pc, #52]	; (8002270 <LoopForever+0xa>)
  ldr r2, =_sidata
 800223c:	4a0d      	ldr	r2, [pc, #52]	; (8002274 <LoopForever+0xe>)
  movs r3, #0
 800223e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8002240:	e002      	b.n	8002248 <LoopCopyDataInit>

08002242 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8002242:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8002244:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8002246:	3304      	adds	r3, #4

08002248 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8002248:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800224a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800224c:	d3f9      	bcc.n	8002242 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800224e:	4a0a      	ldr	r2, [pc, #40]	; (8002278 <LoopForever+0x12>)
  ldr r4, =_ebss
 8002250:	4c0a      	ldr	r4, [pc, #40]	; (800227c <LoopForever+0x16>)
  movs r3, #0
 8002252:	2300      	movs	r3, #0
  b LoopFillZerobss
 8002254:	e001      	b.n	800225a <LoopFillZerobss>

08002256 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8002256:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8002258:	3204      	adds	r2, #4

0800225a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800225a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800225c:	d3fb      	bcc.n	8002256 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 800225e:	f00d fb95 	bl	800f98c <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8002262:	f7fe fe67 	bl	8000f34 <main>

08002266 <LoopForever>:

LoopForever:
    b LoopForever
 8002266:	e7fe      	b.n	8002266 <LoopForever>
  ldr   r0, =_estack
 8002268:	20008000 	.word	0x20008000
  ldr r0, =_sdata
 800226c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8002270:	20000140 	.word	0x20000140
  ldr r2, =_sidata
 8002274:	080111bc 	.word	0x080111bc
  ldr r2, =_sbss
 8002278:	20000140 	.word	0x20000140
  ldr r4, =_ebss
 800227c:	20001b8c 	.word	0x20001b8c

08002280 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8002280:	e7fe      	b.n	8002280 <ADC_IRQHandler>

08002282 <rgb_lcd_command>:
void rgb_lcd_setColorWhite(void) {
	rgb_lcd_setRGB(255, 255, 255);
}

// send command
int32_t rgb_lcd_command(uint8_t value) {
 8002282:	b507      	push	{r0, r1, r2, lr}
    unsigned char dta[2] = {0x80, value};
 8002284:	2380      	movs	r3, #128	; 0x80
 8002286:	f88d 0005 	strb.w	r0, [sp, #5]
    return i2c_send_byteS(dta, 2);
 800228a:	2102      	movs	r1, #2
 800228c:	a801      	add	r0, sp, #4
    unsigned char dta[2] = {0x80, value};
 800228e:	f88d 3004 	strb.w	r3, [sp, #4]
    return i2c_send_byteS(dta, 2);
 8002292:	f7ff f84d 	bl	8001330 <i2c_send_byteS>
}
 8002296:	b003      	add	sp, #12
 8002298:	f85d fb04 	ldr.w	pc, [sp], #4

0800229c <rgb_lcd_write>:

// send data
size_t rgb_lcd_write(uint8_t value) {
 800229c:	b507      	push	{r0, r1, r2, lr}
    unsigned char dta[2] = {0x40, value};
 800229e:	2340      	movs	r3, #64	; 0x40
 80022a0:	f88d 0005 	strb.w	r0, [sp, #5]
    return(i2c_send_byteS(dta, 2)==0);
 80022a4:	2102      	movs	r1, #2
 80022a6:	a801      	add	r0, sp, #4
    unsigned char dta[2] = {0x40, value};
 80022a8:	f88d 3004 	strb.w	r3, [sp, #4]
    return(i2c_send_byteS(dta, 2)==0);
 80022ac:	f7ff f840 	bl	8001330 <i2c_send_byteS>
}
 80022b0:	fab0 f080 	clz	r0, r0
 80022b4:	0940      	lsrs	r0, r0, #5
 80022b6:	b003      	add	sp, #12
 80022b8:	f85d fb04 	ldr.w	pc, [sp], #4

080022bc <rgb_lcd_clear>:
    return ret;

}

/********** high level commands, for the user! */
void rgb_lcd_clear() {
 80022bc:	b508      	push	{r3, lr}
    rgb_lcd_command(LCD_CLEARDISPLAY);        // clear display, set cursor position to zero
 80022be:	2001      	movs	r0, #1
 80022c0:	f7ff ffdf 	bl	8002282 <rgb_lcd_command>
    delayMicroseconds(2000);          // this command takes a long time!
}
 80022c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    delayMicroseconds(2000);          // this command takes a long time!
 80022c8:	2003      	movs	r0, #3
 80022ca:	f7ff b905 	b.w	80014d8 <HAL_Delay>

080022ce <rgb_lcd_setCursor>:
void rgb_lcd_home() {
    rgb_lcd_command(LCD_RETURNHOME);        // set cursor position to zero
    delayMicroseconds(2000);        // this command takes a long time!
}

void rgb_lcd_setCursor(uint8_t col, uint8_t row) {
 80022ce:	b507      	push	{r0, r1, r2, lr}

    col = (row == 0 ? col | 0x80 : col | 0xc0);
 80022d0:	b969      	cbnz	r1, 80022ee <rgb_lcd_setCursor+0x20>
 80022d2:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    unsigned char dta[2] = {0x80, col};
 80022d6:	2380      	movs	r3, #128	; 0x80
 80022d8:	f88d 0005 	strb.w	r0, [sp, #5]

    i2c_send_byteS(dta, 2);
 80022dc:	2102      	movs	r1, #2
 80022de:	a801      	add	r0, sp, #4
    unsigned char dta[2] = {0x80, col};
 80022e0:	f88d 3004 	strb.w	r3, [sp, #4]
    i2c_send_byteS(dta, 2);
 80022e4:	f7ff f824 	bl	8001330 <i2c_send_byteS>

}
 80022e8:	b003      	add	sp, #12
 80022ea:	f85d fb04 	ldr.w	pc, [sp], #4
    col = (row == 0 ? col | 0x80 : col | 0xc0);
 80022ee:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
 80022f2:	e7f0      	b.n	80022d6 <rgb_lcd_setCursor+0x8>

080022f4 <rgb_lcd_display>:
    _displaycontrol &= ~LCD_DISPLAYON;
    rgb_lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
}

void rgb_lcd_display() {
    _displaycontrol |= LCD_DISPLAYON;
 80022f4:	4b04      	ldr	r3, [pc, #16]	; (8002308 <rgb_lcd_display+0x14>)
 80022f6:	7818      	ldrb	r0, [r3, #0]
 80022f8:	f040 0204 	orr.w	r2, r0, #4
    rgb_lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
 80022fc:	f040 000c 	orr.w	r0, r0, #12
    _displaycontrol |= LCD_DISPLAYON;
 8002300:	701a      	strb	r2, [r3, #0]
    rgb_lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
 8002302:	f7ff bfbe 	b.w	8002282 <rgb_lcd_command>
 8002306:	bf00      	nop
 8002308:	20000324 	.word	0x20000324

0800230c <rgb_lcd_begin>:
    if (lines > 1) {
 800230c:	2901      	cmp	r1, #1
uint32_t rgb_lcd_begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
 800230e:	b510      	push	{r4, lr}
 8002310:	4c1e      	ldr	r4, [pc, #120]	; (800238c <rgb_lcd_begin+0x80>)
    if (lines > 1) {
 8002312:	d933      	bls.n	800237c <rgb_lcd_begin+0x70>
        _displayfunction |= LCD_2LINE;
 8002314:	7823      	ldrb	r3, [r4, #0]
 8002316:	f043 0308 	orr.w	r3, r3, #8
        _displayfunction |= LCD_5x10DOTS;
 800231a:	7023      	strb	r3, [r4, #0]
    delayMicroseconds(50000);
 800231c:	2033      	movs	r0, #51	; 0x33
 800231e:	f7ff f8db 	bl	80014d8 <HAL_Delay>
    rgb_lcd_command(LCD_FUNCTIONSET | _displayfunction);
 8002322:	7820      	ldrb	r0, [r4, #0]
 8002324:	f040 0020 	orr.w	r0, r0, #32
 8002328:	f7ff ffab 	bl	8002282 <rgb_lcd_command>
    delayMicroseconds(4500);  // wait more than 4.1ms
 800232c:	2005      	movs	r0, #5
 800232e:	f7ff f8d3 	bl	80014d8 <HAL_Delay>
    rgb_lcd_command(LCD_FUNCTIONSET | _displayfunction);
 8002332:	7820      	ldrb	r0, [r4, #0]
 8002334:	f040 0020 	orr.w	r0, r0, #32
 8002338:	f7ff ffa3 	bl	8002282 <rgb_lcd_command>
    delayMicroseconds(150);
 800233c:	2001      	movs	r0, #1
 800233e:	f7ff f8cb 	bl	80014d8 <HAL_Delay>
    rgb_lcd_command(LCD_FUNCTIONSET | _displayfunction);
 8002342:	7820      	ldrb	r0, [r4, #0]
 8002344:	f040 0020 	orr.w	r0, r0, #32
 8002348:	f7ff ff9b 	bl	8002282 <rgb_lcd_command>
    delayMicroseconds(150);
 800234c:	2001      	movs	r0, #1
 800234e:	f7ff f8c3 	bl	80014d8 <HAL_Delay>
    ret = rgb_lcd_command(LCD_FUNCTIONSET | _displayfunction);
 8002352:	7820      	ldrb	r0, [r4, #0]
 8002354:	f040 0020 	orr.w	r0, r0, #32
 8002358:	f7ff ff93 	bl	8002282 <rgb_lcd_command>
    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
 800235c:	4b0c      	ldr	r3, [pc, #48]	; (8002390 <rgb_lcd_begin+0x84>)
 800235e:	2204      	movs	r2, #4
    ret = rgb_lcd_command(LCD_FUNCTIONSET | _displayfunction);
 8002360:	4604      	mov	r4, r0
    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
 8002362:	701a      	strb	r2, [r3, #0]
    rgb_lcd_display();
 8002364:	f7ff ffc6 	bl	80022f4 <rgb_lcd_display>
    rgb_lcd_clear();
 8002368:	f7ff ffa8 	bl	80022bc <rgb_lcd_clear>
    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 800236c:	4b09      	ldr	r3, [pc, #36]	; (8002394 <rgb_lcd_begin+0x88>)
 800236e:	2202      	movs	r2, #2
    ret |= rgb_lcd_command(LCD_ENTRYMODESET | _displaymode);
 8002370:	2006      	movs	r0, #6
    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
 8002372:	701a      	strb	r2, [r3, #0]
    ret |= rgb_lcd_command(LCD_ENTRYMODESET | _displaymode);
 8002374:	f7ff ff85 	bl	8002282 <rgb_lcd_command>
}
 8002378:	4320      	orrs	r0, r4
 800237a:	bd10      	pop	{r4, pc}
    if ((dotsize != 0) && (lines == 1)) {
 800237c:	2a00      	cmp	r2, #0
 800237e:	d0cd      	beq.n	800231c <rgb_lcd_begin+0x10>
 8002380:	2901      	cmp	r1, #1
 8002382:	d1cb      	bne.n	800231c <rgb_lcd_begin+0x10>
        _displayfunction |= LCD_5x10DOTS;
 8002384:	7823      	ldrb	r3, [r4, #0]
 8002386:	f043 0304 	orr.w	r3, r3, #4
 800238a:	e7c6      	b.n	800231a <rgb_lcd_begin+0xe>
 800238c:	20000325 	.word	0x20000325
 8002390:	20000324 	.word	0x20000324
 8002394:	20000326 	.word	0x20000326

08002398 <rgb_lcd_createChar>:
    rgb_lcd_command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void rgb_lcd_createChar(uint8_t location, uint8_t charmap[]) {
 8002398:	b51f      	push	{r0, r1, r2, r3, r4, lr}

    location &= 0x7; // we only have 8 locations 0-7
    rgb_lcd_command(LCD_SETCGRAMADDR | (location << 3));
 800239a:	f000 0007 	and.w	r0, r0, #7
 800239e:	00c0      	lsls	r0, r0, #3
 80023a0:	f040 0040 	orr.w	r0, r0, #64	; 0x40
void rgb_lcd_createChar(uint8_t location, uint8_t charmap[]) {
 80023a4:	460c      	mov	r4, r1
    rgb_lcd_command(LCD_SETCGRAMADDR | (location << 3));
 80023a6:	f7ff ff6c 	bl	8002282 <rgb_lcd_command>
    delayMicroseconds(150);
 80023aa:	2001      	movs	r0, #1
 80023ac:	f7ff f894 	bl	80014d8 <HAL_Delay>

    unsigned char dta[9];
    dta[0] = 0x40;
 80023b0:	2340      	movs	r3, #64	; 0x40
 80023b2:	f88d 3004 	strb.w	r3, [sp, #4]
    for (int i = 0; i < 8; i++) {
 80023b6:	f10d 0205 	add.w	r2, sp, #5
 80023ba:	1e63      	subs	r3, r4, #1
 80023bc:	3407      	adds	r4, #7
        dta[i + 1] = charmap[i];
 80023be:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80023c2:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i = 0; i < 8; i++) {
 80023c6:	42a3      	cmp	r3, r4
 80023c8:	d1f9      	bne.n	80023be <rgb_lcd_createChar+0x26>
    }
    i2c_send_byteS(dta, 9);
 80023ca:	2109      	movs	r1, #9
 80023cc:	a801      	add	r0, sp, #4
 80023ce:	f7fe ffaf 	bl	8001330 <i2c_send_byteS>
    delayMicroseconds(150);
 80023d2:	2001      	movs	r0, #1
 80023d4:	f7ff f880 	bl	80014d8 <HAL_Delay>
}
 80023d8:	b004      	add	sp, #16
 80023da:	bd10      	pop	{r4, pc}

080023dc <rgb_lcd_print>:

/**
 * @brief Print to display
 */
void rgb_lcd_print(const char* str, ...)
{
 80023dc:	b40f      	push	{r0, r1, r2, r3}
 80023de:	b530      	push	{r4, r5, lr}
 80023e0:	b087      	sub	sp, #28
 80023e2:	aa0a      	add	r2, sp, #40	; 0x28
  char stringArray[20];
  va_list args;
  va_start(args, str);
  vsprintf(stringArray, str, args);
 80023e4:	ad01      	add	r5, sp, #4
{
 80023e6:	f852 1b04 	ldr.w	r1, [r2], #4
  va_start(args, str);
 80023ea:	9200      	str	r2, [sp, #0]
  vsprintf(stringArray, str, args);
 80023ec:	4628      	mov	r0, r5
 80023ee:	f00d fb0f 	bl	800fa10 <vsiprintf>
  va_end(args);
  for(uint8_t i=0;  i<strlen(stringArray) && i<16; i++)
 80023f2:	2400      	movs	r4, #0
 80023f4:	4628      	mov	r0, r5
 80023f6:	f7fd fec3 	bl	8000180 <strlen>
 80023fa:	42a0      	cmp	r0, r4
 80023fc:	d901      	bls.n	8002402 <rgb_lcd_print+0x26>
 80023fe:	2c10      	cmp	r4, #16
 8002400:	d104      	bne.n	800240c <rgb_lcd_print+0x30>
  {
	  rgb_lcd_write((uint8_t)stringArray[i]);
  }
}
 8002402:	b007      	add	sp, #28
 8002404:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8002408:	b004      	add	sp, #16
 800240a:	4770      	bx	lr
	  rgb_lcd_write((uint8_t)stringArray[i]);
 800240c:	5d28      	ldrb	r0, [r5, r4]
 800240e:	f7ff ff45 	bl	800229c <rgb_lcd_write>
  for(uint8_t i=0;  i<strlen(stringArray) && i<16; i++)
 8002412:	3401      	adds	r4, #1
 8002414:	e7ee      	b.n	80023f4 <rgb_lcd_print+0x18>

08002416 <scd30_start_periodic_measurement>:

#define SCD30_MAX_BUFFER_WORDS 24
#define SCD30_CMD_SINGLE_WORD_BUF_LEN \
    (SENSIRION_COMMAND_SIZE + SENSIRION_WORD_SIZE + CRC8_LEN)

int16_t scd30_start_periodic_measurement(uint16_t ambient_pressure_mbar) {
 8002416:	b507      	push	{r0, r1, r2, lr}
 8002418:	f8ad 0006 	strh.w	r0, [sp, #6]
    if (ambient_pressure_mbar &&
 800241c:	b120      	cbz	r0, 8002428 <scd30_start_periodic_measurement+0x12>
 800241e:	f5a0 702f 	sub.w	r0, r0, #700	; 0x2bc
 8002422:	f5b0 7f2f 	cmp.w	r0, #700	; 0x2bc
 8002426:	d809      	bhi.n	800243c <scd30_start_periodic_measurement+0x26>
        (ambient_pressure_mbar < 700 || ambient_pressure_mbar > 1400)) {
        /* out of allowable range */
        return STATUS_FAIL;
    }

    return sensirion_i2c_write_cmd_with_args(
 8002428:	2301      	movs	r3, #1
 800242a:	f10d 0206 	add.w	r2, sp, #6
 800242e:	2110      	movs	r1, #16
 8002430:	2061      	movs	r0, #97	; 0x61
 8002432:	f000 f8fb 	bl	800262c <sensirion_i2c_write_cmd_with_args>
        SCD30_I2C_ADDRESS, SCD30_CMD_START_PERIODIC_MEASUREMENT,
        &ambient_pressure_mbar, SENSIRION_NUM_WORDS(ambient_pressure_mbar));
}
 8002436:	b003      	add	sp, #12
 8002438:	f85d fb04 	ldr.w	pc, [sp], #4
        return STATUS_FAIL;
 800243c:	f04f 30ff 	mov.w	r0, #4294967295
 8002440:	e7f9      	b.n	8002436 <scd30_start_periodic_measurement+0x20>

08002442 <scd30_read_measurement>:
    return sensirion_i2c_write_cmd(SCD30_I2C_ADDRESS,
                                   SCD30_CMD_STOP_PERIODIC_MEASUREMENT);
}

int16_t scd30_read_measurement(float* co2_ppm, float* temperature,
                               float* humidity) {
 8002442:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002444:	4607      	mov	r7, r0
 8002446:	b085      	sub	sp, #20
 8002448:	460e      	mov	r6, r1
    int16_t error;
    uint8_t data[3][4];

    error =
        sensirion_i2c_write_cmd(SCD30_I2C_ADDRESS, SCD30_CMD_READ_MEASUREMENT);
 800244a:	2061      	movs	r0, #97	; 0x61
 800244c:	f44f 7140 	mov.w	r1, #768	; 0x300
                               float* humidity) {
 8002450:	4615      	mov	r5, r2
        sensirion_i2c_write_cmd(SCD30_I2C_ADDRESS, SCD30_CMD_READ_MEASUREMENT);
 8002452:	f000 f8dc 	bl	800260e <sensirion_i2c_write_cmd>
    if (error != NO_ERROR)
 8002456:	4604      	mov	r4, r0
 8002458:	b990      	cbnz	r0, 8002480 <scd30_read_measurement+0x3e>
        return error;

    error = sensirion_i2c_read_words_as_bytes(SCD30_I2C_ADDRESS, &data[0][0],
 800245a:	2206      	movs	r2, #6
 800245c:	a901      	add	r1, sp, #4
 800245e:	2061      	movs	r0, #97	; 0x61
 8002460:	f000 f88b 	bl	800257a <sensirion_i2c_read_words_as_bytes>
                                              SENSIRION_NUM_WORDS(data));
    if (error != NO_ERROR)
 8002464:	4604      	mov	r4, r0
 8002466:	b958      	cbnz	r0, 8002480 <scd30_read_measurement+0x3e>
        return error;

    *co2_ppm = sensirion_bytes_to_float(data[0]);
 8002468:	a801      	add	r0, sp, #4
 800246a:	f000 f841 	bl	80024f0 <sensirion_bytes_to_float>
 800246e:	6038      	str	r0, [r7, #0]
    *temperature = sensirion_bytes_to_float(data[1]);
 8002470:	a802      	add	r0, sp, #8
 8002472:	f000 f83d 	bl	80024f0 <sensirion_bytes_to_float>
 8002476:	6030      	str	r0, [r6, #0]
    *humidity = sensirion_bytes_to_float(data[2]);
 8002478:	a803      	add	r0, sp, #12
 800247a:	f000 f839 	bl	80024f0 <sensirion_bytes_to_float>
 800247e:	6028      	str	r0, [r5, #0]

    return NO_ERROR;
}
 8002480:	4620      	mov	r0, r4
 8002482:	b005      	add	sp, #20
 8002484:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002486 <scd30_set_measurement_interval>:

int16_t scd30_set_measurement_interval(uint16_t interval_sec) {
 8002486:	b513      	push	{r0, r1, r4, lr}
 8002488:	f8ad 0006 	strh.w	r0, [sp, #6]
    int16_t error;

    if (interval_sec < 2 || interval_sec > 1800) {
 800248c:	3802      	subs	r0, #2
 800248e:	b280      	uxth	r0, r0
 8002490:	f240 7306 	movw	r3, #1798	; 0x706
 8002494:	4298      	cmp	r0, r3
 8002496:	d80f      	bhi.n	80024b8 <scd30_set_measurement_interval+0x32>
        /* out of allowable range */
        return STATUS_FAIL;
    }

    error = sensirion_i2c_write_cmd_with_args(
 8002498:	2301      	movs	r3, #1
 800249a:	f10d 0206 	add.w	r2, sp, #6
 800249e:	f44f 418c 	mov.w	r1, #17920	; 0x4600
 80024a2:	2061      	movs	r0, #97	; 0x61
 80024a4:	f000 f8c2 	bl	800262c <sensirion_i2c_write_cmd_with_args>
 80024a8:	4604      	mov	r4, r0
        SCD30_I2C_ADDRESS, SCD30_CMD_SET_MEASUREMENT_INTERVAL, &interval_sec,
        SENSIRION_NUM_WORDS(interval_sec));
    sensirion_sleep_usec(SCD30_WRITE_DELAY_US);
 80024aa:	f644 6020 	movw	r0, #20000	; 0x4e20
 80024ae:	f7fe fdd5 	bl	800105c <sensirion_sleep_usec>

    return error;
}
 80024b2:	4620      	mov	r0, r4
 80024b4:	b002      	add	sp, #8
 80024b6:	bd10      	pop	{r4, pc}
        return STATUS_FAIL;
 80024b8:	f04f 34ff 	mov.w	r4, #4294967295
 80024bc:	e7f9      	b.n	80024b2 <scd30_set_measurement_interval+0x2c>

080024be <scd30_get_data_ready>:

int16_t scd30_get_data_ready(uint16_t* data_ready) {
 80024be:	b507      	push	{r0, r1, r2, lr}
    return sensirion_i2c_delayed_read_cmd(
 80024c0:	2201      	movs	r2, #1
int16_t scd30_get_data_ready(uint16_t* data_ready) {
 80024c2:	4603      	mov	r3, r0
    return sensirion_i2c_delayed_read_cmd(
 80024c4:	9200      	str	r2, [sp, #0]
 80024c6:	f240 2102 	movw	r1, #514	; 0x202
 80024ca:	f640 32b8 	movw	r2, #3000	; 0xbb8
 80024ce:	2061      	movs	r0, #97	; 0x61
 80024d0:	f000 f8bb 	bl	800264a <sensirion_i2c_delayed_read_cmd>
        SCD30_I2C_ADDRESS, SCD30_CMD_GET_DATA_READY, 3000, data_ready,
        SENSIRION_NUM_WORDS(*data_ready));
}
 80024d4:	b003      	add	sp, #12
 80024d6:	f85d fb04 	ldr.w	pc, [sp], #4

080024da <scd30_probe>:

uint8_t scd30_get_configured_address() {
    return SCD30_I2C_ADDRESS;
}

int16_t scd30_probe() {
 80024da:	b507      	push	{r0, r1, r2, lr}
    uint16_t data_ready;

    /* try to read data-ready state */
    return scd30_get_data_ready(&data_ready);
 80024dc:	f10d 0006 	add.w	r0, sp, #6
 80024e0:	f7ff ffed 	bl	80024be <scd30_get_data_ready>
}
 80024e4:	b003      	add	sp, #12
 80024e6:	f85d fb04 	ldr.w	pc, [sp], #4

080024ea <sensirion_bytes_to_uint32_t>:
uint16_t sensirion_bytes_to_uint16_t(const uint8_t* bytes) {
    return (uint16_t)bytes[0] << 8 | (uint16_t)bytes[1];
}

uint32_t sensirion_bytes_to_uint32_t(const uint8_t* bytes) {
    return (uint32_t)bytes[0] << 24 | (uint32_t)bytes[1] << 16 |
 80024ea:	6800      	ldr	r0, [r0, #0]
           (uint32_t)bytes[2] << 8 | (uint32_t)bytes[3];
}
 80024ec:	ba00      	rev	r0, r0
 80024ee:	4770      	bx	lr

080024f0 <sensirion_bytes_to_float>:

float sensirion_bytes_to_float(const uint8_t* bytes) {
 80024f0:	b508      	push	{r3, lr}
    union {
        uint32_t u32_value;
        float float32;
    } tmp;

    tmp.u32_value = sensirion_bytes_to_uint32_t(bytes);
 80024f2:	f7ff fffa 	bl	80024ea <sensirion_bytes_to_uint32_t>
    return tmp.float32;
}
 80024f6:	bd08      	pop	{r3, pc}

080024f8 <sensirion_common_generate_crc>:
    uint16_t current_byte;
    uint8_t crc = CRC8_INIT;
    uint8_t crc_bit;

    /* calculates 8-Bit checksum with given polynomial */
    for (current_byte = 0; current_byte < count; ++current_byte) {
 80024f8:	4603      	mov	r3, r0
 80024fa:	4401      	add	r1, r0
    uint8_t crc = CRC8_INIT;
 80024fc:	20ff      	movs	r0, #255	; 0xff
    for (current_byte = 0; current_byte < count; ++current_byte) {
 80024fe:	4299      	cmp	r1, r3
 8002500:	d100      	bne.n	8002504 <sensirion_common_generate_crc+0xc>
            else
                crc = (crc << 1);
        }
    }
    return crc;
}
 8002502:	4770      	bx	lr
        crc ^= (data[current_byte]);
 8002504:	f813 2b01 	ldrb.w	r2, [r3], #1
 8002508:	4050      	eors	r0, r2
 800250a:	2208      	movs	r2, #8
            if (crc & 0x80)
 800250c:	f010 0f80 	tst.w	r0, #128	; 0x80
 8002510:	f102 32ff 	add.w	r2, r2, #4294967295
 8002514:	ea4f 0040 	mov.w	r0, r0, lsl #1
                crc = (crc << 1) ^ CRC8_POLYNOMIAL;
 8002518:	bf18      	it	ne
 800251a:	f080 0031 	eorne.w	r0, r0, #49	; 0x31
        for (crc_bit = 8; crc_bit > 0; --crc_bit) {
 800251e:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
                crc = (crc << 1);
 8002522:	b2c0      	uxtb	r0, r0
        for (crc_bit = 8; crc_bit > 0; --crc_bit) {
 8002524:	d1f2      	bne.n	800250c <sensirion_common_generate_crc+0x14>
 8002526:	e7ea      	b.n	80024fe <sensirion_common_generate_crc+0x6>

08002528 <sensirion_common_check_crc>:

int8_t sensirion_common_check_crc(const uint8_t* data, uint16_t count,
                                  uint8_t checksum) {
 8002528:	b510      	push	{r4, lr}
 800252a:	4614      	mov	r4, r2
    if (sensirion_common_generate_crc(data, count) != checksum)
 800252c:	f7ff ffe4 	bl	80024f8 <sensirion_common_generate_crc>
        return STATUS_FAIL;
    return NO_ERROR;
}
 8002530:	1b00      	subs	r0, r0, r4
 8002532:	bf18      	it	ne
 8002534:	f04f 30ff 	movne.w	r0, #4294967295
 8002538:	bd10      	pop	{r4, pc}

0800253a <sensirion_fill_cmd_send_buf>:
    const uint8_t data = 0x06;
    return sensirion_i2c_write(0, &data, (uint16_t)sizeof(data));
}

uint16_t sensirion_fill_cmd_send_buf(uint8_t* buf, uint16_t cmd,
                                     const uint16_t* args, uint8_t num_args) {
 800253a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800253c:	461c      	mov	r4, r3
    uint8_t crc;
    uint8_t i;
    uint16_t idx = 0;

    buf[idx++] = (uint8_t)((cmd & 0xFF00) >> 8);
 800253e:	0a0b      	lsrs	r3, r1, #8
 8002540:	7003      	strb	r3, [r0, #0]
    buf[idx++] = (uint8_t)((cmd & 0x00FF) >> 0);
 8002542:	7041      	strb	r1, [r0, #1]

    for (i = 0; i < num_args; ++i) {
 8002544:	4615      	mov	r5, r2
 8002546:	3002      	adds	r0, #2
 8002548:	eb02 0744 	add.w	r7, r2, r4, lsl #1
 800254c:	42bd      	cmp	r5, r7
 800254e:	f100 0603 	add.w	r6, r0, #3
 8002552:	d103      	bne.n	800255c <sensirion_fill_cmd_send_buf+0x22>

        crc = sensirion_common_generate_crc((uint8_t*)&buf[idx - 2],
                                            SENSIRION_WORD_SIZE);
        buf[idx++] = crc;
    }
    return idx;
 8002554:	eb04 0444 	add.w	r4, r4, r4, lsl #1
}
 8002558:	1ca0      	adds	r0, r4, #2
 800255a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        buf[idx++] = (uint8_t)((args[i] & 0xFF00) >> 8);
 800255c:	882b      	ldrh	r3, [r5, #0]
 800255e:	0a1b      	lsrs	r3, r3, #8
 8002560:	f806 3c03 	strb.w	r3, [r6, #-3]
        buf[idx++] = (uint8_t)((args[i] & 0x00FF) >> 0);
 8002564:	f835 3b02 	ldrh.w	r3, [r5], #2
 8002568:	f806 3c02 	strb.w	r3, [r6, #-2]
        crc = sensirion_common_generate_crc((uint8_t*)&buf[idx - 2],
 800256c:	2102      	movs	r1, #2
 800256e:	f7ff ffc3 	bl	80024f8 <sensirion_common_generate_crc>
        buf[idx++] = crc;
 8002572:	f806 0c01 	strb.w	r0, [r6, #-1]
 8002576:	4630      	mov	r0, r6
 8002578:	e7e8      	b.n	800254c <sensirion_fill_cmd_send_buf+0x12>

0800257a <sensirion_i2c_read_words_as_bytes>:

int16_t sensirion_i2c_read_words_as_bytes(uint8_t address, uint8_t* data,
                                          uint16_t num_words) {
 800257a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    int16_t ret;
    uint16_t i, j;
    uint16_t size = num_words * (SENSIRION_WORD_SIZE + CRC8_LEN);
 800257e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
                                          uint16_t num_words) {
 8002582:	b091      	sub	sp, #68	; 0x44
    uint16_t size = num_words * (SENSIRION_WORD_SIZE + CRC8_LEN);
 8002584:	b296      	uxth	r6, r2
                                          uint16_t num_words) {
 8002586:	4688      	mov	r8, r1
    uint16_t word_buf[SENSIRION_MAX_BUFFER_WORDS];
    uint8_t* const buf8 = (uint8_t*)word_buf;

    ret = sensirion_i2c_read(address, buf8, size);
 8002588:	4632      	mov	r2, r6
 800258a:	4669      	mov	r1, sp
 800258c:	f7fe fd5a 	bl	8001044 <sensirion_i2c_read>
 8002590:	b205      	sxth	r5, r0
    if (ret != NO_ERROR)
 8002592:	b91d      	cbnz	r5, 800259c <sensirion_i2c_read_words_as_bytes+0x22>
        return ret;

    /* check the CRC for each word */
    for (i = 0, j = 0; i < size; i += SENSIRION_WORD_SIZE + CRC8_LEN) {
 8002594:	462f      	mov	r7, r5
 8002596:	462c      	mov	r4, r5
 8002598:	42b4      	cmp	r4, r6
 800259a:	d303      	bcc.n	80025a4 <sensirion_i2c_read_words_as_bytes+0x2a>
        data[j++] = buf8[i];
        data[j++] = buf8[i + 1];
    }

    return NO_ERROR;
}
 800259c:	4628      	mov	r0, r5
 800259e:	b011      	add	sp, #68	; 0x44
 80025a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ret = sensirion_common_check_crc(&buf8[i], SENSIRION_WORD_SIZE,
 80025a4:	ab10      	add	r3, sp, #64	; 0x40
 80025a6:	eb03 0904 	add.w	r9, r3, r4
 80025aa:	2102      	movs	r1, #2
 80025ac:	f819 2c3e 	ldrb.w	r2, [r9, #-62]
 80025b0:	eb0d 0004 	add.w	r0, sp, r4
 80025b4:	f7ff ffb8 	bl	8002528 <sensirion_common_check_crc>
 80025b8:	b200      	sxth	r0, r0
        if (ret != NO_ERROR)
 80025ba:	b970      	cbnz	r0, 80025da <sensirion_i2c_read_words_as_bytes+0x60>
        data[j++] = buf8[i];
 80025bc:	1c7b      	adds	r3, r7, #1
 80025be:	f81d 2004 	ldrb.w	r2, [sp, r4]
 80025c2:	f808 2007 	strb.w	r2, [r8, r7]
 80025c6:	b29b      	uxth	r3, r3
        data[j++] = buf8[i + 1];
 80025c8:	f819 2c3f 	ldrb.w	r2, [r9, #-63]
 80025cc:	f808 2003 	strb.w	r2, [r8, r3]
 80025d0:	3702      	adds	r7, #2
    for (i = 0, j = 0; i < size; i += SENSIRION_WORD_SIZE + CRC8_LEN) {
 80025d2:	3403      	adds	r4, #3
        data[j++] = buf8[i + 1];
 80025d4:	b2bf      	uxth	r7, r7
    for (i = 0, j = 0; i < size; i += SENSIRION_WORD_SIZE + CRC8_LEN) {
 80025d6:	b2a4      	uxth	r4, r4
 80025d8:	e7de      	b.n	8002598 <sensirion_i2c_read_words_as_bytes+0x1e>
        ret = sensirion_common_check_crc(&buf8[i], SENSIRION_WORD_SIZE,
 80025da:	4605      	mov	r5, r0
 80025dc:	e7de      	b.n	800259c <sensirion_i2c_read_words_as_bytes+0x22>

080025de <sensirion_i2c_read_words>:

int16_t sensirion_i2c_read_words(uint8_t address, uint16_t* data_words,
                                 uint16_t num_words) {
 80025de:	b570      	push	{r4, r5, r6, lr}
 80025e0:	460c      	mov	r4, r1
 80025e2:	4615      	mov	r5, r2
    int16_t ret;
    uint8_t i;
    const uint8_t* word_bytes;

    ret = sensirion_i2c_read_words_as_bytes(address, (uint8_t*)data_words,
 80025e4:	f7ff ffc9 	bl	800257a <sensirion_i2c_read_words_as_bytes>
                                            num_words);
    if (ret != NO_ERROR)
 80025e8:	b928      	cbnz	r0, 80025f6 <sensirion_i2c_read_words+0x18>
 80025ea:	4603      	mov	r3, r0
        return ret;

    for (i = 0; i < num_words; ++i) {
 80025ec:	b2da      	uxtb	r2, r3
 80025ee:	42aa      	cmp	r2, r5
 80025f0:	f103 0101 	add.w	r1, r3, #1
 80025f4:	d300      	bcc.n	80025f8 <sensirion_i2c_read_words+0x1a>
        word_bytes = (uint8_t*)&data_words[i];
        data_words[i] = ((uint16_t)word_bytes[0] << 8) | word_bytes[1];
    }

    return NO_ERROR;
}
 80025f6:	bd70      	pop	{r4, r5, r6, pc}
        word_bytes = (uint8_t*)&data_words[i];
 80025f8:	eb04 0342 	add.w	r3, r4, r2, lsl #1
        data_words[i] = ((uint16_t)word_bytes[0] << 8) | word_bytes[1];
 80025fc:	f814 6012 	ldrb.w	r6, [r4, r2, lsl #1]
 8002600:	785b      	ldrb	r3, [r3, #1]
 8002602:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 8002606:	f824 3012 	strh.w	r3, [r4, r2, lsl #1]
 800260a:	460b      	mov	r3, r1
 800260c:	e7ee      	b.n	80025ec <sensirion_i2c_read_words+0xe>

0800260e <sensirion_i2c_write_cmd>:

int16_t sensirion_i2c_write_cmd(uint8_t address, uint16_t command) {
 800260e:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[SENSIRION_COMMAND_SIZE];

    sensirion_fill_cmd_send_buf(buf, command, NULL, 0);
 8002610:	2300      	movs	r3, #0
 8002612:	461a      	mov	r2, r3
int16_t sensirion_i2c_write_cmd(uint8_t address, uint16_t command) {
 8002614:	4604      	mov	r4, r0
    sensirion_fill_cmd_send_buf(buf, command, NULL, 0);
 8002616:	a801      	add	r0, sp, #4
 8002618:	f7ff ff8f 	bl	800253a <sensirion_fill_cmd_send_buf>
    return sensirion_i2c_write(address, buf, SENSIRION_COMMAND_SIZE);
 800261c:	2202      	movs	r2, #2
 800261e:	a901      	add	r1, sp, #4
 8002620:	4620      	mov	r0, r4
 8002622:	f7fe fd15 	bl	8001050 <sensirion_i2c_write>
}
 8002626:	b200      	sxth	r0, r0
 8002628:	b002      	add	sp, #8
 800262a:	bd10      	pop	{r4, pc}

0800262c <sensirion_i2c_write_cmd_with_args>:

int16_t sensirion_i2c_write_cmd_with_args(uint8_t address, uint16_t command,
                                          const uint16_t* data_words,
                                          uint16_t num_words) {
 800262c:	b510      	push	{r4, lr}
 800262e:	b088      	sub	sp, #32
 8002630:	4604      	mov	r4, r0
    uint8_t buf[SENSIRION_MAX_BUFFER_WORDS];
    uint16_t buf_size;

    buf_size = sensirion_fill_cmd_send_buf(buf, command, data_words, num_words);
 8002632:	b2db      	uxtb	r3, r3
 8002634:	4668      	mov	r0, sp
 8002636:	f7ff ff80 	bl	800253a <sensirion_fill_cmd_send_buf>
    return sensirion_i2c_write(address, buf, buf_size);
 800263a:	4669      	mov	r1, sp
    buf_size = sensirion_fill_cmd_send_buf(buf, command, data_words, num_words);
 800263c:	4602      	mov	r2, r0
    return sensirion_i2c_write(address, buf, buf_size);
 800263e:	4620      	mov	r0, r4
 8002640:	f7fe fd06 	bl	8001050 <sensirion_i2c_write>
}
 8002644:	b200      	sxth	r0, r0
 8002646:	b008      	add	sp, #32
 8002648:	bd10      	pop	{r4, pc}

0800264a <sensirion_i2c_delayed_read_cmd>:

int16_t sensirion_i2c_delayed_read_cmd(uint8_t address, uint16_t cmd,
                                       uint32_t delay_us, uint16_t* data_words,
                                       uint16_t num_words) {
 800264a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800264c:	461e      	mov	r6, r3
    int16_t ret;
    uint8_t buf[SENSIRION_COMMAND_SIZE];

    sensirion_fill_cmd_send_buf(buf, cmd, NULL, 0);
 800264e:	2300      	movs	r3, #0
                                       uint16_t num_words) {
 8002650:	4604      	mov	r4, r0
 8002652:	4615      	mov	r5, r2
    sensirion_fill_cmd_send_buf(buf, cmd, NULL, 0);
 8002654:	a801      	add	r0, sp, #4
 8002656:	461a      	mov	r2, r3
 8002658:	f7ff ff6f 	bl	800253a <sensirion_fill_cmd_send_buf>
    ret = sensirion_i2c_write(address, buf, SENSIRION_COMMAND_SIZE);
 800265c:	2202      	movs	r2, #2
 800265e:	a901      	add	r1, sp, #4
 8002660:	4620      	mov	r0, r4
 8002662:	f7fe fcf5 	bl	8001050 <sensirion_i2c_write>
 8002666:	b200      	sxth	r0, r0
    if (ret != NO_ERROR)
 8002668:	b948      	cbnz	r0, 800267e <sensirion_i2c_delayed_read_cmd+0x34>
        return ret;

    if (delay_us)
 800266a:	b115      	cbz	r5, 8002672 <sensirion_i2c_delayed_read_cmd+0x28>
        sensirion_sleep_usec(delay_us);
 800266c:	4628      	mov	r0, r5
 800266e:	f7fe fcf5 	bl	800105c <sensirion_sleep_usec>

    return sensirion_i2c_read_words(address, data_words, num_words);
 8002672:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 8002676:	4631      	mov	r1, r6
 8002678:	4620      	mov	r0, r4
 800267a:	f7ff ffb0 	bl	80025de <sensirion_i2c_read_words>
}
 800267e:	b002      	add	sp, #8
 8002680:	bd70      	pop	{r4, r5, r6, pc}

08002682 <LL_AHB2_GRP1_EnableClock>:
  SET_BIT(RCC->AHB2ENR, Periphs);
 8002682:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 8002686:	b082      	sub	sp, #8
  SET_BIT(RCC->AHB2ENR, Periphs);
 8002688:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800268a:	4302      	orrs	r2, r0
 800268c:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 800268e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002690:	4018      	ands	r0, r3
 8002692:	9001      	str	r0, [sp, #4]
  (void)tmpreg;
 8002694:	9b01      	ldr	r3, [sp, #4]
}
 8002696:	b002      	add	sp, #8
 8002698:	4770      	bx	lr
	...

0800269c <BSP_LED_Init>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 800269c:	b570      	push	{r4, r5, r6, lr}
 800269e:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 80026a0:	2214      	movs	r2, #20
{
 80026a2:	4604      	mov	r4, r0
  GPIO_InitTypeDef  gpio_init_structure = {0};
 80026a4:	2100      	movs	r1, #0
 80026a6:	a801      	add	r0, sp, #4
 80026a8:	f00d f994 	bl	800f9d4 <memset>
  
  /* Enable the GPIO_LED Clock */
  LEDx_GPIO_CLK_ENABLE(Led);
 80026ac:	2002      	movs	r0, #2
 80026ae:	f7ff ffe8 	bl	8002682 <LL_AHB2_GRP1_EnableClock>

  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN[Led];
 80026b2:	4b0c      	ldr	r3, [pc, #48]	; (80026e4 <BSP_LED_Init+0x48>)
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull = GPIO_NOPULL;
 80026b4:	2500      	movs	r5, #0
  gpio_init_structure.Pin = LED_PIN[Led];
 80026b6:	f833 6014 	ldrh.w	r6, [r3, r4, lsl #1]
 80026ba:	9601      	str	r6, [sp, #4]
  gpio_init_structure.Pull = GPIO_NOPULL;
 80026bc:	2301      	movs	r3, #1
 80026be:	e9cd 3502 	strd	r3, r5, [sp, #8]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 80026c2:	2302      	movs	r3, #2
 80026c4:	9304      	str	r3, [sp, #16]
  
  HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 80026c6:	4b08      	ldr	r3, [pc, #32]	; (80026e8 <BSP_LED_Init+0x4c>)
 80026c8:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
 80026cc:	a901      	add	r1, sp, #4
 80026ce:	4620      	mov	r0, r4
 80026d0:	f001 f804 	bl	80036dc <HAL_GPIO_Init>
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 80026d4:	4620      	mov	r0, r4
 80026d6:	462a      	mov	r2, r5
 80026d8:	4631      	mov	r1, r6
 80026da:	f001 f91f 	bl	800391c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 80026de:	4628      	mov	r0, r5
 80026e0:	b006      	add	sp, #24
 80026e2:	bd70      	pop	{r4, r5, r6, pc}
 80026e4:	080107b8 	.word	0x080107b8
 80026e8:	080107c0 	.word	0x080107c0

080026ec <BSP_LED_On>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
 80026ec:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET); 
 80026ee:	4b05      	ldr	r3, [pc, #20]	; (8002704 <BSP_LED_On+0x18>)
 80026f0:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 80026f4:	4b04      	ldr	r3, [pc, #16]	; (8002708 <BSP_LED_On+0x1c>)
 80026f6:	2201      	movs	r2, #1
 80026f8:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80026fc:	f001 f90e 	bl	800391c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 8002700:	2000      	movs	r0, #0
 8002702:	bd08      	pop	{r3, pc}
 8002704:	080107b8 	.word	0x080107b8
 8002708:	080107c0 	.word	0x080107c0

0800270c <BSP_LED_Off>:
  *            @arg LED2
  *            @arg LED3
  * @retval BSP status
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
 800270c:	b508      	push	{r3, lr}
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET); 
 800270e:	4b05      	ldr	r3, [pc, #20]	; (8002724 <BSP_LED_Off+0x18>)
 8002710:	f833 1010 	ldrh.w	r1, [r3, r0, lsl #1]
 8002714:	4b04      	ldr	r3, [pc, #16]	; (8002728 <BSP_LED_Off+0x1c>)
 8002716:	2200      	movs	r2, #0
 8002718:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800271c:	f001 f8fe 	bl	800391c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 8002720:	2000      	movs	r0, #0
 8002722:	bd08      	pop	{r3, pc}
 8002724:	080107b8 	.word	0x080107b8
 8002728:	080107c0 	.word	0x080107c0

0800272c <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 800272c:	b530      	push	{r4, r5, lr}
 800272e:	b087      	sub	sp, #28
 8002730:	4604      	mov	r4, r0
 8002732:	460d      	mov	r5, r1
  GPIO_InitTypeDef gpio_init_structure = {0};
 8002734:	2214      	movs	r2, #20
 8002736:	2100      	movs	r1, #0
 8002738:	a801      	add	r0, sp, #4
 800273a:	f00d f94b 	bl	800f9d4 <memset>
  static BSP_EXTI_LineCallback button_callback[BUTTONn] = {BUTTON_SW1_EXTI_Callback, BUTTON_SW2_EXTI_Callback, BUTTON_SW3_EXTI_Callback};
  static uint32_t button_interrupt_priority[BUTTONn] = {BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY, BSP_BUTTON_SWx_IT_PRIORITY};
  static const uint32_t button_exti_line[BUTTONn] = {BUTTON_SW1_EXTI_LINE, BUTTON_SW2_EXTI_LINE, BUTTON_SW3_EXTI_LINE};

  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800273e:	2c01      	cmp	r4, #1
 8002740:	d815      	bhi.n	800276e <BSP_PB_Init+0x42>
 8002742:	2001      	movs	r0, #1
 8002744:	f7ff ff9d 	bl	8002682 <LL_AHB2_GRP1_EnableClock>
  
  gpio_init_structure.Pin = BUTTON_PIN[Button];
 8002748:	4b1c      	ldr	r3, [pc, #112]	; (80027bc <BSP_PB_Init+0x90>)
 800274a:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 800274e:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Pull = GPIO_PULLUP;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8002750:	2201      	movs	r2, #1
 8002752:	2302      	movs	r3, #2
 8002754:	e9cd 2303 	strd	r2, r3, [sp, #12]

  if(ButtonMode == BUTTON_MODE_GPIO)
 8002758:	4b19      	ldr	r3, [pc, #100]	; (80027c0 <BSP_PB_Init+0x94>)
 800275a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800275e:	b955      	cbnz	r5, 8002776 <BSP_PB_Init+0x4a>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8002760:	a901      	add	r1, sp, #4
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 8002762:	9502      	str	r5, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8002764:	f000 ffba 	bl	80036dc <HAL_GPIO_Init>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
  }

  return BSP_ERROR_NONE;
}
 8002768:	2000      	movs	r0, #0
 800276a:	b007      	add	sp, #28
 800276c:	bd30      	pop	{r4, r5, pc}
  BUTTONx_GPIO_CLK_ENABLE(Button);
 800276e:	2c02      	cmp	r4, #2
 8002770:	d1ea      	bne.n	8002748 <BSP_PB_Init+0x1c>
 8002772:	2004      	movs	r0, #4
 8002774:	e7e6      	b.n	8002744 <BSP_PB_Init+0x18>
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 8002776:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 800277a:	a901      	add	r1, sp, #4
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 800277c:	4d11      	ldr	r5, [pc, #68]	; (80027c4 <BSP_PB_Init+0x98>)
    gpio_init_structure.Mode = GPIO_MODE_IT_FALLING;
 800277e:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8002780:	f000 ffac 	bl	80036dc <HAL_GPIO_Init>
    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], button_exti_line[Button]);
 8002784:	4b10      	ldr	r3, [pc, #64]	; (80027c8 <BSP_PB_Init+0x9c>)
 8002786:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 800278a:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800278e:	4628      	mov	r0, r5
 8002790:	f000 ff9d 	bl	80036ce <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, button_callback[Button]);
 8002794:	4b0d      	ldr	r3, [pc, #52]	; (80027cc <BSP_PB_Init+0xa0>)
 8002796:	2100      	movs	r1, #0
 8002798:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
 800279c:	4628      	mov	r0, r5
 800279e:	f000 ff8f 	bl	80036c0 <HAL_EXTI_RegisterCallback>
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), button_interrupt_priority[Button], 0x00);
 80027a2:	4b0b      	ldr	r3, [pc, #44]	; (80027d0 <BSP_PB_Init+0xa4>)
 80027a4:	571d      	ldrsb	r5, [r3, r4]
 80027a6:	4b0b      	ldr	r3, [pc, #44]	; (80027d4 <BSP_PB_Init+0xa8>)
 80027a8:	4628      	mov	r0, r5
 80027aa:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 80027ae:	2200      	movs	r2, #0
 80027b0:	f000 fd10 	bl	80031d4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 80027b4:	4628      	mov	r0, r5
 80027b6:	f000 fd3f 	bl	8003238 <HAL_NVIC_EnableIRQ>
 80027ba:	e7d5      	b.n	8002768 <BSP_PB_Init+0x3c>
 80027bc:	080107a4 	.word	0x080107a4
 80027c0:	080107ac 	.word	0x080107ac
 80027c4:	20001ac8 	.word	0x20001ac8
 80027c8:	080107d8 	.word	0x080107d8
 80027cc:	080107cc 	.word	0x080107cc
 80027d0:	080107a0 	.word	0x080107a0
 80027d4:	080107e4 	.word	0x080107e4

080027d8 <BSP_PB_Callback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 80027d8:	4770      	bx	lr

080027da <BUTTON_SW3_EXTI_Callback>:
/**
  * @brief  Button SW3 EXTI line detection callback.
  * @retval None
  */
static void BUTTON_SW3_EXTI_Callback(void)
{
 80027da:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW3);
 80027dc:	2002      	movs	r0, #2
 80027de:	f7ff fffb 	bl	80027d8 <BSP_PB_Callback>
}
 80027e2:	bd08      	pop	{r3, pc}

080027e4 <BUTTON_SW2_EXTI_Callback>:
{
 80027e4:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW2);
 80027e6:	2001      	movs	r0, #1
 80027e8:	f7ff fff6 	bl	80027d8 <BSP_PB_Callback>
}
 80027ec:	bd08      	pop	{r3, pc}

080027ee <BUTTON_SW1_EXTI_Callback>:
{
 80027ee:	b508      	push	{r3, lr}
  BSP_PB_Callback(BUTTON_SW1);
 80027f0:	2000      	movs	r0, #0
 80027f2:	f7ff fff1 	bl	80027d8 <BSP_PB_Callback>
}
 80027f6:	bd08      	pop	{r3, pc}

080027f8 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 80027f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80027fc:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 80027fe:	2400      	movs	r4, #0
  SET_BIT(RCC->AHB2ENR, Periphs);
 8002800:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8002804:	9405      	str	r4, [sp, #20]
 8002806:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8002808:	4d1a      	ldr	r5, [pc, #104]	; (8002874 <BSP_RADIO_Init+0x7c>)
 800280a:	f042 0204 	orr.w	r2, r2, #4
 800280e:	64da      	str	r2, [r3, #76]	; 0x4c
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8002810:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init_structure.Pull  = GPIO_NOPULL;
 8002812:	9403      	str	r4, [sp, #12]
 8002814:	f003 0304 	and.w	r3, r3, #4
 8002818:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800281a:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 800281c:	2710      	movs	r7, #16
 800281e:	2301      	movs	r3, #1
 8002820:	e9cd 7301 	strd	r7, r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8002824:	a901      	add	r1, sp, #4
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8002826:	2303      	movs	r3, #3
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8002828:	4628      	mov	r0, r5
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800282a:	9304      	str	r3, [sp, #16]
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 800282c:	f04f 0820 	mov.w	r8, #32
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8002830:	f000 ff54 	bl	80036dc <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 8002834:	a901      	add	r1, sp, #4
 8002836:	4628      	mov	r0, r5
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 8002838:	2608      	movs	r6, #8
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 800283a:	f8cd 8004 	str.w	r8, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 800283e:	f000 ff4d 	bl	80036dc <HAL_GPIO_Init>
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 8002842:	a901      	add	r1, sp, #4
 8002844:	4628      	mov	r0, r5
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 8002846:	9601      	str	r6, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 8002848:	f000 ff48 	bl	80036dc <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 800284c:	4622      	mov	r2, r4
 800284e:	4641      	mov	r1, r8
 8002850:	4628      	mov	r0, r5
 8002852:	f001 f863 	bl	800391c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 8002856:	4622      	mov	r2, r4
 8002858:	4639      	mov	r1, r7
 800285a:	4628      	mov	r0, r5
 800285c:	f001 f85e 	bl	800391c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 8002860:	4628      	mov	r0, r5
 8002862:	4622      	mov	r2, r4
 8002864:	4631      	mov	r1, r6
 8002866:	f001 f859 	bl	800391c <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 800286a:	4620      	mov	r0, r4
 800286c:	b006      	add	sp, #24
 800286e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002872:	bf00      	nop
 8002874:	48000800 	.word	0x48000800

08002878 <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 8002878:	b508      	push	{r3, lr}
 800287a:	2803      	cmp	r0, #3
 800287c:	d812      	bhi.n	80028a4 <BSP_RADIO_ConfigRFSwitch+0x2c>
 800287e:	e8df f000 	tbb	[pc, r0]
 8002882:	1302      	.short	0x1302
 8002884:	261a      	.short	0x261a
  switch (Config)
  {
    case RADIO_SWITCH_OFF:
    {
      /* Turn off switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 8002886:	2200      	movs	r2, #0
 8002888:	4814      	ldr	r0, [pc, #80]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 800288a:	2108      	movs	r1, #8
 800288c:	f001 f846 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 8002890:	2200      	movs	r2, #0
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 8002892:	4812      	ldr	r0, [pc, #72]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 8002894:	2110      	movs	r1, #16
 8002896:	f001 f841 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 800289a:	2200      	movs	r2, #0
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 800289c:	480f      	ldr	r0, [pc, #60]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 800289e:	2120      	movs	r1, #32
 80028a0:	f001 f83c 	bl	800391c <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 80028a4:	2000      	movs	r0, #0
 80028a6:	bd08      	pop	{r3, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80028a8:	2201      	movs	r2, #1
 80028aa:	480c      	ldr	r0, [pc, #48]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 80028ac:	2108      	movs	r1, #8
 80028ae:	f001 f835 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 80028b2:	2201      	movs	r2, #1
 80028b4:	e7ed      	b.n	8002892 <BSP_RADIO_ConfigRFSwitch+0x1a>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80028b6:	2201      	movs	r2, #1
 80028b8:	4808      	ldr	r0, [pc, #32]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 80028ba:	2108      	movs	r1, #8
 80028bc:	f001 f82e 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 80028c0:	2201      	movs	r2, #1
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 80028c2:	4806      	ldr	r0, [pc, #24]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 80028c4:	2110      	movs	r1, #16
 80028c6:	f001 f829 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 80028ca:	2201      	movs	r2, #1
 80028cc:	e7e6      	b.n	800289c <BSP_RADIO_ConfigRFSwitch+0x24>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80028ce:	2201      	movs	r2, #1
 80028d0:	4802      	ldr	r0, [pc, #8]	; (80028dc <BSP_RADIO_ConfigRFSwitch+0x64>)
 80028d2:	2108      	movs	r1, #8
 80028d4:	f001 f822 	bl	800391c <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 80028d8:	2200      	movs	r2, #0
 80028da:	e7f2      	b.n	80028c2 <BSP_RADIO_ConfigRFSwitch+0x4a>
 80028dc:	48000800 	.word	0x48000800

080028e0 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 80028e0:	2000      	movs	r0, #0
 80028e2:	4770      	bx	lr

080028e4 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 80028e4:	2001      	movs	r0, #1
 80028e6:	4770      	bx	lr

080028e8 <BSP_RADIO_IsDCDC>:
 80028e8:	2001      	movs	r0, #1
 80028ea:	4770      	bx	lr

080028ec <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 80028ec:	4770      	bx	lr
	...

080028f0 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80028f0:	b510      	push	{r4, lr}
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80028f2:	2003      	movs	r0, #3
 80028f4:	f000 fc5c 	bl	80031b0 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80028f8:	f001 fc98 	bl	800422c <HAL_RCC_GetHCLKFreq>
 80028fc:	4b06      	ldr	r3, [pc, #24]	; (8002918 <HAL_Init+0x28>)
 80028fe:	6018      	str	r0, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8002900:	200f      	movs	r0, #15
 8002902:	f7fe fde5 	bl	80014d0 <HAL_InitTick>
 8002906:	4604      	mov	r4, r0
 8002908:	b918      	cbnz	r0, 8002912 <HAL_Init+0x22>
    status = HAL_ERROR;
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 800290a:	f7fe fbd4 	bl	80010b6 <HAL_MspInit>
  }

  /* Return function status */
  return status;
}
 800290e:	4620      	mov	r0, r4
 8002910:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 8002912:	2401      	movs	r4, #1
 8002914:	e7fb      	b.n	800290e <HAL_Init+0x1e>
 8002916:	bf00      	nop
 8002918:	20000050 	.word	0x20000050

0800291c <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 800291c:	4a02      	ldr	r2, [pc, #8]	; (8002928 <HAL_SuspendTick+0xc>)
 800291e:	6813      	ldr	r3, [r2, #0]
 8002920:	f023 0302 	bic.w	r3, r3, #2
 8002924:	6013      	str	r3, [r2, #0]
}
 8002926:	4770      	bx	lr
 8002928:	e000e010 	.word	0xe000e010

0800292c <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 800292c:	4a02      	ldr	r2, [pc, #8]	; (8002938 <HAL_ResumeTick+0xc>)
 800292e:	6813      	ldr	r3, [r2, #0]
 8002930:	f043 0302 	orr.w	r3, r3, #2
 8002934:	6013      	str	r3, [r2, #0]
}
 8002936:	4770      	bx	lr
 8002938:	e000e010 	.word	0xe000e010

0800293c <HAL_GetUIDw0>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
}
 800293c:	4b01      	ldr	r3, [pc, #4]	; (8002944 <HAL_GetUIDw0+0x8>)
 800293e:	6818      	ldr	r0, [r3, #0]
 8002940:	4770      	bx	lr
 8002942:	bf00      	nop
 8002944:	1fff7590 	.word	0x1fff7590

08002948 <HAL_GetUIDw1>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
}
 8002948:	4b01      	ldr	r3, [pc, #4]	; (8002950 <HAL_GetUIDw1+0x8>)
 800294a:	6818      	ldr	r0, [r3, #0]
 800294c:	4770      	bx	lr
 800294e:	bf00      	nop
 8002950:	1fff7594 	.word	0x1fff7594

08002954 <HAL_GetUIDw2>:
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
}
 8002954:	4b01      	ldr	r3, [pc, #4]	; (800295c <HAL_GetUIDw2+0x8>)
 8002956:	6818      	ldr	r0, [r3, #0]
 8002958:	4770      	bx	lr
 800295a:	bf00      	nop
 800295c:	1fff7598 	.word	0x1fff7598

08002960 <HAL_DBGMCU_EnableDBGSleepMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8002960:	4a02      	ldr	r2, [pc, #8]	; (800296c <HAL_DBGMCU_EnableDBGSleepMode+0xc>)
 8002962:	6853      	ldr	r3, [r2, #4]
 8002964:	f043 0301 	orr.w	r3, r3, #1
 8002968:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGSleepMode(void)
{
  LL_DBGMCU_EnableDBGSleepMode();
}
 800296a:	4770      	bx	lr
 800296c:	e0042000 	.word	0xe0042000

08002970 <HAL_DBGMCU_DisableDBGSleepMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
 8002970:	4a02      	ldr	r2, [pc, #8]	; (800297c <HAL_DBGMCU_DisableDBGSleepMode+0xc>)
 8002972:	6853      	ldr	r3, [r2, #4]
 8002974:	f023 0301 	bic.w	r3, r3, #1
 8002978:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGSleepMode(void)
{
  LL_DBGMCU_DisableDBGSleepMode();
}
 800297a:	4770      	bx	lr
 800297c:	e0042000 	.word	0xe0042000

08002980 <HAL_DBGMCU_EnableDBGStopMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8002980:	4a02      	ldr	r2, [pc, #8]	; (800298c <HAL_DBGMCU_EnableDBGStopMode+0xc>)
 8002982:	6853      	ldr	r3, [r2, #4]
 8002984:	f043 0302 	orr.w	r3, r3, #2
 8002988:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStopMode(void)
{
  LL_DBGMCU_EnableDBGStopMode();
}
 800298a:	4770      	bx	lr
 800298c:	e0042000 	.word	0xe0042000

08002990 <HAL_DBGMCU_DisableDBGStopMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 8002990:	4a02      	ldr	r2, [pc, #8]	; (800299c <HAL_DBGMCU_DisableDBGStopMode+0xc>)
 8002992:	6853      	ldr	r3, [r2, #4]
 8002994:	f023 0302 	bic.w	r3, r3, #2
 8002998:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStopMode(void)
{
  LL_DBGMCU_DisableDBGStopMode();
}
 800299a:	4770      	bx	lr
 800299c:	e0042000 	.word	0xe0042000

080029a0 <HAL_DBGMCU_EnableDBGStandbyMode>:
  SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 80029a0:	4a02      	ldr	r2, [pc, #8]	; (80029ac <HAL_DBGMCU_EnableDBGStandbyMode+0xc>)
 80029a2:	6853      	ldr	r3, [r2, #4]
 80029a4:	f043 0304 	orr.w	r3, r3, #4
 80029a8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_EnableDBGStandbyMode(void)
{
  LL_DBGMCU_EnableDBGStandbyMode();
}
 80029aa:	4770      	bx	lr
 80029ac:	e0042000 	.word	0xe0042000

080029b0 <HAL_DBGMCU_DisableDBGStandbyMode>:
  CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
 80029b0:	4a02      	ldr	r2, [pc, #8]	; (80029bc <HAL_DBGMCU_DisableDBGStandbyMode+0xc>)
 80029b2:	6853      	ldr	r3, [r2, #4]
 80029b4:	f023 0304 	bic.w	r3, r3, #4
 80029b8:	6053      	str	r3, [r2, #4]
  * @retval None
  */
void HAL_DBGMCU_DisableDBGStandbyMode(void)
{
  LL_DBGMCU_DisableDBGStandbyMode();
}
 80029ba:	4770      	bx	lr
 80029bc:	e0042000 	.word	0xe0042000

080029c0 <LL_ADC_REG_IsConversionOngoing>:
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80029c0:	6880      	ldr	r0, [r0, #8]
}
 80029c2:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80029c6:	4770      	bx	lr

080029c8 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 80029c8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR1 = 0UL;
  uint32_t tmpCFGR2 = 0UL;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 80029cc:	2300      	movs	r3, #0
 80029ce:	9301      	str	r3, [sp, #4]

  /* Check ADC handle */
  if (hadc == NULL)
 80029d0:	4604      	mov	r4, r0
 80029d2:	2800      	cmp	r0, #0
 80029d4:	f000 810a 	beq.w	8002bec <HAL_ADC_Init+0x224>
  /* continuous mode is disabled.                                             */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 80029d8:	6d85      	ldr	r5, [r0, #88]	; 0x58
 80029da:	b925      	cbnz	r5, 80029e6 <HAL_ADC_Init+0x1e>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 80029dc:	f7fe f98e 	bl	8000cfc <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 80029e0:	65e5      	str	r5, [r4, #92]	; 0x5c

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 80029e2:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80029e6:	6820      	ldr	r0, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80029e8:	6883      	ldr	r3, [r0, #8]
 80029ea:	00d9      	lsls	r1, r3, #3
 80029ec:	f140 80b3 	bpl.w	8002b56 <HAL_ADC_Init+0x18e>
 80029f0:	6883      	ldr	r3, [r0, #8]
 80029f2:	00da      	lsls	r2, r3, #3
 80029f4:	f100 80c6 	bmi.w	8002b84 <HAL_ADC_Init+0x1bc>
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80029f8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80029fa:	f043 0310 	orr.w	r3, r3, #16
 80029fe:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002a00:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002a02:	f043 0301 	orr.w	r3, r3, #1
 8002a06:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8002a08:	2101      	movs	r1, #1

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002a0a:	f7ff ffd9 	bl	80029c0 <LL_ADC_REG_IsConversionOngoing>

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002a0e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002a10:	f003 0310 	and.w	r3, r3, #16
 8002a14:	4318      	orrs	r0, r3
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8002a16:	6da3      	ldr	r3, [r4, #88]	; 0x58
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002a18:	f040 80ea 	bne.w	8002bf0 <HAL_ADC_Init+0x228>
    ADC_STATE_CLR_SET(hadc->State,
 8002a1c:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8002a20:	f043 0302 	orr.w	r3, r3, #2
    /*  - Oversampling                                                        */
    /*  - Trigger frequency mode                                              */
    /* Note: If low power mode AutoPowerOff is enabled, ADC enable            */
    /*       and disable phases are performed automatically by hardware       */
    /*       (in this case, flag ADC_FLAG_RDY is not set).                    */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002a24:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 8002a26:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002a28:	6893      	ldr	r3, [r2, #8]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002a2a:	07db      	lsls	r3, r3, #31
 8002a2c:	f100 80ac 	bmi.w	8002b88 <HAL_ADC_Init+0x1c0>
      /* parameters):                                                         */
      /*   - internal measurement paths (VrefInt, ...)                        */
      /*     (set into HAL_ADC_ConfigChannel() )                              */

      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 8002a30:	68d3      	ldr	r3, [r2, #12]
 8002a32:	68a5      	ldr	r5, [r4, #8]
                 ADC_CFGR1_RES,
                 hadc->Init.Resolution);

      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8002a34:	6866      	ldr	r6, [r4, #4]
      MODIFY_REG(hadc->Instance->CFGR1,
 8002a36:	f023 0318 	bic.w	r3, r3, #24
 8002a3a:	432b      	orrs	r3, r5
 8002a3c:	60d3      	str	r3, [r2, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8002a3e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8002a40:	f006 4c40 	and.w	ip, r6, #3221225472	; 0xc0000000
 8002a44:	ea4c 0503 	orr.w	r5, ip, r3
                   hadc->Init.TriggerFrequencyMode
                  );

      if (hadc->Init.OversamplingMode == ENABLE)
 8002a48:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 8002a4c:	2b01      	cmp	r3, #1
 8002a4e:	d109      	bne.n	8002a64 <HAL_ADC_Init+0x9c>
      {
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 8002a50:	e9d4 3710 	ldrd	r3, r7, [r4, #64]	; 0x40
 8002a54:	433b      	orrs	r3, r7
 8002a56:	432b      	orrs	r3, r5
 8002a58:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8002a5a:	432b      	orrs	r3, r5
 8002a5c:	ea43 030c 	orr.w	r3, r3, ip
 8002a60:	f043 0501 	orr.w	r5, r3, #1
                     hadc->Init.Oversampling.RightBitShift |
                     hadc->Init.Oversampling.TriggeredMode
                    );
      }

      MODIFY_REG(hadc->Instance->CFGR2,
 8002a64:	6917      	ldr	r7, [r2, #16]
 8002a66:	4b64      	ldr	r3, [pc, #400]	; (8002bf8 <HAL_ADC_Init+0x230>)
 8002a68:	403b      	ands	r3, r7
 8002a6a:	432b      	orrs	r3, r5
 8002a6c:	6113      	str	r3, [r2, #16]
                 ADC_CFGR2_TOVS,
                 tmpCFGR2);

      /* Configuration of ADC clock mode: asynchronous clock source           */
      /* with selectable prescaler.                                           */
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 8002a6e:	f026 4300 	bic.w	r3, r6, #2147483648	; 0x80000000
 8002a72:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002a76:	d00a      	beq.n	8002a8e <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 8002a78:	f1b6 4f00 	cmp.w	r6, #2147483648	; 0x80000000
 8002a7c:	d007      	beq.n	8002a8e <HAL_ADC_Init+0xc6>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV4))
      {
        MODIFY_REG(ADC_COMMON->CCR,
 8002a7e:	4f5f      	ldr	r7, [pc, #380]	; (8002bfc <HAL_ADC_Init+0x234>)
 8002a80:	683b      	ldr	r3, [r7, #0]
 8002a82:	f406 1670 	and.w	r6, r6, #3932160	; 0x3c0000
 8002a86:	f423 1370 	bic.w	r3, r3, #3932160	; 0x3c0000
 8002a8a:	431e      	orrs	r6, r3
 8002a8c:	603e      	str	r6, [r7, #0]
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 8002a8e:	7e63      	ldrb	r3, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 8002a90:	7e26      	ldrb	r6, [r4, #24]
 8002a92:	68e7      	ldr	r7, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 8002a94:	f8d4 c030 	ldr.w	ip, [r4, #48]	; 0x30
                 hadc->Init.DataAlign                                           |
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 8002a98:	f894 802c 	ldrb.w	r8, [r4, #44]	; 0x2c
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 8002a9c:	03db      	lsls	r3, r3, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 8002a9e:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 8002aa2:	7ea6      	ldrb	r6, [r4, #26]
 8002aa4:	433b      	orrs	r3, r7
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 8002aa6:	f1bc 0f00 	cmp.w	ip, #0
 8002aaa:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 8002aae:	bf18      	it	ne
 8002ab0:	f44f 5c80 	movne.w	ip, #4096	; 0x1000
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8002ab4:	6927      	ldr	r7, [r4, #16]
 8002ab6:	ea43 0348 	orr.w	r3, r3, r8, lsl #1
 8002aba:	ea43 030c 	orr.w	r3, r3, ip

    /* Update setting of discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002abe:	f894 c020 	ldrb.w	ip, [r4, #32]
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8002ac2:	2f00      	cmp	r7, #0
 8002ac4:	bfb4      	ite	lt
 8002ac6:	f027 4e00 	biclt.w	lr, r7, #2147483648	; 0x80000000
 8002aca:	f44f 1e00 	movge.w	lr, #2097152	; 0x200000
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002ace:	f1bc 0f01 	cmp.w	ip, #1
                 ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8002ad2:	ea43 0e0e 	orr.w	lr, r3, lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002ad6:	d103      	bne.n	8002ae0 <HAL_ADC_Init+0x118>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8002ad8:	2e00      	cmp	r6, #0
 8002ada:	d157      	bne.n	8002b8c <HAL_ADC_Init+0x1c4>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8002adc:	f44e 3e80 	orr.w	lr, lr, #65536	; 0x10000
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8002ae0:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8002ae2:	b12e      	cbz	r6, 8002af0 <HAL_ADC_Init+0x128>
    {
      tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 8002ae4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002ae6:	f406 76e0 	and.w	r6, r6, #448	; 0x1c0
 8002aea:	431e      	orrs	r6, r3
 8002aec:	ea4e 0e06 	orr.w	lr, lr, r6
                   hadc->Init.ExternalTrigConvEdge);
    }

    /* Update ADC configuration register with previous settings */
    MODIFY_REG(hadc->Instance->CFGR1,
 8002af0:	68d6      	ldr	r6, [r2, #12]
 8002af2:	f426 36fe 	bic.w	r6, r6, #130048	; 0x1fc00
 8002af6:	f426 76f3 	bic.w	r6, r6, #486	; 0x1e6
 8002afa:	ea46 060e 	orr.w	r6, r6, lr
 8002afe:	60d6      	str	r6, [r2, #12]
               ADC_CFGR1_ALIGN   |
               ADC_CFGR1_SCANDIR |
               ADC_CFGR1_DMACFG,
               tmpCFGR1);

    MODIFY_REG(hadc->Instance->CFGR2,
 8002b00:	f8d2 c010 	ldr.w	ip, [r2, #16]
 8002b04:	4e3e      	ldr	r6, [pc, #248]	; (8002c00 <HAL_ADC_Init+0x238>)
 8002b06:	ea0c 0606 	and.w	r6, ip, r6
 8002b0a:	4335      	orrs	r5, r6
 8002b0c:	6115      	str	r5, [r2, #16]
  MODIFY_REG(ADCx->SMPR,
 8002b0e:	6955      	ldr	r5, [r2, #20]
 8002b10:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8002b12:	f025 0507 	bic.w	r5, r5, #7
 8002b16:	4335      	orrs	r5, r6
 8002b18:	6155      	str	r5, [r2, #20]
 8002b1a:	6955      	ldr	r5, [r2, #20]
 8002b1c:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 8002b1e:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 8002b22:	ea45 1506 	orr.w	r5, r5, r6, lsl #4
 8002b26:	6155      	str	r5, [r2, #20]
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */
    /*   Channels must be configured into each rank using function            */
    /*   "HAL_ADC_ConfigChannel()".                                           */
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 8002b28:	2f00      	cmp	r7, #0
 8002b2a:	d138      	bne.n	8002b9e <HAL_ADC_Init+0x1d6>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
      {
        /* Set ADC group regular sequencer:                                   */
        /* Set sequencer scan length by clearing ranks above rank 1           */
        /* and do not modify rank 1 value.                                    */
        SET_BIT(hadc->Instance->CHSELR,
 8002b2c:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002b2e:	f060 000f 	orn	r0, r0, #15
        /*          therefore after the first call of "HAL_ADC_Init()",       */
        /*          each rank corresponding to parameter "NbrOfConversion"    */
        /*          must be set using "HAL_ADC_ConfigChannel()".              */
        /*  - Set sequencer scan length by clearing ranks above maximum rank  */
        /*    and do not modify other ranks value.                            */
        MODIFY_REG(hadc->Instance->CHSELR,
 8002b32:	6290      	str	r0, [r2, #40]	; 0x28
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core peripheral clocking.        */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWD1CH | ADC_CFGR1_AWD1EN | ADC_CFGR1_AWD1SGL | ADC_CFGR1_RES))
 8002b34:	68d0      	ldr	r0, [r2, #12]
 8002b36:	4a33      	ldr	r2, [pc, #204]	; (8002c04 <HAL_ADC_Init+0x23c>)
 8002b38:	4002      	ands	r2, r0
 8002b3a:	4572      	cmp	r2, lr
 8002b3c:	d14c      	bne.n	8002bd8 <HAL_ADC_Init+0x210>
        == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 8002b3e:	2300      	movs	r3, #0
 8002b40:	65e3      	str	r3, [r4, #92]	; 0x5c

      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 8002b42:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002b44:	f023 0303 	bic.w	r3, r3, #3
 8002b48:	f043 0301 	orr.w	r3, r3, #1
 8002b4c:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
  }

  return tmp_hal_status;
}
 8002b4e:	4608      	mov	r0, r1
 8002b50:	b002      	add	sp, #8
 8002b52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  MODIFY_REG(ADCx->CR,
 8002b56:	6883      	ldr	r3, [r0, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8002b58:	4a2b      	ldr	r2, [pc, #172]	; (8002c08 <HAL_ADC_Init+0x240>)
 8002b5a:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8002b5e:	f023 0317 	bic.w	r3, r3, #23
 8002b62:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002b66:	6083      	str	r3, [r0, #8]
 8002b68:	4b28      	ldr	r3, [pc, #160]	; (8002c0c <HAL_ADC_Init+0x244>)
 8002b6a:	681b      	ldr	r3, [r3, #0]
 8002b6c:	fbb3 f3f2 	udiv	r3, r3, r2
 8002b70:	3301      	adds	r3, #1
 8002b72:	005b      	lsls	r3, r3, #1
      wait_loop_index--;
 8002b74:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8002b76:	9b01      	ldr	r3, [sp, #4]
 8002b78:	2b00      	cmp	r3, #0
 8002b7a:	f43f af39 	beq.w	80029f0 <HAL_ADC_Init+0x28>
      wait_loop_index--;
 8002b7e:	9b01      	ldr	r3, [sp, #4]
 8002b80:	3b01      	subs	r3, #1
 8002b82:	e7f7      	b.n	8002b74 <HAL_ADC_Init+0x1ac>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002b84:	2100      	movs	r1, #0
 8002b86:	e740      	b.n	8002a0a <HAL_ADC_Init+0x42>
  uint32_t tmpCFGR2 = 0UL;
 8002b88:	4605      	mov	r5, r0
 8002b8a:	e780      	b.n	8002a8e <HAL_ADC_Init+0xc6>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002b8c:	6da6      	ldr	r6, [r4, #88]	; 0x58
 8002b8e:	f046 0620 	orr.w	r6, r6, #32
 8002b92:	65a6      	str	r6, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002b94:	6de6      	ldr	r6, [r4, #92]	; 0x5c
 8002b96:	f046 0601 	orr.w	r6, r6, #1
 8002b9a:	65e6      	str	r6, [r4, #92]	; 0x5c
 8002b9c:	e7a0      	b.n	8002ae0 <HAL_ADC_Init+0x118>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8002b9e:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 8002ba2:	d1c7      	bne.n	8002b34 <HAL_ADC_Init+0x16c>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 8002ba4:	6e26      	ldr	r6, [r4, #96]	; 0x60
 8002ba6:	0085      	lsls	r5, r0, #2
 8002ba8:	fa26 f505 	lsr.w	r5, r6, r5
 8002bac:	f005 050f 	and.w	r5, r5, #15
 8002bb0:	2d0f      	cmp	r5, #15
 8002bb2:	d00e      	beq.n	8002bd2 <HAL_ADC_Init+0x20a>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 8002bb4:	3001      	adds	r0, #1
 8002bb6:	2808      	cmp	r0, #8
 8002bb8:	d1f5      	bne.n	8002ba6 <HAL_ADC_Init+0x1de>
        MODIFY_REG(hadc->Instance->CHSELR,
 8002bba:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002bbc:	69e0      	ldr	r0, [r4, #28]
 8002bbe:	3801      	subs	r0, #1
 8002bc0:	0080      	lsls	r0, r0, #2
 8002bc2:	f000 001c 	and.w	r0, r0, #28
 8002bc6:	f06f 050f 	mvn.w	r5, #15
 8002bca:	fa05 f000 	lsl.w	r0, r5, r0
 8002bce:	4330      	orrs	r0, r6
 8002bd0:	e7af      	b.n	8002b32 <HAL_ADC_Init+0x16a>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 8002bd2:	2801      	cmp	r0, #1
 8002bd4:	d0aa      	beq.n	8002b2c <HAL_ADC_Init+0x164>
 8002bd6:	e7f0      	b.n	8002bba <HAL_ADC_Init+0x1f2>
      ADC_STATE_CLR_SET(hadc->State,
 8002bd8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002bda:	f023 0312 	bic.w	r3, r3, #18
 8002bde:	f043 0310 	orr.w	r3, r3, #16
 8002be2:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002be4:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002be6:	f043 0301 	orr.w	r3, r3, #1
 8002bea:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 8002bec:	2101      	movs	r1, #1
 8002bee:	e7ae      	b.n	8002b4e <HAL_ADC_Init+0x186>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002bf0:	f043 0310 	orr.w	r3, r3, #16
 8002bf4:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 8002bf6:	e7f9      	b.n	8002bec <HAL_ADC_Init+0x224>
 8002bf8:	1ffffc02 	.word	0x1ffffc02
 8002bfc:	40012708 	.word	0x40012708
 8002c00:	dffffc02 	.word	0xdffffc02
 8002c04:	833fffe7 	.word	0x833fffe7
 8002c08:	00030d40 	.word	0x00030d40
 8002c0c:	20000050 	.word	0x20000050

08002c10 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 8002c10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8002c12:	6945      	ldr	r5, [r0, #20]
 8002c14:	2d08      	cmp	r5, #8
{
 8002c16:	4604      	mov	r4, r0
 8002c18:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 8002c1a:	d00a      	beq.n	8002c32 <HAL_ADC_PollForConversion+0x22>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 8002c1c:	6803      	ldr	r3, [r0, #0]
 8002c1e:	68db      	ldr	r3, [r3, #12]
 8002c20:	07d9      	lsls	r1, r3, #31
 8002c22:	d505      	bpl.n	8002c30 <HAL_ADC_PollForConversion+0x20>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002c24:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8002c26:	f043 0320 	orr.w	r3, r3, #32
 8002c2a:	6583      	str	r3, [r0, #88]	; 0x58

      return HAL_ERROR;
 8002c2c:	2001      	movs	r0, #1
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
  }

  /* Return function status */
  return HAL_OK;
}
 8002c2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      tmp_flag_end = (ADC_FLAG_EOC);
 8002c30:	2504      	movs	r5, #4
  tickstart = HAL_GetTick();
 8002c32:	f7fe fc4f 	bl	80014d4 <HAL_GetTick>
 8002c36:	4607      	mov	r7, r0
  while ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8002c38:	6820      	ldr	r0, [r4, #0]
 8002c3a:	6803      	ldr	r3, [r0, #0]
 8002c3c:	422b      	tst	r3, r5
 8002c3e:	d022      	beq.n	8002c86 <HAL_ADC_PollForConversion+0x76>
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8002c40:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002c42:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002c46:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 8002c48:	68c3      	ldr	r3, [r0, #12]
 8002c4a:	f413 6f40 	tst.w	r3, #3072	; 0xc00
 8002c4e:	d114      	bne.n	8002c7a <HAL_ADC_PollForConversion+0x6a>
      && (hadc->Init.ContinuousConvMode == DISABLE)
 8002c50:	7ea3      	ldrb	r3, [r4, #26]
 8002c52:	b993      	cbnz	r3, 8002c7a <HAL_ADC_PollForConversion+0x6a>
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8002c54:	6803      	ldr	r3, [r0, #0]
 8002c56:	071b      	lsls	r3, r3, #28
 8002c58:	d50f      	bpl.n	8002c7a <HAL_ADC_PollForConversion+0x6a>
      if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002c5a:	f7ff feb1 	bl	80029c0 <LL_ADC_REG_IsConversionOngoing>
 8002c5e:	bb38      	cbnz	r0, 8002cb0 <HAL_ADC_PollForConversion+0xa0>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8002c60:	6822      	ldr	r2, [r4, #0]
 8002c62:	6853      	ldr	r3, [r2, #4]
 8002c64:	f023 030c 	bic.w	r3, r3, #12
 8002c68:	6053      	str	r3, [r2, #4]
        ADC_STATE_CLR_SET(hadc->State,
 8002c6a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002c6c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002c70:	f023 0301 	bic.w	r3, r3, #1
 8002c74:	f043 0301 	orr.w	r3, r3, #1
 8002c78:	65a3      	str	r3, [r4, #88]	; 0x58
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 8002c7a:	7e20      	ldrb	r0, [r4, #24]
 8002c7c:	bb08      	cbnz	r0, 8002cc2 <HAL_ADC_PollForConversion+0xb2>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8002c7e:	6823      	ldr	r3, [r4, #0]
 8002c80:	220c      	movs	r2, #12
 8002c82:	601a      	str	r2, [r3, #0]
 8002c84:	e7d3      	b.n	8002c2e <HAL_ADC_PollForConversion+0x1e>
    if (Timeout != HAL_MAX_DELAY)
 8002c86:	1c72      	adds	r2, r6, #1
 8002c88:	d0d7      	beq.n	8002c3a <HAL_ADC_PollForConversion+0x2a>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 8002c8a:	f7fe fc23 	bl	80014d4 <HAL_GetTick>
 8002c8e:	1bc0      	subs	r0, r0, r7
 8002c90:	42b0      	cmp	r0, r6
 8002c92:	d801      	bhi.n	8002c98 <HAL_ADC_PollForConversion+0x88>
 8002c94:	2e00      	cmp	r6, #0
 8002c96:	d1cf      	bne.n	8002c38 <HAL_ADC_PollForConversion+0x28>
        if ((hadc->Instance->ISR & tmp_flag_end) == 0UL)
 8002c98:	6823      	ldr	r3, [r4, #0]
 8002c9a:	681b      	ldr	r3, [r3, #0]
 8002c9c:	402b      	ands	r3, r5
 8002c9e:	d1cb      	bne.n	8002c38 <HAL_ADC_PollForConversion+0x28>
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8002ca0:	6da2      	ldr	r2, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 8002ca2:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8002ca6:	f042 0204 	orr.w	r2, r2, #4
 8002caa:	65a2      	str	r2, [r4, #88]	; 0x58
          return HAL_TIMEOUT;
 8002cac:	2003      	movs	r0, #3
 8002cae:	e7be      	b.n	8002c2e <HAL_ADC_PollForConversion+0x1e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002cb0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002cb2:	f043 0320 	orr.w	r3, r3, #32
 8002cb6:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002cb8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002cba:	f043 0301 	orr.w	r3, r3, #1
 8002cbe:	65e3      	str	r3, [r4, #92]	; 0x5c
 8002cc0:	e7db      	b.n	8002c7a <HAL_ADC_PollForConversion+0x6a>
  return HAL_OK;
 8002cc2:	2000      	movs	r0, #0
 8002cc4:	e7b3      	b.n	8002c2e <HAL_ADC_PollForConversion+0x1e>

08002cc6 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 8002cc6:	6803      	ldr	r3, [r0, #0]
 8002cc8:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 8002cca:	4770      	bx	lr

08002ccc <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param pConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *pConfig)
{
 8002ccc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 8002cce:	2300      	movs	r3, #0
 8002cd0:	9301      	str	r3, [sp, #4]
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));

    assert_param(IS_ADC_REGULAR_RANK(pConfig->Rank));
  }

  __HAL_LOCK(hadc);
 8002cd2:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 8002cd6:	2b01      	cmp	r3, #1
{
 8002cd8:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8002cda:	f000 80bb 	beq.w	8002e54 <HAL_ADC_ConfigChannel+0x188>
 8002cde:	2301      	movs	r3, #1
 8002ce0:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002ce4:	6800      	ldr	r0, [r0, #0]
 8002ce6:	f7ff fe6b 	bl	80029c0 <LL_ADC_REG_IsConversionOngoing>
 8002cea:	2800      	cmp	r0, #0
 8002cec:	f040 80ac 	bne.w	8002e48 <HAL_ADC_ConfigChannel+0x17c>
    /* If sequencer set to not fully configurable with channel rank set to    */
    /* none, remove the channel from the sequencer.                           */
    /* Otherwise (sequencer set to fully configurable or to to not fully      */
    /* configurable with channel rank to be set), configure the selected      */
    /* channel.                                                               */
    if (pConfig->Rank != ADC_RANK_NONE)
 8002cf0:	6848      	ldr	r0, [r1, #4]
 8002cf2:	6923      	ldr	r3, [r4, #16]
 8002cf4:	680a      	ldr	r2, [r1, #0]
 8002cf6:	2802      	cmp	r0, #2
 8002cf8:	f023 0304 	bic.w	r3, r3, #4
 8002cfc:	d07c      	beq.n	8002df8 <HAL_ADC_ConfigChannel+0x12c>
      /* Note: ADC channel configuration requires few ADC clock cycles        */
      /*       to be ready. Processing of ADC settings in this function       */
      /*       induce that a specific wait time is not necessary.             */
      /*       For more details on ADC channel configuration ready,           */
      /*       refer to function "LL_ADC_IsActiveFlag_CCRDY()".               */
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8002cfe:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8002d02:	6825      	ldr	r5, [r4, #0]
 8002d04:	f3c2 0e11 	ubfx	lr, r2, #0, #18
 8002d08:	d113      	bne.n	8002d32 <HAL_ADC_ConfigChannel+0x66>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8002d0a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002d0c:	ea43 030e 	orr.w	r3, r3, lr
  MODIFY_REG(ADCx->CHSELR,
 8002d10:	62ab      	str	r3, [r5, #40]	; 0x28
  MODIFY_REG(ADCx->SMPR,
 8002d12:	688b      	ldr	r3, [r1, #8]
 8002d14:	6968      	ldr	r0, [r5, #20]
 8002d16:	ea03 2302 	and.w	r3, r3, r2, lsl #8
 8002d1a:	f023 437c 	bic.w	r3, r3, #4227858432	; 0xfc000000
 8002d1e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8002d22:	ea20 2102 	bic.w	r1, r0, r2, lsl #8
 8002d26:	430b      	orrs	r3, r1
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 8002d28:	2a00      	cmp	r2, #0
 8002d2a:	616b      	str	r3, [r5, #20]
 8002d2c:	db26      	blt.n	8002d7c <HAL_ADC_ConfigChannel+0xb0>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002d2e:	2000      	movs	r0, #0
}
 8002d30:	e050      	b.n	8002dd4 <HAL_ADC_ConfigChannel+0x108>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8002d32:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002d34:	f000 071f 	and.w	r7, r0, #31
 8002d38:	f04f 0c0f 	mov.w	ip, #15
 8002d3c:	fa0c fc07 	lsl.w	ip, ip, r7
 8002d40:	ea6f 060c 	mvn.w	r6, ip
 8002d44:	ea23 0c0c 	bic.w	ip, r3, ip
 8002d48:	f1be 0f00 	cmp.w	lr, #0
 8002d4c:	d111      	bne.n	8002d72 <HAL_ADC_ConfigChannel+0xa6>
 8002d4e:	f3c2 6384 	ubfx	r3, r2, #26, #5
 8002d52:	40bb      	lsls	r3, r7
 8002d54:	ea43 030c 	orr.w	r3, r3, ip
 8002d58:	6623      	str	r3, [r4, #96]	; 0x60
        if (((pConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 8002d5a:	0880      	lsrs	r0, r0, #2
 8002d5c:	69e3      	ldr	r3, [r4, #28]
 8002d5e:	3001      	adds	r0, #1
 8002d60:	4298      	cmp	r0, r3
 8002d62:	d8d6      	bhi.n	8002d12 <HAL_ADC_ConfigChannel+0x46>
  MODIFY_REG(ADCx->CHSELR,
 8002d64:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 8002d66:	f3c2 6383 	ubfx	r3, r2, #26, #4
 8002d6a:	40bb      	lsls	r3, r7
 8002d6c:	4006      	ands	r6, r0
 8002d6e:	4333      	orrs	r3, r6
 8002d70:	e7ce      	b.n	8002d10 <HAL_ADC_ConfigChannel+0x44>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002d72:	fa92 f3a2 	rbit	r3, r2
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 8002d76:	fab3 f383 	clz	r3, r3
 8002d7a:	e7ea      	b.n	8002d52 <HAL_ADC_ConfigChannel+0x86>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8002d7c:	4936      	ldr	r1, [pc, #216]	; (8002e58 <HAL_ADC_ConfigChannel+0x18c>)
      {
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));

        /* If the requested internal measurement path has already been enabled,   */
        /* bypass the configuration processing.                                   */
        if ((pConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8002d7e:	4837      	ldr	r0, [pc, #220]	; (8002e5c <HAL_ADC_ConfigChannel+0x190>)
 8002d80:	680b      	ldr	r3, [r1, #0]
 8002d82:	4282      	cmp	r2, r0
 8002d84:	f003 75e0 	and.w	r5, r3, #29360128	; 0x1c00000
 8002d88:	d117      	bne.n	8002dba <HAL_ADC_ConfigChannel+0xee>
 8002d8a:	021b      	lsls	r3, r3, #8
 8002d8c:	d4cf      	bmi.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8002d8e:	680b      	ldr	r3, [r1, #0]
          /* Delay for temperature sensor stabilization time */
          /* Wait loop initialization and execution */
          /* Note: Variable divided by 2 to compensate partially              */
          /*       CPU processing cycles, scaling in us split to not          */
          /*       exceed 32 bits register capacity and handle low frequency. */
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8002d90:	4a33      	ldr	r2, [pc, #204]	; (8002e60 <HAL_ADC_ConfigChannel+0x194>)
 8002d92:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8002d96:	432b      	orrs	r3, r5
 8002d98:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8002d9c:	600b      	str	r3, [r1, #0]
 8002d9e:	4b31      	ldr	r3, [pc, #196]	; (8002e64 <HAL_ADC_ConfigChannel+0x198>)
 8002da0:	681b      	ldr	r3, [r3, #0]
 8002da2:	fbb3 f2f2 	udiv	r2, r3, r2
 8002da6:	230c      	movs	r3, #12
 8002da8:	fb02 3303 	mla	r3, r2, r3, r3
          while (wait_loop_index != 0UL)
          {
            wait_loop_index--;
 8002dac:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 8002dae:	9b01      	ldr	r3, [sp, #4]
 8002db0:	2b00      	cmp	r3, #0
 8002db2:	d0bc      	beq.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
            wait_loop_index--;
 8002db4:	9b01      	ldr	r3, [sp, #4]
 8002db6:	3b01      	subs	r3, #1
 8002db8:	e7f8      	b.n	8002dac <HAL_ADC_ConfigChannel+0xe0>
          }
        }
        else if ((pConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8002dba:	482b      	ldr	r0, [pc, #172]	; (8002e68 <HAL_ADC_ConfigChannel+0x19c>)
 8002dbc:	4282      	cmp	r2, r0
 8002dbe:	d10e      	bne.n	8002dde <HAL_ADC_ConfigChannel+0x112>
 8002dc0:	f013 7080 	ands.w	r0, r3, #16777216	; 0x1000000
 8002dc4:	d1b3      	bne.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
 8002dc6:	680b      	ldr	r3, [r1, #0]
 8002dc8:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8002dcc:	432b      	orrs	r3, r5
 8002dce:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002dd2:	600b      	str	r3, [r1, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);

    tmp_hal_status = HAL_ERROR;
  }

  __HAL_UNLOCK(hadc);
 8002dd4:	2300      	movs	r3, #0
 8002dd6:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

  return tmp_hal_status;
}
 8002dda:	b003      	add	sp, #12
 8002ddc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        else if ((pConfig->Channel == ADC_CHANNEL_VREFINT) &&
 8002dde:	4823      	ldr	r0, [pc, #140]	; (8002e6c <HAL_ADC_ConfigChannel+0x1a0>)
 8002de0:	4282      	cmp	r2, r0
 8002de2:	d1a4      	bne.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
 8002de4:	f413 0080 	ands.w	r0, r3, #4194304	; 0x400000
 8002de8:	d1a1      	bne.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
 8002dea:	680b      	ldr	r3, [r1, #0]
 8002dec:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 8002df0:	432b      	orrs	r3, r5
 8002df2:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8002df6:	e7ec      	b.n	8002dd2 <HAL_ADC_ConfigChannel+0x106>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8002df8:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8002dfc:	d106      	bne.n	8002e0c <HAL_ADC_ConfigChannel+0x140>
        LL_ADC_REG_SetSequencerChRem(hadc->Instance, pConfig->Channel);
 8002dfe:	6821      	ldr	r1, [r4, #0]
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8002e00:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8002e02:	f3c2 0011 	ubfx	r0, r2, #0, #18
 8002e06:	ea23 0300 	bic.w	r3, r3, r0
 8002e0a:	628b      	str	r3, [r1, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(pConfig->Channel))
 8002e0c:	2a00      	cmp	r2, #0
 8002e0e:	da8e      	bge.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
        if (pConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8002e10:	4812      	ldr	r0, [pc, #72]	; (8002e5c <HAL_ADC_ConfigChannel+0x190>)
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8002e12:	4911      	ldr	r1, [pc, #68]	; (8002e58 <HAL_ADC_ConfigChannel+0x18c>)
 8002e14:	4282      	cmp	r2, r0
 8002e16:	680b      	ldr	r3, [r1, #0]
 8002e18:	d107      	bne.n	8002e2a <HAL_ADC_ConfigChannel+0x15e>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8002e1a:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8002e1c:	f003 73a0 	and.w	r3, r3, #20971520	; 0x1400000
 8002e20:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 8002e24:	4313      	orrs	r3, r2
 8002e26:	600b      	str	r3, [r1, #0]
 8002e28:	e781      	b.n	8002d2e <HAL_ADC_ConfigChannel+0x62>
        else if (pConfig->Channel == ADC_CHANNEL_VBAT)
 8002e2a:	480f      	ldr	r0, [pc, #60]	; (8002e68 <HAL_ADC_ConfigChannel+0x19c>)
 8002e2c:	4282      	cmp	r2, r0
 8002e2e:	d103      	bne.n	8002e38 <HAL_ADC_ConfigChannel+0x16c>
 8002e30:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8002e32:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 8002e36:	e7f3      	b.n	8002e20 <HAL_ADC_ConfigChannel+0x154>
        else if (pConfig->Channel == ADC_CHANNEL_VREFINT)
 8002e38:	480c      	ldr	r0, [pc, #48]	; (8002e6c <HAL_ADC_ConfigChannel+0x1a0>)
 8002e3a:	4282      	cmp	r2, r0
 8002e3c:	f47f af77 	bne.w	8002d2e <HAL_ADC_ConfigChannel+0x62>
 8002e40:	680a      	ldr	r2, [r1, #0]
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8002e42:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
 8002e46:	e7eb      	b.n	8002e20 <HAL_ADC_ConfigChannel+0x154>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002e48:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8002e4a:	f042 0220 	orr.w	r2, r2, #32
 8002e4e:	65a2      	str	r2, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 8002e50:	4618      	mov	r0, r3
 8002e52:	e7bf      	b.n	8002dd4 <HAL_ADC_ConfigChannel+0x108>
  __HAL_LOCK(hadc);
 8002e54:	2002      	movs	r0, #2
 8002e56:	e7c0      	b.n	8002dda <HAL_ADC_ConfigChannel+0x10e>
 8002e58:	40012708 	.word	0x40012708
 8002e5c:	b0001000 	.word	0xb0001000
 8002e60:	00030d40 	.word	0x00030d40
 8002e64:	20000050 	.word	0x20000050
 8002e68:	b8004000 	.word	0xb8004000
 8002e6c:	b4002000 	.word	0xb4002000

08002e70 <ADC_ConversionStop>:
  *         stopped to disable the ADC.
  * @param  hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop(ADC_HandleTypeDef *hadc)
{
 8002e70:	b538      	push	{r3, r4, r5, lr}
 8002e72:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Verification if ADC is not already stopped on regular group to bypass    */
  /* this function if not needed.                                             */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) != 0UL)
 8002e74:	6800      	ldr	r0, [r0, #0]
 8002e76:	f7ff fda3 	bl	80029c0 <LL_ADC_REG_IsConversionOngoing>
 8002e7a:	b908      	cbnz	r0, 8002e80 <ADC_ConversionStop+0x10>
    }

  }

  /* Return HAL status */
  return HAL_OK;
 8002e7c:	2000      	movs	r0, #0
}
 8002e7e:	bd38      	pop	{r3, r4, r5, pc}
    if (LL_ADC_IsDisableOngoing(hadc->Instance) == 0UL)
 8002e80:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8002e82:	6893      	ldr	r3, [r2, #8]
 8002e84:	0799      	lsls	r1, r3, #30
 8002e86:	d407      	bmi.n	8002e98 <ADC_ConversionStop+0x28>
  MODIFY_REG(ADCx->CR,
 8002e88:	6893      	ldr	r3, [r2, #8]
 8002e8a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8002e8e:	f023 0317 	bic.w	r3, r3, #23
 8002e92:	f043 0310 	orr.w	r3, r3, #16
 8002e96:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 8002e98:	f7fe fb1c 	bl	80014d4 <HAL_GetTick>
 8002e9c:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 8002e9e:	6823      	ldr	r3, [r4, #0]
 8002ea0:	689b      	ldr	r3, [r3, #8]
 8002ea2:	075b      	lsls	r3, r3, #29
 8002ea4:	d5ea      	bpl.n	8002e7c <ADC_ConversionStop+0xc>
      if ((HAL_GetTick() - tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 8002ea6:	f7fe fb15 	bl	80014d4 <HAL_GetTick>
 8002eaa:	1b40      	subs	r0, r0, r5
 8002eac:	2802      	cmp	r0, #2
 8002eae:	d9f6      	bls.n	8002e9e <ADC_ConversionStop+0x2e>
        if ((hadc->Instance->CR & ADC_CR_ADSTART) != 0UL)
 8002eb0:	6823      	ldr	r3, [r4, #0]
 8002eb2:	689b      	ldr	r3, [r3, #8]
 8002eb4:	075a      	lsls	r2, r3, #29
 8002eb6:	d5f2      	bpl.n	8002e9e <ADC_ConversionStop+0x2e>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002eb8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002eba:	f043 0310 	orr.w	r3, r3, #16
 8002ebe:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002ec0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002ec2:	f043 0301 	orr.w	r3, r3, #1
 8002ec6:	65e3      	str	r3, [r4, #92]	; 0x5c
 8002ec8:	2001      	movs	r0, #1
 8002eca:	e7d8      	b.n	8002e7e <ADC_ConversionStop+0xe>

08002ecc <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 8002ecc:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 8002ece:	2300      	movs	r3, #0

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002ed0:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0UL;
 8002ed2:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002ed4:	6893      	ldr	r3, [r2, #8]
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002ed6:	07dd      	lsls	r5, r3, #31
{
 8002ed8:	4604      	mov	r4, r0
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002eda:	d502      	bpl.n	8002ee2 <ADC_Enable+0x16>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8002edc:	2000      	movs	r0, #0
}
 8002ede:	b002      	add	sp, #8
 8002ee0:	bd70      	pop	{r4, r5, r6, pc}
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8002ee2:	6891      	ldr	r1, [r2, #8]
 8002ee4:	4b21      	ldr	r3, [pc, #132]	; (8002f6c <ADC_Enable+0xa0>)
 8002ee6:	4219      	tst	r1, r3
 8002ee8:	d009      	beq.n	8002efe <ADC_Enable+0x32>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002eea:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002eec:	f043 0310 	orr.w	r3, r3, #16
 8002ef0:	65a3      	str	r3, [r4, #88]	; 0x58
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002ef2:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8002ef4:	f043 0301 	orr.w	r3, r3, #1
 8002ef8:	65e3      	str	r3, [r4, #92]	; 0x5c
            return HAL_ERROR;
 8002efa:	2001      	movs	r0, #1
 8002efc:	e7ef      	b.n	8002ede <ADC_Enable+0x12>
  MODIFY_REG(ADCx->CR,
 8002efe:	6893      	ldr	r3, [r2, #8]
 8002f00:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8002f04:	f023 0317 	bic.w	r3, r3, #23
 8002f08:	f043 0301 	orr.w	r3, r3, #1
 8002f0c:	6093      	str	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8002f0e:	4b18      	ldr	r3, [pc, #96]	; (8002f70 <ADC_Enable+0xa4>)
 8002f10:	681b      	ldr	r3, [r3, #0]
    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 8002f12:	0218      	lsls	r0, r3, #8
 8002f14:	d41c      	bmi.n	8002f50 <ADC_Enable+0x84>
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 8002f16:	7e63      	ldrb	r3, [r4, #25]
 8002f18:	2b01      	cmp	r3, #1
 8002f1a:	d0df      	beq.n	8002edc <ADC_Enable+0x10>
      tickstart = HAL_GetTick();
 8002f1c:	f7fe fada 	bl	80014d4 <HAL_GetTick>
  MODIFY_REG(ADCx->CR,
 8002f20:	4e14      	ldr	r6, [pc, #80]	; (8002f74 <ADC_Enable+0xa8>)
 8002f22:	4605      	mov	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8002f24:	6822      	ldr	r2, [r4, #0]
 8002f26:	6813      	ldr	r3, [r2, #0]
 8002f28:	07db      	lsls	r3, r3, #31
 8002f2a:	d4d7      	bmi.n	8002edc <ADC_Enable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002f2c:	6893      	ldr	r3, [r2, #8]
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002f2e:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 8002f30:	bf5f      	itttt	pl
 8002f32:	6893      	ldrpl	r3, [r2, #8]
 8002f34:	4033      	andpl	r3, r6
 8002f36:	f043 0301 	orrpl.w	r3, r3, #1
 8002f3a:	6093      	strpl	r3, [r2, #8]
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8002f3c:	f7fe faca 	bl	80014d4 <HAL_GetTick>
 8002f40:	1b40      	subs	r0, r0, r5
 8002f42:	2802      	cmp	r0, #2
 8002f44:	d9ee      	bls.n	8002f24 <ADC_Enable+0x58>
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8002f46:	6823      	ldr	r3, [r4, #0]
 8002f48:	681b      	ldr	r3, [r3, #0]
 8002f4a:	07da      	lsls	r2, r3, #31
 8002f4c:	d4ea      	bmi.n	8002f24 <ADC_Enable+0x58>
 8002f4e:	e7cc      	b.n	8002eea <ADC_Enable+0x1e>
      wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8002f50:	4b09      	ldr	r3, [pc, #36]	; (8002f78 <ADC_Enable+0xac>)
 8002f52:	4a0a      	ldr	r2, [pc, #40]	; (8002f7c <ADC_Enable+0xb0>)
 8002f54:	681b      	ldr	r3, [r3, #0]
 8002f56:	fbb3 f3f2 	udiv	r3, r3, r2
 8002f5a:	3301      	adds	r3, #1
        wait_loop_index--;
 8002f5c:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 8002f5e:	9b01      	ldr	r3, [sp, #4]
 8002f60:	2b00      	cmp	r3, #0
 8002f62:	d0d8      	beq.n	8002f16 <ADC_Enable+0x4a>
        wait_loop_index--;
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	3b01      	subs	r3, #1
 8002f68:	e7f8      	b.n	8002f5c <ADC_Enable+0x90>
 8002f6a:	bf00      	nop
 8002f6c:	80000017 	.word	0x80000017
 8002f70:	40012708 	.word	0x40012708
 8002f74:	7fffffe8 	.word	0x7fffffe8
 8002f78:	20000050 	.word	0x20000050
 8002f7c:	00030d40 	.word	0x00030d40

08002f80 <HAL_ADC_Start>:
{
 8002f80:	b538      	push	{r3, r4, r5, lr}
 8002f82:	4604      	mov	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002f84:	6800      	ldr	r0, [r0, #0]
 8002f86:	f7ff fd1b 	bl	80029c0 <LL_ADC_REG_IsConversionOngoing>
 8002f8a:	4605      	mov	r5, r0
 8002f8c:	bb20      	cbnz	r0, 8002fd8 <HAL_ADC_Start+0x58>
    __HAL_LOCK(hadc);
 8002f8e:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 8002f92:	2b01      	cmp	r3, #1
 8002f94:	d020      	beq.n	8002fd8 <HAL_ADC_Start+0x58>
 8002f96:	2301      	movs	r3, #1
 8002f98:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
    tmp_hal_status = ADC_Enable(hadc);
 8002f9c:	4620      	mov	r0, r4
 8002f9e:	f7ff ff95 	bl	8002ecc <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8002fa2:	b9b0      	cbnz	r0, 8002fd2 <HAL_ADC_Start+0x52>
      ADC_STATE_CLR_SET(hadc->State,
 8002fa4:	6da3      	ldr	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8002fa6:	6822      	ldr	r2, [r4, #0]
      ADC_STATE_CLR_SET(hadc->State,
 8002fa8:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8002fac:	f023 0301 	bic.w	r3, r3, #1
 8002fb0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002fb4:	65a3      	str	r3, [r4, #88]	; 0x58
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8002fb6:	231c      	movs	r3, #28
      ADC_CLEAR_ERRORCODE(hadc);
 8002fb8:	65e0      	str	r0, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8002fba:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 8002fbc:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 8002fc0:	6893      	ldr	r3, [r2, #8]
 8002fc2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8002fc6:	f023 0317 	bic.w	r3, r3, #23
 8002fca:	f043 0304 	orr.w	r3, r3, #4
 8002fce:	6093      	str	r3, [r2, #8]
}
 8002fd0:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 8002fd2:	f884 5054 	strb.w	r5, [r4, #84]	; 0x54
 8002fd6:	e7fb      	b.n	8002fd0 <HAL_ADC_Start+0x50>
    tmp_hal_status = HAL_BUSY;
 8002fd8:	2002      	movs	r0, #2
 8002fda:	e7f9      	b.n	8002fd0 <HAL_ADC_Start+0x50>

08002fdc <ADC_Disable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8002fdc:	6802      	ldr	r2, [r0, #0]
{
 8002fde:	b538      	push	{r3, r4, r5, lr}
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8002fe0:	6893      	ldr	r3, [r2, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002fe2:	6891      	ldr	r1, [r2, #8]
 8002fe4:	4604      	mov	r4, r0

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8002fe6:	07c8      	lsls	r0, r1, #31
 8002fe8:	d401      	bmi.n	8002fee <ADC_Disable+0x12>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8002fea:	2000      	movs	r0, #0
}
 8002fec:	bd38      	pop	{r3, r4, r5, pc}
      && (tmp_adc_is_disable_on_going == 0UL)
 8002fee:	0799      	lsls	r1, r3, #30
 8002ff0:	d4fb      	bmi.n	8002fea <ADC_Disable+0xe>
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8002ff2:	6893      	ldr	r3, [r2, #8]
 8002ff4:	f003 0305 	and.w	r3, r3, #5
 8002ff8:	2b01      	cmp	r3, #1
 8002ffa:	d119      	bne.n	8003030 <ADC_Disable+0x54>
  MODIFY_REG(ADCx->CR,
 8002ffc:	6893      	ldr	r3, [r2, #8]
 8002ffe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003002:	f023 0317 	bic.w	r3, r3, #23
 8003006:	f043 0302 	orr.w	r3, r3, #2
 800300a:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 800300c:	2303      	movs	r3, #3
 800300e:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8003010:	f7fe fa60 	bl	80014d4 <HAL_GetTick>
 8003014:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003016:	6823      	ldr	r3, [r4, #0]
 8003018:	689b      	ldr	r3, [r3, #8]
 800301a:	07db      	lsls	r3, r3, #31
 800301c:	d5e5      	bpl.n	8002fea <ADC_Disable+0xe>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800301e:	f7fe fa59 	bl	80014d4 <HAL_GetTick>
 8003022:	1b40      	subs	r0, r0, r5
 8003024:	2802      	cmp	r0, #2
 8003026:	d9f6      	bls.n	8003016 <ADC_Disable+0x3a>
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003028:	6823      	ldr	r3, [r4, #0]
 800302a:	689b      	ldr	r3, [r3, #8]
 800302c:	07da      	lsls	r2, r3, #31
 800302e:	d5f2      	bpl.n	8003016 <ADC_Disable+0x3a>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003030:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003032:	f043 0310 	orr.w	r3, r3, #16
 8003036:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003038:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800303a:	f043 0301 	orr.w	r3, r3, #1
 800303e:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 8003040:	2001      	movs	r0, #1
 8003042:	e7d3      	b.n	8002fec <ADC_Disable+0x10>

08003044 <HAL_ADC_DeInit>:
{
 8003044:	b570      	push	{r4, r5, r6, lr}
  if (hadc == NULL)
 8003046:	4604      	mov	r4, r0
 8003048:	2800      	cmp	r0, #0
 800304a:	d041      	beq.n	80030d0 <HAL_ADC_DeInit+0x8c>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 800304c:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800304e:	f043 0302 	orr.w	r3, r3, #2
 8003052:	6583      	str	r3, [r0, #88]	; 0x58
  tmp_hal_status = ADC_ConversionStop(hadc);
 8003054:	f7ff ff0c 	bl	8002e70 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 8003058:	4605      	mov	r5, r0
 800305a:	b968      	cbnz	r0, 8003078 <HAL_ADC_DeInit+0x34>
    tmp_hal_status = ADC_Disable(hadc);
 800305c:	4620      	mov	r0, r4
 800305e:	f7ff ffbd 	bl	8002fdc <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 8003062:	4605      	mov	r5, r0
 8003064:	b908      	cbnz	r0, 800306a <HAL_ADC_DeInit+0x26>
      hadc->State = HAL_ADC_STATE_READY;
 8003066:	2301      	movs	r3, #1
 8003068:	65a3      	str	r3, [r4, #88]	; 0x58
    LL_ADC_DisableInternalRegulator(hadc->Instance);
 800306a:	6822      	ldr	r2, [r4, #0]
  CLEAR_BIT(ADCx->CR, (ADC_CR_ADVREGEN | ADC_CR_BITS_PROPERTY_RS));
 800306c:	6893      	ldr	r3, [r2, #8]
 800306e:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8003072:	f023 0317 	bic.w	r3, r3, #23
 8003076:	6093      	str	r3, [r2, #8]
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 |
 8003078:	6823      	ldr	r3, [r4, #0]
 800307a:	685a      	ldr	r2, [r3, #4]
 800307c:	f422 7267 	bic.w	r2, r2, #924	; 0x39c
 8003080:	f022 0203 	bic.w	r2, r2, #3
 8003084:	605a      	str	r2, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 |
 8003086:	f240 329f 	movw	r2, #927	; 0x39f
 800308a:	601a      	str	r2, [r3, #0]
  hadc->Instance->CFGR1 &= ~(ADC_CFGR1_AWD1CH   | ADC_CFGR1_AWD1EN  | ADC_CFGR1_AWD1SGL | ADC_CFGR1_DISCEN |
 800308c:	68d9      	ldr	r1, [r3, #12]
 800308e:	4a11      	ldr	r2, [pc, #68]	; (80030d4 <HAL_ADC_DeInit+0x90>)
 8003090:	400a      	ands	r2, r1
 8003092:	60da      	str	r2, [r3, #12]
  hadc->Instance->CFGR2 &= ~ADC_CFGR2_CKMODE;
 8003094:	691a      	ldr	r2, [r3, #16]
 8003096:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
 800309a:	611a      	str	r2, [r3, #16]
  hadc->Instance->SMPR &= ~ADC_SMPR_SMP1;
 800309c:	695a      	ldr	r2, [r3, #20]
 800309e:	f022 0207 	bic.w	r2, r2, #7
 80030a2:	615a      	str	r2, [r3, #20]
  hadc->Instance->TR1 &= ~(ADC_TR1_HT1 | ADC_TR1_LT1);
 80030a4:	6a1a      	ldr	r2, [r3, #32]
 80030a6:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 80030aa:	621a      	str	r2, [r3, #32]
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 80030ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 80030ae:	4a0a      	ldr	r2, [pc, #40]	; (80030d8 <HAL_ADC_DeInit+0x94>)
  hadc->Instance->CHSELR &= ~(ADC_CHSELR_SQ_ALL);
 80030b0:	2600      	movs	r6, #0
 80030b2:	629e      	str	r6, [r3, #40]	; 0x28
  ADC_COMMON->CCR &= ~(ADC_CCR_VBATEN | ADC_CCR_TSEN | ADC_CCR_VREFEN | ADC_CCR_PRESC);
 80030b4:	6813      	ldr	r3, [r2, #0]
 80030b6:	f023 73fe 	bic.w	r3, r3, #33292288	; 0x1fc0000
 80030ba:	6013      	str	r3, [r2, #0]
  HAL_ADC_MspDeInit(hadc);
 80030bc:	4620      	mov	r0, r4
 80030be:	f7fd fe31 	bl	8000d24 <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 80030c2:	65e6      	str	r6, [r4, #92]	; 0x5c
  hadc->ADCGroupRegularSequencerRanks = 0x00000000UL;
 80030c4:	6626      	str	r6, [r4, #96]	; 0x60
  hadc->State = HAL_ADC_STATE_RESET;
 80030c6:	65a6      	str	r6, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 80030c8:	f884 6054 	strb.w	r6, [r4, #84]	; 0x54
}
 80030cc:	4628      	mov	r0, r5
 80030ce:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 80030d0:	2501      	movs	r5, #1
 80030d2:	e7fb      	b.n	80030cc <HAL_ADC_DeInit+0x88>
 80030d4:	833e0200 	.word	0x833e0200
 80030d8:	40012708 	.word	0x40012708

080030dc <HAL_ADC_Stop>:
{
 80030dc:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 80030de:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 80030e2:	2b01      	cmp	r3, #1
{
 80030e4:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 80030e6:	d015      	beq.n	8003114 <HAL_ADC_Stop+0x38>
 80030e8:	2301      	movs	r3, #1
 80030ea:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54
  tmp_hal_status = ADC_ConversionStop(hadc);
 80030ee:	f7ff febf 	bl	8002e70 <ADC_ConversionStop>
  if (tmp_hal_status == HAL_OK)
 80030f2:	b958      	cbnz	r0, 800310c <HAL_ADC_Stop+0x30>
    tmp_hal_status = ADC_Disable(hadc);
 80030f4:	4620      	mov	r0, r4
 80030f6:	f7ff ff71 	bl	8002fdc <ADC_Disable>
    if (tmp_hal_status == HAL_OK)
 80030fa:	b938      	cbnz	r0, 800310c <HAL_ADC_Stop+0x30>
      ADC_STATE_CLR_SET(hadc->State,
 80030fc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80030fe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003102:	f023 0301 	bic.w	r3, r3, #1
 8003106:	f043 0301 	orr.w	r3, r3, #1
 800310a:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 800310c:	2300      	movs	r3, #0
 800310e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
}
 8003112:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 8003114:	2002      	movs	r0, #2
 8003116:	e7fc      	b.n	8003112 <HAL_ADC_Stop+0x36>

08003118 <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 8003118:	b513      	push	{r0, r1, r4, lr}
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 800311a:	2300      	movs	r3, #0
 800311c:	9301      	str	r3, [sp, #4]
  uint32_t backup_setting_adc_dma_transfer; /* Note: Variable not declared as volatile because register read is already declared as volatile */

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  __HAL_LOCK(hadc);
 800311e:	f890 3054 	ldrb.w	r3, [r0, #84]	; 0x54
 8003122:	2b01      	cmp	r3, #1
{
 8003124:	4604      	mov	r4, r0
  __HAL_LOCK(hadc);
 8003126:	d040      	beq.n	80031aa <HAL_ADCEx_Calibration_Start+0x92>
 8003128:	2301      	movs	r3, #1
 800312a:	f880 3054 	strb.w	r3, [r0, #84]	; 0x54

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 800312e:	f7ff ff55 	bl	8002fdc <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003132:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003134:	689a      	ldr	r2, [r3, #8]
 8003136:	07d2      	lsls	r2, r2, #31
 8003138:	d433      	bmi.n	80031a2 <HAL_ADCEx_Calibration_Start+0x8a>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800313a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800313c:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8003140:	f042 0202 	orr.w	r2, r2, #2
 8003144:	65a2      	str	r2, [r4, #88]	; 0x58
    /* Note: Specificity of this STM32 series: Calibration factor is          */
    /*       available in data register and also transferred by DMA.          */
    /*       To not insert ADC calibration factor among ADC conversion data   */
    /*       in array variable, DMA transfer must be disabled during          */
    /*       calibration.                                                     */
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8003146:	68d9      	ldr	r1, [r3, #12]
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8003148:	68da      	ldr	r2, [r3, #12]
 800314a:	f022 0203 	bic.w	r2, r2, #3
 800314e:	60da      	str	r2, [r3, #12]

    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 8003150:	689a      	ldr	r2, [r3, #8]
 8003152:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8003156:	f001 0103 	and.w	r1, r1, #3
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 800315a:	609a      	str	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 800315c:	689a      	ldr	r2, [r3, #8]
 800315e:	2a00      	cmp	r2, #0
 8003160:	da12      	bge.n	8003188 <HAL_ADCEx_Calibration_Start+0x70>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
 8003162:	9a01      	ldr	r2, [sp, #4]
 8003164:	3201      	adds	r2, #1
 8003166:	9201      	str	r2, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8003168:	9a01      	ldr	r2, [sp, #4]
 800316a:	f5b2 3f2e 	cmp.w	r2, #178176	; 0x2b800
 800316e:	d3f5      	bcc.n	800315c <HAL_ADCEx_Calibration_Start+0x44>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 8003170:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003172:	f023 0312 	bic.w	r3, r3, #18
 8003176:	f043 0310 	orr.w	r3, r3, #16
 800317a:	65a3      	str	r3, [r4, #88]	; 0x58
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        __HAL_UNLOCK(hadc);
 800317c:	2300      	movs	r3, #0
 800317e:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54

        return HAL_ERROR;
 8003182:	2001      	movs	r0, #1
  }

  __HAL_UNLOCK(hadc);

  return tmp_hal_status;
}
 8003184:	b002      	add	sp, #8
 8003186:	bd10      	pop	{r4, pc}
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8003188:	68da      	ldr	r2, [r3, #12]
 800318a:	430a      	orrs	r2, r1
 800318c:	60da      	str	r2, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 800318e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003190:	f023 0303 	bic.w	r3, r3, #3
 8003194:	f043 0301 	orr.w	r3, r3, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003198:	65a3      	str	r3, [r4, #88]	; 0x58
  __HAL_UNLOCK(hadc);
 800319a:	2300      	movs	r3, #0
 800319c:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
  return tmp_hal_status;
 80031a0:	e7f0      	b.n	8003184 <HAL_ADCEx_Calibration_Start+0x6c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80031a2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80031a4:	f043 0310 	orr.w	r3, r3, #16
 80031a8:	e7f6      	b.n	8003198 <HAL_ADCEx_Calibration_Start+0x80>
  __HAL_LOCK(hadc);
 80031aa:	2002      	movs	r0, #2
 80031ac:	e7ea      	b.n	8003184 <HAL_ADCEx_Calibration_Start+0x6c>
	...

080031b0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80031b0:	4907      	ldr	r1, [pc, #28]	; (80031d0 <HAL_NVIC_SetPriorityGrouping+0x20>)
 80031b2:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80031b4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80031b8:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80031ba:	0412      	lsls	r2, r2, #16
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80031bc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80031c0:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80031c2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80031c4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80031c8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 80031cc:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80031ce:	4770      	bx	lr
 80031d0:	e000ed00 	.word	0xe000ed00

080031d4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80031d4:	4b16      	ldr	r3, [pc, #88]	; (8003230 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80031d6:	b530      	push	{r4, r5, lr}
 80031d8:	68dc      	ldr	r4, [r3, #12]
 80031da:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80031de:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80031e2:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80031e4:	2b04      	cmp	r3, #4
 80031e6:	bf28      	it	cs
 80031e8:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80031ea:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80031ec:	f04f 35ff 	mov.w	r5, #4294967295
 80031f0:	fa05 f303 	lsl.w	r3, r5, r3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80031f4:	bf8c      	ite	hi
 80031f6:	3c03      	subhi	r4, #3
 80031f8:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80031fa:	ea21 0303 	bic.w	r3, r1, r3
 80031fe:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003200:	fa05 f404 	lsl.w	r4, r5, r4
 8003204:	ea22 0204 	bic.w	r2, r2, r4
  if ((int32_t)(IRQn) >= 0)
 8003208:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800320a:	ea43 0302 	orr.w	r3, r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800320e:	bfac      	ite	ge
 8003210:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003214:	4a07      	ldrlt	r2, [pc, #28]	; (8003234 <HAL_NVIC_SetPriority+0x60>)
 8003216:	ea4f 1303 	mov.w	r3, r3, lsl #4
 800321a:	bfb8      	it	lt
 800321c:	f000 000f 	andlt.w	r0, r0, #15
 8003220:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003222:	bfaa      	itet	ge
 8003224:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003228:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800322a:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800322e:	bd30      	pop	{r4, r5, pc}
 8003230:	e000ed00 	.word	0xe000ed00
 8003234:	e000ed14 	.word	0xe000ed14

08003238 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003238:	2800      	cmp	r0, #0
 800323a:	db08      	blt.n	800324e <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800323c:	2301      	movs	r3, #1
 800323e:	0942      	lsrs	r2, r0, #5
 8003240:	f000 001f 	and.w	r0, r0, #31
 8003244:	fa03 f000 	lsl.w	r0, r3, r0
 8003248:	4b01      	ldr	r3, [pc, #4]	; (8003250 <HAL_NVIC_EnableIRQ+0x18>)
 800324a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800324e:	4770      	bx	lr
 8003250:	e000e100 	.word	0xe000e100

08003254 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8003254:	2800      	cmp	r0, #0
 8003256:	db0d      	blt.n	8003274 <HAL_NVIC_DisableIRQ+0x20>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003258:	0943      	lsrs	r3, r0, #5
 800325a:	2201      	movs	r2, #1
 800325c:	f000 001f 	and.w	r0, r0, #31
 8003260:	fa02 f000 	lsl.w	r0, r2, r0
 8003264:	3320      	adds	r3, #32
 8003266:	4a04      	ldr	r2, [pc, #16]	; (8003278 <HAL_NVIC_DisableIRQ+0x24>)
 8003268:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 800326c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8003270:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8003274:	4770      	bx	lr
 8003276:	bf00      	nop
 8003278:	e000e100 	.word	0xe000e100

0800327c <DMA_SetConfig>:
  * @param DstAddress The destination memory Buffer address
  * @param DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 800327c:	b570      	push	{r4, r5, r6, lr}
  /* Clear the DMAMUX synchro overrun flag */
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800327e:	e9d0 4513 	ldrd	r4, r5, [r0, #76]	; 0x4c
 8003282:	6065      	str	r5, [r4, #4]

  if (hdma->DMAmuxRequestGen != 0U)
 8003284:	6d44      	ldr	r4, [r0, #84]	; 0x54
 8003286:	b114      	cbz	r4, 800328e <DMA_SetConfig+0x12>
  {
    /* Clear the DMAMUX request generator overrun flag */
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003288:	e9d0 4516 	ldrd	r4, r5, [r0, #88]	; 0x58
 800328c:	6065      	str	r5, [r4, #4]
  }

  /* Clear all flags */
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800328e:	e9d0 5410 	ldrd	r5, r4, [r0, #64]	; 0x40
 8003292:	f004 061c 	and.w	r6, r4, #28
 8003296:	2401      	movs	r4, #1
 8003298:	40b4      	lsls	r4, r6
 800329a:	606c      	str	r4, [r5, #4]

  /* Configure DMA Channel data length */
  hdma->Instance->CNDTR = DataLength;
 800329c:	6804      	ldr	r4, [r0, #0]
 800329e:	6063      	str	r3, [r4, #4]

  /* Memory to Peripheral */
  if ((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80032a0:	6883      	ldr	r3, [r0, #8]
 80032a2:	2b10      	cmp	r3, #16
  {
    /* Configure DMA Channel destination address */
    hdma->Instance->CPAR = DstAddress;
 80032a4:	bf0b      	itete	eq
 80032a6:	60a2      	streq	r2, [r4, #8]
  }
  /* Peripheral to Memory */
  else
  {
    /* Configure DMA Channel source address */
    hdma->Instance->CPAR = SrcAddress;
 80032a8:	60a1      	strne	r1, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 80032aa:	60e1      	streq	r1, [r4, #12]

    /* Configure DMA Channel destination address */
    hdma->Instance->CMAR = DstAddress;
 80032ac:	60e2      	strne	r2, [r4, #12]
  }
}
 80032ae:	bd70      	pop	{r4, r5, r6, pc}

080032b0 <DMA_CalcDMAMUXChannelBaseAndMask>:
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t channel_number;

  /* check if instance is not outside the DMA channel range */
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80032b0:	6802      	ldr	r2, [r0, #0]
 80032b2:	6c41      	ldr	r1, [r0, #68]	; 0x44
 80032b4:	b2d3      	uxtb	r3, r2
{
 80032b6:	b510      	push	{r4, lr}
 80032b8:	3b08      	subs	r3, #8
 80032ba:	2414      	movs	r4, #20
 80032bc:	fbb3 f3f4 	udiv	r3, r3, r4
  if ((uint32_t)hdma->Instance < (uint32_t)DMA2_Channel1)
 80032c0:	4c0b      	ldr	r4, [pc, #44]	; (80032f0 <DMA_CalcDMAMUXChannelBaseAndMask+0x40>)
 80032c2:	42a2      	cmp	r2, r4
  }
  else
  {
    /* DMA2 */
    /* Associate a DMA Channel to a DMAMUX channel */
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 80032c4:	bf88      	it	hi
 80032c6:	4a0b      	ldrhi	r2, [pc, #44]	; (80032f4 <DMA_CalcDMAMUXChannelBaseAndMask+0x44>)
 80032c8:	f021 0103 	bic.w	r1, r1, #3
    hdma->DMAmuxChannel = (DMAMUX1_Channel0 + (hdma->ChannelIndex >> 2U));
 80032cc:	bf99      	ittee	ls
 80032ce:	f101 4280 	addls.w	r2, r1, #1073741824	; 0x40000000
 80032d2:	f502 3202 	addls.w	r2, r2, #133120	; 0x20800
    hdma->DMAmuxChannel = (DMAMUX1_Channel7 + (hdma->ChannelIndex >> 2U));
 80032d6:	1852      	addhi	r2, r2, r1

    /* Prepare channel_number used for DMAmuxChannelStatusMask computation */
    channel_number = (((((uint32_t)hdma->Instance & 0xFFU) - 8U) / 20U) + 7U);
 80032d8:	3307      	addhi	r3, #7
 80032da:	6482      	str	r2, [r0, #72]	; 0x48
  }

  /* Initialize the field DMAmuxChannelStatus to DMAMUX1_ChannelStatus base */
  hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 80032dc:	4a06      	ldr	r2, [pc, #24]	; (80032f8 <DMA_CalcDMAMUXChannelBaseAndMask+0x48>)
 80032de:	64c2      	str	r2, [r0, #76]	; 0x4c

  /* Initialize the field DMAmuxChannelStatusMask with the corresponding index of the DMAMUX channel selected for the current ChannelIndex */
  hdma->DMAmuxChannelStatusMask = 1UL << (channel_number & 0x1FU);
 80032e0:	f003 031f 	and.w	r3, r3, #31
 80032e4:	2201      	movs	r2, #1
 80032e6:	fa02 f303 	lsl.w	r3, r2, r3
 80032ea:	6503      	str	r3, [r0, #80]	; 0x50
}
 80032ec:	bd10      	pop	{r4, pc}
 80032ee:	bf00      	nop
 80032f0:	40020407 	.word	0x40020407
 80032f4:	4002081c 	.word	0x4002081c
 80032f8:	40020880 	.word	0x40020880

080032fc <HAL_DMA_Init>:
{
 80032fc:	b510      	push	{r4, lr}
  if (hdma == NULL)
 80032fe:	2800      	cmp	r0, #0
 8003300:	d060      	beq.n	80033c4 <HAL_DMA_Init+0xc8>
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 8003302:	6802      	ldr	r2, [r0, #0]
 8003304:	4b30      	ldr	r3, [pc, #192]	; (80033c8 <HAL_DMA_Init+0xcc>)
 8003306:	429a      	cmp	r2, r3
 8003308:	f04f 0414 	mov.w	r4, #20
 800330c:	d84d      	bhi.n	80033aa <HAL_DMA_Init+0xae>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 800330e:	492f      	ldr	r1, [pc, #188]	; (80033cc <HAL_DMA_Init+0xd0>)
 8003310:	4411      	add	r1, r2
 8003312:	fbb1 f1f4 	udiv	r1, r1, r4
 8003316:	0089      	lsls	r1, r1, #2
 8003318:	6441      	str	r1, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 800331a:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 800331e:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->State = HAL_DMA_STATE_BUSY;
 8003320:	2302      	movs	r3, #2
 8003322:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  CLEAR_BIT(hdma->Instance->CCR, (DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8003326:	6813      	ldr	r3, [r2, #0]
 8003328:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800332c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8003330:	6013      	str	r3, [r2, #0]
  SET_BIT(hdma->Instance->CCR, (hdma->Init.Direction           |                               \
 8003332:	e9d0 3402 	ldrd	r3, r4, [r0, #8]
 8003336:	4323      	orrs	r3, r4
 8003338:	6904      	ldr	r4, [r0, #16]
 800333a:	6811      	ldr	r1, [r2, #0]
 800333c:	4323      	orrs	r3, r4
 800333e:	6944      	ldr	r4, [r0, #20]
 8003340:	4323      	orrs	r3, r4
 8003342:	6984      	ldr	r4, [r0, #24]
 8003344:	4323      	orrs	r3, r4
 8003346:	69c4      	ldr	r4, [r0, #28]
 8003348:	4323      	orrs	r3, r4
 800334a:	6a04      	ldr	r4, [r0, #32]
 800334c:	4323      	orrs	r3, r4
 800334e:	430b      	orrs	r3, r1
 8003350:	6013      	str	r3, [r2, #0]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8003352:	f7ff ffad 	bl	80032b0 <DMA_CalcDMAMUXChannelBaseAndMask>
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8003356:	6883      	ldr	r3, [r0, #8]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8003358:	6c81      	ldr	r1, [r0, #72]	; 0x48
  if (hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800335a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800335e:	bf04      	itt	eq
 8003360:	2300      	moveq	r3, #0
 8003362:	6043      	streq	r3, [r0, #4]
  hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8003364:	6842      	ldr	r2, [r0, #4]
 8003366:	f002 037f 	and.w	r3, r2, #127	; 0x7f
 800336a:	600b      	str	r3, [r1, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800336c:	e9d0 1413 	ldrd	r1, r4, [r0, #76]	; 0x4c
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8003370:	3a01      	subs	r2, #1
 8003372:	2a03      	cmp	r2, #3
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8003374:	604c      	str	r4, [r1, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8003376:	d820      	bhi.n	80033ba <HAL_DMA_Init+0xbe>
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  /* DMA Channels are connected to DMAMUX1 request generator blocks*/
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003378:	4a15      	ldr	r2, [pc, #84]	; (80033d0 <HAL_DMA_Init+0xd4>)

  hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800337a:	4c16      	ldr	r4, [pc, #88]	; (80033d4 <HAL_DMA_Init+0xd8>)
 800337c:	6584      	str	r4, [r0, #88]	; 0x58
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800337e:	441a      	add	r2, r3

  /* here "Request" is either DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR3, i.e. <= 4*/
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8003380:	3b01      	subs	r3, #1
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003382:	0092      	lsls	r2, r2, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8003384:	2101      	movs	r1, #1
 8003386:	f003 0303 	and.w	r3, r3, #3
 800338a:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800338e:	2100      	movs	r1, #0
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003390:	6542      	str	r2, [r0, #84]	; 0x54
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 8003392:	65c3      	str	r3, [r0, #92]	; 0x5c
    hdma->DMAmuxRequestGen->RGCR = 0U;
 8003394:	6011      	str	r1, [r2, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003396:	6063      	str	r3, [r4, #4]
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003398:	2300      	movs	r3, #0
  hdma->State = HAL_DMA_STATE_READY;
 800339a:	2201      	movs	r2, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800339c:	63c3      	str	r3, [r0, #60]	; 0x3c
  __HAL_UNLOCK(hdma);
 800339e:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  hdma->State = HAL_DMA_STATE_READY;
 80033a2:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
  return HAL_OK;
 80033a6:	4618      	mov	r0, r3
}
 80033a8:	bd10      	pop	{r4, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 80033aa:	4b0b      	ldr	r3, [pc, #44]	; (80033d8 <HAL_DMA_Init+0xdc>)
 80033ac:	4413      	add	r3, r2
 80033ae:	fbb3 f3f4 	udiv	r3, r3, r4
 80033b2:	009b      	lsls	r3, r3, #2
 80033b4:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 80033b6:	4b09      	ldr	r3, [pc, #36]	; (80033dc <HAL_DMA_Init+0xe0>)
 80033b8:	e7b1      	b.n	800331e <HAL_DMA_Init+0x22>
    hdma->DMAmuxRequestGen = 0U;
 80033ba:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 80033bc:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
    hdma->DMAmuxRequestGenStatusMask = 0U;
 80033c0:	65c3      	str	r3, [r0, #92]	; 0x5c
 80033c2:	e7e9      	b.n	8003398 <HAL_DMA_Init+0x9c>
    return HAL_ERROR;
 80033c4:	2001      	movs	r0, #1
 80033c6:	e7ef      	b.n	80033a8 <HAL_DMA_Init+0xac>
 80033c8:	40020407 	.word	0x40020407
 80033cc:	bffdfff8 	.word	0xbffdfff8
 80033d0:	1000823f 	.word	0x1000823f
 80033d4:	40020940 	.word	0x40020940
 80033d8:	bffdfbf8 	.word	0xbffdfbf8
 80033dc:	40020400 	.word	0x40020400

080033e0 <HAL_DMA_DeInit>:
{
 80033e0:	b538      	push	{r3, r4, r5, lr}
  if (NULL == hdma)
 80033e2:	2800      	cmp	r0, #0
 80033e4:	d045      	beq.n	8003472 <HAL_DMA_DeInit+0x92>
  __HAL_DMA_DISABLE(hdma);
 80033e6:	6801      	ldr	r1, [r0, #0]
 80033e8:	680b      	ldr	r3, [r1, #0]
 80033ea:	f023 0301 	bic.w	r3, r3, #1
 80033ee:	600b      	str	r3, [r1, #0]
  if ((uint32_t)(hdma->Instance) < (uint32_t)(DMA2_Channel1))
 80033f0:	4b21      	ldr	r3, [pc, #132]	; (8003478 <HAL_DMA_DeInit+0x98>)
 80033f2:	4299      	cmp	r1, r3
 80033f4:	f04f 0414 	mov.w	r4, #20
 80033f8:	d833      	bhi.n	8003462 <HAL_DMA_DeInit+0x82>
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 80033fa:	4a20      	ldr	r2, [pc, #128]	; (800347c <HAL_DMA_DeInit+0x9c>)
 80033fc:	440a      	add	r2, r1
 80033fe:	fbb2 f2f4 	udiv	r2, r2, r4
 8003402:	0092      	lsls	r2, r2, #2
 8003404:	6442      	str	r2, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA1;
 8003406:	f2a3 4307 	subw	r3, r3, #1031	; 0x407
    hdma->DmaBaseAddress = DMA2;
 800340a:	6403      	str	r3, [r0, #64]	; 0x40
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800340c:	e9d0 2310 	ldrd	r2, r3, [r0, #64]	; 0x40
 8003410:	2401      	movs	r4, #1
 8003412:	f003 031c 	and.w	r3, r3, #28
 8003416:	fa04 f303 	lsl.w	r3, r4, r3
  hdma->Instance->CCR = 0U;
 800341a:	2500      	movs	r5, #0
 800341c:	600d      	str	r5, [r1, #0]
  hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800341e:	6053      	str	r3, [r2, #4]
  DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8003420:	f7ff ff46 	bl	80032b0 <DMA_CalcDMAMUXChannelBaseAndMask>
  hdma->DMAmuxChannel->CCR = 0U;
 8003424:	6c83      	ldr	r3, [r0, #72]	; 0x48
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8003426:	6841      	ldr	r1, [r0, #4]
  hdma->DMAmuxChannel->CCR = 0U;
 8003428:	601d      	str	r5, [r3, #0]
  hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800342a:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 800342e:	605a      	str	r2, [r3, #4]
  if (((hdma->Init.Request >  0UL) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR3)))
 8003430:	1e4a      	subs	r2, r1, #1
 8003432:	2a03      	cmp	r2, #3
 8003434:	d806      	bhi.n	8003444 <HAL_DMA_DeInit+0x64>
  hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003436:	4b12      	ldr	r3, [pc, #72]	; (8003480 <HAL_DMA_DeInit+0xa0>)
 8003438:	440b      	add	r3, r1
 800343a:	009b      	lsls	r3, r3, #2
  hdma->DMAmuxRequestGenStatusMask = 1UL << ((request - 1U) & 0x3U);
 800343c:	4094      	lsls	r4, r2
    hdma->DMAmuxRequestGen->RGCR = 0U;
 800343e:	601d      	str	r5, [r3, #0]
    hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003440:	4b10      	ldr	r3, [pc, #64]	; (8003484 <HAL_DMA_DeInit+0xa4>)
 8003442:	605c      	str	r4, [r3, #4]
  hdma->DMAmuxRequestGen = 0U;
 8003444:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003446:	63c3      	str	r3, [r0, #60]	; 0x3c
  hdma->DMAmuxRequestGenStatus = 0U;
 8003448:	e9c0 3315 	strd	r3, r3, [r0, #84]	; 0x54
  hdma->XferHalfCpltCallback = NULL;
 800344c:	e9c0 330b 	strd	r3, r3, [r0, #44]	; 0x2c
  hdma->XferAbortCallback = NULL;
 8003450:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
  hdma->DMAmuxRequestGenStatusMask = 0U;
 8003454:	65c3      	str	r3, [r0, #92]	; 0x5c
  hdma->State = HAL_DMA_STATE_RESET;
 8003456:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  __HAL_UNLOCK(hdma);
 800345a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 800345e:	4618      	mov	r0, r3
}
 8003460:	bd38      	pop	{r3, r4, r5, pc}
    hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA2_Channel1) / ((uint32_t)DMA2_Channel2 - (uint32_t)DMA2_Channel1)) << 2U;
 8003462:	4b09      	ldr	r3, [pc, #36]	; (8003488 <HAL_DMA_DeInit+0xa8>)
 8003464:	440b      	add	r3, r1
 8003466:	fbb3 f3f4 	udiv	r3, r3, r4
 800346a:	009b      	lsls	r3, r3, #2
 800346c:	6443      	str	r3, [r0, #68]	; 0x44
    hdma->DmaBaseAddress = DMA2;
 800346e:	4b07      	ldr	r3, [pc, #28]	; (800348c <HAL_DMA_DeInit+0xac>)
 8003470:	e7cb      	b.n	800340a <HAL_DMA_DeInit+0x2a>
    return HAL_ERROR;
 8003472:	2001      	movs	r0, #1
 8003474:	e7f4      	b.n	8003460 <HAL_DMA_DeInit+0x80>
 8003476:	bf00      	nop
 8003478:	40020407 	.word	0x40020407
 800347c:	bffdfff8 	.word	0xbffdfff8
 8003480:	1000823f 	.word	0x1000823f
 8003484:	40020940 	.word	0x40020940
 8003488:	bffdfbf8 	.word	0xbffdfbf8
 800348c:	40020400 	.word	0x40020400

08003490 <HAL_DMA_Start_IT>:
{
 8003490:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hdma);
 8003492:	f890 5024 	ldrb.w	r5, [r0, #36]	; 0x24
 8003496:	2d01      	cmp	r5, #1
{
 8003498:	4604      	mov	r4, r0
  __HAL_LOCK(hdma);
 800349a:	d03c      	beq.n	8003516 <HAL_DMA_Start_IT+0x86>
  if (hdma->State == HAL_DMA_STATE_READY)
 800349c:	f890 6025 	ldrb.w	r6, [r0, #37]	; 0x25
  __HAL_LOCK(hdma);
 80034a0:	2501      	movs	r5, #1
  if (hdma->State == HAL_DMA_STATE_READY)
 80034a2:	42ae      	cmp	r6, r5
  __HAL_LOCK(hdma);
 80034a4:	f880 5024 	strb.w	r5, [r0, #36]	; 0x24
  if (hdma->State == HAL_DMA_STATE_READY)
 80034a8:	f04f 0600 	mov.w	r6, #0
 80034ac:	d12d      	bne.n	800350a <HAL_DMA_Start_IT+0x7a>
    hdma->State = HAL_DMA_STATE_BUSY;
 80034ae:	2502      	movs	r5, #2
 80034b0:	f880 5025 	strb.w	r5, [r0, #37]	; 0x25
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80034b4:	63c6      	str	r6, [r0, #60]	; 0x3c
    __HAL_DMA_DISABLE(hdma);
 80034b6:	6806      	ldr	r6, [r0, #0]
 80034b8:	6835      	ldr	r5, [r6, #0]
 80034ba:	f025 0501 	bic.w	r5, r5, #1
 80034be:	6035      	str	r5, [r6, #0]
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80034c0:	f7ff fedc 	bl	800327c <DMA_SetConfig>
    if (NULL != hdma->XferHalfCpltCallback)
 80034c4:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80034c6:	6803      	ldr	r3, [r0, #0]
 80034c8:	b1ba      	cbz	r2, 80034fa <HAL_DMA_Start_IT+0x6a>
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80034ca:	681a      	ldr	r2, [r3, #0]
 80034cc:	f042 020e 	orr.w	r2, r2, #14
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 80034d0:	601a      	str	r2, [r3, #0]
    if ((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 80034d2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80034d4:	6811      	ldr	r1, [r2, #0]
 80034d6:	03c9      	lsls	r1, r1, #15
      hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 80034d8:	bf42      	ittt	mi
 80034da:	6811      	ldrmi	r1, [r2, #0]
 80034dc:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 80034e0:	6011      	strmi	r1, [r2, #0]
    if (hdma->DMAmuxRequestGen != 0U)
 80034e2:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80034e4:	b11a      	cbz	r2, 80034ee <HAL_DMA_Start_IT+0x5e>
      hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 80034e6:	6811      	ldr	r1, [r2, #0]
 80034e8:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80034ec:	6011      	str	r1, [r2, #0]
    __HAL_DMA_ENABLE(hdma);
 80034ee:	681a      	ldr	r2, [r3, #0]
 80034f0:	f042 0201 	orr.w	r2, r2, #1
 80034f4:	601a      	str	r2, [r3, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80034f6:	2000      	movs	r0, #0
}
 80034f8:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 80034fa:	681a      	ldr	r2, [r3, #0]
 80034fc:	f022 0204 	bic.w	r2, r2, #4
 8003500:	601a      	str	r2, [r3, #0]
      __HAL_DMA_ENABLE_IT(hdma, (DMA_IT_TC | DMA_IT_TE));
 8003502:	681a      	ldr	r2, [r3, #0]
 8003504:	f042 020a 	orr.w	r2, r2, #10
 8003508:	e7e2      	b.n	80034d0 <HAL_DMA_Start_IT+0x40>
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 800350a:	2380      	movs	r3, #128	; 0x80
 800350c:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 800350e:	f880 6024 	strb.w	r6, [r0, #36]	; 0x24
    status = HAL_ERROR;
 8003512:	4628      	mov	r0, r5
 8003514:	e7f0      	b.n	80034f8 <HAL_DMA_Start_IT+0x68>
  __HAL_LOCK(hdma);
 8003516:	2002      	movs	r0, #2
 8003518:	e7ee      	b.n	80034f8 <HAL_DMA_Start_IT+0x68>

0800351a <HAL_DMA_Abort>:
  if (NULL == hdma)
 800351a:	b140      	cbz	r0, 800352e <HAL_DMA_Abort+0x14>
  if (hdma->State != HAL_DMA_STATE_BUSY)
 800351c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 8003520:	2b02      	cmp	r3, #2
 8003522:	d006      	beq.n	8003532 <HAL_DMA_Abort+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8003524:	2304      	movs	r3, #4
 8003526:	63c3      	str	r3, [r0, #60]	; 0x3c
    __HAL_UNLOCK(hdma);
 8003528:	2300      	movs	r3, #0
 800352a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    return HAL_ERROR;
 800352e:	2001      	movs	r0, #1
}
 8003530:	4770      	bx	lr
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003532:	6803      	ldr	r3, [r0, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8003534:	6c81      	ldr	r1, [r0, #72]	; 0x48
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003536:	681a      	ldr	r2, [r3, #0]
 8003538:	f022 020e 	bic.w	r2, r2, #14
 800353c:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 800353e:	680a      	ldr	r2, [r1, #0]
 8003540:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8003544:	600a      	str	r2, [r1, #0]
    __HAL_DMA_DISABLE(hdma);
 8003546:	681a      	ldr	r2, [r3, #0]
 8003548:	f022 0201 	bic.w	r2, r2, #1
 800354c:	601a      	str	r2, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 800354e:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 8003552:	f003 021c 	and.w	r2, r3, #28
 8003556:	2301      	movs	r3, #1
 8003558:	4093      	lsls	r3, r2
 800355a:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800355c:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 8003560:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 8003562:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8003564:	b133      	cbz	r3, 8003574 <HAL_DMA_Abort+0x5a>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8003566:	681a      	ldr	r2, [r3, #0]
 8003568:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800356c:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800356e:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 8003572:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8003574:	2301      	movs	r3, #1
 8003576:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 800357a:	2300      	movs	r3, #0
 800357c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
  return HAL_OK;
 8003580:	4618      	mov	r0, r3
 8003582:	4770      	bx	lr

08003584 <HAL_DMA_Abort_IT>:
{
 8003584:	b510      	push	{r4, lr}
  if (hdma->State != HAL_DMA_STATE_BUSY)
 8003586:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 800358a:	2b02      	cmp	r3, #2
 800358c:	d003      	beq.n	8003596 <HAL_DMA_Abort_IT+0x12>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800358e:	2304      	movs	r3, #4
 8003590:	63c3      	str	r3, [r0, #60]	; 0x3c
    status = HAL_ERROR;
 8003592:	2001      	movs	r0, #1
}
 8003594:	bd10      	pop	{r4, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003596:	6803      	ldr	r3, [r0, #0]
 8003598:	681a      	ldr	r2, [r3, #0]
 800359a:	f022 020e 	bic.w	r2, r2, #14
 800359e:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 80035a0:	681a      	ldr	r2, [r3, #0]
 80035a2:	f022 0201 	bic.w	r2, r2, #1
 80035a6:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80035a8:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80035aa:	6813      	ldr	r3, [r2, #0]
 80035ac:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80035b0:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80035b2:	e9d0 1310 	ldrd	r1, r3, [r0, #64]	; 0x40
 80035b6:	f003 021c 	and.w	r2, r3, #28
 80035ba:	2301      	movs	r3, #1
 80035bc:	4093      	lsls	r3, r2
 80035be:	604b      	str	r3, [r1, #4]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80035c0:	e9d0 3213 	ldrd	r3, r2, [r0, #76]	; 0x4c
 80035c4:	605a      	str	r2, [r3, #4]
    if (hdma->DMAmuxRequestGen != 0U)
 80035c6:	6d43      	ldr	r3, [r0, #84]	; 0x54
 80035c8:	b133      	cbz	r3, 80035d8 <HAL_DMA_Abort_IT+0x54>
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 80035ca:	681a      	ldr	r2, [r3, #0]
 80035cc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80035d0:	601a      	str	r2, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80035d2:	e9d0 3216 	ldrd	r3, r2, [r0, #88]	; 0x58
 80035d6:	605a      	str	r2, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 80035d8:	2301      	movs	r3, #1
 80035da:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    if (hdma->XferAbortCallback != NULL)
 80035de:	6b83      	ldr	r3, [r0, #56]	; 0x38
    __HAL_UNLOCK(hdma);
 80035e0:	2400      	movs	r4, #0
 80035e2:	f880 4024 	strb.w	r4, [r0, #36]	; 0x24
    if (hdma->XferAbortCallback != NULL)
 80035e6:	b113      	cbz	r3, 80035ee <HAL_DMA_Abort_IT+0x6a>
      hdma->XferAbortCallback(hdma);
 80035e8:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 80035ea:	4620      	mov	r0, r4
 80035ec:	e7d2      	b.n	8003594 <HAL_DMA_Abort_IT+0x10>
 80035ee:	4618      	mov	r0, r3
 80035f0:	e7d0      	b.n	8003594 <HAL_DMA_Abort_IT+0x10>
	...

080035f4 <HAL_DMA_IRQHandler>:
{
 80035f4:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 80035f6:	6c42      	ldr	r2, [r0, #68]	; 0x44
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80035f8:	6c04      	ldr	r4, [r0, #64]	; 0x40
  uint32_t source_it = hdma->Instance->CCR;
 80035fa:	6803      	ldr	r3, [r0, #0]
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 80035fc:	6826      	ldr	r6, [r4, #0]
  uint32_t source_it = hdma->Instance->CCR;
 80035fe:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_HT) != 0U))
 8003600:	f002 021c 	and.w	r2, r2, #28
 8003604:	2104      	movs	r1, #4
 8003606:	4091      	lsls	r1, r2
 8003608:	4231      	tst	r1, r6
 800360a:	d00f      	beq.n	800362c <HAL_DMA_IRQHandler+0x38>
 800360c:	f015 0f04 	tst.w	r5, #4
 8003610:	d00c      	beq.n	800362c <HAL_DMA_IRQHandler+0x38>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8003612:	681a      	ldr	r2, [r3, #0]
 8003614:	0692      	lsls	r2, r2, #26
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8003616:	bf5e      	ittt	pl
 8003618:	681a      	ldrpl	r2, [r3, #0]
 800361a:	f022 0204 	bicpl.w	r2, r2, #4
 800361e:	601a      	strpl	r2, [r3, #0]
      if (hdma->XferHalfCpltCallback != NULL)
 8003620:	6b03      	ldr	r3, [r0, #48]	; 0x30
      hdma->DmaBaseAddress->IFCR = DMA_ISR_HTIF1 << (hdma->ChannelIndex & 0x1CU);
 8003622:	6061      	str	r1, [r4, #4]
    if (hdma->XferErrorCallback != NULL)
 8003624:	2b00      	cmp	r3, #0
 8003626:	d033      	beq.n	8003690 <HAL_DMA_IRQHandler+0x9c>
}
 8003628:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 800362a:	4718      	bx	r3
  else if ((0U != (flag_it & (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)))) && (0U != (source_it & DMA_IT_TC)))
 800362c:	2102      	movs	r1, #2
 800362e:	4091      	lsls	r1, r2
 8003630:	4231      	tst	r1, r6
 8003632:	d017      	beq.n	8003664 <HAL_DMA_IRQHandler+0x70>
 8003634:	f015 0f02 	tst.w	r5, #2
 8003638:	d014      	beq.n	8003664 <HAL_DMA_IRQHandler+0x70>
      if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 800363a:	681a      	ldr	r2, [r3, #0]
 800363c:	0694      	lsls	r4, r2, #26
 800363e:	d406      	bmi.n	800364e <HAL_DMA_IRQHandler+0x5a>
        __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8003640:	681a      	ldr	r2, [r3, #0]
 8003642:	f022 020a 	bic.w	r2, r2, #10
 8003646:	601a      	str	r2, [r3, #0]
        hdma->State = HAL_DMA_STATE_READY;
 8003648:	2201      	movs	r2, #1
 800364a:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
      __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC1 << (hdma->ChannelIndex & 0x1CU)));
 800364e:	4a11      	ldr	r2, [pc, #68]	; (8003694 <HAL_DMA_IRQHandler+0xa0>)
 8003650:	4293      	cmp	r3, r2
 8003652:	bf8c      	ite	hi
 8003654:	4b10      	ldrhi	r3, [pc, #64]	; (8003698 <HAL_DMA_IRQHandler+0xa4>)
 8003656:	4b11      	ldrls	r3, [pc, #68]	; (800369c <HAL_DMA_IRQHandler+0xa8>)
 8003658:	6059      	str	r1, [r3, #4]
      __HAL_UNLOCK(hdma);
 800365a:	2300      	movs	r3, #0
 800365c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
      if (hdma->XferCpltCallback != NULL)
 8003660:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8003662:	e7df      	b.n	8003624 <HAL_DMA_IRQHandler+0x30>
  else if (((flag_it & (DMA_FLAG_TE1 << (hdma->ChannelIndex & 0x1CU))) != 0U) && ((source_it & DMA_IT_TE) != 0U))
 8003664:	2108      	movs	r1, #8
 8003666:	4091      	lsls	r1, r2
 8003668:	4231      	tst	r1, r6
 800366a:	d011      	beq.n	8003690 <HAL_DMA_IRQHandler+0x9c>
 800366c:	0729      	lsls	r1, r5, #28
 800366e:	d50f      	bpl.n	8003690 <HAL_DMA_IRQHandler+0x9c>
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8003670:	6819      	ldr	r1, [r3, #0]
 8003672:	f021 010e 	bic.w	r1, r1, #14
 8003676:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 8003678:	2301      	movs	r3, #1
 800367a:	fa03 f202 	lsl.w	r2, r3, r2
 800367e:	6062      	str	r2, [r4, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8003680:	63c3      	str	r3, [r0, #60]	; 0x3c
    hdma->State = HAL_DMA_STATE_READY;
 8003682:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 8003686:	2300      	movs	r3, #0
 8003688:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if (hdma->XferErrorCallback != NULL)
 800368c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800368e:	e7c9      	b.n	8003624 <HAL_DMA_IRQHandler+0x30>
}
 8003690:	bc70      	pop	{r4, r5, r6}
 8003692:	4770      	bx	lr
 8003694:	40020080 	.word	0x40020080
 8003698:	40020400 	.word	0x40020400
 800369c:	40020000 	.word	0x40020000

080036a0 <HAL_DMA_ConfigChannelAttributes>:
  if (hdma == NULL)
 80036a0:	b160      	cbz	r0, 80036bc <HAL_DMA_ConfigChannelAttributes+0x1c>
  ccr = READ_REG(hdma->Instance->CCR);
 80036a2:	6802      	ldr	r2, [r0, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 80036a4:	06c8      	lsls	r0, r1, #27
  ccr = READ_REG(hdma->Instance->CCR);
 80036a6:	6813      	ldr	r3, [r2, #0]
  if ((ChannelAttributes & DMA_CHANNEL_ATTR_PRIV_MASK) != 0U)
 80036a8:	d505      	bpl.n	80036b6 <HAL_DMA_ConfigChannelAttributes+0x16>
    if ((ChannelAttributes & DMA_CCR_PRIV) != 0U)
 80036aa:	02c9      	lsls	r1, r1, #11
      SET_BIT(ccr, DMA_CCR_PRIV);
 80036ac:	bf4c      	ite	mi
 80036ae:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
      CLEAR_BIT(ccr, DMA_CCR_PRIV);
 80036b2:	f423 1380 	bicpl.w	r3, r3, #1048576	; 0x100000
  WRITE_REG(hdma->Instance->CCR, ccr);
 80036b6:	6013      	str	r3, [r2, #0]
  return status;
 80036b8:	2000      	movs	r0, #0
 80036ba:	4770      	bx	lr
    return status;
 80036bc:	2001      	movs	r0, #1
}
 80036be:	4770      	bx	lr

080036c0 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 80036c0:	4603      	mov	r3, r0
  HAL_StatusTypeDef status = HAL_OK;

  switch (CallbackID)
 80036c2:	4608      	mov	r0, r1
 80036c4:	b909      	cbnz	r1, 80036ca <HAL_EXTI_RegisterCallback+0xa>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 80036c6:	605a      	str	r2, [r3, #4]
      break;
 80036c8:	4770      	bx	lr

    default:
      status = HAL_ERROR;
 80036ca:	2001      	movs	r0, #1
      break;
  }

  return status;
}
 80036cc:	4770      	bx	lr

080036ce <HAL_EXTI_GetHandle>:
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 80036ce:	b110      	cbz	r0, 80036d6 <HAL_EXTI_GetHandle+0x8>
    return HAL_ERROR;
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 80036d0:	6001      	str	r1, [r0, #0]

    return HAL_OK;
 80036d2:	2000      	movs	r0, #0
 80036d4:	4770      	bx	lr
    return HAL_ERROR;
 80036d6:	2001      	movs	r0, #1
  }
}
 80036d8:	4770      	bx	lr
	...

080036dc <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80036dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
#else
        temp = EXTI->IMR1;
 80036e0:	4c52      	ldr	r4, [pc, #328]	; (800382c <HAL_GPIO_Init+0x150>)
  uint32_t position = 0x00u;
 80036e2:	2300      	movs	r3, #0
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80036e4:	f04f 090f 	mov.w	r9, #15
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80036e8:	680a      	ldr	r2, [r1, #0]
 80036ea:	fa32 f503 	lsrs.w	r5, r2, r3
 80036ee:	d101      	bne.n	80036f4 <HAL_GPIO_Init+0x18>
      }
    }

    position++;
  }
}
 80036f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 80036f4:	2501      	movs	r5, #1
 80036f6:	fa05 f803 	lsl.w	r8, r5, r3
    if (iocurrent != 0x00u)
 80036fa:	ea18 0202 	ands.w	r2, r8, r2
 80036fe:	f000 808f 	beq.w	8003820 <HAL_GPIO_Init+0x144>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8003702:	684e      	ldr	r6, [r1, #4]
 8003704:	2703      	movs	r7, #3
 8003706:	f006 0503 	and.w	r5, r6, #3
 800370a:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 800370e:	fa07 fc0e 	lsl.w	ip, r7, lr
 8003712:	1e6f      	subs	r7, r5, #1
 8003714:	2f01      	cmp	r7, #1
 8003716:	ea6f 0c0c 	mvn.w	ip, ip
 800371a:	d832      	bhi.n	8003782 <HAL_GPIO_Init+0xa6>
        temp = GPIOx->OSPEEDR;
 800371c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800371e:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 8003722:	68cf      	ldr	r7, [r1, #12]
 8003724:	fa07 f70e 	lsl.w	r7, r7, lr
 8003728:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 800372c:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 800372e:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8003730:	ea27 0808 	bic.w	r8, r7, r8
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8003734:	f3c6 1700 	ubfx	r7, r6, #4, #1
 8003738:	409f      	lsls	r7, r3
 800373a:	ea47 0708 	orr.w	r7, r7, r8
        GPIOx->OTYPER = temp;
 800373e:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 8003740:	68c7      	ldr	r7, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8003742:	ea07 080c 	and.w	r8, r7, ip
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8003746:	688f      	ldr	r7, [r1, #8]
 8003748:	fa07 f70e 	lsl.w	r7, r7, lr
 800374c:	ea47 0708 	orr.w	r7, r7, r8
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8003750:	2d02      	cmp	r5, #2
        GPIOx->PUPDR = temp;
 8003752:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8003754:	d117      	bne.n	8003786 <HAL_GPIO_Init+0xaa>
        temp = GPIOx->AFR[position >> 3U];
 8003756:	ea4f 08d3 	mov.w	r8, r3, lsr #3
 800375a:	eb00 0888 	add.w	r8, r0, r8, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800375e:	f003 0a07 	and.w	sl, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8003762:	f8d8 7020 	ldr.w	r7, [r8, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8003766:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800376a:	fa09 fb0a 	lsl.w	fp, r9, sl
 800376e:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8003772:	690f      	ldr	r7, [r1, #16]
 8003774:	fa07 f70a 	lsl.w	r7, r7, sl
 8003778:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3u] = temp;
 800377c:	f8c8 7020 	str.w	r7, [r8, #32]
 8003780:	e001      	b.n	8003786 <HAL_GPIO_Init+0xaa>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8003782:	2d03      	cmp	r5, #3
 8003784:	d1dc      	bne.n	8003740 <HAL_GPIO_Init+0x64>
      temp = GPIOx->MODER;
 8003786:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8003788:	ea07 0c0c 	and.w	ip, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800378c:	fa05 f70e 	lsl.w	r7, r5, lr
 8003790:	ea47 070c 	orr.w	r7, r7, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 8003794:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      GPIOx->MODER = temp;
 8003798:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 800379a:	d041      	beq.n	8003820 <HAL_GPIO_Init+0x144>
        temp = SYSCFG->EXTICR[position >> 2u];
 800379c:	f023 0703 	bic.w	r7, r3, #3
 80037a0:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80037a4:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 80037a8:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2u];
 80037ac:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 80037ae:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80037b2:	f04f 0e07 	mov.w	lr, #7
 80037b6:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80037ba:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 80037be:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80037c2:	d02f      	beq.n	8003824 <HAL_GPIO_Init+0x148>
 80037c4:	4d1a      	ldr	r5, [pc, #104]	; (8003830 <HAL_GPIO_Init+0x154>)
 80037c6:	42a8      	cmp	r0, r5
 80037c8:	d02e      	beq.n	8003828 <HAL_GPIO_Init+0x14c>
 80037ca:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80037ce:	42a8      	cmp	r0, r5
 80037d0:	bf0c      	ite	eq
 80037d2:	2502      	moveq	r5, #2
 80037d4:	2507      	movne	r5, #7
 80037d6:	fa05 f50c 	lsl.w	r5, r5, ip
 80037da:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 80037de:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 80037e0:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 80037e4:	43d7      	mvns	r7, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 80037e6:	f416 3f80 	tst.w	r6, #65536	; 0x10000
        temp &= ~(iocurrent);
 80037ea:	bf0c      	ite	eq
 80037ec:	403d      	andeq	r5, r7
          temp |= iocurrent;
 80037ee:	4315      	orrne	r5, r2
        EXTI->IMR1 = temp;
 80037f0:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
        temp = EXTI->EMR1;
 80037f4:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 80037f8:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        temp &= ~(iocurrent);
 80037fc:	bf0c      	ite	eq
 80037fe:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8003800:	4315      	orrne	r5, r2
        EXTI->EMR1 = temp;
 8003802:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI->RTSR1;
 8003806:	6825      	ldr	r5, [r4, #0]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 8003808:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp &= ~(iocurrent);
 800380c:	bf0c      	ite	eq
 800380e:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8003810:	4315      	orrne	r5, r2
        EXTI->RTSR1 = temp;
 8003812:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 8003814:	6865      	ldr	r5, [r4, #4]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8003816:	02b6      	lsls	r6, r6, #10
        temp &= ~(iocurrent);
 8003818:	bf54      	ite	pl
 800381a:	403d      	andpl	r5, r7
          temp |= iocurrent;
 800381c:	4315      	orrmi	r5, r2
        EXTI->FTSR1 = temp;
 800381e:	6065      	str	r5, [r4, #4]
    position++;
 8003820:	3301      	adds	r3, #1
 8003822:	e761      	b.n	80036e8 <HAL_GPIO_Init+0xc>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8003824:	2500      	movs	r5, #0
 8003826:	e7d6      	b.n	80037d6 <HAL_GPIO_Init+0xfa>
 8003828:	2501      	movs	r5, #1
 800382a:	e7d4      	b.n	80037d6 <HAL_GPIO_Init+0xfa>
 800382c:	58000800 	.word	0x58000800
 8003830:	48000400 	.word	0x48000400

08003834 <HAL_GPIO_DeInit>:
        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 &= ~(iocurrent);
        EXTI->C2EMR1 &= ~(iocurrent);
#else
        EXTI->IMR1 &= ~(iocurrent);
 8003834:	4a37      	ldr	r2, [pc, #220]	; (8003914 <HAL_GPIO_DeInit+0xe0>)
{
 8003836:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00u;
 800383a:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 800383c:	f04f 0a01 	mov.w	sl, #1
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 8003840:	f04f 0b07 	mov.w	fp, #7
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8003844:	f04f 090f 	mov.w	r9, #15
  while ((GPIO_Pin >> position) != 0x00u)
 8003848:	fa31 f403 	lsrs.w	r4, r1, r3
 800384c:	d101      	bne.n	8003852 <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 800384e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 8003852:	fa0a fc03 	lsl.w	ip, sl, r3
    if (iocurrent != 0x00u)
 8003856:	ea1c 0601 	ands.w	r6, ip, r1
 800385a:	d054      	beq.n	8003906 <HAL_GPIO_DeInit+0xd2>
      tmp = SYSCFG->EXTICR[position >> 2u];
 800385c:	f023 0403 	bic.w	r4, r3, #3
 8003860:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8003864:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 8003868:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 800386c:	68a5      	ldr	r5, [r4, #8]
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 800386e:	00bf      	lsls	r7, r7, #2
 8003870:	fa0b f807 	lsl.w	r8, fp, r7
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8003874:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x07uL << (4U * (position & 0x03U)));
 8003878:	ea08 0e05 	and.w	lr, r8, r5
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800387c:	d045      	beq.n	800390a <HAL_GPIO_DeInit+0xd6>
 800387e:	4d26      	ldr	r5, [pc, #152]	; (8003918 <HAL_GPIO_DeInit+0xe4>)
 8003880:	42a8      	cmp	r0, r5
 8003882:	d044      	beq.n	800390e <HAL_GPIO_DeInit+0xda>
 8003884:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8003888:	42a8      	cmp	r0, r5
 800388a:	bf0c      	ite	eq
 800388c:	2502      	moveq	r5, #2
 800388e:	2507      	movne	r5, #7
 8003890:	40bd      	lsls	r5, r7
 8003892:	4575      	cmp	r5, lr
 8003894:	d117      	bne.n	80038c6 <HAL_GPIO_DeInit+0x92>
        EXTI->IMR1 &= ~(iocurrent);
 8003896:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
 800389a:	ea25 0506 	bic.w	r5, r5, r6
 800389e:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 80038a2:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
 80038a6:	ea25 0506 	bic.w	r5, r5, r6
 80038aa:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 80038ae:	6815      	ldr	r5, [r2, #0]
 80038b0:	ea25 0506 	bic.w	r5, r5, r6
 80038b4:	6015      	str	r5, [r2, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 80038b6:	6855      	ldr	r5, [r2, #4]
 80038b8:	ea25 0606 	bic.w	r6, r5, r6
 80038bc:	6056      	str	r6, [r2, #4]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 80038be:	68a5      	ldr	r5, [r4, #8]
 80038c0:	ea25 0508 	bic.w	r5, r5, r8
 80038c4:	60a5      	str	r5, [r4, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 80038c6:	6805      	ldr	r5, [r0, #0]
 80038c8:	2603      	movs	r6, #3
 80038ca:	005c      	lsls	r4, r3, #1
 80038cc:	fa06 f404 	lsl.w	r4, r6, r4
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 80038d0:	fa23 f606 	lsr.w	r6, r3, r6
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 80038d4:	4325      	orrs	r5, r4
 80038d6:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 80038da:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 80038dc:	f003 0507 	and.w	r5, r3, #7
 80038e0:	6a37      	ldr	r7, [r6, #32]
 80038e2:	00ad      	lsls	r5, r5, #2
 80038e4:	fa09 f505 	lsl.w	r5, r9, r5
 80038e8:	ea27 0505 	bic.w	r5, r7, r5
 80038ec:	6235      	str	r5, [r6, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80038ee:	6885      	ldr	r5, [r0, #8]
 80038f0:	ea25 0504 	bic.w	r5, r5, r4
 80038f4:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80038f6:	6845      	ldr	r5, [r0, #4]
 80038f8:	ea25 050c 	bic.w	r5, r5, ip
 80038fc:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80038fe:	68c5      	ldr	r5, [r0, #12]
 8003900:	ea25 0404 	bic.w	r4, r5, r4
 8003904:	60c4      	str	r4, [r0, #12]
    position++;
 8003906:	3301      	adds	r3, #1
 8003908:	e79e      	b.n	8003848 <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800390a:	2500      	movs	r5, #0
 800390c:	e7c0      	b.n	8003890 <HAL_GPIO_DeInit+0x5c>
 800390e:	2501      	movs	r5, #1
 8003910:	e7be      	b.n	8003890 <HAL_GPIO_DeInit+0x5c>
 8003912:	bf00      	nop
 8003914:	58000800 	.word	0x58000800
 8003918:	48000400 	.word	0x48000400

0800391c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800391c:	b10a      	cbz	r2, 8003922 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800391e:	6181      	str	r1, [r0, #24]
 8003920:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8003922:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8003924:	4770      	bx	lr
	...

08003928 <HAL_GPIO_EXTI_IRQHandler>:
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8003928:	4a04      	ldr	r2, [pc, #16]	; (800393c <HAL_GPIO_EXTI_IRQHandler+0x14>)
 800392a:	68d1      	ldr	r1, [r2, #12]
 800392c:	4201      	tst	r1, r0
{
 800392e:	b508      	push	{r3, lr}
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8003930:	d002      	beq.n	8003938 <HAL_GPIO_EXTI_IRQHandler+0x10>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8003932:	60d0      	str	r0, [r2, #12]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8003934:	f7fe fc5a 	bl	80021ec <HAL_GPIO_EXTI_Callback>
  }
}
 8003938:	bd08      	pop	{r3, pc}
 800393a:	bf00      	nop
 800393c:	58000800 	.word	0x58000800

08003940 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8003940:	6803      	ldr	r3, [r0, #0]
 8003942:	699a      	ldr	r2, [r3, #24]
 8003944:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 8003946:	bf44      	itt	mi
 8003948:	2200      	movmi	r2, #0
 800394a:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800394c:	699a      	ldr	r2, [r3, #24]
 800394e:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8003950:	bf5e      	ittt	pl
 8003952:	699a      	ldrpl	r2, [r3, #24]
 8003954:	f042 0201 	orrpl.w	r2, r2, #1
 8003958:	619a      	strpl	r2, [r3, #24]
  }
}
 800395a:	4770      	bx	lr

0800395c <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 800395c:	b530      	push	{r4, r5, lr}
 800395e:	9d03      	ldr	r5, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 8003960:	6804      	ldr	r4, [r0, #0]
 8003962:	ea45 4202 	orr.w	r2, r5, r2, lsl #16
 8003966:	431a      	orrs	r2, r3
 8003968:	4b05      	ldr	r3, [pc, #20]	; (8003980 <I2C_TransferConfig+0x24>)
 800396a:	6860      	ldr	r0, [r4, #4]
 800396c:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8003970:	ea43 5355 	orr.w	r3, r3, r5, lsr #21
 8003974:	430a      	orrs	r2, r1
 8003976:	ea20 0003 	bic.w	r0, r0, r3
 800397a:	4302      	orrs	r2, r0
 800397c:	6062      	str	r2, [r4, #4]
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
                        (uint32_t)Mode | (uint32_t)Request));
}
 800397e:	bd30      	pop	{r4, r5, pc}
 8003980:	03ff63ff 	.word	0x03ff63ff

08003984 <I2C_IsAcknowledgeFailed>:
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8003984:	6803      	ldr	r3, [r0, #0]
{
 8003986:	b570      	push	{r4, r5, r6, lr}
 8003988:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800398a:	6998      	ldr	r0, [r3, #24]
 800398c:	f010 0010 	ands.w	r0, r0, #16
{
 8003990:	460d      	mov	r5, r1
 8003992:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8003994:	d039      	beq.n	8003a0a <I2C_IsAcknowledgeFailed+0x86>
    if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 8003996:	685a      	ldr	r2, [r3, #4]
 8003998:	0190      	lsls	r0, r2, #6
 800399a:	d403      	bmi.n	80039a4 <I2C_IsAcknowledgeFailed+0x20>
      hi2c->Instance->CR2 |= I2C_CR2_STOP;
 800399c:	685a      	ldr	r2, [r3, #4]
 800399e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80039a2:	605a      	str	r2, [r3, #4]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80039a4:	6823      	ldr	r3, [r4, #0]
 80039a6:	699a      	ldr	r2, [r3, #24]
 80039a8:	0692      	lsls	r2, r2, #26
 80039aa:	d518      	bpl.n	80039de <I2C_IsAcknowledgeFailed+0x5a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80039ac:	2210      	movs	r2, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80039ae:	2520      	movs	r5, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80039b0:	61da      	str	r2, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 80039b2:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80039b4:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 80039b6:	f7ff ffc3 	bl	8003940 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 80039ba:	6822      	ldr	r2, [r4, #0]
 80039bc:	6853      	ldr	r3, [r2, #4]
 80039be:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 80039c2:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 80039c6:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 80039ca:	f023 0301 	bic.w	r3, r3, #1
 80039ce:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80039d0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80039d2:	f043 0304 	orr.w	r3, r3, #4
 80039d6:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80039d8:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 80039dc:	e00f      	b.n	80039fe <I2C_IsAcknowledgeFailed+0x7a>
      if (Timeout != HAL_MAX_DELAY)
 80039de:	1c69      	adds	r1, r5, #1
 80039e0:	d0e1      	beq.n	80039a6 <I2C_IsAcknowledgeFailed+0x22>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80039e2:	f7fd fd77 	bl	80014d4 <HAL_GetTick>
 80039e6:	1b80      	subs	r0, r0, r6
 80039e8:	4285      	cmp	r5, r0
 80039ea:	d301      	bcc.n	80039f0 <I2C_IsAcknowledgeFailed+0x6c>
 80039ec:	2d00      	cmp	r5, #0
 80039ee:	d1d9      	bne.n	80039a4 <I2C_IsAcknowledgeFailed+0x20>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80039f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80039f2:	f043 0320 	orr.w	r3, r3, #32
 80039f6:	6463      	str	r3, [r4, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 80039f8:	2320      	movs	r3, #32
 80039fa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80039fe:	2300      	movs	r3, #0
 8003a00:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8003a04:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_ERROR;
 8003a08:	2001      	movs	r0, #1
}
 8003a0a:	bd70      	pop	{r4, r5, r6, pc}

08003a0c <I2C_WaitOnRXNEFlagUntilTimeout>:
{
 8003a0c:	b570      	push	{r4, r5, r6, lr}
 8003a0e:	4604      	mov	r4, r0
 8003a10:	460d      	mov	r5, r1
 8003a12:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8003a14:	6823      	ldr	r3, [r4, #0]
 8003a16:	699b      	ldr	r3, [r3, #24]
 8003a18:	075b      	lsls	r3, r3, #29
 8003a1a:	d40e      	bmi.n	8003a3a <I2C_WaitOnRXNEFlagUntilTimeout+0x2e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8003a1c:	4632      	mov	r2, r6
 8003a1e:	4629      	mov	r1, r5
 8003a20:	4620      	mov	r0, r4
 8003a22:	f7ff ffaf 	bl	8003984 <I2C_IsAcknowledgeFailed>
 8003a26:	b9f0      	cbnz	r0, 8003a66 <I2C_WaitOnRXNEFlagUntilTimeout+0x5a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8003a28:	6823      	ldr	r3, [r4, #0]
 8003a2a:	699a      	ldr	r2, [r3, #24]
 8003a2c:	0691      	lsls	r1, r2, #26
 8003a2e:	d51c      	bpl.n	8003a6a <I2C_WaitOnRXNEFlagUntilTimeout+0x5e>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 8003a30:	699a      	ldr	r2, [r3, #24]
 8003a32:	0752      	lsls	r2, r2, #29
 8003a34:	d503      	bpl.n	8003a3e <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
 8003a36:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8003a38:	b10a      	cbz	r2, 8003a3e <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
        return HAL_OK;
 8003a3a:	2000      	movs	r0, #0
}
 8003a3c:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003a3e:	2120      	movs	r1, #32
 8003a40:	61d9      	str	r1, [r3, #28]
        I2C_RESET_CR2(hi2c);
 8003a42:	685a      	ldr	r2, [r3, #4]
 8003a44:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8003a48:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8003a4c:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8003a50:	f022 0201 	bic.w	r2, r2, #1
 8003a54:	605a      	str	r2, [r3, #4]
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003a56:	2300      	movs	r3, #0
 8003a58:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003a5a:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003a5e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8003a62:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8003a66:	2001      	movs	r0, #1
 8003a68:	e7e8      	b.n	8003a3c <I2C_WaitOnRXNEFlagUntilTimeout+0x30>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003a6a:	f7fd fd33 	bl	80014d4 <HAL_GetTick>
 8003a6e:	1b80      	subs	r0, r0, r6
 8003a70:	42a8      	cmp	r0, r5
 8003a72:	d801      	bhi.n	8003a78 <I2C_WaitOnRXNEFlagUntilTimeout+0x6c>
 8003a74:	2d00      	cmp	r5, #0
 8003a76:	d1cd      	bne.n	8003a14 <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003a78:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8003a7a:	f043 0320 	orr.w	r3, r3, #32
 8003a7e:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8003a80:	2320      	movs	r3, #32
 8003a82:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      __HAL_UNLOCK(hi2c);
 8003a86:	2300      	movs	r3, #0
 8003a88:	e7eb      	b.n	8003a62 <I2C_WaitOnRXNEFlagUntilTimeout+0x56>

08003a8a <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8003a8a:	b570      	push	{r4, r5, r6, lr}
 8003a8c:	4604      	mov	r4, r0
 8003a8e:	460d      	mov	r5, r1
 8003a90:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8003a92:	6823      	ldr	r3, [r4, #0]
 8003a94:	699b      	ldr	r3, [r3, #24]
 8003a96:	079b      	lsls	r3, r3, #30
 8003a98:	d501      	bpl.n	8003a9e <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
 8003a9a:	2000      	movs	r0, #0
}
 8003a9c:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8003a9e:	4632      	mov	r2, r6
 8003aa0:	4629      	mov	r1, r5
 8003aa2:	4620      	mov	r0, r4
 8003aa4:	f7ff ff6e 	bl	8003984 <I2C_IsAcknowledgeFailed>
 8003aa8:	b9a0      	cbnz	r0, 8003ad4 <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
 8003aaa:	1c6a      	adds	r2, r5, #1
 8003aac:	d0f1      	beq.n	8003a92 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003aae:	f7fd fd11 	bl	80014d4 <HAL_GetTick>
 8003ab2:	1b80      	subs	r0, r0, r6
 8003ab4:	42a8      	cmp	r0, r5
 8003ab6:	d801      	bhi.n	8003abc <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 8003ab8:	2d00      	cmp	r5, #0
 8003aba:	d1ea      	bne.n	8003a92 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003abc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8003abe:	f043 0320 	orr.w	r3, r3, #32
 8003ac2:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003ac4:	2320      	movs	r3, #32
 8003ac6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003aca:	2300      	movs	r3, #0
 8003acc:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8003ad0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8003ad4:	2001      	movs	r0, #1
 8003ad6:	e7e1      	b.n	8003a9c <I2C_WaitOnTXISFlagUntilTimeout+0x12>

08003ad8 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8003ad8:	b570      	push	{r4, r5, r6, lr}
 8003ada:	4604      	mov	r4, r0
 8003adc:	460d      	mov	r5, r1
 8003ade:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8003ae0:	6823      	ldr	r3, [r4, #0]
 8003ae2:	699b      	ldr	r3, [r3, #24]
 8003ae4:	069b      	lsls	r3, r3, #26
 8003ae6:	d501      	bpl.n	8003aec <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
 8003ae8:	2000      	movs	r0, #0
}
 8003aea:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8003aec:	4632      	mov	r2, r6
 8003aee:	4629      	mov	r1, r5
 8003af0:	4620      	mov	r0, r4
 8003af2:	f7ff ff47 	bl	8003984 <I2C_IsAcknowledgeFailed>
 8003af6:	b990      	cbnz	r0, 8003b1e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003af8:	f7fd fcec 	bl	80014d4 <HAL_GetTick>
 8003afc:	1b80      	subs	r0, r0, r6
 8003afe:	42a8      	cmp	r0, r5
 8003b00:	d801      	bhi.n	8003b06 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 8003b02:	2d00      	cmp	r5, #0
 8003b04:	d1ec      	bne.n	8003ae0 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b06:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8003b08:	f043 0320 	orr.w	r3, r3, #32
 8003b0c:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003b0e:	2320      	movs	r3, #32
 8003b10:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003b14:	2300      	movs	r3, #0
 8003b16:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8003b1a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8003b1e:	2001      	movs	r0, #1
 8003b20:	e7e3      	b.n	8003aea <I2C_WaitOnSTOPFlagUntilTimeout+0x12>

08003b22 <I2C_WaitOnFlagUntilTimeout>:
{
 8003b22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003b26:	9f06      	ldr	r7, [sp, #24]
 8003b28:	4604      	mov	r4, r0
 8003b2a:	4688      	mov	r8, r1
 8003b2c:	4616      	mov	r6, r2
 8003b2e:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003b30:	6822      	ldr	r2, [r4, #0]
 8003b32:	6993      	ldr	r3, [r2, #24]
 8003b34:	ea38 0303 	bics.w	r3, r8, r3
 8003b38:	bf0c      	ite	eq
 8003b3a:	2301      	moveq	r3, #1
 8003b3c:	2300      	movne	r3, #0
 8003b3e:	42b3      	cmp	r3, r6
 8003b40:	d001      	beq.n	8003b46 <I2C_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 8003b42:	2000      	movs	r0, #0
 8003b44:	e015      	b.n	8003b72 <I2C_WaitOnFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 8003b46:	1c6b      	adds	r3, r5, #1
 8003b48:	d0f3      	beq.n	8003b32 <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003b4a:	f7fd fcc3 	bl	80014d4 <HAL_GetTick>
 8003b4e:	1bc0      	subs	r0, r0, r7
 8003b50:	42a8      	cmp	r0, r5
 8003b52:	d801      	bhi.n	8003b58 <I2C_WaitOnFlagUntilTimeout+0x36>
 8003b54:	2d00      	cmp	r5, #0
 8003b56:	d1eb      	bne.n	8003b30 <I2C_WaitOnFlagUntilTimeout+0xe>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b58:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8003b5a:	f043 0320 	orr.w	r3, r3, #32
 8003b5e:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003b60:	2320      	movs	r3, #32
 8003b62:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003b66:	2300      	movs	r3, #0
 8003b68:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8003b6c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8003b70:	2001      	movs	r0, #1
}
 8003b72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003b76 <HAL_I2C_MspInit>:
}
 8003b76:	4770      	bx	lr

08003b78 <HAL_I2C_Init>:
{
 8003b78:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 8003b7a:	4604      	mov	r4, r0
 8003b7c:	2800      	cmp	r0, #0
 8003b7e:	d04a      	beq.n	8003c16 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8003b80:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8003b84:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003b88:	b91b      	cbnz	r3, 8003b92 <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
 8003b8a:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8003b8e:	f7ff fff2 	bl	8003b76 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8003b92:	2324      	movs	r3, #36	; 0x24
 8003b94:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8003b98:	6823      	ldr	r3, [r4, #0]
 8003b9a:	681a      	ldr	r2, [r3, #0]
 8003b9c:	f022 0201 	bic.w	r2, r2, #1
 8003ba0:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8003ba2:	6862      	ldr	r2, [r4, #4]
 8003ba4:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8003ba8:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8003baa:	689a      	ldr	r2, [r3, #8]
 8003bac:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003bb0:	609a      	str	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003bb2:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
 8003bb6:	2901      	cmp	r1, #1
 8003bb8:	d124      	bne.n	8003c04 <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8003bba:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003bbe:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8003bc0:	685a      	ldr	r2, [r3, #4]
 8003bc2:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8003bc6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003bca:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8003bcc:	68da      	ldr	r2, [r3, #12]
 8003bce:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003bd2:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8003bd4:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
 8003bd8:	430a      	orrs	r2, r1
                          (hi2c->Init.OwnAddress2Masks << 8));
 8003bda:	69a1      	ldr	r1, [r4, #24]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 8003bdc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8003be0:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8003be2:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
 8003be6:	430a      	orrs	r2, r1
 8003be8:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8003bea:	681a      	ldr	r2, [r3, #0]
 8003bec:	f042 0201 	orr.w	r2, r2, #1
 8003bf0:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003bf2:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8003bf4:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003bf6:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8003bf8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8003bfc:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8003bfe:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8003c02:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8003c04:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8003c08:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8003c0a:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8003c0c:	bf04      	itt	eq
 8003c0e:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8003c12:	605a      	streq	r2, [r3, #4]
 8003c14:	e7d4      	b.n	8003bc0 <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 8003c16:	2001      	movs	r0, #1
 8003c18:	e7f3      	b.n	8003c02 <HAL_I2C_Init+0x8a>

08003c1a <HAL_I2C_MspDeInit>:
 8003c1a:	4770      	bx	lr

08003c1c <HAL_I2C_DeInit>:
{
 8003c1c:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 8003c1e:	4604      	mov	r4, r0
 8003c20:	b198      	cbz	r0, 8003c4a <HAL_I2C_DeInit+0x2e>
  __HAL_I2C_DISABLE(hi2c);
 8003c22:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8003c24:	2324      	movs	r3, #36	; 0x24
 8003c26:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8003c2a:	6813      	ldr	r3, [r2, #0]
 8003c2c:	f023 0301 	bic.w	r3, r3, #1
 8003c30:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8003c32:	f7ff fff2 	bl	8003c1a <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003c36:	2000      	movs	r0, #0
 8003c38:	6460      	str	r0, [r4, #68]	; 0x44
  __HAL_UNLOCK(hi2c);
 8003c3a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 8003c3e:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8003c42:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8003c44:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8003c48:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8003c4a:	2001      	movs	r0, #1
 8003c4c:	e7fc      	b.n	8003c48 <HAL_I2C_DeInit+0x2c>
	...

08003c50 <HAL_I2C_Master_Transmit>:
{
 8003c50:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8003c54:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003c56:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8003c5a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003c5c:	2b20      	cmp	r3, #32
{
 8003c5e:	4604      	mov	r4, r0
 8003c60:	460e      	mov	r6, r1
 8003c62:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003c64:	f040 8086 	bne.w	8003d74 <HAL_I2C_Master_Transmit+0x124>
    __HAL_LOCK(hi2c);
 8003c68:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8003c6c:	2b01      	cmp	r3, #1
 8003c6e:	f000 8081 	beq.w	8003d74 <HAL_I2C_Master_Transmit+0x124>
 8003c72:	f04f 0a01 	mov.w	sl, #1
 8003c76:	f880 a040 	strb.w	sl, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8003c7a:	f7fd fc2b 	bl	80014d4 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8003c7e:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 8003c80:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8003c82:	9000      	str	r0, [sp, #0]
 8003c84:	4652      	mov	r2, sl
 8003c86:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003c8a:	4620      	mov	r0, r4
 8003c8c:	f7ff ff49 	bl	8003b22 <I2C_WaitOnFlagUntilTimeout>
 8003c90:	b118      	cbz	r0, 8003c9a <HAL_I2C_Master_Transmit+0x4a>
      return HAL_ERROR;
 8003c92:	2001      	movs	r0, #1
}
 8003c94:	b002      	add	sp, #8
 8003c96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8003c9a:	2321      	movs	r3, #33	; 0x21
 8003c9c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8003ca0:	2310      	movs	r3, #16
 8003ca2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003ca6:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8003ca8:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003cac:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8003cae:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003cb2:	b29b      	uxth	r3, r3
 8003cb4:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8003cb6:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003cb8:	4b2f      	ldr	r3, [pc, #188]	; (8003d78 <HAL_I2C_Master_Transmit+0x128>)
 8003cba:	d926      	bls.n	8003d0a <HAL_I2C_Master_Transmit+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8003cbc:	22ff      	movs	r2, #255	; 0xff
 8003cbe:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003cc0:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003cc2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003cc6:	4631      	mov	r1, r6
 8003cc8:	4620      	mov	r0, r4
 8003cca:	f7ff fe47 	bl	800395c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8003cce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003cd0:	b29b      	uxth	r3, r3
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003cd2:	462a      	mov	r2, r5
 8003cd4:	4639      	mov	r1, r7
 8003cd6:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8003cd8:	b9fb      	cbnz	r3, 8003d1a <HAL_I2C_Master_Transmit+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003cda:	f7ff fefd 	bl	8003ad8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003cde:	2800      	cmp	r0, #0
 8003ce0:	d1d7      	bne.n	8003c92 <HAL_I2C_Master_Transmit+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003ce2:	6823      	ldr	r3, [r4, #0]
 8003ce4:	2120      	movs	r1, #32
 8003ce6:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8003ce8:	685a      	ldr	r2, [r3, #4]
 8003cea:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8003cee:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8003cf2:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8003cf6:	f022 0201 	bic.w	r2, r2, #1
 8003cfa:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8003cfc:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8003d00:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8003d04:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8003d08:	e7c4      	b.n	8003c94 <HAL_I2C_Master_Transmit+0x44>
      hi2c->XferSize = hi2c->XferCount;
 8003d0a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003d0c:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 8003d0e:	b292      	uxth	r2, r2
 8003d10:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003d12:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8003d16:	b2d2      	uxtb	r2, r2
 8003d18:	e7d5      	b.n	8003cc6 <HAL_I2C_Master_Transmit+0x76>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003d1a:	f7ff feb6 	bl	8003a8a <I2C_WaitOnTXISFlagUntilTimeout>
 8003d1e:	2800      	cmp	r0, #0
 8003d20:	d1b7      	bne.n	8003c92 <HAL_I2C_Master_Transmit+0x42>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8003d22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003d24:	6822      	ldr	r2, [r4, #0]
 8003d26:	f813 1b01 	ldrb.w	r1, [r3], #1
 8003d2a:	6291      	str	r1, [r2, #40]	; 0x28
      hi2c->pBuffPtr++;
 8003d2c:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8003d2e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8003d30:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8003d32:	3b01      	subs	r3, #1
 8003d34:	b29b      	uxth	r3, r3
 8003d36:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003d38:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8003d3a:	3a01      	subs	r2, #1
 8003d3c:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003d3e:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8003d40:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003d42:	2b00      	cmp	r3, #0
 8003d44:	d0c3      	beq.n	8003cce <HAL_I2C_Master_Transmit+0x7e>
 8003d46:	2a00      	cmp	r2, #0
 8003d48:	d1c1      	bne.n	8003cce <HAL_I2C_Master_Transmit+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8003d4a:	9500      	str	r5, [sp, #0]
 8003d4c:	463b      	mov	r3, r7
 8003d4e:	2180      	movs	r1, #128	; 0x80
 8003d50:	4620      	mov	r0, r4
 8003d52:	f7ff fee6 	bl	8003b22 <I2C_WaitOnFlagUntilTimeout>
 8003d56:	2800      	cmp	r0, #0
 8003d58:	d19b      	bne.n	8003c92 <HAL_I2C_Master_Transmit+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003d5a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003d5c:	b29b      	uxth	r3, r3
 8003d5e:	2bff      	cmp	r3, #255	; 0xff
 8003d60:	d903      	bls.n	8003d6a <HAL_I2C_Master_Transmit+0x11a>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8003d62:	22ff      	movs	r2, #255	; 0xff
 8003d64:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003d66:	9000      	str	r0, [sp, #0]
 8003d68:	e7ab      	b.n	8003cc2 <HAL_I2C_Master_Transmit+0x72>
          hi2c->XferSize = hi2c->XferCount;
 8003d6a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003d6c:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8003d6e:	b292      	uxth	r2, r2
 8003d70:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003d72:	e7ce      	b.n	8003d12 <HAL_I2C_Master_Transmit+0xc2>
    return HAL_BUSY;
 8003d74:	2002      	movs	r0, #2
 8003d76:	e78d      	b.n	8003c94 <HAL_I2C_Master_Transmit+0x44>
 8003d78:	80002000 	.word	0x80002000

08003d7c <HAL_I2C_Master_Receive>:
{
 8003d7c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8003d80:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003d82:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8003d86:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003d88:	2b20      	cmp	r3, #32
{
 8003d8a:	4604      	mov	r4, r0
 8003d8c:	460e      	mov	r6, r1
 8003d8e:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 8003d90:	f040 8087 	bne.w	8003ea2 <HAL_I2C_Master_Receive+0x126>
    __HAL_LOCK(hi2c);
 8003d94:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8003d98:	2b01      	cmp	r3, #1
 8003d9a:	f000 8082 	beq.w	8003ea2 <HAL_I2C_Master_Receive+0x126>
 8003d9e:	f04f 0a01 	mov.w	sl, #1
 8003da2:	f880 a040 	strb.w	sl, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8003da6:	f7fd fb95 	bl	80014d4 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8003daa:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 8003dac:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8003dae:	9000      	str	r0, [sp, #0]
 8003db0:	4652      	mov	r2, sl
 8003db2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003db6:	4620      	mov	r0, r4
 8003db8:	f7ff feb3 	bl	8003b22 <I2C_WaitOnFlagUntilTimeout>
 8003dbc:	b118      	cbz	r0, 8003dc6 <HAL_I2C_Master_Receive+0x4a>
      return HAL_ERROR;
 8003dbe:	2001      	movs	r0, #1
}
 8003dc0:	b002      	add	sp, #8
 8003dc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8003dc6:	2322      	movs	r3, #34	; 0x22
 8003dc8:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8003dcc:	2310      	movs	r3, #16
 8003dce:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003dd2:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8003dd4:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003dd8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8003dda:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003dde:	b29b      	uxth	r3, r3
 8003de0:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8003de2:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003de4:	4b30      	ldr	r3, [pc, #192]	; (8003ea8 <HAL_I2C_Master_Receive+0x12c>)
 8003de6:	d926      	bls.n	8003e36 <HAL_I2C_Master_Receive+0xba>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8003de8:	22ff      	movs	r2, #255	; 0xff
 8003dea:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003dec:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003dee:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003df2:	4631      	mov	r1, r6
 8003df4:	4620      	mov	r0, r4
 8003df6:	f7ff fdb1 	bl	800395c <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8003dfa:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003dfc:	b29b      	uxth	r3, r3
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003dfe:	462a      	mov	r2, r5
 8003e00:	4639      	mov	r1, r7
 8003e02:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8003e04:	b9fb      	cbnz	r3, 8003e46 <HAL_I2C_Master_Receive+0xca>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003e06:	f7ff fe67 	bl	8003ad8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003e0a:	2800      	cmp	r0, #0
 8003e0c:	d1d7      	bne.n	8003dbe <HAL_I2C_Master_Receive+0x42>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003e0e:	6823      	ldr	r3, [r4, #0]
 8003e10:	2120      	movs	r1, #32
 8003e12:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8003e14:	685a      	ldr	r2, [r3, #4]
 8003e16:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8003e1a:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8003e1e:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8003e22:	f022 0201 	bic.w	r2, r2, #1
 8003e26:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8003e28:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8003e2c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8003e30:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8003e34:	e7c4      	b.n	8003dc0 <HAL_I2C_Master_Receive+0x44>
      hi2c->XferSize = hi2c->XferCount;
 8003e36:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003e38:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 8003e3a:	b292      	uxth	r2, r2
 8003e3c:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003e3e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8003e42:	b2d2      	uxtb	r2, r2
 8003e44:	e7d5      	b.n	8003df2 <HAL_I2C_Master_Receive+0x76>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8003e46:	f7ff fde1 	bl	8003a0c <I2C_WaitOnRXNEFlagUntilTimeout>
 8003e4a:	2800      	cmp	r0, #0
 8003e4c:	d1b7      	bne.n	8003dbe <HAL_I2C_Master_Receive+0x42>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8003e4e:	6823      	ldr	r3, [r4, #0]
 8003e50:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003e52:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003e54:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8003e56:	6a63      	ldr	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8003e58:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->pBuffPtr++;
 8003e5a:	3301      	adds	r3, #1
 8003e5c:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8003e5e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003e60:	3b01      	subs	r3, #1
 8003e62:	b29b      	uxth	r3, r3
 8003e64:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003e66:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8003e68:	3a01      	subs	r2, #1
 8003e6a:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003e6c:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8003e6e:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8003e70:	2b00      	cmp	r3, #0
 8003e72:	d0c2      	beq.n	8003dfa <HAL_I2C_Master_Receive+0x7e>
 8003e74:	2a00      	cmp	r2, #0
 8003e76:	d1c0      	bne.n	8003dfa <HAL_I2C_Master_Receive+0x7e>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8003e78:	9500      	str	r5, [sp, #0]
 8003e7a:	463b      	mov	r3, r7
 8003e7c:	2180      	movs	r1, #128	; 0x80
 8003e7e:	4620      	mov	r0, r4
 8003e80:	f7ff fe4f 	bl	8003b22 <I2C_WaitOnFlagUntilTimeout>
 8003e84:	2800      	cmp	r0, #0
 8003e86:	d19a      	bne.n	8003dbe <HAL_I2C_Master_Receive+0x42>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003e88:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8003e8a:	b29b      	uxth	r3, r3
 8003e8c:	2bff      	cmp	r3, #255	; 0xff
 8003e8e:	d903      	bls.n	8003e98 <HAL_I2C_Master_Receive+0x11c>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8003e90:	22ff      	movs	r2, #255	; 0xff
 8003e92:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8003e94:	9000      	str	r0, [sp, #0]
 8003e96:	e7aa      	b.n	8003dee <HAL_I2C_Master_Receive+0x72>
          hi2c->XferSize = hi2c->XferCount;
 8003e98:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003e9a:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8003e9c:	b292      	uxth	r2, r2
 8003e9e:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8003ea0:	e7cd      	b.n	8003e3e <HAL_I2C_Master_Receive+0xc2>
    return HAL_BUSY;
 8003ea2:	2002      	movs	r0, #2
 8003ea4:	e78c      	b.n	8003dc0 <HAL_I2C_Master_Receive+0x44>
 8003ea6:	bf00      	nop
 8003ea8:	80002400 	.word	0x80002400

08003eac <HAL_I2C_GetState>:
  return hi2c->State;
 8003eac:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
}
 8003eb0:	4770      	bx	lr

08003eb2 <HAL_I2C_GetError>:
  return hi2c->ErrorCode;
 8003eb2:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
 8003eb4:	4770      	bx	lr

08003eb6 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8003eb6:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8003eb8:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8003ebc:	2b20      	cmp	r3, #32
 8003ebe:	b2dc      	uxtb	r4, r3
 8003ec0:	d11d      	bne.n	8003efe <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003ec2:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8003ec6:	2b01      	cmp	r3, #1
 8003ec8:	d019      	beq.n	8003efe <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8003eca:	2324      	movs	r3, #36	; 0x24
 8003ecc:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8003ed0:	6803      	ldr	r3, [r0, #0]
 8003ed2:	681a      	ldr	r2, [r3, #0]
 8003ed4:	f022 0201 	bic.w	r2, r2, #1
 8003ed8:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8003eda:	681a      	ldr	r2, [r3, #0]
 8003edc:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003ee0:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8003ee2:	681a      	ldr	r2, [r3, #0]
 8003ee4:	4311      	orrs	r1, r2
 8003ee6:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8003ee8:	681a      	ldr	r2, [r3, #0]
 8003eea:	f042 0201 	orr.w	r2, r2, #1
 8003eee:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003ef0:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8003ef2:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8003ef6:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8003efa:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8003efc:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 8003efe:	2002      	movs	r0, #2
 8003f00:	e7fc      	b.n	8003efc <HAL_I2CEx_ConfigAnalogFilter+0x46>

08003f02 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8003f02:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8003f04:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8003f08:	2b20      	cmp	r3, #32
 8003f0a:	b2dc      	uxtb	r4, r3
 8003f0c:	d11c      	bne.n	8003f48 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003f0e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8003f12:	2b01      	cmp	r3, #1
 8003f14:	d018      	beq.n	8003f48 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8003f16:	2324      	movs	r3, #36	; 0x24
 8003f18:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8003f1c:	6803      	ldr	r3, [r0, #0]
 8003f1e:	681a      	ldr	r2, [r3, #0]
 8003f20:	f022 0201 	bic.w	r2, r2, #1
 8003f24:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8003f26:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8003f28:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8003f2c:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8003f30:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8003f32:	681a      	ldr	r2, [r3, #0]
 8003f34:	f042 0201 	orr.w	r2, r2, #1
 8003f38:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003f3a:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8003f3c:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8003f40:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8003f44:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8003f46:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 8003f48:	2002      	movs	r0, #2
 8003f4a:	e7fc      	b.n	8003f46 <HAL_I2CEx_ConfigDigitalFilter+0x44>

08003f4c <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003f4c:	4a02      	ldr	r2, [pc, #8]	; (8003f58 <HAL_PWR_EnableBkUpAccess+0xc>)
 8003f4e:	6813      	ldr	r3, [r2, #0]
 8003f50:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003f54:	6013      	str	r3, [r2, #0]
}
 8003f56:	4770      	bx	lr
 8003f58:	58000400 	.word	0x58000400

08003f5c <HAL_PWR_EnterSLEEPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 8003f5c:	4b0d      	ldr	r3, [pc, #52]	; (8003f94 <HAL_PWR_EnterSLEEPMode+0x38>)
{
 8003f5e:	b510      	push	{r4, lr}
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8003f60:	695b      	ldr	r3, [r3, #20]
{
 8003f62:	460c      	mov	r4, r1
  if (Regulator == PWR_MAINREGULATOR_ON)
 8003f64:	b928      	cbnz	r0, 8003f72 <HAL_PWR_EnterSLEEPMode+0x16>
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8003f66:	059a      	lsls	r2, r3, #22
 8003f68:	d507      	bpl.n	8003f7a <HAL_PWR_EnterSLEEPMode+0x1e>
    {
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 8003f6a:	f000 f827 	bl	8003fbc <HAL_PWREx_DisableLowPowerRunMode>
 8003f6e:	b120      	cbz	r0, 8003f7a <HAL_PWR_EnterSLEEPMode+0x1e>
    /* Request Wait For Event */
    __SEV();
    __WFE();
    __WFE();
  }
}
 8003f70:	bd10      	pop	{r4, pc}
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 8003f72:	059b      	lsls	r3, r3, #22
 8003f74:	d401      	bmi.n	8003f7a <HAL_PWR_EnterSLEEPMode+0x1e>
      HAL_PWREx_EnableLowPowerRunMode();
 8003f76:	f000 f819 	bl	8003fac <HAL_PWREx_EnableLowPowerRunMode>
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8003f7a:	4a07      	ldr	r2, [pc, #28]	; (8003f98 <HAL_PWR_EnterSLEEPMode+0x3c>)
 8003f7c:	6913      	ldr	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8003f7e:	2c01      	cmp	r4, #1
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8003f80:	f023 0304 	bic.w	r3, r3, #4
 8003f84:	6113      	str	r3, [r2, #16]
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8003f86:	d101      	bne.n	8003f8c <HAL_PWR_EnterSLEEPMode+0x30>
    __WFI();
 8003f88:	bf30      	wfi
 8003f8a:	e7f1      	b.n	8003f70 <HAL_PWR_EnterSLEEPMode+0x14>
    __SEV();
 8003f8c:	bf40      	sev
    __WFE();
 8003f8e:	bf20      	wfe
    __WFE();
 8003f90:	bf20      	wfe
 8003f92:	e7ed      	b.n	8003f70 <HAL_PWR_EnterSLEEPMode+0x14>
 8003f94:	58000400 	.word	0x58000400
 8003f98:	e000ed00 	.word	0xe000ed00

08003f9c <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE1 or PWPWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 8003f9c:	4b02      	ldr	r3, [pc, #8]	; (8003fa8 <HAL_PWREx_GetVoltageRange+0xc>)
 8003f9e:	6818      	ldr	r0, [r3, #0]
}
 8003fa0:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop
 8003fa8:	58000400 	.word	0x58000400

08003fac <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 8003fac:	4a02      	ldr	r2, [pc, #8]	; (8003fb8 <HAL_PWREx_EnableLowPowerRunMode+0xc>)
 8003fae:	6813      	ldr	r3, [r2, #0]
 8003fb0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003fb4:	6013      	str	r3, [r2, #0]
}
 8003fb6:	4770      	bx	lr
 8003fb8:	58000400 	.word	0x58000400

08003fbc <HAL_PWREx_DisableLowPowerRunMode>:
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 8003fbc:	4a0d      	ldr	r2, [pc, #52]	; (8003ff4 <HAL_PWREx_DisableLowPowerRunMode+0x38>)
 8003fbe:	6813      	ldr	r3, [r2, #0]
 8003fc0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003fc4:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8003fc6:	4b0c      	ldr	r3, [pc, #48]	; (8003ff8 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8003fc8:	6819      	ldr	r1, [r3, #0]
 8003fca:	2332      	movs	r3, #50	; 0x32
 8003fcc:	434b      	muls	r3, r1
 8003fce:	490b      	ldr	r1, [pc, #44]	; (8003ffc <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8003fd0:	fbb3 f3f1 	udiv	r3, r3, r1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8003fd4:	4611      	mov	r1, r2
 8003fd6:	6950      	ldr	r0, [r2, #20]
 8003fd8:	f410 7f00 	tst.w	r0, #512	; 0x200
 8003fdc:	d000      	beq.n	8003fe0 <HAL_PWREx_DisableLowPowerRunMode+0x24>
 8003fde:	b933      	cbnz	r3, 8003fee <HAL_PWREx_DisableLowPowerRunMode+0x32>
  {
    wait_loop_index--;
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8003fe0:	694b      	ldr	r3, [r1, #20]
  {
    return HAL_TIMEOUT;
 8003fe2:	f413 7f00 	tst.w	r3, #512	; 0x200
  }

  return HAL_OK;
}
 8003fe6:	bf14      	ite	ne
 8003fe8:	2003      	movne	r0, #3
 8003fea:	2000      	moveq	r0, #0
 8003fec:	4770      	bx	lr
    wait_loop_index--;
 8003fee:	3b01      	subs	r3, #1
 8003ff0:	e7f1      	b.n	8003fd6 <HAL_PWREx_DisableLowPowerRunMode+0x1a>
 8003ff2:	bf00      	nop
 8003ff4:	58000400 	.word	0x58000400
 8003ff8:	20000050 	.word	0x20000050
 8003ffc:	000f4240 	.word	0x000f4240

08004000 <HAL_PWREx_EnterSTOP2Mode>:
#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#else
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 8004000:	4a0b      	ldr	r2, [pc, #44]	; (8004030 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 8004002:	6813      	ldr	r3, [r2, #0]
 8004004:	f023 0307 	bic.w	r3, r3, #7
 8004008:	f043 0302 	orr.w	r3, r3, #2
 800400c:	6013      	str	r3, [r2, #0]
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800400e:	4b09      	ldr	r3, [pc, #36]	; (8004034 <HAL_PWREx_EnterSTOP2Mode+0x34>)
 8004010:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 8004012:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8004014:	f042 0204 	orr.w	r2, r2, #4
 8004018:	611a      	str	r2, [r3, #16]
  if (STOPEntry == PWR_STOPENTRY_WFI)
 800401a:	d105      	bne.n	8004028 <HAL_PWREx_EnterSTOP2Mode+0x28>
  {
    /* Request Wait For Interrupt */
    __WFI();
 800401c:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 800401e:	691a      	ldr	r2, [r3, #16]
 8004020:	f022 0204 	bic.w	r2, r2, #4
 8004024:	611a      	str	r2, [r3, #16]
}
 8004026:	4770      	bx	lr
    __SEV();
 8004028:	bf40      	sev
    __WFE();
 800402a:	bf20      	wfe
    __WFE();
 800402c:	bf20      	wfe
 800402e:	e7f6      	b.n	800401e <HAL_PWREx_EnterSTOP2Mode+0x1e>
 8004030:	58000400 	.word	0x58000400
 8004034:	e000ed00 	.word	0xe000ed00

08004038 <LL_RCC_HSE_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY)) ? 1UL : 0UL);
 8004038:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800403c:	6818      	ldr	r0, [r3, #0]
}
 800403e:	f3c0 4040 	ubfx	r0, r0, #17, #1
 8004042:	4770      	bx	lr

08004044 <LL_RCC_HSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8004044:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004048:	6818      	ldr	r0, [r3, #0]
}
 800404a:	f3c0 2080 	ubfx	r0, r0, #10, #1
 800404e:	4770      	bx	lr

08004050 <LL_RCC_MSI_IsReady>:
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) == (RCC_CR_MSIRDY)) ? 1UL : 0UL);
 8004050:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004054:	6818      	ldr	r0, [r3, #0]
}
 8004056:	f3c0 0040 	ubfx	r0, r0, #1, #1
 800405a:	4770      	bx	lr

0800405c <LL_RCC_MSI_SetCalibTrimming>:
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_MSITRIM, Value << RCC_ICSCR_MSITRIM_Pos);
 800405c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8004060:	6853      	ldr	r3, [r2, #4]
 8004062:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8004066:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800406a:	6053      	str	r3, [r2, #4]
}
 800406c:	4770      	bx	lr

0800406e <LL_RCC_PLL_IsReady>:
  * @rmtoll CR           PLLRDY        LL_RCC_PLL_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
{
  return ((READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY)) ? 1UL : 0UL);
 800406e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004072:	6818      	ldr	r0, [r3, #0]
}
 8004074:	f3c0 6040 	ubfx	r0, r0, #25, #1
 8004078:	4770      	bx	lr
	...

0800407c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  MSI_Range  MSI range value from @ref RCC_MSIRANGE_0 to @ref RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t MSI_Range)
{
 800407c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE) << 4);
 800407e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
  uint32_t flash_clksrcfreq;
  uint32_t msifreq;

  /* MSI frequency range in Hz */
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 8004082:	4a2c      	ldr	r2, [pc, #176]	; (8004134 <RCC_SetFlashLatencyFromMSIRange+0xb8>)
 8004084:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  msifreq           = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSIRANGESEL_RUN, MSI_Range);
 8004088:	f3c0 1003 	ubfx	r0, r0, #4, #4
  flash_clksrcfreq  = __LL_RCC_CALC_HCLK3_FREQ(msifreq, LL_RCC_GetAHB3Prescaler());
 800408c:	f003 030f 	and.w	r3, r3, #15
 8004090:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 8004094:	4a28      	ldr	r2, [pc, #160]	; (8004138 <RCC_SetFlashLatencyFromMSIRange+0xbc>)
 8004096:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800409a:	fbb4 f4f3 	udiv	r4, r4, r3

  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 800409e:	f7ff ff7d 	bl	8003f9c <HAL_PWREx_GetVoltageRange>

  /* Flash Clock source (HCLK3) range in MHz for VCORE range2 */
  const uint16_t FLASH_CLK_SRC_RANGE_VOS2[] = {6, 12, 16};

  /* Flash Latency range */
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 80040a2:	4b26      	ldr	r3, [pc, #152]	; (800413c <RCC_SetFlashLatencyFromMSIRange+0xc0>)
  return RCC_SetFlashLatency((flash_clksrcfreq / MEGA_HZ), HAL_PWREx_GetVoltageRange());
 80040a4:	4605      	mov	r5, r0
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 80040a6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}

  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t tickstart;

  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80040aa:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
  const uint32_t FLASH_LATENCY_RANGE[] = {FLASH_LATENCY_0, FLASH_LATENCY_1, FLASH_LATENCY_2};
 80040ae:	ab04      	add	r3, sp, #16
 80040b0:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if (VCORE_Voltage == PWR_REGULATOR_VOLTAGE_SCALE1)
 80040b4:	d010      	beq.n	80040d8 <RCC_SetFlashLatencyFromMSIRange+0x5c>
  }
  else  /* PWR_REGULATOR_VOLTAGE_SCALE2 */
  {
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
    {
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS2[index])
 80040b6:	4b22      	ldr	r3, [pc, #136]	; (8004140 <RCC_SetFlashLatencyFromMSIRange+0xc4>)
 80040b8:	429c      	cmp	r4, r3
 80040ba:	d318      	bcc.n	80040ee <RCC_SetFlashLatencyFromMSIRange+0x72>
 80040bc:	f503 03b7 	add.w	r3, r3, #5996544	; 0x5b8000
 80040c0:	f603 537f 	addw	r3, r3, #3455	; 0xd7f
 80040c4:	429c      	cmp	r4, r3
 80040c6:	d929      	bls.n	800411c <RCC_SetFlashLatencyFromMSIRange+0xa0>
 80040c8:	f503 1374 	add.w	r3, r3, #3997696	; 0x3d0000
 80040cc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 80040d0:	429c      	cmp	r4, r3
 80040d2:	d825      	bhi.n	8004120 <RCC_SetFlashLatencyFromMSIRange+0xa4>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 80040d4:	2302      	movs	r3, #2
 80040d6:	e00b      	b.n	80040f0 <RCC_SetFlashLatencyFromMSIRange+0x74>
      if (Flash_ClkSrcFreq <= FLASH_CLK_SRC_RANGE_VOS1[index])
 80040d8:	4b1a      	ldr	r3, [pc, #104]	; (8004144 <RCC_SetFlashLatencyFromMSIRange+0xc8>)
 80040da:	429c      	cmp	r4, r3
 80040dc:	d907      	bls.n	80040ee <RCC_SetFlashLatencyFromMSIRange+0x72>
 80040de:	4b1a      	ldr	r3, [pc, #104]	; (8004148 <RCC_SetFlashLatencyFromMSIRange+0xcc>)
 80040e0:	429c      	cmp	r4, r3
 80040e2:	d91b      	bls.n	800411c <RCC_SetFlashLatencyFromMSIRange+0xa0>
 80040e4:	f503 0337 	add.w	r3, r3, #11993088	; 0xb70000
 80040e8:	f503 53d8 	add.w	r3, r3, #6912	; 0x1b00
 80040ec:	e7f0      	b.n	80040d0 <RCC_SetFlashLatencyFromMSIRange+0x54>
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 80040ee:	2300      	movs	r3, #0
      {
        latency = FLASH_LATENCY_RANGE[index];
 80040f0:	aa04      	add	r2, sp, #16
 80040f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80040f6:	f853 4c0c 	ldr.w	r4, [r3, #-12]
        break;
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 80040fa:	4d14      	ldr	r5, [pc, #80]	; (800414c <RCC_SetFlashLatencyFromMSIRange+0xd0>)
 80040fc:	682b      	ldr	r3, [r5, #0]
 80040fe:	f023 0307 	bic.w	r3, r3, #7
 8004102:	4323      	orrs	r3, r4
 8004104:	602b      	str	r3, [r5, #0]

  /* Get Start Tick*/
  tickstart = HAL_GetTick();
 8004106:	f7fd f9e5 	bl	80014d4 <HAL_GetTick>
 800410a:	4606      	mov	r6, r0

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  while (__HAL_FLASH_GET_LATENCY() != latency)
 800410c:	682b      	ldr	r3, [r5, #0]
 800410e:	f003 0307 	and.w	r3, r3, #7
 8004112:	429c      	cmp	r4, r3
 8004114:	d106      	bne.n	8004124 <RCC_SetFlashLatencyFromMSIRange+0xa8>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 8004116:	2000      	movs	r0, #0
}
 8004118:	b004      	add	sp, #16
 800411a:	bd70      	pop	{r4, r5, r6, pc}
    for (uint32_t index = 0; index < __COUNTOF(FLASH_CLK_SRC_RANGE_VOS2); index++)
 800411c:	2301      	movs	r3, #1
 800411e:	e7e7      	b.n	80040f0 <RCC_SetFlashLatencyFromMSIRange+0x74>
  uint32_t latency   = FLASH_LATENCY_0;  /* default value 0WS */
 8004120:	2400      	movs	r4, #0
 8004122:	e7ea      	b.n	80040fa <RCC_SetFlashLatencyFromMSIRange+0x7e>
    if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8004124:	f7fd f9d6 	bl	80014d4 <HAL_GetTick>
 8004128:	1b80      	subs	r0, r0, r6
 800412a:	2802      	cmp	r0, #2
 800412c:	d9ee      	bls.n	800410c <RCC_SetFlashLatencyFromMSIRange+0x90>
      return HAL_TIMEOUT;
 800412e:	2003      	movs	r0, #3
 8004130:	e7f2      	b.n	8004118 <RCC_SetFlashLatencyFromMSIRange+0x9c>
 8004132:	bf00      	nop
 8004134:	08010850 	.word	0x08010850
 8004138:	080107f0 	.word	0x080107f0
 800413c:	08010368 	.word	0x08010368
 8004140:	006acfc0 	.word	0x006acfc0
 8004144:	0121eabf 	.word	0x0121eabf
 8004148:	0234933f 	.word	0x0234933f
 800414c:	58004000 	.word	0x58004000

08004150 <HAL_RCC_GetSysClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8004150:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
{
 8004154:	b510      	push	{r4, lr}
 8004156:	689a      	ldr	r2, [r3, #8]
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8004158:	68d9      	ldr	r1, [r3, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800415a:	f012 020c 	ands.w	r2, r2, #12
 800415e:	d005      	beq.n	800416c <HAL_RCC_GetSysClockFreq+0x1c>
 8004160:	2a0c      	cmp	r2, #12
 8004162:	d14a      	bne.n	80041fa <HAL_RCC_GetSysClockFreq+0xaa>
 8004164:	f001 0303 	and.w	r3, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8004168:	2b01      	cmp	r3, #1
 800416a:	d150      	bne.n	800420e <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 800416c:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004170:	482b      	ldr	r0, [pc, #172]	; (8004220 <HAL_RCC_GetSysClockFreq+0xd0>)
 8004172:	680b      	ldr	r3, [r1, #0]
 8004174:	f013 0308 	ands.w	r3, r3, #8
 8004178:	d006      	beq.n	8004188 <HAL_RCC_GetSysClockFreq+0x38>
 800417a:	680b      	ldr	r3, [r1, #0]
 800417c:	f013 0308 	ands.w	r3, r3, #8
 8004180:	d137      	bne.n	80041f2 <HAL_RCC_GetSysClockFreq+0xa2>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8004182:	f8d1 1094 	ldr.w	r1, [r1, #148]	; 0x94
 8004186:	e007      	b.n	8004198 <HAL_RCC_GetSysClockFreq+0x48>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8004188:	680c      	ldr	r4, [r1, #0]
 800418a:	0724      	lsls	r4, r4, #28
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 800418c:	bf56      	itet	pl
 800418e:	f8d1 3094 	ldrpl.w	r3, [r1, #148]	; 0x94
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8004192:	6809      	ldrmi	r1, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8004194:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
 8004198:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
      sysclockfreq = msifreq;
 800419c:	2a00      	cmp	r2, #0
 800419e:	bf0c      	ite	eq
 80041a0:	4618      	moveq	r0, r3
 80041a2:	2000      	movne	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80041a4:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80041a8:	688a      	ldr	r2, [r1, #8]
 80041aa:	f002 020c 	and.w	r2, r2, #12
  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80041ae:	2a0c      	cmp	r2, #12
 80041b0:	d11e      	bne.n	80041f0 <HAL_RCC_GetSysClockFreq+0xa0>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80041b2:	68ca      	ldr	r2, [r1, #12]
 80041b4:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 80041b8:	2a02      	cmp	r2, #2
 80041ba:	d02e      	beq.n	800421a <HAL_RCC_GetSysClockFreq+0xca>
 80041bc:	2a03      	cmp	r2, #3
 80041be:	d106      	bne.n	80041ce <HAL_RCC_GetSysClockFreq+0x7e>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 80041c0:	680b      	ldr	r3, [r1, #0]
          pllinputfreq = HSE_VALUE / 2U;
 80041c2:	4818      	ldr	r0, [pc, #96]	; (8004224 <HAL_RCC_GetSysClockFreq+0xd4>)
 80041c4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80041c8:	4b17      	ldr	r3, [pc, #92]	; (8004228 <HAL_RCC_GetSysClockFreq+0xd8>)
 80041ca:	bf18      	it	ne
 80041cc:	4603      	movne	r3, r0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80041ce:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
 80041d2:	68c1      	ldr	r1, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 80041d4:	68c2      	ldr	r2, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 80041d6:	68c0      	ldr	r0, [r0, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 80041d8:	f3c1 2106 	ubfx	r1, r1, #8, #7
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 80041dc:	f3c2 1202 	ubfx	r2, r2, #4, #3
 80041e0:	0f40      	lsrs	r0, r0, #29
 80041e2:	434b      	muls	r3, r1
 80041e4:	3201      	adds	r2, #1
 80041e6:	3001      	adds	r0, #1
 80041e8:	fbb3 f3f2 	udiv	r3, r3, r2
 80041ec:	fbb3 f0f0 	udiv	r0, r3, r0
}
 80041f0:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 80041f2:	680b      	ldr	r3, [r1, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 80041f4:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80041f8:	e7ce      	b.n	8004198 <HAL_RCC_GetSysClockFreq+0x48>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 80041fa:	2a04      	cmp	r2, #4
 80041fc:	d00a      	beq.n	8004214 <HAL_RCC_GetSysClockFreq+0xc4>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 80041fe:	2a08      	cmp	r2, #8
 8004200:	d105      	bne.n	800420e <HAL_RCC_GetSysClockFreq+0xbe>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8004202:	681b      	ldr	r3, [r3, #0]
 8004204:	f413 1380 	ands.w	r3, r3, #1048576	; 0x100000
 8004208:	d104      	bne.n	8004214 <HAL_RCC_GetSysClockFreq+0xc4>
      sysclockfreq = HSE_VALUE;
 800420a:	4807      	ldr	r0, [pc, #28]	; (8004228 <HAL_RCC_GetSysClockFreq+0xd8>)
 800420c:	e7ca      	b.n	80041a4 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msifreq = 0U;
 800420e:	2300      	movs	r3, #0
  uint32_t sysclockfreq = 0U;
 8004210:	4618      	mov	r0, r3
 8004212:	e7c7      	b.n	80041a4 <HAL_RCC_GetSysClockFreq+0x54>
      sysclockfreq = HSE_VALUE / 2U;
 8004214:	4803      	ldr	r0, [pc, #12]	; (8004224 <HAL_RCC_GetSysClockFreq+0xd4>)
  uint32_t msifreq = 0U;
 8004216:	2300      	movs	r3, #0
 8004218:	e7c4      	b.n	80041a4 <HAL_RCC_GetSysClockFreq+0x54>
        pllinputfreq = HSI_VALUE;
 800421a:	4b02      	ldr	r3, [pc, #8]	; (8004224 <HAL_RCC_GetSysClockFreq+0xd4>)
 800421c:	e7d7      	b.n	80041ce <HAL_RCC_GetSysClockFreq+0x7e>
 800421e:	bf00      	nop
 8004220:	08010850 	.word	0x08010850
 8004224:	00f42400 	.word	0x00f42400
 8004228:	01e84800 	.word	0x01e84800

0800422c <HAL_RCC_GetHCLKFreq>:
{
 800422c:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 800422e:	f7ff ff8f 	bl	8004150 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8004232:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004236:	4a04      	ldr	r2, [pc, #16]	; (8004248 <HAL_RCC_GetHCLKFreq+0x1c>)
 8004238:	689b      	ldr	r3, [r3, #8]
 800423a:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800423e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8004242:	fbb0 f0f3 	udiv	r0, r0, r3
 8004246:	bd08      	pop	{r3, pc}
 8004248:	080107f0 	.word	0x080107f0

0800424c <HAL_RCC_OscConfig>:
{
 800424c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 8004250:	4604      	mov	r4, r0
 8004252:	2800      	cmp	r0, #0
 8004254:	d055      	beq.n	8004302 <HAL_RCC_OscConfig+0xb6>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8004256:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800425a:	689e      	ldr	r6, [r3, #8]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 800425c:	68dd      	ldr	r5, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800425e:	6803      	ldr	r3, [r0, #0]
 8004260:	0699      	lsls	r1, r3, #26
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8004262:	f006 060c 	and.w	r6, r6, #12
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8004266:	f005 0503 	and.w	r5, r5, #3
 800426a:	d56b      	bpl.n	8004344 <HAL_RCC_OscConfig+0xf8>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 800426c:	b11e      	cbz	r6, 8004276 <HAL_RCC_OscConfig+0x2a>
 800426e:	2e0c      	cmp	r6, #12
 8004270:	d149      	bne.n	8004306 <HAL_RCC_OscConfig+0xba>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 8004272:	2d01      	cmp	r5, #1
 8004274:	d147      	bne.n	8004306 <HAL_RCC_OscConfig+0xba>
      if ((LL_RCC_MSI_IsReady() != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8004276:	f7ff feeb 	bl	8004050 <LL_RCC_MSI_IsReady>
 800427a:	b110      	cbz	r0, 8004282 <HAL_RCC_OscConfig+0x36>
 800427c:	6a23      	ldr	r3, [r4, #32]
 800427e:	2b00      	cmp	r3, #0
 8004280:	d03f      	beq.n	8004302 <HAL_RCC_OscConfig+0xb6>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8004282:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004286:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8004288:	681a      	ldr	r2, [r3, #0]
 800428a:	0712      	lsls	r2, r2, #28
 800428c:	bf56      	itet	pl
 800428e:	f8d3 3094 	ldrpl.w	r3, [r3, #148]	; 0x94
 8004292:	681b      	ldrmi	r3, [r3, #0]
 8004294:	091b      	lsrpl	r3, r3, #4
 8004296:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800429a:	4298      	cmp	r0, r3
 800429c:	d91e      	bls.n	80042dc <HAL_RCC_OscConfig+0x90>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800429e:	f7ff feed 	bl	800407c <RCC_SetFlashLatencyFromMSIRange>
 80042a2:	2800      	cmp	r0, #0
 80042a4:	d12d      	bne.n	8004302 <HAL_RCC_OscConfig+0xb6>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80042a6:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80042aa:	6813      	ldr	r3, [r2, #0]
 80042ac:	f043 0308 	orr.w	r3, r3, #8
 80042b0:	6013      	str	r3, [r2, #0]
 80042b2:	6813      	ldr	r3, [r2, #0]
 80042b4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80042b6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80042ba:	430b      	orrs	r3, r1
 80042bc:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80042be:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80042c0:	f7ff fecc 	bl	800405c <LL_RCC_MSI_SetCalibTrimming>
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80042c4:	f7ff ffb2 	bl	800422c <HAL_RCC_GetHCLKFreq>
 80042c8:	4bac      	ldr	r3, [pc, #688]	; (800457c <HAL_RCC_OscConfig+0x330>)
 80042ca:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 80042cc:	4bac      	ldr	r3, [pc, #688]	; (8004580 <HAL_RCC_OscConfig+0x334>)
 80042ce:	6818      	ldr	r0, [r3, #0]
 80042d0:	f7fd f8fe 	bl	80014d0 <HAL_InitTick>
        if (status != HAL_OK)
 80042d4:	2800      	cmp	r0, #0
 80042d6:	d035      	beq.n	8004344 <HAL_RCC_OscConfig+0xf8>
}
 80042d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80042dc:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80042e0:	6813      	ldr	r3, [r2, #0]
 80042e2:	f043 0308 	orr.w	r3, r3, #8
 80042e6:	6013      	str	r3, [r2, #0]
 80042e8:	6813      	ldr	r3, [r2, #0]
 80042ea:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80042ee:	4303      	orrs	r3, r0
 80042f0:	6013      	str	r3, [r2, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80042f2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80042f4:	f7ff feb2 	bl	800405c <LL_RCC_MSI_SetCalibTrimming>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80042f8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80042fa:	f7ff febf 	bl	800407c <RCC_SetFlashLatencyFromMSIRange>
 80042fe:	2800      	cmp	r0, #0
 8004300:	d0e0      	beq.n	80042c4 <HAL_RCC_OscConfig+0x78>
          return HAL_ERROR;
 8004302:	2001      	movs	r0, #1
 8004304:	e7e8      	b.n	80042d8 <HAL_RCC_OscConfig+0x8c>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8004306:	6a22      	ldr	r2, [r4, #32]
 8004308:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 800430c:	2a00      	cmp	r2, #0
 800430e:	d054      	beq.n	80043ba <HAL_RCC_OscConfig+0x16e>
  SET_BIT(RCC->CR, RCC_CR_MSION);
 8004310:	681a      	ldr	r2, [r3, #0]
 8004312:	f042 0201 	orr.w	r2, r2, #1
 8004316:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8004318:	f7fd f8dc 	bl	80014d4 <HAL_GetTick>
 800431c:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() == 0U)
 800431e:	f7ff fe97 	bl	8004050 <LL_RCC_MSI_IsReady>
 8004322:	2800      	cmp	r0, #0
 8004324:	d042      	beq.n	80043ac <HAL_RCC_OscConfig+0x160>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8004326:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 800432a:	6813      	ldr	r3, [r2, #0]
 800432c:	f043 0308 	orr.w	r3, r3, #8
 8004330:	6013      	str	r3, [r2, #0]
 8004332:	6813      	ldr	r3, [r2, #0]
 8004334:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004336:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800433a:	430b      	orrs	r3, r1
 800433c:	6013      	str	r3, [r2, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 800433e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8004340:	f7ff fe8c 	bl	800405c <LL_RCC_MSI_SetCalibTrimming>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8004344:	6823      	ldr	r3, [r4, #0]
 8004346:	07db      	lsls	r3, r3, #31
 8004348:	d448      	bmi.n	80043dc <HAL_RCC_OscConfig+0x190>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800434a:	6823      	ldr	r3, [r4, #0]
 800434c:	079f      	lsls	r7, r3, #30
 800434e:	f100 8090 	bmi.w	8004472 <HAL_RCC_OscConfig+0x226>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004352:	6823      	ldr	r3, [r4, #0]
 8004354:	071d      	lsls	r5, r3, #28
 8004356:	f140 80fc 	bpl.w	8004552 <HAL_RCC_OscConfig+0x306>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800435a:	69a3      	ldr	r3, [r4, #24]
 800435c:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 8004360:	2b00      	cmp	r3, #0
 8004362:	f000 80e3 	beq.w	800452c <HAL_RCC_OscConfig+0x2e0>
      uint32_t csr_temp = RCC->CSR;
 8004366:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
      if (RCC_OscInitStruct->LSIDiv != (csr_temp & RCC_CSR_LSIPRE))
 800436a:	69e1      	ldr	r1, [r4, #28]
 800436c:	f003 0210 	and.w	r2, r3, #16
 8004370:	4291      	cmp	r1, r2
 8004372:	f000 80c6 	beq.w	8004502 <HAL_RCC_OscConfig+0x2b6>
        if (((csr_temp & RCC_CSR_LSIRDY) == RCC_CSR_LSIRDY) && \
 8004376:	f003 0203 	and.w	r2, r3, #3
 800437a:	2a02      	cmp	r2, #2
 800437c:	d0c1      	beq.n	8004302 <HAL_RCC_OscConfig+0xb6>
        if ((csr_temp & RCC_CSR_LSION) == RCC_CSR_LSION)
 800437e:	07d8      	lsls	r0, r3, #31
 8004380:	f140 80b5 	bpl.w	80044ee <HAL_RCC_OscConfig+0x2a2>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 8004384:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8004388:	f023 0301 	bic.w	r3, r3, #1
 800438c:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
          tickstart = HAL_GetTick();
 8004390:	f7fd f8a0 	bl	80014d4 <HAL_GetTick>
 8004394:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8004396:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800439a:	0799      	lsls	r1, r3, #30
 800439c:	f140 80a7 	bpl.w	80044ee <HAL_RCC_OscConfig+0x2a2>
            if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80043a0:	f7fd f898 	bl	80014d4 <HAL_GetTick>
 80043a4:	1bc3      	subs	r3, r0, r7
 80043a6:	2b11      	cmp	r3, #17
 80043a8:	d9f5      	bls.n	8004396 <HAL_RCC_OscConfig+0x14a>
 80043aa:	e004      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80043ac:	f7fd f892 	bl	80014d4 <HAL_GetTick>
 80043b0:	1bc0      	subs	r0, r0, r7
 80043b2:	2802      	cmp	r0, #2
 80043b4:	d9b3      	bls.n	800431e <HAL_RCC_OscConfig+0xd2>
            return HAL_TIMEOUT;
 80043b6:	2003      	movs	r0, #3
 80043b8:	e78e      	b.n	80042d8 <HAL_RCC_OscConfig+0x8c>
  CLEAR_BIT(RCC->CR, RCC_CR_MSION);
 80043ba:	681a      	ldr	r2, [r3, #0]
 80043bc:	f022 0201 	bic.w	r2, r2, #1
 80043c0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80043c2:	f7fd f887 	bl	80014d4 <HAL_GetTick>
 80043c6:	4607      	mov	r7, r0
        while (LL_RCC_MSI_IsReady() != 0U)
 80043c8:	f7ff fe42 	bl	8004050 <LL_RCC_MSI_IsReady>
 80043cc:	2800      	cmp	r0, #0
 80043ce:	d0b9      	beq.n	8004344 <HAL_RCC_OscConfig+0xf8>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80043d0:	f7fd f880 	bl	80014d4 <HAL_GetTick>
 80043d4:	1bc0      	subs	r0, r0, r7
 80043d6:	2802      	cmp	r0, #2
 80043d8:	d9f6      	bls.n	80043c8 <HAL_RCC_OscConfig+0x17c>
 80043da:	e7ec      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 80043dc:	2e08      	cmp	r6, #8
 80043de:	d003      	beq.n	80043e8 <HAL_RCC_OscConfig+0x19c>
 80043e0:	2e0c      	cmp	r6, #12
 80043e2:	d109      	bne.n	80043f8 <HAL_RCC_OscConfig+0x1ac>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 80043e4:	2d03      	cmp	r5, #3
 80043e6:	d107      	bne.n	80043f8 <HAL_RCC_OscConfig+0x1ac>
      if ((LL_RCC_HSE_IsReady() != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80043e8:	f7ff fe26 	bl	8004038 <LL_RCC_HSE_IsReady>
 80043ec:	2800      	cmp	r0, #0
 80043ee:	d0ac      	beq.n	800434a <HAL_RCC_OscConfig+0xfe>
 80043f0:	6863      	ldr	r3, [r4, #4]
 80043f2:	2b00      	cmp	r3, #0
 80043f4:	d1a9      	bne.n	800434a <HAL_RCC_OscConfig+0xfe>
 80043f6:	e784      	b.n	8004302 <HAL_RCC_OscConfig+0xb6>
      MODIFY_REG(RCC->CR, RCC_CR_HSEPRE, RCC_OscInitStruct->HSEDiv);
 80043f8:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80043fc:	68a1      	ldr	r1, [r4, #8]
 80043fe:	681a      	ldr	r2, [r3, #0]
 8004400:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8004404:	430a      	orrs	r2, r1
 8004406:	601a      	str	r2, [r3, #0]
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004408:	6862      	ldr	r2, [r4, #4]
 800440a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800440e:	d110      	bne.n	8004432 <HAL_RCC_OscConfig+0x1e6>
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8004410:	681a      	ldr	r2, [r3, #0]
 8004412:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004416:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8004418:	f7fd f85c 	bl	80014d4 <HAL_GetTick>
 800441c:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() == 0U)
 800441e:	f7ff fe0b 	bl	8004038 <LL_RCC_HSE_IsReady>
 8004422:	2800      	cmp	r0, #0
 8004424:	d191      	bne.n	800434a <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004426:	f7fd f855 	bl	80014d4 <HAL_GetTick>
 800442a:	1bc0      	subs	r0, r0, r7
 800442c:	2864      	cmp	r0, #100	; 0x64
 800442e:	d9f6      	bls.n	800441e <HAL_RCC_OscConfig+0x1d2>
 8004430:	e7c1      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8004432:	f5b2 1f04 	cmp.w	r2, #2162688	; 0x210000
 8004436:	d104      	bne.n	8004442 <HAL_RCC_OscConfig+0x1f6>
  SET_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 8004438:	681a      	ldr	r2, [r3, #0]
 800443a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800443e:	601a      	str	r2, [r3, #0]
 8004440:	e7e6      	b.n	8004410 <HAL_RCC_OscConfig+0x1c4>
  CLEAR_BIT(RCC->CR, RCC_CR_HSEON);
 8004442:	6819      	ldr	r1, [r3, #0]
 8004444:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 8004448:	6019      	str	r1, [r3, #0]
  CLEAR_BIT(RCC->CR, RCC_CR_HSEBYPPWR);
 800444a:	6819      	ldr	r1, [r3, #0]
 800444c:	f421 1100 	bic.w	r1, r1, #2097152	; 0x200000
 8004450:	6019      	str	r1, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8004452:	2a00      	cmp	r2, #0
 8004454:	d1e0      	bne.n	8004418 <HAL_RCC_OscConfig+0x1cc>
        tickstart = HAL_GetTick();
 8004456:	f7fd f83d 	bl	80014d4 <HAL_GetTick>
 800445a:	4607      	mov	r7, r0
        while (LL_RCC_HSE_IsReady() != 0U)
 800445c:	f7ff fdec 	bl	8004038 <LL_RCC_HSE_IsReady>
 8004460:	2800      	cmp	r0, #0
 8004462:	f43f af72 	beq.w	800434a <HAL_RCC_OscConfig+0xfe>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8004466:	f7fd f835 	bl	80014d4 <HAL_GetTick>
 800446a:	1bc0      	subs	r0, r0, r7
 800446c:	2864      	cmp	r0, #100	; 0x64
 800446e:	d9f5      	bls.n	800445c <HAL_RCC_OscConfig+0x210>
 8004470:	e7a1      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 8004472:	2e04      	cmp	r6, #4
 8004474:	d003      	beq.n	800447e <HAL_RCC_OscConfig+0x232>
 8004476:	2e0c      	cmp	r6, #12
 8004478:	d112      	bne.n	80044a0 <HAL_RCC_OscConfig+0x254>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 800447a:	2d02      	cmp	r5, #2
 800447c:	d110      	bne.n	80044a0 <HAL_RCC_OscConfig+0x254>
      if ((LL_RCC_HSI_IsReady() != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800447e:	f7ff fde1 	bl	8004044 <LL_RCC_HSI_IsReady>
 8004482:	b118      	cbz	r0, 800448c <HAL_RCC_OscConfig+0x240>
 8004484:	6923      	ldr	r3, [r4, #16]
 8004486:	2b00      	cmp	r3, #0
 8004488:	f43f af3b 	beq.w	8004302 <HAL_RCC_OscConfig+0xb6>
  MODIFY_REG(RCC->ICSCR, RCC_ICSCR_HSITRIM, Value << RCC_ICSCR_HSITRIM_Pos);
 800448c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8004490:	6961      	ldr	r1, [r4, #20]
 8004492:	6853      	ldr	r3, [r2, #4]
 8004494:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8004498:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800449c:	6053      	str	r3, [r2, #4]
}
 800449e:	e758      	b.n	8004352 <HAL_RCC_OscConfig+0x106>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80044a0:	6922      	ldr	r2, [r4, #16]
 80044a2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80044a6:	b182      	cbz	r2, 80044ca <HAL_RCC_OscConfig+0x27e>
  SET_BIT(RCC->CR, RCC_CR_HSION);
 80044a8:	681a      	ldr	r2, [r3, #0]
 80044aa:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80044ae:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80044b0:	f7fd f810 	bl	80014d4 <HAL_GetTick>
 80044b4:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() == 0U)
 80044b6:	f7ff fdc5 	bl	8004044 <LL_RCC_HSI_IsReady>
 80044ba:	2800      	cmp	r0, #0
 80044bc:	d1e6      	bne.n	800448c <HAL_RCC_OscConfig+0x240>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80044be:	f7fd f809 	bl	80014d4 <HAL_GetTick>
 80044c2:	1b40      	subs	r0, r0, r5
 80044c4:	2802      	cmp	r0, #2
 80044c6:	d9f6      	bls.n	80044b6 <HAL_RCC_OscConfig+0x26a>
 80044c8:	e775      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CR, RCC_CR_HSION);
 80044ca:	681a      	ldr	r2, [r3, #0]
 80044cc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80044d0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80044d2:	f7fc ffff 	bl	80014d4 <HAL_GetTick>
 80044d6:	4605      	mov	r5, r0
        while (LL_RCC_HSI_IsReady() != 0U)
 80044d8:	f7ff fdb4 	bl	8004044 <LL_RCC_HSI_IsReady>
 80044dc:	2800      	cmp	r0, #0
 80044de:	f43f af38 	beq.w	8004352 <HAL_RCC_OscConfig+0x106>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80044e2:	f7fc fff7 	bl	80014d4 <HAL_GetTick>
 80044e6:	1b40      	subs	r0, r0, r5
 80044e8:	2802      	cmp	r0, #2
 80044ea:	d9f5      	bls.n	80044d8 <HAL_RCC_OscConfig+0x28c>
 80044ec:	e763      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->CSR, RCC_CSR_LSIPRE, RCC_OscInitStruct->LSIDiv);
 80044ee:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80044f2:	69e1      	ldr	r1, [r4, #28]
 80044f4:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80044f8:	f023 0310 	bic.w	r3, r3, #16
 80044fc:	430b      	orrs	r3, r1
 80044fe:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
  SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8004502:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 8004506:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800450a:	f043 0301 	orr.w	r3, r3, #1
 800450e:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 8004512:	f7fc ffdf 	bl	80014d4 <HAL_GetTick>
 8004516:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 8004518:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 800451c:	079a      	lsls	r2, r3, #30
 800451e:	d418      	bmi.n	8004552 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004520:	f7fc ffd8 	bl	80014d4 <HAL_GetTick>
 8004524:	1bc3      	subs	r3, r0, r7
 8004526:	2b11      	cmp	r3, #17
 8004528:	d9f6      	bls.n	8004518 <HAL_RCC_OscConfig+0x2cc>
 800452a:	e744      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
  CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
 800452c:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8004530:	f023 0301 	bic.w	r3, r3, #1
 8004534:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 8004538:	f7fc ffcc 	bl	80014d4 <HAL_GetTick>
 800453c:	4607      	mov	r7, r0
  return ((READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY)) ? 1UL : 0UL);
 800453e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8004542:	079b      	lsls	r3, r3, #30
 8004544:	d505      	bpl.n	8004552 <HAL_RCC_OscConfig+0x306>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8004546:	f7fc ffc5 	bl	80014d4 <HAL_GetTick>
 800454a:	1bc3      	subs	r3, r0, r7
 800454c:	2b11      	cmp	r3, #17
 800454e:	d9f6      	bls.n	800453e <HAL_RCC_OscConfig+0x2f2>
 8004550:	e731      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004552:	6823      	ldr	r3, [r4, #0]
 8004554:	0758      	lsls	r0, r3, #29
 8004556:	d553      	bpl.n	8004600 <HAL_RCC_OscConfig+0x3b4>
  return ((READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)) ? 1UL : 0UL);
 8004558:	4d0a      	ldr	r5, [pc, #40]	; (8004584 <HAL_RCC_OscConfig+0x338>)
 800455a:	682b      	ldr	r3, [r5, #0]
 800455c:	05d9      	lsls	r1, r3, #23
 800455e:	d413      	bmi.n	8004588 <HAL_RCC_OscConfig+0x33c>
      HAL_PWR_EnableBkUpAccess();
 8004560:	f7ff fcf4 	bl	8003f4c <HAL_PWR_EnableBkUpAccess>
      tickstart = HAL_GetTick();
 8004564:	f7fc ffb6 	bl	80014d4 <HAL_GetTick>
 8004568:	4607      	mov	r7, r0
 800456a:	682b      	ldr	r3, [r5, #0]
 800456c:	05da      	lsls	r2, r3, #23
 800456e:	d40b      	bmi.n	8004588 <HAL_RCC_OscConfig+0x33c>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004570:	f7fc ffb0 	bl	80014d4 <HAL_GetTick>
 8004574:	1bc3      	subs	r3, r0, r7
 8004576:	2b02      	cmp	r3, #2
 8004578:	d9f7      	bls.n	800456a <HAL_RCC_OscConfig+0x31e>
 800457a:	e71c      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
 800457c:	20000050 	.word	0x20000050
 8004580:	20000054 	.word	0x20000054
 8004584:	58000400 	.word	0x58000400
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8004588:	68e3      	ldr	r3, [r4, #12]
 800458a:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
 800458e:	2b00      	cmp	r3, #0
 8004590:	d058      	beq.n	8004644 <HAL_RCC_OscConfig+0x3f8>
          || (RCC_OscInitStruct->LSEState == RCC_LSE_BYPASS_RTC_ONLY))
 8004592:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004596:	2b05      	cmp	r3, #5
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 8004598:	bf02      	ittt	eq
 800459a:	f8d5 3090 	ldreq.w	r3, [r5, #144]	; 0x90
 800459e:	f043 0304 	orreq.w	r3, r3, #4
 80045a2:	f8c5 3090 	streq.w	r3, [r5, #144]	; 0x90
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80045a6:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
      tickstart = HAL_GetTick();
 80045aa:	f7fc ff93 	bl	80014d4 <HAL_GetTick>
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80045ae:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80045b2:	f043 0301 	orr.w	r3, r3, #1
      tickstart = HAL_GetTick();
 80045b6:	4607      	mov	r7, r0
      SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 80045b8:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80045bc:	f241 3888 	movw	r8, #5000	; 0x1388
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80045c0:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80045c4:	079b      	lsls	r3, r3, #30
 80045c6:	d405      	bmi.n	80045d4 <HAL_RCC_OscConfig+0x388>
 80045c8:	f7fc ff84 	bl	80014d4 <HAL_GetTick>
 80045cc:	1bc3      	subs	r3, r0, r7
 80045ce:	4543      	cmp	r3, r8
 80045d0:	d9f6      	bls.n	80045c0 <HAL_RCC_OscConfig+0x374>
 80045d2:	e6f0      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->LSEState == RCC_LSE_ON)
 80045d4:	68e3      	ldr	r3, [r4, #12]
 80045d6:	f023 0304 	bic.w	r3, r3, #4
 80045da:	2b81      	cmp	r3, #129	; 0x81
 80045dc:	d11b      	bne.n	8004616 <HAL_RCC_OscConfig+0x3ca>
        tickstart = HAL_GetTick();
 80045de:	f7fc ff79 	bl	80014d4 <HAL_GetTick>
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 80045e2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80045e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80045ea:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 80045ee:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80045f0:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80045f4:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 80045f8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 80045fc:	0518      	lsls	r0, r3, #20
 80045fe:	d504      	bpl.n	800460a <HAL_RCC_OscConfig+0x3be>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8004600:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8004602:	2800      	cmp	r0, #0
 8004604:	d14a      	bne.n	800469c <HAL_RCC_OscConfig+0x450>
  return HAL_OK;
 8004606:	2000      	movs	r0, #0
 8004608:	e666      	b.n	80042d8 <HAL_RCC_OscConfig+0x8c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800460a:	f7fc ff63 	bl	80014d4 <HAL_GetTick>
 800460e:	1bc0      	subs	r0, r0, r7
 8004610:	4540      	cmp	r0, r8
 8004612:	d9f1      	bls.n	80045f8 <HAL_RCC_OscConfig+0x3ac>
 8004614:	e6cf      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
        tickstart = HAL_GetTick();
 8004616:	f7fc ff5d 	bl	80014d4 <HAL_GetTick>
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 800461a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800461e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004622:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        tickstart = HAL_GetTick();
 8004626:	4607      	mov	r7, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8004628:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800462c:	f241 3888 	movw	r8, #5000	; 0x1388
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 8004630:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 8004634:	0519      	lsls	r1, r3, #20
 8004636:	d5e3      	bpl.n	8004600 <HAL_RCC_OscConfig+0x3b4>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004638:	f7fc ff4c 	bl	80014d4 <HAL_GetTick>
 800463c:	1bc0      	subs	r0, r0, r7
 800463e:	4540      	cmp	r0, r8
 8004640:	d9f6      	bls.n	8004630 <HAL_RCC_OscConfig+0x3e4>
 8004642:	e6b8      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
      tickstart = HAL_GetTick();
 8004644:	f7fc ff46 	bl	80014d4 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8004648:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800464c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
      tickstart = HAL_GetTick();
 8004650:	4607      	mov	r7, r0
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 8004652:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004656:	f241 3888 	movw	r8, #5000	; 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 800465a:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800465e:	051a      	lsls	r2, r3, #20
 8004660:	d416      	bmi.n	8004690 <HAL_RCC_OscConfig+0x444>
      tickstart = HAL_GetTick();
 8004662:	f7fc ff37 	bl	80014d4 <HAL_GetTick>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 8004666:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 800466a:	f023 0301 	bic.w	r3, r3, #1
 800466e:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 8004672:	4607      	mov	r7, r0
 8004674:	f04f 48b0 	mov.w	r8, #1476395008	; 0x58000000
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004678:	f241 3588 	movw	r5, #5000	; 0x1388
 800467c:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 8004680:	079b      	lsls	r3, r3, #30
 8004682:	d5bd      	bpl.n	8004600 <HAL_RCC_OscConfig+0x3b4>
 8004684:	f7fc ff26 	bl	80014d4 <HAL_GetTick>
 8004688:	1bc3      	subs	r3, r0, r7
 800468a:	42ab      	cmp	r3, r5
 800468c:	d9f6      	bls.n	800467c <HAL_RCC_OscConfig+0x430>
 800468e:	e692      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004690:	f7fc ff20 	bl	80014d4 <HAL_GetTick>
 8004694:	1bc0      	subs	r0, r0, r7
 8004696:	4540      	cmp	r0, r8
 8004698:	d9df      	bls.n	800465a <HAL_RCC_OscConfig+0x40e>
 800469a:	e68c      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
    if (sysclk_source != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800469c:	2e0c      	cmp	r6, #12
 800469e:	d053      	beq.n	8004748 <HAL_RCC_OscConfig+0x4fc>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80046a0:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80046a4:	2802      	cmp	r0, #2
  CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 80046a6:	681a      	ldr	r2, [r3, #0]
 80046a8:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80046ac:	601a      	str	r2, [r3, #0]
 80046ae:	d133      	bne.n	8004718 <HAL_RCC_OscConfig+0x4cc>
        tickstart = HAL_GetTick();
 80046b0:	f7fc ff10 	bl	80014d4 <HAL_GetTick>
 80046b4:	4605      	mov	r5, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 80046b6:	f7ff fcda 	bl	800406e <LL_RCC_PLL_IsReady>
 80046ba:	bb38      	cbnz	r0, 800470c <HAL_RCC_OscConfig+0x4c0>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80046bc:	e9d4 310c 	ldrd	r3, r1, [r4, #48]	; 0x30
 80046c0:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 80046c4:	430b      	orrs	r3, r1
 80046c6:	68d0      	ldr	r0, [r2, #12]
 80046c8:	492f      	ldr	r1, [pc, #188]	; (8004788 <HAL_RCC_OscConfig+0x53c>)
 80046ca:	4001      	ands	r1, r0
 80046cc:	430b      	orrs	r3, r1
 80046ce:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80046d0:	430b      	orrs	r3, r1
 80046d2:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80046d4:	430b      	orrs	r3, r1
 80046d6:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80046d8:	430b      	orrs	r3, r1
 80046da:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80046dc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80046e0:	60d3      	str	r3, [r2, #12]
  SET_BIT(RCC->CR, RCC_CR_PLLON);
 80046e2:	6813      	ldr	r3, [r2, #0]
 80046e4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80046e8:	6013      	str	r3, [r2, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80046ea:	68d3      	ldr	r3, [r2, #12]
 80046ec:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80046f0:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 80046f2:	f7fc feef 	bl	80014d4 <HAL_GetTick>
 80046f6:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() == 0U)
 80046f8:	f7ff fcb9 	bl	800406e <LL_RCC_PLL_IsReady>
 80046fc:	2800      	cmp	r0, #0
 80046fe:	d182      	bne.n	8004606 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8004700:	f7fc fee8 	bl	80014d4 <HAL_GetTick>
 8004704:	1b00      	subs	r0, r0, r4
 8004706:	280a      	cmp	r0, #10
 8004708:	d9f6      	bls.n	80046f8 <HAL_RCC_OscConfig+0x4ac>
 800470a:	e654      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800470c:	f7fc fee2 	bl	80014d4 <HAL_GetTick>
 8004710:	1b40      	subs	r0, r0, r5
 8004712:	280a      	cmp	r0, #10
 8004714:	d9cf      	bls.n	80046b6 <HAL_RCC_OscConfig+0x46a>
 8004716:	e64e      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
        MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PLLSOURCE_NONE);
 8004718:	68da      	ldr	r2, [r3, #12]
 800471a:	f022 0203 	bic.w	r2, r2, #3
 800471e:	60da      	str	r2, [r3, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_RNGCLK | RCC_PLL_ADCCLK);
 8004720:	68da      	ldr	r2, [r3, #12]
 8004722:	f022 5288 	bic.w	r2, r2, #285212672	; 0x11000000
 8004726:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800472a:	60da      	str	r2, [r3, #12]
        tickstart = HAL_GetTick();
 800472c:	f7fc fed2 	bl	80014d4 <HAL_GetTick>
 8004730:	4604      	mov	r4, r0
        while (LL_RCC_PLL_IsReady() != 0U)
 8004732:	f7ff fc9c 	bl	800406e <LL_RCC_PLL_IsReady>
 8004736:	2800      	cmp	r0, #0
 8004738:	f43f af65 	beq.w	8004606 <HAL_RCC_OscConfig+0x3ba>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800473c:	f7fc feca 	bl	80014d4 <HAL_GetTick>
 8004740:	1b00      	subs	r0, r0, r4
 8004742:	280a      	cmp	r0, #10
 8004744:	d9f5      	bls.n	8004732 <HAL_RCC_OscConfig+0x4e6>
 8004746:	e636      	b.n	80043b6 <HAL_RCC_OscConfig+0x16a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8004748:	2801      	cmp	r0, #1
 800474a:	f43f adc5 	beq.w	80042d8 <HAL_RCC_OscConfig+0x8c>
        pll_config = RCC->PLLCFGR;
 800474e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 8004752:	6b22      	ldr	r2, [r4, #48]	; 0x30
        pll_config = RCC->PLLCFGR;
 8004754:	68db      	ldr	r3, [r3, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource)
 8004756:	f003 0103 	and.w	r1, r3, #3
 800475a:	4291      	cmp	r1, r2
 800475c:	f47f add1 	bne.w	8004302 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)   != RCC_OscInitStruct->PLL.PLLM)
 8004760:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8004762:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8004766:	428a      	cmp	r2, r1
 8004768:	f47f adcb 	bne.w	8004302 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)   != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos))
 800476c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800476e:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 8004772:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8004776:	f47f adc4 	bne.w	8004302 <HAL_RCC_OscConfig+0xb6>
            || (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)   != RCC_OscInitStruct->PLL.PLLR))
 800477a:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800477c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
 8004780:	4293      	cmp	r3, r2
 8004782:	f43f af40 	beq.w	8004606 <HAL_RCC_OscConfig+0x3ba>
 8004786:	e5bc      	b.n	8004302 <HAL_RCC_OscConfig+0xb6>
 8004788:	11c1808c 	.word	0x11c1808c

0800478c <HAL_RCC_ClockConfig>:
{
 800478c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004790:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 8004792:	4604      	mov	r4, r0
 8004794:	b910      	cbnz	r0, 800479c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8004796:	2001      	movs	r0, #1
}
 8004798:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800479c:	4e74      	ldr	r6, [pc, #464]	; (8004970 <HAL_RCC_ClockConfig+0x1e4>)
 800479e:	6833      	ldr	r3, [r6, #0]
 80047a0:	f003 0307 	and.w	r3, r3, #7
 80047a4:	428b      	cmp	r3, r1
 80047a6:	d316      	bcc.n	80047d6 <HAL_RCC_ClockConfig+0x4a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80047a8:	6823      	ldr	r3, [r4, #0]
 80047aa:	079a      	lsls	r2, r3, #30
 80047ac:	d527      	bpl.n	80047fe <HAL_RCC_ClockConfig+0x72>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 80047ae:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 80047b2:	68a2      	ldr	r2, [r4, #8]
 80047b4:	68b3      	ldr	r3, [r6, #8]
 80047b6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80047ba:	4313      	orrs	r3, r2
 80047bc:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80047be:	f7fc fe89 	bl	80014d4 <HAL_GetTick>
 80047c2:	4607      	mov	r7, r0
  * @rmtoll CFGR         HPREF       LL_RCC_IsActiveFlag_HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_HPRE(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_HPREF) == (RCC_CFGR_HPREF)) ? 1UL : 0UL);
 80047c4:	68b3      	ldr	r3, [r6, #8]
 80047c6:	03db      	lsls	r3, r3, #15
 80047c8:	d419      	bmi.n	80047fe <HAL_RCC_ClockConfig+0x72>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80047ca:	f7fc fe83 	bl	80014d4 <HAL_GetTick>
 80047ce:	1bc3      	subs	r3, r0, r7
 80047d0:	2b02      	cmp	r3, #2
 80047d2:	d9f7      	bls.n	80047c4 <HAL_RCC_ClockConfig+0x38>
 80047d4:	e011      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80047d6:	6833      	ldr	r3, [r6, #0]
 80047d8:	f023 0307 	bic.w	r3, r3, #7
 80047dc:	430b      	orrs	r3, r1
 80047de:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 80047e0:	f7fc fe78 	bl	80014d4 <HAL_GetTick>
 80047e4:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 80047e6:	6833      	ldr	r3, [r6, #0]
 80047e8:	f003 0307 	and.w	r3, r3, #7
 80047ec:	42ab      	cmp	r3, r5
 80047ee:	d0db      	beq.n	80047a8 <HAL_RCC_ClockConfig+0x1c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 80047f0:	f7fc fe70 	bl	80014d4 <HAL_GetTick>
 80047f4:	1bc0      	subs	r0, r0, r7
 80047f6:	2802      	cmp	r0, #2
 80047f8:	d9f5      	bls.n	80047e6 <HAL_RCC_ClockConfig+0x5a>
        return HAL_TIMEOUT;
 80047fa:	2003      	movs	r0, #3
 80047fc:	e7cc      	b.n	8004798 <HAL_RCC_ClockConfig+0xc>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK2) == RCC_CLOCKTYPE_HCLK2)
 80047fe:	6823      	ldr	r3, [r4, #0]
 8004800:	0698      	lsls	r0, r3, #26
 8004802:	d516      	bpl.n	8004832 <HAL_RCC_ClockConfig+0xa6>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE, Prescaler);
 8004804:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 8004808:	6962      	ldr	r2, [r4, #20]
 800480a:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 800480e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8004812:	4313      	orrs	r3, r2
 8004814:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 8004818:	f7fc fe5c 	bl	80014d4 <HAL_GetTick>
 800481c:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         C2HPREF       LL_RCC_IsActiveFlag_C2HPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_C2HPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPREF) == (RCC_EXTCFGR_C2HPREF)) ? 1UL : 0UL);
 800481e:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 8004822:	0399      	lsls	r1, r3, #14
 8004824:	d405      	bmi.n	8004832 <HAL_RCC_ClockConfig+0xa6>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 8004826:	f7fc fe55 	bl	80014d4 <HAL_GetTick>
 800482a:	1bc3      	subs	r3, r0, r7
 800482c:	2b02      	cmp	r3, #2
 800482e:	d9f6      	bls.n	800481e <HAL_RCC_ClockConfig+0x92>
 8004830:	e7e3      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK3) == RCC_CLOCKTYPE_HCLK3)
 8004832:	6823      	ldr	r3, [r4, #0]
 8004834:	065a      	lsls	r2, r3, #25
 8004836:	d517      	bpl.n	8004868 <HAL_RCC_ClockConfig+0xdc>
  MODIFY_REG(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPRE, Prescaler >> 4);
 8004838:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 800483c:	69a2      	ldr	r2, [r4, #24]
 800483e:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 8004842:	f023 030f 	bic.w	r3, r3, #15
 8004846:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 800484a:	f8c6 3108 	str.w	r3, [r6, #264]	; 0x108
    tickstart = HAL_GetTick();
 800484e:	f7fc fe41 	bl	80014d4 <HAL_GetTick>
 8004852:	4607      	mov	r7, r0
  * @rmtoll EXTCFGR         SHDHPREF       LL_RCC_IsActiveFlag_SHDHPRE
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_SHDHPRE(void)
{
  return ((READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_SHDHPREF) == (RCC_EXTCFGR_SHDHPREF)) ? 1UL : 0UL);
 8004854:	f8d6 3108 	ldr.w	r3, [r6, #264]	; 0x108
 8004858:	03db      	lsls	r3, r3, #15
 800485a:	d405      	bmi.n	8004868 <HAL_RCC_ClockConfig+0xdc>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800485c:	f7fc fe3a 	bl	80014d4 <HAL_GetTick>
 8004860:	1bc3      	subs	r3, r0, r7
 8004862:	2b02      	cmp	r3, #2
 8004864:	d9f6      	bls.n	8004854 <HAL_RCC_ClockConfig+0xc8>
 8004866:	e7c8      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8004868:	6823      	ldr	r3, [r4, #0]
 800486a:	075e      	lsls	r6, r3, #29
 800486c:	d513      	bpl.n	8004896 <HAL_RCC_ClockConfig+0x10a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 800486e:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 8004872:	68e2      	ldr	r2, [r4, #12]
 8004874:	68b3      	ldr	r3, [r6, #8]
 8004876:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800487a:	4313      	orrs	r3, r2
 800487c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800487e:	f7fc fe29 	bl	80014d4 <HAL_GetTick>
 8004882:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE1F       LL_RCC_IsActiveFlag_PPRE1
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE1(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1F) == (RCC_CFGR_PPRE1F)) ? 1UL : 0UL);
 8004884:	68b3      	ldr	r3, [r6, #8]
 8004886:	0398      	lsls	r0, r3, #14
 8004888:	d405      	bmi.n	8004896 <HAL_RCC_ClockConfig+0x10a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 800488a:	f7fc fe23 	bl	80014d4 <HAL_GetTick>
 800488e:	1bc3      	subs	r3, r0, r7
 8004890:	2b02      	cmp	r3, #2
 8004892:	d9f7      	bls.n	8004884 <HAL_RCC_ClockConfig+0xf8>
 8004894:	e7b1      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004896:	6823      	ldr	r3, [r4, #0]
 8004898:	0719      	lsls	r1, r3, #28
 800489a:	d514      	bpl.n	80048c6 <HAL_RCC_ClockConfig+0x13a>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 800489c:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
    LL_RCC_SetAPB2Prescaler((RCC_ClkInitStruct->APB2CLKDivider) << 3U);
 80048a0:	6922      	ldr	r2, [r4, #16]
 80048a2:	68b3      	ldr	r3, [r6, #8]
 80048a4:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80048a8:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 80048ac:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 80048ae:	f7fc fe11 	bl	80014d4 <HAL_GetTick>
 80048b2:	4607      	mov	r7, r0
  * @rmtoll CFGR         PPRE2F       LL_RCC_IsActiveFlag_PPRE2
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_IsActiveFlag_PPRE2(void)
{
  return ((READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2F) == (RCC_CFGR_PPRE2F)) ? 1UL : 0UL);
 80048b4:	68b3      	ldr	r3, [r6, #8]
 80048b6:	035a      	lsls	r2, r3, #13
 80048b8:	d405      	bmi.n	80048c6 <HAL_RCC_ClockConfig+0x13a>
      if ((HAL_GetTick() - tickstart) > PRESCALER_TIMEOUT_VALUE)
 80048ba:	f7fc fe0b 	bl	80014d4 <HAL_GetTick>
 80048be:	1bc3      	subs	r3, r0, r7
 80048c0:	2b02      	cmp	r3, #2
 80048c2:	d9f7      	bls.n	80048b4 <HAL_RCC_ClockConfig+0x128>
 80048c4:	e799      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80048c6:	6823      	ldr	r3, [r4, #0]
 80048c8:	07db      	lsls	r3, r3, #31
 80048ca:	d40f      	bmi.n	80048ec <HAL_RCC_ClockConfig+0x160>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80048cc:	4c28      	ldr	r4, [pc, #160]	; (8004970 <HAL_RCC_ClockConfig+0x1e4>)
 80048ce:	6823      	ldr	r3, [r4, #0]
 80048d0:	f003 0307 	and.w	r3, r3, #7
 80048d4:	42ab      	cmp	r3, r5
 80048d6:	d837      	bhi.n	8004948 <HAL_RCC_ClockConfig+0x1bc>
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80048d8:	f7ff fca8 	bl	800422c <HAL_RCC_GetHCLKFreq>
 80048dc:	4b25      	ldr	r3, [pc, #148]	; (8004974 <HAL_RCC_ClockConfig+0x1e8>)
 80048de:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 80048e0:	4b25      	ldr	r3, [pc, #148]	; (8004978 <HAL_RCC_ClockConfig+0x1ec>)
}
 80048e2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return HAL_InitTick(uwTickPrio);
 80048e6:	6818      	ldr	r0, [r3, #0]
 80048e8:	f7fc bdf2 	b.w	80014d0 <HAL_InitTick>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80048ec:	6863      	ldr	r3, [r4, #4]
 80048ee:	2b02      	cmp	r3, #2
 80048f0:	d11e      	bne.n	8004930 <HAL_RCC_ClockConfig+0x1a4>
      if (LL_RCC_HSE_IsReady() == 0U)
 80048f2:	f7ff fba1 	bl	8004038 <LL_RCC_HSE_IsReady>
      if (LL_RCC_HSI_IsReady() == 0U)
 80048f6:	2800      	cmp	r0, #0
 80048f8:	f43f af4d 	beq.w	8004796 <HAL_RCC_ClockConfig+0xa>
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 80048fc:	f04f 46b0 	mov.w	r6, #1476395008	; 0x58000000
 8004900:	6862      	ldr	r2, [r4, #4]
 8004902:	68b3      	ldr	r3, [r6, #8]
 8004904:	f023 0303 	bic.w	r3, r3, #3
 8004908:	4313      	orrs	r3, r2
 800490a:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800490c:	f7fc fde2 	bl	80014d4 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004910:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8004914:	4607      	mov	r7, r0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8004916:	68b3      	ldr	r3, [r6, #8]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004918:	6862      	ldr	r2, [r4, #4]
 800491a:	f003 030c 	and.w	r3, r3, #12
 800491e:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8004922:	d0d3      	beq.n	80048cc <HAL_RCC_ClockConfig+0x140>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004924:	f7fc fdd6 	bl	80014d4 <HAL_GetTick>
 8004928:	1bc0      	subs	r0, r0, r7
 800492a:	4540      	cmp	r0, r8
 800492c:	d9f3      	bls.n	8004916 <HAL_RCC_ClockConfig+0x18a>
 800492e:	e764      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8004930:	2b03      	cmp	r3, #3
 8004932:	d102      	bne.n	800493a <HAL_RCC_ClockConfig+0x1ae>
      if (LL_RCC_PLL_IsReady() == 0U)
 8004934:	f7ff fb9b 	bl	800406e <LL_RCC_PLL_IsReady>
 8004938:	e7dd      	b.n	80048f6 <HAL_RCC_ClockConfig+0x16a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 800493a:	b913      	cbnz	r3, 8004942 <HAL_RCC_ClockConfig+0x1b6>
      if (LL_RCC_MSI_IsReady() == 0U)
 800493c:	f7ff fb88 	bl	8004050 <LL_RCC_MSI_IsReady>
 8004940:	e7d9      	b.n	80048f6 <HAL_RCC_ClockConfig+0x16a>
      if (LL_RCC_HSI_IsReady() == 0U)
 8004942:	f7ff fb7f 	bl	8004044 <LL_RCC_HSI_IsReady>
 8004946:	e7d6      	b.n	80048f6 <HAL_RCC_ClockConfig+0x16a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004948:	6823      	ldr	r3, [r4, #0]
 800494a:	f023 0307 	bic.w	r3, r3, #7
 800494e:	432b      	orrs	r3, r5
 8004950:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8004952:	f7fc fdbf 	bl	80014d4 <HAL_GetTick>
 8004956:	4606      	mov	r6, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8004958:	6823      	ldr	r3, [r4, #0]
 800495a:	f003 0307 	and.w	r3, r3, #7
 800495e:	42ab      	cmp	r3, r5
 8004960:	d0ba      	beq.n	80048d8 <HAL_RCC_ClockConfig+0x14c>
      if ((HAL_GetTick() - tickstart) > LATENCY_TIMEOUT_VALUE)
 8004962:	f7fc fdb7 	bl	80014d4 <HAL_GetTick>
 8004966:	1b80      	subs	r0, r0, r6
 8004968:	2802      	cmp	r0, #2
 800496a:	d9f5      	bls.n	8004958 <HAL_RCC_ClockConfig+0x1cc>
 800496c:	e745      	b.n	80047fa <HAL_RCC_ClockConfig+0x6e>
 800496e:	bf00      	nop
 8004970:	58004000 	.word	0x58004000
 8004974:	20000050 	.word	0x20000050
 8004978:	20000054 	.word	0x20000054

0800497c <HAL_RCC_GetPCLK1Freq>:
{
 800497c:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK1_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB1Prescaler())));
 800497e:	f7ff fc55 	bl	800422c <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8004982:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8004986:	4a04      	ldr	r2, [pc, #16]	; (8004998 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8004988:	689b      	ldr	r3, [r3, #8]
 800498a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 800498e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 8004992:	40d8      	lsrs	r0, r3
 8004994:	bd08      	pop	{r3, pc}
 8004996:	bf00      	nop
 8004998:	08010830 	.word	0x08010830

0800499c <HAL_RCC_GetPCLK2Freq>:
{
 800499c:	b508      	push	{r3, lr}
  return ((uint32_t)(__LL_RCC_CALC_PCLK2_FREQ(HAL_RCC_GetHCLKFreq(), LL_RCC_GetAPB2Prescaler())));
 800499e:	f7ff fc45 	bl	800422c <HAL_RCC_GetHCLKFreq>
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 80049a2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80049a6:	4a04      	ldr	r2, [pc, #16]	; (80049b8 <HAL_RCC_GetPCLK2Freq+0x1c>)
 80049a8:	689b      	ldr	r3, [r3, #8]
 80049aa:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 80049ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
 80049b2:	40d8      	lsrs	r0, r3
 80049b4:	bd08      	pop	{r3, pc}
 80049b6:	bf00      	nop
 80049b8:	08010830 	.word	0x08010830

080049bc <LL_RCC_LSE_IsReady>:
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 80049bc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 80049c0:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 80049c4:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80049c8:	4770      	bx	lr

080049ca <LL_RCC_SetI2CClockSource>:
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 80049ca:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80049ce:	0902      	lsrs	r2, r0, #4
 80049d0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80049d4:	f402 227f 	and.w	r2, r2, #1044480	; 0xff000
 80049d8:	0100      	lsls	r0, r0, #4
 80049da:	ea23 0302 	bic.w	r3, r3, r2
 80049de:	f400 207f 	and.w	r0, r0, #1044480	; 0xff000
 80049e2:	4318      	orrs	r0, r3
 80049e4:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 80049e8:	4770      	bx	lr

080049ea <LL_RCC_SetLPTIMClockSource>:
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 80049ea:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 80049ee:	0c02      	lsrs	r2, r0, #16
 80049f0:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80049f4:	0412      	lsls	r2, r2, #16
 80049f6:	ea23 0302 	bic.w	r3, r3, r2
 80049fa:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80049fe:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
}
 8004a02:	4770      	bx	lr

08004a04 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004a04:	b570      	push	{r4, r5, r6, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8004a06:	6805      	ldr	r5, [r0, #0]
 8004a08:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
{
 8004a0c:	4604      	mov	r4, r0
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8004a0e:	d038      	beq.n	8004a82 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));


    /* Enable write access to Backup domain */
    HAL_PWR_EnableBkUpAccess();
 8004a10:	f7ff fa9c 	bl	8003f4c <HAL_PWR_EnableBkUpAccess>

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8004a14:	f7fc fd5e 	bl	80014d4 <HAL_GetTick>

    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8004a18:	4e64      	ldr	r6, [pc, #400]	; (8004bac <HAL_RCCEx_PeriphCLKConfig+0x1a8>)
    tickstart = HAL_GetTick();
 8004a1a:	4605      	mov	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8004a1c:	6833      	ldr	r3, [r6, #0]
 8004a1e:	05db      	lsls	r3, r3, #23
 8004a20:	d529      	bpl.n	8004a76 <HAL_RCCEx_PeriphCLKConfig+0x72>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8004a22:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
    }

    if (ret == HAL_OK)
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8004a26:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8004a28:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004a2c:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8004a30:	4291      	cmp	r1, r2
 8004a32:	d014      	beq.n	8004a5e <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8004a34:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8004a38:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004a3c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8004a40:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8004a44:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8004a48:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 8004a4c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8004a50:	078d      	lsls	r5, r1, #30
 8004a52:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8004a56:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8004a5a:	f100 8096 	bmi.w	8004b8a <HAL_RCCEx_PeriphCLKConfig+0x186>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8004a5e:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8004a62:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8004a64:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8004a68:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004a6c:	430b      	orrs	r3, r1
 8004a6e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8004a72:	2500      	movs	r5, #0
}
 8004a74:	e005      	b.n	8004a82 <HAL_RCCEx_PeriphCLKConfig+0x7e>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004a76:	f7fc fd2d 	bl	80014d4 <HAL_GetTick>
 8004a7a:	1b40      	subs	r0, r0, r5
 8004a7c:	2802      	cmp	r0, #2
 8004a7e:	d9cd      	bls.n	8004a1c <HAL_RCCEx_PeriphCLKConfig+0x18>
        ret = HAL_TIMEOUT;
 8004a80:	2503      	movs	r5, #3
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004a82:	6822      	ldr	r2, [r4, #0]
 8004a84:	07d0      	lsls	r0, r2, #31
 8004a86:	d50a      	bpl.n	8004a9e <HAL_RCCEx_PeriphCLKConfig+0x9a>
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 8004a88:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8004a8c:	6861      	ldr	r1, [r4, #4]
 8004a8e:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8004a92:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 8004a96:	b289      	uxth	r1, r1
 8004a98:	430b      	orrs	r3, r1
 8004a9a:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004a9e:	0791      	lsls	r1, r2, #30
 8004aa0:	d50a      	bpl.n	8004ab8 <HAL_RCCEx_PeriphCLKConfig+0xb4>
 8004aa2:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8004aa6:	68a1      	ldr	r1, [r4, #8]
 8004aa8:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8004aac:	ea23 4311 	bic.w	r3, r3, r1, lsr #16
 8004ab0:	b289      	uxth	r1, r1
 8004ab2:	430b      	orrs	r3, r1
 8004ab4:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8004ab8:	0693      	lsls	r3, r2, #26
 8004aba:	d509      	bpl.n	8004ad0 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8004abc:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
 8004ac0:	6920      	ldr	r0, [r4, #16]
 8004ac2:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8004ac6:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8004aca:	4303      	orrs	r3, r0
 8004acc:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8004ad0:	0596      	lsls	r6, r2, #22
 8004ad2:	d502      	bpl.n	8004ada <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8004ad4:	6a20      	ldr	r0, [r4, #32]
 8004ad6:	f7ff ff88 	bl	80049ea <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8004ada:	6823      	ldr	r3, [r4, #0]
 8004adc:	0558      	lsls	r0, r3, #21
 8004ade:	d502      	bpl.n	8004ae6 <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8004ae0:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8004ae2:	f7ff ff82 	bl	80049ea <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 8004ae6:	6823      	ldr	r3, [r4, #0]
 8004ae8:	0519      	lsls	r1, r3, #20
 8004aea:	d502      	bpl.n	8004af2 <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 8004aec:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8004aee:	f7ff ff7c 	bl	80049ea <LL_RCC_SetLPTIMClockSource>
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004af2:	6823      	ldr	r3, [r4, #0]
 8004af4:	065a      	lsls	r2, r3, #25
 8004af6:	d502      	bpl.n	8004afe <HAL_RCCEx_PeriphCLKConfig+0xfa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004af8:	6960      	ldr	r0, [r4, #20]
 8004afa:	f7ff ff66 	bl	80049ca <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004afe:	6823      	ldr	r3, [r4, #0]
 8004b00:	061b      	lsls	r3, r3, #24
 8004b02:	d502      	bpl.n	8004b0a <HAL_RCCEx_PeriphCLKConfig+0x106>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004b04:	69a0      	ldr	r0, [r4, #24]
 8004b06:	f7ff ff60 	bl	80049ca <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004b0a:	6823      	ldr	r3, [r4, #0]
 8004b0c:	05de      	lsls	r6, r3, #23
 8004b0e:	d502      	bpl.n	8004b16 <HAL_RCCEx_PeriphCLKConfig+0x112>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8004b10:	69e0      	ldr	r0, [r4, #28]
 8004b12:	f7ff ff5a 	bl	80049ca <LL_RCC_SetI2CClockSource>
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 8004b16:	6821      	ldr	r1, [r4, #0]
 8004b18:	06c8      	lsls	r0, r1, #27
 8004b1a:	d510      	bpl.n	8004b3e <HAL_RCCEx_PeriphCLKConfig+0x13a>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 8004b1c:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
 8004b20:	68e0      	ldr	r0, [r4, #12]
 8004b22:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8004b26:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004b2a:	4303      	orrs	r3, r0
 8004b2c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 8004b30:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      /* Enable RCC_PLL_I2S2CLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 8004b34:	bf02      	ittt	eq
 8004b36:	68d3      	ldreq	r3, [r2, #12]
 8004b38:	f043 7380 	orreq.w	r3, r3, #16777216	; 0x1000000
 8004b3c:	60d3      	streq	r3, [r2, #12]
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8004b3e:	040a      	lsls	r2, r1, #16
 8004b40:	d50e      	bpl.n	8004b60 <HAL_RCCEx_PeriphCLKConfig+0x15c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 8004b42:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8004b46:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8004b48:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8004b4c:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
 8004b50:	4303      	orrs	r3, r0
 8004b52:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8004b56:	b918      	cbnz	r0, 8004b60 <HAL_RCCEx_PeriphCLKConfig+0x15c>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8004b58:	68d3      	ldr	r3, [r2, #12]
 8004b5a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004b5e:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8004b60:	044b      	lsls	r3, r1, #17
 8004b62:	d510      	bpl.n	8004b86 <HAL_RCCEx_PeriphCLKConfig+0x182>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 8004b64:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8004b68:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8004b6a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8004b6e:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8004b72:	430b      	orrs	r3, r1

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8004b74:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 8004b78:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 8004b7c:	d103      	bne.n	8004b86 <HAL_RCCEx_PeriphCLKConfig+0x182>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8004b7e:	68d3      	ldr	r3, [r2, #12]
 8004b80:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004b84:	60d3      	str	r3, [r2, #12]
    }
  }

  return status;
}
 8004b86:	4628      	mov	r0, r5
 8004b88:	bd70      	pop	{r4, r5, r6, pc}
        tickstart = HAL_GetTick();
 8004b8a:	f7fc fca3 	bl	80014d4 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004b8e:	f241 3688 	movw	r6, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8004b92:	4605      	mov	r5, r0
        while (LL_RCC_LSE_IsReady() != 1U)
 8004b94:	f7ff ff12 	bl	80049bc <LL_RCC_LSE_IsReady>
 8004b98:	2801      	cmp	r0, #1
 8004b9a:	f43f af60 	beq.w	8004a5e <HAL_RCCEx_PeriphCLKConfig+0x5a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004b9e:	f7fc fc99 	bl	80014d4 <HAL_GetTick>
 8004ba2:	1b40      	subs	r0, r0, r5
 8004ba4:	42b0      	cmp	r0, r6
 8004ba6:	d9f5      	bls.n	8004b94 <HAL_RCCEx_PeriphCLKConfig+0x190>
 8004ba8:	e76a      	b.n	8004a80 <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8004baa:	bf00      	nop
 8004bac:	58000400 	.word	0x58000400

08004bb0 <HAL_RTC_DeactivateAlarm>:
  *            @arg RTC_ALARM_A:  AlarmA
  *            @arg RTC_ALARM_B:  AlarmB
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
{
 8004bb0:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8004bb2:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004bb6:	2b01      	cmp	r3, #1
 8004bb8:	f04f 0202 	mov.w	r2, #2
 8004bbc:	d022      	beq.n	8004c04 <HAL_RTC_DeactivateAlarm+0x54>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004bbe:	4b19      	ldr	r3, [pc, #100]	; (8004c24 <HAL_RTC_DeactivateAlarm+0x74>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004bc0:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004bc4:	24ca      	movs	r4, #202	; 0xca
  __HAL_LOCK(hrtc);
 8004bc6:	2501      	movs	r5, #1
 8004bc8:	f880 502c 	strb.w	r5, [r0, #44]	; 0x2c
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004bcc:	625c      	str	r4, [r3, #36]	; 0x24
 8004bce:	2453      	movs	r4, #83	; 0x53
 8004bd0:	625c      	str	r4, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 8004bd2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8004bd6:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8004bd8:	d116      	bne.n	8004c08 <HAL_RTC_DeactivateAlarm+0x58>
  {
    /* AlarmA, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8004bda:	699a      	ldr	r2, [r3, #24]
 8004bdc:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
 8004be0:	619a      	str	r2, [r3, #24]

    /* AlarmA, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8004be2:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    /* Store in the handle the Alarm A disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8004be4:	f024 0401 	bic.w	r4, r4, #1
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8004be8:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8004bec:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8004bee:	6304      	str	r4, [r0, #48]	; 0x30

    /* Clear AlarmA flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8004bf0:	65dd      	str	r5, [r3, #92]	; 0x5c
    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004bf2:	4b0c      	ldr	r3, [pc, #48]	; (8004c24 <HAL_RTC_DeactivateAlarm+0x74>)
 8004bf4:	22ff      	movs	r2, #255	; 0xff
 8004bf6:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8004bf8:	2301      	movs	r3, #1

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8004bfa:	2200      	movs	r2, #0
  hrtc->State = HAL_RTC_STATE_READY;
 8004bfc:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 8004c00:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
  __HAL_LOCK(hrtc);
 8004c04:	4610      	mov	r0, r2

  return HAL_OK;
}
 8004c06:	bd30      	pop	{r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8004c08:	6999      	ldr	r1, [r3, #24]
 8004c0a:	f421 5108 	bic.w	r1, r1, #8704	; 0x2200
 8004c0e:	6199      	str	r1, [r3, #24]
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8004c10:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8004c12:	f024 0402 	bic.w	r4, r4, #2
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8004c16:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8004c1a:	64d9      	str	r1, [r3, #76]	; 0x4c
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8004c1c:	6304      	str	r4, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8004c1e:	65da      	str	r2, [r3, #92]	; 0x5c
 8004c20:	e7e7      	b.n	8004bf2 <HAL_RTC_DeactivateAlarm+0x42>
 8004c22:	bf00      	nop
 8004c24:	40002800 	.word	0x40002800

08004c28 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8004c28:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 8004c2a:	4d0b      	ldr	r5, [pc, #44]	; (8004c58 <HAL_RTC_AlarmIRQHandler+0x30>)
 8004c2c:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004c2e:	6d6e      	ldr	r6, [r5, #84]	; 0x54
 8004c30:	401e      	ands	r6, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8004c32:	07f2      	lsls	r2, r6, #31
{
 8004c34:	4604      	mov	r4, r0
  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8004c36:	d503      	bpl.n	8004c40 <HAL_RTC_AlarmIRQHandler+0x18>
  {
    /* Clear the AlarmA interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8004c38:	2301      	movs	r3, #1
 8004c3a:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmAEventCallback(hrtc);
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
 8004c3c:	f7fc fdc2 	bl	80017c4 <HAL_RTC_AlarmAEventCallback>
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8004c40:	07b3      	lsls	r3, r6, #30
 8004c42:	d504      	bpl.n	8004c4e <HAL_RTC_AlarmIRQHandler+0x26>
  {
    /* Clear the AlarmB interrupt pending bit */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8004c44:	2302      	movs	r3, #2
 8004c46:	65eb      	str	r3, [r5, #92]	; 0x5c

#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call Compare Match registered Callback */
    hrtc->AlarmBEventCallback(hrtc);
#else
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 8004c48:	4620      	mov	r0, r4
 8004c4a:	f000 f9c5 	bl	8004fd8 <HAL_RTCEx_AlarmBEventCallback>
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8004c4e:	2301      	movs	r3, #1
 8004c50:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 8004c54:	bd70      	pop	{r4, r5, r6, pc}
 8004c56:	bf00      	nop
 8004c58:	40002800 	.word	0x40002800

08004c5c <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8004c5c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8004c5e:	4c0a      	ldr	r4, [pc, #40]	; (8004c88 <HAL_RTC_WaitForSynchro+0x2c>)
 8004c60:	68e3      	ldr	r3, [r4, #12]
 8004c62:	f023 0320 	bic.w	r3, r3, #32
 8004c66:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 8004c68:	f7fc fc34 	bl	80014d4 <HAL_GetTick>
 8004c6c:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8004c6e:	68e3      	ldr	r3, [r4, #12]
 8004c70:	069b      	lsls	r3, r3, #26
 8004c72:	d501      	bpl.n	8004c78 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 8004c74:	2000      	movs	r0, #0
}
 8004c76:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8004c78:	f7fc fc2c 	bl	80014d4 <HAL_GetTick>
 8004c7c:	1b40      	subs	r0, r0, r5
 8004c7e:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8004c82:	d9f4      	bls.n	8004c6e <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 8004c84:	2003      	movs	r0, #3
 8004c86:	e7f6      	b.n	8004c76 <HAL_RTC_WaitForSynchro+0x1a>
 8004c88:	40002800 	.word	0x40002800

08004c8c <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8004c8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8004c90:	4d11      	ldr	r5, [pc, #68]	; (8004cd8 <RTC_EnterInitMode+0x4c>)
 8004c92:	68ec      	ldr	r4, [r5, #12]
 8004c94:	f014 0440 	ands.w	r4, r4, #64	; 0x40
{
 8004c98:	4607      	mov	r7, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8004c9a:	d11a      	bne.n	8004cd2 <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8004c9c:	68eb      	ldr	r3, [r5, #12]
 8004c9e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004ca2:	60eb      	str	r3, [r5, #12]

    tickstart = HAL_GetTick();
 8004ca4:	f7fc fc16 	bl	80014d4 <HAL_GetTick>
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8004ca8:	f04f 0803 	mov.w	r8, #3
    tickstart = HAL_GetTick();
 8004cac:	4606      	mov	r6, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8004cae:	68eb      	ldr	r3, [r5, #12]
 8004cb0:	065b      	lsls	r3, r3, #25
 8004cb2:	d401      	bmi.n	8004cb8 <RTC_EnterInitMode+0x2c>
 8004cb4:	2c03      	cmp	r4, #3
 8004cb6:	d102      	bne.n	8004cbe <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 8004cb8:	4620      	mov	r0, r4
 8004cba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8004cbe:	f7fc fc09 	bl	80014d4 <HAL_GetTick>
 8004cc2:	1b80      	subs	r0, r0, r6
 8004cc4:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8004cc8:	bf84      	itt	hi
 8004cca:	f887 802d 	strbhi.w	r8, [r7, #45]	; 0x2d
        status = HAL_TIMEOUT;
 8004cce:	2403      	movhi	r4, #3
 8004cd0:	e7ed      	b.n	8004cae <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 8004cd2:	2400      	movs	r4, #0
 8004cd4:	e7f0      	b.n	8004cb8 <RTC_EnterInitMode+0x2c>
 8004cd6:	bf00      	nop
 8004cd8:	40002800 	.word	0x40002800

08004cdc <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8004cdc:	4b10      	ldr	r3, [pc, #64]	; (8004d20 <RTC_ExitInitMode+0x44>)
 8004cde:	68da      	ldr	r2, [r3, #12]
 8004ce0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
{
 8004ce4:	b510      	push	{r4, lr}
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8004ce6:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8004ce8:	699a      	ldr	r2, [r3, #24]
 8004cea:	0692      	lsls	r2, r2, #26
{
 8004cec:	4604      	mov	r4, r0
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8004cee:	d406      	bmi.n	8004cfe <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8004cf0:	f7ff ffb4 	bl	8004c5c <HAL_RTC_WaitForSynchro>
 8004cf4:	b110      	cbz	r0, 8004cfc <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8004cf6:	2003      	movs	r0, #3
 8004cf8:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 8004cfc:	bd10      	pop	{r4, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8004cfe:	699a      	ldr	r2, [r3, #24]
 8004d00:	f022 0220 	bic.w	r2, r2, #32
 8004d04:	619a      	str	r2, [r3, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8004d06:	f7ff ffa9 	bl	8004c5c <HAL_RTC_WaitForSynchro>
 8004d0a:	b110      	cbz	r0, 8004d12 <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8004d0c:	2003      	movs	r0, #3
 8004d0e:	f884 002d 	strb.w	r0, [r4, #45]	; 0x2d
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8004d12:	4a03      	ldr	r2, [pc, #12]	; (8004d20 <RTC_ExitInitMode+0x44>)
 8004d14:	6993      	ldr	r3, [r2, #24]
 8004d16:	f043 0320 	orr.w	r3, r3, #32
 8004d1a:	6193      	str	r3, [r2, #24]
  return status;
 8004d1c:	e7ee      	b.n	8004cfc <RTC_ExitInitMode+0x20>
 8004d1e:	bf00      	nop
 8004d20:	40002800 	.word	0x40002800

08004d24 <HAL_RTC_Init>:
{
 8004d24:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 8004d26:	4604      	mov	r4, r0
 8004d28:	2800      	cmp	r0, #0
 8004d2a:	d047      	beq.n	8004dbc <HAL_RTC_Init+0x98>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8004d2c:	f890 302d 	ldrb.w	r3, [r0, #45]	; 0x2d
 8004d30:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004d34:	b91b      	cbnz	r3, 8004d3e <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 8004d36:	f880 202c 	strb.w	r2, [r0, #44]	; 0x2c
      HAL_RTC_MspInit(hrtc);
 8004d3a:	f7fc f941 	bl	8000fc0 <HAL_RTC_MspInit>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004d3e:	4d20      	ldr	r5, [pc, #128]	; (8004dc0 <HAL_RTC_Init+0x9c>)
    hrtc->State = HAL_RTC_STATE_BUSY;
 8004d40:	2302      	movs	r3, #2
 8004d42:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004d46:	23ca      	movs	r3, #202	; 0xca
 8004d48:	626b      	str	r3, [r5, #36]	; 0x24
 8004d4a:	2353      	movs	r3, #83	; 0x53
 8004d4c:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 8004d4e:	4620      	mov	r0, r4
 8004d50:	f7ff ff9c 	bl	8004c8c <RTC_EnterInitMode>
    if (status == HAL_OK)
 8004d54:	bb70      	cbnz	r0, 8004db4 <HAL_RTC_Init+0x90>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8004d56:	69ab      	ldr	r3, [r5, #24]
 8004d58:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 8004d5c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004d60:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 8004d62:	6921      	ldr	r1, [r4, #16]
 8004d64:	6863      	ldr	r3, [r4, #4]
 8004d66:	69aa      	ldr	r2, [r5, #24]
 8004d68:	430b      	orrs	r3, r1
 8004d6a:	4313      	orrs	r3, r2
 8004d6c:	69a2      	ldr	r2, [r4, #24]
 8004d6e:	4313      	orrs	r3, r2
 8004d70:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 8004d72:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8004d76:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8004d7a:	612b      	str	r3, [r5, #16]
      MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 8004d7c:	e9d4 3109 	ldrd	r3, r1, [r4, #36]	; 0x24
 8004d80:	68ea      	ldr	r2, [r5, #12]
 8004d82:	430b      	orrs	r3, r1
 8004d84:	f422 52f8 	bic.w	r2, r2, #7936	; 0x1f00
 8004d88:	4313      	orrs	r3, r2
 8004d8a:	60eb      	str	r3, [r5, #12]
      status = RTC_ExitInitMode(hrtc);
 8004d8c:	4620      	mov	r0, r4
 8004d8e:	f7ff ffa5 	bl	8004cdc <RTC_ExitInitMode>
      if (status == HAL_OK)
 8004d92:	b978      	cbnz	r0, 8004db4 <HAL_RTC_Init+0x90>
        MODIFY_REG(RTC->CR, \
 8004d94:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 8004d98:	69aa      	ldr	r2, [r5, #24]
 8004d9a:	430b      	orrs	r3, r1
 8004d9c:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8004da0:	4313      	orrs	r3, r2
 8004da2:	6962      	ldr	r2, [r4, #20]
 8004da4:	4313      	orrs	r3, r2
 8004da6:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004da8:	23ff      	movs	r3, #255	; 0xff
 8004daa:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 8004dac:	2301      	movs	r3, #1
 8004dae:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 8004db2:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004db4:	4b02      	ldr	r3, [pc, #8]	; (8004dc0 <HAL_RTC_Init+0x9c>)
 8004db6:	22ff      	movs	r2, #255	; 0xff
 8004db8:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 8004dba:	e7fa      	b.n	8004db2 <HAL_RTC_Init+0x8e>
  HAL_StatusTypeDef status = HAL_ERROR;
 8004dbc:	2001      	movs	r0, #1
 8004dbe:	e7f8      	b.n	8004db2 <HAL_RTC_Init+0x8e>
 8004dc0:	40002800 	.word	0x40002800

08004dc4 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8004dc4:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8004dc6:	2809      	cmp	r0, #9
 8004dc8:	d803      	bhi.n	8004dd2 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    tmp_Value -= 10U;
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8004dca:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 8004dce:	b2c0      	uxtb	r0, r0
 8004dd0:	4770      	bx	lr
    tmp_Value -= 10U;
 8004dd2:	380a      	subs	r0, #10
    bcdhigh++;
 8004dd4:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 8004dd6:	b2c0      	uxtb	r0, r0
 8004dd8:	e7f5      	b.n	8004dc6 <RTC_ByteToBcd2+0x2>
	...

08004ddc <HAL_RTC_SetAlarm_IT>:
{
 8004ddc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(hrtc);
 8004de0:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8004de4:	2b01      	cmp	r3, #1
{
 8004de6:	4605      	mov	r5, r0
 8004de8:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 8004dec:	d067      	beq.n	8004ebe <HAL_RTC_SetAlarm_IT+0xe2>
 8004dee:	2301      	movs	r3, #1
 8004df0:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8004df4:	4b4c      	ldr	r3, [pc, #304]	; (8004f28 <HAL_RTC_SetAlarm_IT+0x14c>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004df6:	f885 002d 	strb.w	r0, [r5, #45]	; 0x2d
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 8004dfa:	68de      	ldr	r6, [r3, #12]
 8004dfc:	f406 7640 	and.w	r6, r6, #768	; 0x300
  if (binaryMode != RTC_BINARY_ONLY)
 8004e00:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8004e04:	d076      	beq.n	8004ef4 <HAL_RTC_SetAlarm_IT+0x118>
    if (Format == RTC_FORMAT_BIN)
 8004e06:	694c      	ldr	r4, [r1, #20]
 8004e08:	7808      	ldrb	r0, [r1, #0]
 8004e0a:	f891 8001 	ldrb.w	r8, [r1, #1]
 8004e0e:	f891 a002 	ldrb.w	sl, [r1, #2]
 8004e12:	f891 7024 	ldrb.w	r7, [r1, #36]	; 0x24
 8004e16:	2a00      	cmp	r2, #0
 8004e18:	d153      	bne.n	8004ec2 <HAL_RTC_SetAlarm_IT+0xe6>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8004e1a:	699a      	ldr	r2, [r3, #24]
 8004e1c:	f012 0240 	ands.w	r2, r2, #64	; 0x40
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 8004e20:	bf08      	it	eq
 8004e22:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004e24:	f7ff ffce 	bl	8004dc4 <RTC_ByteToBcd2>
 8004e28:	4681      	mov	r9, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 8004e2a:	4640      	mov	r0, r8
 8004e2c:	f7ff ffca 	bl	8004dc4 <RTC_ByteToBcd2>
 8004e30:	4680      	mov	r8, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8004e32:	4650      	mov	r0, sl
 8004e34:	f7ff ffc6 	bl	8004dc4 <RTC_ByteToBcd2>
 8004e38:	4682      	mov	sl, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8004e3a:	4638      	mov	r0, r7
 8004e3c:	f7ff ffc2 	bl	8004dc4 <RTC_ByteToBcd2>
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004e40:	6a0a      	ldr	r2, [r1, #32]
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8004e42:	78cb      	ldrb	r3, [r1, #3]
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004e44:	4314      	orrs	r4, r2
 8004e46:	ea44 5483 	orr.w	r4, r4, r3, lsl #22
 8004e4a:	ea44 030a 	orr.w	r3, r4, sl
 8004e4e:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 8004e52:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 8004e56:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004e5a:	4a33      	ldr	r2, [pc, #204]	; (8004f28 <HAL_RTC_SetAlarm_IT+0x14c>)
 8004e5c:	20ca      	movs	r0, #202	; 0xca
 8004e5e:	6250      	str	r0, [r2, #36]	; 0x24
 8004e60:	2053      	movs	r0, #83	; 0x53
 8004e62:	6250      	str	r0, [r2, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 8004e64:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 8004e66:	6988      	ldr	r0, [r1, #24]
 8004e68:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8004e6c:	6994      	ldr	r4, [r2, #24]
  if (sAlarm->Alarm == RTC_ALARM_A)
 8004e6e:	d143      	bne.n	8004ef8 <HAL_RTC_SetAlarm_IT+0x11c>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8004e70:	f424 5488 	bic.w	r4, r4, #4352	; 0x1100
 8004e74:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8004e76:	2401      	movs	r4, #1
 8004e78:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 8004e7a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8004e7e:	bf0a      	itet	eq
 8004e80:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMAR, tmpreg);
 8004e82:	6413      	strne	r3, [r2, #64]	; 0x40
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8004e84:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 8004e86:	6450      	str	r0, [r2, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 8004e88:	4b27      	ldr	r3, [pc, #156]	; (8004f28 <HAL_RTC_SetAlarm_IT+0x14c>)
 8004e8a:	684a      	ldr	r2, [r1, #4]
 8004e8c:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8004e8e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8004e90:	f042 0201 	orr.w	r2, r2, #1
 8004e94:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8004e96:	699a      	ldr	r2, [r3, #24]
 8004e98:	f442 5288 	orr.w	r2, r2, #4352	; 0x1100
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8004e9c:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8004e9e:	4a23      	ldr	r2, [pc, #140]	; (8004f2c <HAL_RTC_SetAlarm_IT+0x150>)
 8004ea0:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8004ea4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004ea8:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004eac:	4b1e      	ldr	r3, [pc, #120]	; (8004f28 <HAL_RTC_SetAlarm_IT+0x14c>)
 8004eae:	22ff      	movs	r2, #255	; 0xff
 8004eb0:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 8004eb2:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 8004eb4:	2301      	movs	r3, #1
 8004eb6:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 8004eba:	f885 002c 	strb.w	r0, [r5, #44]	; 0x2c
}
 8004ebe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 8004ec2:	f1b4 3f80 	cmp.w	r4, #2155905152	; 0x80808080
 8004ec6:	d007      	beq.n	8004ed8 <HAL_RTC_SetAlarm_IT+0xfc>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 8004ec8:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 8004ecc:	d004      	beq.n	8004ed8 <HAL_RTC_SetAlarm_IT+0xfc>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8004ece:	699a      	ldr	r2, [r3, #24]
 8004ed0:	f012 0240 	ands.w	r2, r2, #64	; 0x40
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 8004ed4:	bf08      	it	eq
 8004ed6:	70ca      	strbeq	r2, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004ed8:	6a0a      	ldr	r2, [r1, #32]
 8004eda:	4314      	orrs	r4, r2
 8004edc:	ea44 040a 	orr.w	r4, r4, sl
 8004ee0:	ea44 4300 	orr.w	r3, r4, r0, lsl #16
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 8004ee4:	78c8      	ldrb	r0, [r1, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8004ee6:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
 8004eea:	ea43 5380 	orr.w	r3, r3, r0, lsl #22
 8004eee:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 8004ef2:	e7b2      	b.n	8004e5a <HAL_RTC_SetAlarm_IT+0x7e>
  uint32_t tmpreg = 0;
 8004ef4:	2300      	movs	r3, #0
 8004ef6:	e7b0      	b.n	8004e5a <HAL_RTC_SetAlarm_IT+0x7e>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8004ef8:	f424 5408 	bic.w	r4, r4, #8704	; 0x2200
 8004efc:	6194      	str	r4, [r2, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8004efe:	2402      	movs	r4, #2
 8004f00:	65d4      	str	r4, [r2, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 8004f02:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8004f06:	bf0a      	itet	eq
 8004f08:	69cb      	ldreq	r3, [r1, #28]
      WRITE_REG(RTC->ALRMBR, tmpreg);
 8004f0a:	6493      	strne	r3, [r2, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8004f0c:	4318      	orreq	r0, r3
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 8004f0e:	64d0      	str	r0, [r2, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 8004f10:	4b05      	ldr	r3, [pc, #20]	; (8004f28 <HAL_RTC_SetAlarm_IT+0x14c>)
 8004f12:	684a      	ldr	r2, [r1, #4]
 8004f14:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8004f16:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8004f18:	f042 0202 	orr.w	r2, r2, #2
 8004f1c:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8004f1e:	699a      	ldr	r2, [r3, #24]
 8004f20:	f442 5208 	orr.w	r2, r2, #8704	; 0x2200
 8004f24:	e7ba      	b.n	8004e9c <HAL_RTC_SetAlarm_IT+0xc0>
 8004f26:	bf00      	nop
 8004f28:	40002800 	.word	0x40002800
 8004f2c:	58000800 	.word	0x58000800

08004f30 <HAL_RTCEx_EnableBypassShadow>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8004f30:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 8004f34:	2a01      	cmp	r2, #1
{
 8004f36:	4603      	mov	r3, r0
 8004f38:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 8004f3c:	d012      	beq.n	8004f64 <HAL_RTCEx_EnableBypassShadow+0x34>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004f3e:	4a0a      	ldr	r2, [pc, #40]	; (8004f68 <HAL_RTCEx_EnableBypassShadow+0x38>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004f40:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004f44:	21ca      	movs	r1, #202	; 0xca
 8004f46:	6251      	str	r1, [r2, #36]	; 0x24
 8004f48:	2153      	movs	r1, #83	; 0x53
 8004f4a:	6251      	str	r1, [r2, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8004f4c:	6991      	ldr	r1, [r2, #24]
 8004f4e:	f041 0120 	orr.w	r1, r1, #32
 8004f52:	6191      	str	r1, [r2, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004f54:	21ff      	movs	r1, #255	; 0xff
 8004f56:	6251      	str	r1, [r2, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8004f58:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 8004f5a:	2201      	movs	r2, #1
 8004f5c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 8004f60:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 8004f64:	4770      	bx	lr
 8004f66:	bf00      	nop
 8004f68:	40002800 	.word	0x40002800

08004f6c <HAL_RTCEx_SetSSRU_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
  /* Process Locked */
  __HAL_LOCK(hrtc);
 8004f6c:	f890 202c 	ldrb.w	r2, [r0, #44]	; 0x2c
 8004f70:	2a01      	cmp	r2, #1
{
 8004f72:	4603      	mov	r3, r0
 8004f74:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 8004f78:	d019      	beq.n	8004fae <HAL_RTCEx_SetSSRU_IT+0x42>

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004f7a:	4a0d      	ldr	r2, [pc, #52]	; (8004fb0 <HAL_RTCEx_SetSSRU_IT+0x44>)
  hrtc->State = HAL_RTC_STATE_BUSY;
 8004f7c:	f883 002d 	strb.w	r0, [r3, #45]	; 0x2d
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8004f80:	21ca      	movs	r1, #202	; 0xca
 8004f82:	6251      	str	r1, [r2, #36]	; 0x24
 8004f84:	2153      	movs	r1, #83	; 0x53
 8004f86:	6251      	str	r1, [r2, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8004f88:	6991      	ldr	r1, [r2, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8004f8a:	480a      	ldr	r0, [pc, #40]	; (8004fb4 <HAL_RTCEx_SetSSRU_IT+0x48>)
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 8004f8c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 8004f90:	6191      	str	r1, [r2, #24]
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8004f92:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
 8004f96:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
 8004f9a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8004f9e:	21ff      	movs	r1, #255	; 0xff
 8004fa0:	6251      	str	r1, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8004fa2:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 8004fa4:	2201      	movs	r2, #1
 8004fa6:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  __HAL_UNLOCK(hrtc);
 8004faa:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c

  return HAL_OK;
}
 8004fae:	4770      	bx	lr
 8004fb0:	40002800 	.word	0x40002800
 8004fb4:	58000800 	.word	0x58000800

08004fb8 <HAL_RTCEx_SSRUIRQHandler>:
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8004fb8:	4b06      	ldr	r3, [pc, #24]	; (8004fd4 <HAL_RTCEx_SSRUIRQHandler+0x1c>)
 8004fba:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8004fbc:	0652      	lsls	r2, r2, #25
{
 8004fbe:	b510      	push	{r4, lr}
 8004fc0:	4604      	mov	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8004fc2:	d503      	bpl.n	8004fcc <HAL_RTCEx_SSRUIRQHandler+0x14>
  {
    /* Immediately clear flags */
    RTC->SCR = RTC_SCR_CSSRUF;
 8004fc4:	2240      	movs	r2, #64	; 0x40
 8004fc6:	65da      	str	r2, [r3, #92]	; 0x5c
    /* SSRU callback */
#if (USE_HAL_RTC_REGISTER_CALLBACKS == 1)
    /* Call SSRUEvent registered Callback */
    hrtc->SSRUEventCallback(hrtc);
#else
    HAL_RTCEx_SSRUEventCallback(hrtc);
 8004fc8:	f7fc fbfe 	bl	80017c8 <HAL_RTCEx_SSRUEventCallback>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8004fcc:	2301      	movs	r3, #1
 8004fce:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
}
 8004fd2:	bd10      	pop	{r4, pc}
 8004fd4:	40002800 	.word	0x40002800

08004fd8 <HAL_RTCEx_AlarmBEventCallback>:
 8004fd8:	4770      	bx	lr

08004fda <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8004fda:	0089      	lsls	r1, r1, #2
 8004fdc:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8004fe0:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8004fe4:	600a      	str	r2, [r1, #0]
}
 8004fe6:	4770      	bx	lr

08004fe8 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8004fe8:	0089      	lsls	r1, r1, #2
 8004fea:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8004fee:	f501 4131 	add.w	r1, r1, #45312	; 0xb100

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8004ff2:	6808      	ldr	r0, [r1, #0]
}
 8004ff4:	4770      	bx	lr
	...

08004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>:
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8004ff8:	4a03      	ldr	r2, [pc, #12]	; (8005008 <LL_PWR_UnselectSUBGHZSPI_NSS+0x10>)
 8004ffa:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8004ffe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005002:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 8005006:	4770      	bx	lr
 8005008:	58000400 	.word	0x58000400

0800500c <LL_PWR_SelectSUBGHZSPI_NSS>:
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 800500c:	4a03      	ldr	r2, [pc, #12]	; (800501c <LL_PWR_SelectSUBGHZSPI_NSS+0x10>)
 800500e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8005012:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005016:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 800501a:	4770      	bx	lr
 800501c:	58000400 	.word	0x58000400

08005020 <SUBGHZSPI_Init>:
{
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8005020:	4b07      	ldr	r3, [pc, #28]	; (8005040 <SUBGHZSPI_Init+0x20>)
 8005022:	681a      	ldr	r2, [r3, #0]
 8005024:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8005028:	601a      	str	r2, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 800502a:	f440 7041 	orr.w	r0, r0, #772	; 0x304
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 800502e:	f44f 52b8 	mov.w	r2, #5888	; 0x1700
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8005032:	6018      	str	r0, [r3, #0]
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 8005034:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 8005036:	681a      	ldr	r2, [r3, #0]
 8005038:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800503c:	601a      	str	r2, [r3, #0]
}
 800503e:	4770      	bx	lr
 8005040:	58010000 	.word	0x58010000

08005044 <HAL_SUBGHZ_Init>:
{
 8005044:	b513      	push	{r0, r1, r4, lr}
  if (hsubghz == NULL)
 8005046:	4604      	mov	r4, r0
 8005048:	2800      	cmp	r0, #0
 800504a:	d042      	beq.n	80050d2 <HAL_SUBGHZ_Init+0x8e>
  if (hsubghz->State == HAL_SUBGHZ_STATE_RESET)
 800504c:	7983      	ldrb	r3, [r0, #6]
 800504e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8005052:	b913      	cbnz	r3, 800505a <HAL_SUBGHZ_Init+0x16>
    hsubghz->Lock = HAL_UNLOCKED;
 8005054:	7142      	strb	r2, [r0, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 8005056:	f7fc f92b 	bl	80012b0 <HAL_SUBGHZ_MspInit>
  hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 800505a:	2302      	movs	r3, #2
 800505c:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 800505e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005062:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8005066:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800506a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 800506e:	4a1a      	ldr	r2, [pc, #104]	; (80050d8 <HAL_SUBGHZ_Init+0x94>)
 8005070:	6811      	ldr	r1, [r2, #0]
 8005072:	221c      	movs	r2, #28
 8005074:	434a      	muls	r2, r1
 8005076:	0cd2      	lsrs	r2, r2, #19
 8005078:	2164      	movs	r1, #100	; 0x64
 800507a:	434a      	muls	r2, r1
 800507c:	9201      	str	r2, [sp, #4]
    if (count == 0U)
 800507e:	9a01      	ldr	r2, [sp, #4]
 8005080:	b9f2      	cbnz	r2, 80050c0 <HAL_SUBGHZ_Init+0x7c>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8005082:	2101      	movs	r1, #1
 8005084:	60a1      	str	r1, [r4, #8]
  LL_PWR_UnselectSUBGHZSPI_NSS();
 8005086:	f7ff ffb7 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
  SET_BIT(EXTI->IMR2, ExtiLine);
 800508a:	4a14      	ldr	r2, [pc, #80]	; (80050dc <HAL_SUBGHZ_Init+0x98>)
 800508c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8005090:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005094:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 8005098:	4b11      	ldr	r3, [pc, #68]	; (80050e0 <HAL_SUBGHZ_Init+0x9c>)
 800509a:	689a      	ldr	r2, [r3, #8]
 800509c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80050a0:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 80050a2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80050a6:	619a      	str	r2, [r3, #24]
  if (status == HAL_OK)
 80050a8:	b929      	cbnz	r1, 80050b6 <HAL_SUBGHZ_Init+0x72>
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 80050aa:	6820      	ldr	r0, [r4, #0]
 80050ac:	f7ff ffb8 	bl	8005020 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 80050b0:	2301      	movs	r3, #1
 80050b2:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 80050b4:	60a1      	str	r1, [r4, #8]
  hsubghz->State     = HAL_SUBGHZ_STATE_READY;
 80050b6:	2301      	movs	r3, #1
 80050b8:	71a3      	strb	r3, [r4, #6]
}
 80050ba:	4608      	mov	r0, r1
 80050bc:	b002      	add	sp, #8
 80050be:	bd10      	pop	{r4, pc}
    count--;
 80050c0:	9a01      	ldr	r2, [sp, #4]
 80050c2:	3a01      	subs	r2, #1
 80050c4:	9201      	str	r2, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 80050c6:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80050ca:	f411 4180 	ands.w	r1, r1, #16384	; 0x4000
 80050ce:	d1d6      	bne.n	800507e <HAL_SUBGHZ_Init+0x3a>
 80050d0:	e7d9      	b.n	8005086 <HAL_SUBGHZ_Init+0x42>
    return status;
 80050d2:	2101      	movs	r1, #1
 80050d4:	e7f1      	b.n	80050ba <HAL_SUBGHZ_Init+0x76>
 80050d6:	bf00      	nop
 80050d8:	20000050 	.word	0x20000050
 80050dc:	58000800 	.word	0x58000800
 80050e0:	58000400 	.word	0x58000400

080050e4 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 80050e4:	b513      	push	{r0, r1, r4, lr}
 80050e6:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80050e8:	4817      	ldr	r0, [pc, #92]	; (8005148 <SUBGHZSPI_Transmit+0x64>)
 80050ea:	6804      	ldr	r4, [r0, #0]
 80050ec:	231c      	movs	r3, #28
 80050ee:	4363      	muls	r3, r4
 80050f0:	0cdb      	lsrs	r3, r3, #19
 80050f2:	2464      	movs	r4, #100	; 0x64
 80050f4:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 80050f6:	4c15      	ldr	r4, [pc, #84]	; (800514c <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80050f8:	9301      	str	r3, [sp, #4]
 80050fa:	4603      	mov	r3, r0
    if (count == 0U)
 80050fc:	9801      	ldr	r0, [sp, #4]
 80050fe:	b998      	cbnz	r0, 8005128 <SUBGHZSPI_Transmit+0x44>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8005100:	2001      	movs	r0, #1
 8005102:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 8005104:	4c12      	ldr	r4, [pc, #72]	; (8005150 <SUBGHZSPI_Transmit+0x6c>)
 8005106:	7021      	strb	r1, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8005108:	6819      	ldr	r1, [r3, #0]
 800510a:	231c      	movs	r3, #28
 800510c:	434b      	muls	r3, r1
 800510e:	0cdb      	lsrs	r3, r3, #19
 8005110:	2164      	movs	r1, #100	; 0x64
 8005112:	434b      	muls	r3, r1
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 8005114:	490d      	ldr	r1, [pc, #52]	; (800514c <SUBGHZSPI_Transmit+0x68>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8005116:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 8005118:	9b01      	ldr	r3, [sp, #4]
 800511a:	b96b      	cbnz	r3, 8005138 <SUBGHZSPI_Transmit+0x54>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 800511c:	2001      	movs	r0, #1
 800511e:	6090      	str	r0, [r2, #8]

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 8005120:	4b0a      	ldr	r3, [pc, #40]	; (800514c <SUBGHZSPI_Transmit+0x68>)
 8005122:	68db      	ldr	r3, [r3, #12]

  return status;
}
 8005124:	b002      	add	sp, #8
 8005126:	bd10      	pop	{r4, pc}
    count--;
 8005128:	9801      	ldr	r0, [sp, #4]
 800512a:	3801      	subs	r0, #1
 800512c:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 800512e:	68a0      	ldr	r0, [r4, #8]
 8005130:	0780      	lsls	r0, r0, #30
 8005132:	d5e3      	bpl.n	80050fc <SUBGHZSPI_Transmit+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 8005134:	2000      	movs	r0, #0
 8005136:	e7e5      	b.n	8005104 <SUBGHZSPI_Transmit+0x20>
    count--;
 8005138:	9b01      	ldr	r3, [sp, #4]
 800513a:	3b01      	subs	r3, #1
 800513c:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 800513e:	688b      	ldr	r3, [r1, #8]
 8005140:	07db      	lsls	r3, r3, #31
 8005142:	d5e9      	bpl.n	8005118 <SUBGHZSPI_Transmit+0x34>
 8005144:	e7ec      	b.n	8005120 <SUBGHZSPI_Transmit+0x3c>
 8005146:	bf00      	nop
 8005148:	20000050 	.word	0x20000050
 800514c:	58010000 	.word	0x58010000
 8005150:	5801000c 	.word	0x5801000c

08005154 <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 8005154:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8005156:	4602      	mov	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8005158:	4818      	ldr	r0, [pc, #96]	; (80051bc <SUBGHZSPI_Receive+0x68>)
 800515a:	6804      	ldr	r4, [r0, #0]
 800515c:	231c      	movs	r3, #28
 800515e:	4363      	muls	r3, r4
 8005160:	0cdb      	lsrs	r3, r3, #19
 8005162:	2464      	movs	r4, #100	; 0x64
 8005164:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8005166:	4c16      	ldr	r4, [pc, #88]	; (80051c0 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8005168:	9301      	str	r3, [sp, #4]
 800516a:	4603      	mov	r3, r0
    if (count == 0U)
 800516c:	9801      	ldr	r0, [sp, #4]
 800516e:	b9a8      	cbnz	r0, 800519c <SUBGHZSPI_Receive+0x48>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8005170:	2001      	movs	r0, #1
 8005172:	6090      	str	r0, [r2, #8]

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 8005174:	4c13      	ldr	r4, [pc, #76]	; (80051c4 <SUBGHZSPI_Receive+0x70>)
 8005176:	25ff      	movs	r5, #255	; 0xff
 8005178:	7025      	strb	r5, [r4, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 800517a:	681c      	ldr	r4, [r3, #0]
 800517c:	231c      	movs	r3, #28
 800517e:	4363      	muls	r3, r4
 8005180:	0cdb      	lsrs	r3, r3, #19
 8005182:	2464      	movs	r4, #100	; 0x64
 8005184:	4363      	muls	r3, r4
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 8005186:	4c0e      	ldr	r4, [pc, #56]	; (80051c0 <SUBGHZSPI_Receive+0x6c>)
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8005188:	9301      	str	r3, [sp, #4]
    if (count == 0U)
 800518a:	9b01      	ldr	r3, [sp, #4]
 800518c:	b973      	cbnz	r3, 80051ac <SUBGHZSPI_Receive+0x58>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 800518e:	2001      	movs	r0, #1
 8005190:	6090      	str	r0, [r2, #8]

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 8005192:	4b0b      	ldr	r3, [pc, #44]	; (80051c0 <SUBGHZSPI_Receive+0x6c>)
 8005194:	68db      	ldr	r3, [r3, #12]
 8005196:	700b      	strb	r3, [r1, #0]

  return status;
}
 8005198:	b003      	add	sp, #12
 800519a:	bd30      	pop	{r4, r5, pc}
    count--;
 800519c:	9801      	ldr	r0, [sp, #4]
 800519e:	3801      	subs	r0, #1
 80051a0:	9001      	str	r0, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 80051a2:	68a0      	ldr	r0, [r4, #8]
 80051a4:	0780      	lsls	r0, r0, #30
 80051a6:	d5e1      	bpl.n	800516c <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 80051a8:	2000      	movs	r0, #0
 80051aa:	e7e3      	b.n	8005174 <SUBGHZSPI_Receive+0x20>
    count--;
 80051ac:	9b01      	ldr	r3, [sp, #4]
 80051ae:	3b01      	subs	r3, #1
 80051b0:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 80051b2:	68a3      	ldr	r3, [r4, #8]
 80051b4:	07db      	lsls	r3, r3, #31
 80051b6:	d5e8      	bpl.n	800518a <SUBGHZSPI_Receive+0x36>
 80051b8:	e7eb      	b.n	8005192 <SUBGHZSPI_Receive+0x3e>
 80051ba:	bf00      	nop
 80051bc:	20000050 	.word	0x20000050
 80051c0:	58010000 	.word	0x58010000
 80051c4:	5801000c 	.word	0x5801000c

080051c8 <SUBGHZ_WaitOnBusy>:
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80051c8:	4b0f      	ldr	r3, [pc, #60]	; (8005208 <SUBGHZ_WaitOnBusy+0x40>)
{
 80051ca:	b513      	push	{r0, r1, r4, lr}
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80051cc:	681a      	ldr	r2, [r3, #0]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80051ce:	4c0f      	ldr	r4, [pc, #60]	; (800520c <SUBGHZ_WaitOnBusy+0x44>)
 80051d0:	2318      	movs	r3, #24
 80051d2:	4353      	muls	r3, r2
 80051d4:	0d1b      	lsrs	r3, r3, #20
 80051d6:	2264      	movs	r2, #100	; 0x64
 80051d8:	4353      	muls	r3, r2
{
 80051da:	4601      	mov	r1, r0
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 80051dc:	9301      	str	r3, [sp, #4]
 80051de:	6962      	ldr	r2, [r4, #20]
  /* Wait until Busy signal is set */
  do
  {
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
 80051e0:	9b01      	ldr	r3, [sp, #4]
 80051e2:	f002 0204 	and.w	r2, r2, #4
 80051e6:	b923      	cbnz	r3, 80051f2 <SUBGHZ_WaitOnBusy+0x2a>
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 80051e8:	2302      	movs	r3, #2
 80051ea:	608b      	str	r3, [r1, #8]
      status  = HAL_ERROR;
 80051ec:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 80051ee:	b002      	add	sp, #8
 80051f0:	bd10      	pop	{r4, pc}
    count--;
 80051f2:	9b01      	ldr	r3, [sp, #4]
 80051f4:	3b01      	subs	r3, #1
 80051f6:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 80051f8:	6960      	ldr	r0, [r4, #20]
 80051fa:	f010 0002 	ands.w	r0, r0, #2
 80051fe:	d0f6      	beq.n	80051ee <SUBGHZ_WaitOnBusy+0x26>
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 8005200:	2a00      	cmp	r2, #0
 8005202:	d1ec      	bne.n	80051de <SUBGHZ_WaitOnBusy+0x16>
  status = HAL_OK;
 8005204:	4610      	mov	r0, r2
 8005206:	e7f2      	b.n	80051ee <SUBGHZ_WaitOnBusy+0x26>
 8005208:	20000050 	.word	0x20000050
 800520c:	58000400 	.word	0x58000400

08005210 <SUBGHZ_CheckDeviceReady>:
{
 8005210:	b507      	push	{r0, r1, r2, lr}
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 8005212:	7903      	ldrb	r3, [r0, #4]
 8005214:	2b01      	cmp	r3, #1
 8005216:	d10f      	bne.n	8005238 <SUBGHZ_CheckDeviceReady+0x28>
    count  = SUBGHZ_NSS_LOOP_TIME;
 8005218:	4b0a      	ldr	r3, [pc, #40]	; (8005244 <SUBGHZ_CheckDeviceReady+0x34>)
 800521a:	681a      	ldr	r2, [r3, #0]
 800521c:	2318      	movs	r3, #24
 800521e:	4353      	muls	r3, r2
 8005220:	0c1b      	lsrs	r3, r3, #16
 8005222:	9301      	str	r3, [sp, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 8005224:	f7ff fef2 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
      count--;
 8005228:	9b01      	ldr	r3, [sp, #4]
 800522a:	3b01      	subs	r3, #1
 800522c:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 800522e:	9b01      	ldr	r3, [sp, #4]
 8005230:	2b00      	cmp	r3, #0
 8005232:	d1f9      	bne.n	8005228 <SUBGHZ_CheckDeviceReady+0x18>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 8005234:	f7ff fee0 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
}
 8005238:	b003      	add	sp, #12
 800523a:	f85d eb04 	ldr.w	lr, [sp], #4
  return (SUBGHZ_WaitOnBusy(hsubghz));
 800523e:	f7ff bfc3 	b.w	80051c8 <SUBGHZ_WaitOnBusy>
 8005242:	bf00      	nop
 8005244:	20000050 	.word	0x20000050

08005248 <HAL_SUBGHZ_WriteRegisters>:
{
 8005248:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800524a:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800524c:	7983      	ldrb	r3, [r0, #6]
 800524e:	2b01      	cmp	r3, #1
{
 8005250:	4615      	mov	r5, r2
 8005252:	4604      	mov	r4, r0
 8005254:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8005256:	b2da      	uxtb	r2, r3
 8005258:	d12d      	bne.n	80052b6 <HAL_SUBGHZ_WriteRegisters+0x6e>
    __HAL_LOCK(hsubghz);
 800525a:	7943      	ldrb	r3, [r0, #5]
 800525c:	2b01      	cmp	r3, #1
 800525e:	d02a      	beq.n	80052b6 <HAL_SUBGHZ_WriteRegisters+0x6e>
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8005260:	2302      	movs	r3, #2
    __HAL_LOCK(hsubghz);
 8005262:	7142      	strb	r2, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8005264:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8005266:	f7ff ffd3 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 800526a:	f7ff fecf 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 800526e:	210d      	movs	r1, #13
 8005270:	4620      	mov	r0, r4
 8005272:	f7ff ff37 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8005276:	0a39      	lsrs	r1, r7, #8
 8005278:	4620      	mov	r0, r4
 800527a:	f7ff ff33 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 800527e:	b2f9      	uxtb	r1, r7
 8005280:	4620      	mov	r0, r4
 8005282:	f7ff ff2f 	bl	80050e4 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_WriteRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 8005286:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 8005288:	42b5      	cmp	r5, r6
 800528a:	d10e      	bne.n	80052aa <HAL_SUBGHZ_WriteRegisters+0x62>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 800528c:	f7ff feb4 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8005290:	4620      	mov	r0, r4
 8005292:	f7ff ff99 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8005296:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8005298:	2301      	movs	r3, #1
      status = HAL_ERROR;
 800529a:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 800529c:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 800529e:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 80052a2:	bf18      	it	ne
 80052a4:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 80052a6:	7163      	strb	r3, [r4, #5]
}
 80052a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80052aa:	f815 1b01 	ldrb.w	r1, [r5], #1
 80052ae:	4620      	mov	r0, r4
 80052b0:	f7ff ff18 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80052b4:	e7e8      	b.n	8005288 <HAL_SUBGHZ_WriteRegisters+0x40>
    return HAL_BUSY;
 80052b6:	2002      	movs	r0, #2
 80052b8:	e7f6      	b.n	80052a8 <HAL_SUBGHZ_WriteRegisters+0x60>

080052ba <HAL_SUBGHZ_ReadRegisters>:
{
 80052ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80052bc:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80052be:	7983      	ldrb	r3, [r0, #6]
 80052c0:	2b01      	cmp	r3, #1
{
 80052c2:	4615      	mov	r5, r2
 80052c4:	4604      	mov	r4, r0
 80052c6:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80052c8:	b2da      	uxtb	r2, r3
 80052ca:	d12f      	bne.n	800532c <HAL_SUBGHZ_ReadRegisters+0x72>
    __HAL_LOCK(hsubghz);
 80052cc:	7943      	ldrb	r3, [r0, #5]
 80052ce:	2b01      	cmp	r3, #1
 80052d0:	d02c      	beq.n	800532c <HAL_SUBGHZ_ReadRegisters+0x72>
 80052d2:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80052d4:	f7ff ff9c 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 80052d8:	f7ff fe98 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 80052dc:	211d      	movs	r1, #29
 80052de:	4620      	mov	r0, r4
 80052e0:	f7ff ff00 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 80052e4:	0a39      	lsrs	r1, r7, #8
 80052e6:	4620      	mov	r0, r4
 80052e8:	f7ff fefc 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 80052ec:	b2f9      	uxtb	r1, r7
 80052ee:	4620      	mov	r0, r4
 80052f0:	f7ff fef8 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 80052f4:	2100      	movs	r1, #0
 80052f6:	4620      	mov	r0, r4
 80052f8:	f7ff fef4 	bl	80050e4 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 80052fc:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 80052fe:	42b5      	cmp	r5, r6
 8005300:	d10e      	bne.n	8005320 <HAL_SUBGHZ_ReadRegisters+0x66>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 8005302:	f7ff fe79 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8005306:	4620      	mov	r0, r4
 8005308:	f7ff ff5e 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800530c:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 800530e:	2301      	movs	r3, #1
      status = HAL_ERROR;
 8005310:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8005312:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 8005314:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 8005318:	bf18      	it	ne
 800531a:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 800531c:	7163      	strb	r3, [r4, #5]
}
 800531e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8005320:	4629      	mov	r1, r5
 8005322:	4620      	mov	r0, r4
 8005324:	f7ff ff16 	bl	8005154 <SUBGHZSPI_Receive>
      pData++;
 8005328:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 800532a:	e7e8      	b.n	80052fe <HAL_SUBGHZ_ReadRegisters+0x44>
    return HAL_BUSY;
 800532c:	2002      	movs	r0, #2
 800532e:	e7f6      	b.n	800531e <HAL_SUBGHZ_ReadRegisters+0x64>

08005330 <HAL_SUBGHZ_ExecSetCmd>:
{
 8005330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005332:	461f      	mov	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8005334:	7983      	ldrb	r3, [r0, #6]
 8005336:	2b01      	cmp	r3, #1
{
 8005338:	4615      	mov	r5, r2
 800533a:	4604      	mov	r4, r0
 800533c:	460e      	mov	r6, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800533e:	b2da      	uxtb	r2, r3
 8005340:	d12c      	bne.n	800539c <HAL_SUBGHZ_ExecSetCmd+0x6c>
    __HAL_LOCK(hsubghz);
 8005342:	7943      	ldrb	r3, [r0, #5]
 8005344:	2b01      	cmp	r3, #1
 8005346:	d029      	beq.n	800539c <HAL_SUBGHZ_ExecSetCmd+0x6c>
 8005348:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 800534a:	f7ff ff61 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 800534e:	f006 03ef 	and.w	r3, r6, #239	; 0xef
 8005352:	f1a3 0284 	sub.w	r2, r3, #132	; 0x84
 8005356:	4253      	negs	r3, r2
 8005358:	4153      	adcs	r3, r2
 800535a:	7123      	strb	r3, [r4, #4]
    LL_PWR_SelectSUBGHZSPI_NSS();
 800535c:	f7ff fe56 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8005360:	4631      	mov	r1, r6
 8005362:	4620      	mov	r0, r4
 8005364:	f7ff febe 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8005368:	442f      	add	r7, r5
 800536a:	42af      	cmp	r7, r5
 800536c:	d110      	bne.n	8005390 <HAL_SUBGHZ_ExecSetCmd+0x60>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 800536e:	f7ff fe43 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    if (Command != RADIO_SET_SLEEP)
 8005372:	2e84      	cmp	r6, #132	; 0x84
 8005374:	d002      	beq.n	800537c <HAL_SUBGHZ_ExecSetCmd+0x4c>
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 8005376:	4620      	mov	r0, r4
 8005378:	f7ff ff26 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 800537c:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 800537e:	2301      	movs	r3, #1
      status = HAL_ERROR;
 8005380:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8005382:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 8005384:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 8005388:	bf18      	it	ne
 800538a:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 800538c:	7163      	strb	r3, [r4, #5]
}
 800538e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8005390:	f815 1b01 	ldrb.w	r1, [r5], #1
 8005394:	4620      	mov	r0, r4
 8005396:	f7ff fea5 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 800539a:	e7e6      	b.n	800536a <HAL_SUBGHZ_ExecSetCmd+0x3a>
    return HAL_BUSY;
 800539c:	2002      	movs	r0, #2
 800539e:	e7f6      	b.n	800538e <HAL_SUBGHZ_ExecSetCmd+0x5e>

080053a0 <HAL_SUBGHZ_WriteBuffer>:
{
 80053a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80053a2:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80053a4:	7983      	ldrb	r3, [r0, #6]
 80053a6:	2b01      	cmp	r3, #1
{
 80053a8:	4615      	mov	r5, r2
 80053aa:	4604      	mov	r4, r0
 80053ac:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80053ae:	b2da      	uxtb	r2, r3
 80053b0:	d127      	bne.n	8005402 <HAL_SUBGHZ_WriteBuffer+0x62>
    __HAL_LOCK(hsubghz);
 80053b2:	7943      	ldrb	r3, [r0, #5]
 80053b4:	2b01      	cmp	r3, #1
 80053b6:	d024      	beq.n	8005402 <HAL_SUBGHZ_WriteBuffer+0x62>
 80053b8:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80053ba:	f7ff ff29 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 80053be:	f7ff fe25 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 80053c2:	210e      	movs	r1, #14
 80053c4:	4620      	mov	r0, r4
 80053c6:	f7ff fe8d 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 80053ca:	4639      	mov	r1, r7
 80053cc:	4620      	mov	r0, r4
 80053ce:	f7ff fe89 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80053d2:	442e      	add	r6, r5
 80053d4:	42b5      	cmp	r5, r6
 80053d6:	d10e      	bne.n	80053f6 <HAL_SUBGHZ_WriteBuffer+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 80053d8:	f7ff fe0e 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 80053dc:	4620      	mov	r0, r4
 80053de:	f7ff fef3 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80053e2:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80053e4:	2301      	movs	r3, #1
      status = HAL_ERROR;
 80053e6:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80053e8:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 80053ea:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 80053ee:	bf18      	it	ne
 80053f0:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 80053f2:	7163      	strb	r3, [r4, #5]
}
 80053f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80053f6:	f815 1b01 	ldrb.w	r1, [r5], #1
 80053fa:	4620      	mov	r0, r4
 80053fc:	f7ff fe72 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8005400:	e7e8      	b.n	80053d4 <HAL_SUBGHZ_WriteBuffer+0x34>
    return HAL_BUSY;
 8005402:	2002      	movs	r0, #2
 8005404:	e7f6      	b.n	80053f4 <HAL_SUBGHZ_WriteBuffer+0x54>

08005406 <HAL_SUBGHZ_ReadBuffer>:
{
 8005406:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005408:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 800540a:	7983      	ldrb	r3, [r0, #6]
 800540c:	2b01      	cmp	r3, #1
{
 800540e:	4615      	mov	r5, r2
 8005410:	4604      	mov	r4, r0
 8005412:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8005414:	b2da      	uxtb	r2, r3
 8005416:	d12b      	bne.n	8005470 <HAL_SUBGHZ_ReadBuffer+0x6a>
    __HAL_LOCK(hsubghz);
 8005418:	7943      	ldrb	r3, [r0, #5]
 800541a:	2b01      	cmp	r3, #1
 800541c:	d028      	beq.n	8005470 <HAL_SUBGHZ_ReadBuffer+0x6a>
 800541e:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8005420:	f7ff fef6 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 8005424:	f7ff fdf2 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 8005428:	211e      	movs	r1, #30
 800542a:	4620      	mov	r0, r4
 800542c:	f7ff fe5a 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 8005430:	4639      	mov	r1, r7
 8005432:	4620      	mov	r0, r4
 8005434:	f7ff fe56 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8005438:	2100      	movs	r1, #0
 800543a:	4620      	mov	r0, r4
 800543c:	f7ff fe52 	bl	80050e4 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8005440:	442e      	add	r6, r5
 8005442:	42b5      	cmp	r5, r6
 8005444:	d10e      	bne.n	8005464 <HAL_SUBGHZ_ReadBuffer+0x5e>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 8005446:	f7ff fdd7 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 800544a:	4620      	mov	r0, r4
 800544c:	f7ff febc 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8005450:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8005452:	2301      	movs	r3, #1
      status = HAL_ERROR;
 8005454:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8005456:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 8005458:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 800545c:	bf18      	it	ne
 800545e:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 8005460:	7163      	strb	r3, [r4, #5]
}
 8005462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8005464:	4629      	mov	r1, r5
 8005466:	4620      	mov	r0, r4
 8005468:	f7ff fe74 	bl	8005154 <SUBGHZSPI_Receive>
      pData++;
 800546c:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 800546e:	e7e8      	b.n	8005442 <HAL_SUBGHZ_ReadBuffer+0x3c>
    return HAL_BUSY;
 8005470:	2002      	movs	r0, #2
 8005472:	e7f6      	b.n	8005462 <HAL_SUBGHZ_ReadBuffer+0x5c>

08005474 <HAL_SUBGHZ_ExecGetCmd>:
{
 8005474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005476:	461e      	mov	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8005478:	7983      	ldrb	r3, [r0, #6]
 800547a:	2b01      	cmp	r3, #1
{
 800547c:	4615      	mov	r5, r2
 800547e:	4604      	mov	r4, r0
 8005480:	460f      	mov	r7, r1
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8005482:	b2da      	uxtb	r2, r3
 8005484:	d127      	bne.n	80054d6 <HAL_SUBGHZ_ExecGetCmd+0x62>
    __HAL_LOCK(hsubghz);
 8005486:	7943      	ldrb	r3, [r0, #5]
 8005488:	2b01      	cmp	r3, #1
 800548a:	d024      	beq.n	80054d6 <HAL_SUBGHZ_ExecGetCmd+0x62>
 800548c:	7142      	strb	r2, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 800548e:	f7ff febf 	bl	8005210 <SUBGHZ_CheckDeviceReady>
    LL_PWR_SelectSUBGHZSPI_NSS();
 8005492:	f7ff fdbb 	bl	800500c <LL_PWR_SelectSUBGHZSPI_NSS>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8005496:	4639      	mov	r1, r7
 8005498:	4620      	mov	r0, r4
 800549a:	f7ff fe23 	bl	80050e4 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 800549e:	2100      	movs	r1, #0
 80054a0:	4620      	mov	r0, r4
 80054a2:	f7ff fe1f 	bl	80050e4 <SUBGHZSPI_Transmit>
HAL_StatusTypeDef HAL_SUBGHZ_ReadRegisters(SUBGHZ_HandleTypeDef *hsubghz,
 80054a6:	442e      	add	r6, r5
    for (uint16_t i = 0U; i < Size; i++)
 80054a8:	42b5      	cmp	r5, r6
 80054aa:	d10e      	bne.n	80054ca <HAL_SUBGHZ_ExecGetCmd+0x56>
    LL_PWR_UnselectSUBGHZSPI_NSS();
 80054ac:	f7ff fda4 	bl	8004ff8 <LL_PWR_UnselectSUBGHZSPI_NSS>
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 80054b0:	4620      	mov	r0, r4
 80054b2:	f7ff fe89 	bl	80051c8 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80054b6:	68a0      	ldr	r0, [r4, #8]
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80054b8:	2301      	movs	r3, #1
      status = HAL_ERROR;
 80054ba:	3800      	subs	r0, #0
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80054bc:	71a3      	strb	r3, [r4, #6]
    __HAL_UNLOCK(hsubghz);
 80054be:	f04f 0300 	mov.w	r3, #0
      status = HAL_ERROR;
 80054c2:	bf18      	it	ne
 80054c4:	2001      	movne	r0, #1
    __HAL_UNLOCK(hsubghz);
 80054c6:	7163      	strb	r3, [r4, #5]
}
 80054c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 80054ca:	4629      	mov	r1, r5
 80054cc:	4620      	mov	r0, r4
 80054ce:	f7ff fe41 	bl	8005154 <SUBGHZSPI_Receive>
      pData++;
 80054d2:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 80054d4:	e7e8      	b.n	80054a8 <HAL_SUBGHZ_ExecGetCmd+0x34>
    return HAL_BUSY;
 80054d6:	2002      	movs	r0, #2
 80054d8:	e7f6      	b.n	80054c8 <HAL_SUBGHZ_ExecGetCmd+0x54>

080054da <HAL_SUBGHZ_IRQHandler>:
{
 80054da:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint8_t tmpisr[2] = {0};
 80054dc:	2300      	movs	r3, #0
 80054de:	f8ad 3004 	strh.w	r3, [sp, #4]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 80054e2:	aa01      	add	r2, sp, #4
 80054e4:	2302      	movs	r3, #2
 80054e6:	2112      	movs	r1, #18
{
 80054e8:	4604      	mov	r4, r0
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2);
 80054ea:	f7ff ffc3 	bl	8005474 <HAL_SUBGHZ_ExecGetCmd>
  itsource = (itsource << 8) | tmpisr[1];
 80054ee:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80054f2:	f89d 5004 	ldrb.w	r5, [sp, #4]
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 80054f6:	07da      	lsls	r2, r3, #31
  itsource = (itsource << 8) | tmpisr[1];
 80054f8:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 80054fc:	d502      	bpl.n	8005504 <HAL_SUBGHZ_IRQHandler+0x2a>
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 80054fe:	4620      	mov	r0, r4
 8005500:	f009 fba4 	bl	800ec4c <HAL_SUBGHZ_TxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 8005504:	07ab      	lsls	r3, r5, #30
 8005506:	d502      	bpl.n	800550e <HAL_SUBGHZ_IRQHandler+0x34>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 8005508:	4620      	mov	r0, r4
 800550a:	f009 fba5 	bl	800ec58 <HAL_SUBGHZ_RxCpltCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 800550e:	0768      	lsls	r0, r5, #29
 8005510:	d502      	bpl.n	8005518 <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 8005512:	4620      	mov	r0, r4
 8005514:	f009 fbca 	bl	800ecac <HAL_SUBGHZ_PreambleDetectedCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 8005518:	0729      	lsls	r1, r5, #28
 800551a:	d502      	bpl.n	8005522 <HAL_SUBGHZ_IRQHandler+0x48>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 800551c:	4620      	mov	r0, r4
 800551e:	f009 fbcb 	bl	800ecb8 <HAL_SUBGHZ_SyncWordValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8005522:	06ea      	lsls	r2, r5, #27
 8005524:	d502      	bpl.n	800552c <HAL_SUBGHZ_IRQHandler+0x52>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 8005526:	4620      	mov	r0, r4
 8005528:	f009 fbcc 	bl	800ecc4 <HAL_SUBGHZ_HeaderValidCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 800552c:	06ab      	lsls	r3, r5, #26
 800552e:	d502      	bpl.n	8005536 <HAL_SUBGHZ_IRQHandler+0x5c>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 8005530:	4620      	mov	r0, r4
 8005532:	f009 fbb5 	bl	800eca0 <HAL_SUBGHZ_HeaderErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 8005536:	0668      	lsls	r0, r5, #25
 8005538:	d502      	bpl.n	8005540 <HAL_SUBGHZ_IRQHandler+0x66>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 800553a:	4620      	mov	r0, r4
 800553c:	f009 fb92 	bl	800ec64 <HAL_SUBGHZ_CRCErrorCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 8005540:	0629      	lsls	r1, r5, #24
 8005542:	d507      	bpl.n	8005554 <HAL_SUBGHZ_IRQHandler+0x7a>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 8005544:	05ea      	lsls	r2, r5, #23
 8005546:	f3c5 2100 	ubfx	r1, r5, #8, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 800554a:	4620      	mov	r0, r4
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 800554c:	bf48      	it	mi
 800554e:	2101      	movmi	r1, #1
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 8005550:	f009 fb8e 	bl	800ec70 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 8005554:	05ab      	lsls	r3, r5, #22
 8005556:	d502      	bpl.n	800555e <HAL_SUBGHZ_IRQHandler+0x84>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 8005558:	4620      	mov	r0, r4
 800555a:	f009 fb99 	bl	800ec90 <HAL_SUBGHZ_RxTxTimeoutCallback>
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2);
 800555e:	2302      	movs	r3, #2
 8005560:	aa01      	add	r2, sp, #4
 8005562:	4619      	mov	r1, r3
 8005564:	4620      	mov	r0, r4
 8005566:	f7ff fee3 	bl	8005330 <HAL_SUBGHZ_ExecSetCmd>
}
 800556a:	b003      	add	sp, #12
 800556c:	bd30      	pop	{r4, r5, pc}

0800556e <UART_EndTxTransfer>:
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 800556e:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005570:	e852 3f00 	ldrex	r3, [r2]
 8005574:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005578:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 800557c:	6802      	ldr	r2, [r0, #0]
 800557e:	2900      	cmp	r1, #0
 8005580:	d1f5      	bne.n	800556e <UART_EndTxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005582:	f102 0308 	add.w	r3, r2, #8
 8005586:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 800558a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800558e:	f102 0c08 	add.w	ip, r2, #8
 8005592:	e84c 3100 	strex	r1, r3, [ip]
 8005596:	2900      	cmp	r1, #0
 8005598:	d1f3      	bne.n	8005582 <UART_EndTxTransfer+0x14>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800559a:	2320      	movs	r3, #32
 800559c:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
 80055a0:	4770      	bx	lr
	...

080055a4 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 80055a4:	b510      	push	{r4, lr}
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 80055a6:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80055a8:	e852 3f00 	ldrex	r3, [r2]
 80055ac:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80055b0:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80055b4:	6802      	ldr	r2, [r0, #0]
 80055b6:	2900      	cmp	r1, #0
 80055b8:	d1f5      	bne.n	80055a6 <UART_EndRxTransfer+0x2>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 80055ba:	4c0f      	ldr	r4, [pc, #60]	; (80055f8 <UART_EndRxTransfer+0x54>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80055bc:	f102 0308 	add.w	r3, r2, #8
 80055c0:	e853 3f00 	ldrex	r3, [r3]
 80055c4:	4023      	ands	r3, r4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80055c6:	f102 0c08 	add.w	ip, r2, #8
 80055ca:	e84c 3100 	strex	r1, r3, [ip]
 80055ce:	2900      	cmp	r1, #0
 80055d0:	d1f4      	bne.n	80055bc <UART_EndRxTransfer+0x18>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80055d2:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80055d4:	2b01      	cmp	r3, #1
 80055d6:	d107      	bne.n	80055e8 <UART_EndRxTransfer+0x44>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80055d8:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80055dc:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80055e0:	e842 3100 	strex	r1, r3, [r2]
 80055e4:	2900      	cmp	r1, #0
 80055e6:	d1f7      	bne.n	80055d8 <UART_EndRxTransfer+0x34>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80055e8:	2320      	movs	r3, #32
 80055ea:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80055ee:	2300      	movs	r3, #0
 80055f0:	66c3      	str	r3, [r0, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 80055f2:	6703      	str	r3, [r0, #112]	; 0x70
}
 80055f4:	bd10      	pop	{r4, pc}
 80055f6:	bf00      	nop
 80055f8:	effffffe 	.word	0xeffffffe

080055fc <HAL_UART_Transmit_DMA>:
{
 80055fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80055fe:	4604      	mov	r4, r0
 8005600:	4613      	mov	r3, r2
  if (huart->gState == HAL_UART_STATE_READY)
 8005602:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
 8005606:	2f20      	cmp	r7, #32
 8005608:	d143      	bne.n	8005692 <HAL_UART_Transmit_DMA+0x96>
    if ((pData == NULL) || (Size == 0U))
 800560a:	b361      	cbz	r1, 8005666 <HAL_UART_Transmit_DMA+0x6a>
 800560c:	b35a      	cbz	r2, 8005666 <HAL_UART_Transmit_DMA+0x6a>
    __HAL_LOCK(huart);
 800560e:	f894 2080 	ldrb.w	r2, [r4, #128]	; 0x80
 8005612:	2a01      	cmp	r2, #1
 8005614:	d03d      	beq.n	8005692 <HAL_UART_Transmit_DMA+0x96>
    if (huart->hdmatx != NULL)
 8005616:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    huart->TxXferCount = Size;
 8005618:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
    __HAL_LOCK(huart);
 800561c:	2501      	movs	r5, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800561e:	2600      	movs	r6, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005620:	2221      	movs	r2, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005622:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
    __HAL_LOCK(huart);
 8005626:	f884 5080 	strb.w	r5, [r4, #128]	; 0x80
    huart->pTxBuffPtr  = pData;
 800562a:	6521      	str	r1, [r4, #80]	; 0x50
    huart->TxXferSize  = Size;
 800562c:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8005630:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
    if (huart->hdmatx != NULL)
 8005634:	b1c8      	cbz	r0, 800566a <HAL_UART_Transmit_DMA+0x6e>
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 8005636:	f8df c060 	ldr.w	ip, [pc, #96]	; 8005698 <HAL_UART_Transmit_DMA+0x9c>
 800563a:	6822      	ldr	r2, [r4, #0]
 800563c:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8005640:	f8df c058 	ldr.w	ip, [pc, #88]	; 800569c <HAL_UART_Transmit_DMA+0xa0>
 8005644:	f8c0 c030 	str.w	ip, [r0, #48]	; 0x30
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 8005648:	f8df c054 	ldr.w	ip, [pc, #84]	; 80056a0 <HAL_UART_Transmit_DMA+0xa4>
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 800564c:	3228      	adds	r2, #40	; 0x28
      huart->hdmatx->XferAbortCallback = NULL;
 800564e:	e9c0 c60d 	strd	ip, r6, [r0, #52]	; 0x34
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 8005652:	f7fd ff1d 	bl	8003490 <HAL_DMA_Start_IT>
 8005656:	b140      	cbz	r0, 800566a <HAL_UART_Transmit_DMA+0x6e>
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 8005658:	2310      	movs	r3, #16
 800565a:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        __HAL_UNLOCK(huart);
 800565e:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
        huart->gState = HAL_UART_STATE_READY;
 8005662:	f8c4 7084 	str.w	r7, [r4, #132]	; 0x84
      return HAL_ERROR;
 8005666:	2001      	movs	r0, #1
 8005668:	e012      	b.n	8005690 <HAL_UART_Transmit_DMA+0x94>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 800566a:	6823      	ldr	r3, [r4, #0]
 800566c:	2240      	movs	r2, #64	; 0x40
 800566e:	621a      	str	r2, [r3, #32]
    __HAL_UNLOCK(huart);
 8005670:	2300      	movs	r3, #0
 8005672:	6822      	ldr	r2, [r4, #0]
 8005674:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005678:	f102 0308 	add.w	r3, r2, #8
 800567c:	e853 3f00 	ldrex	r3, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 8005680:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005684:	f102 0108 	add.w	r1, r2, #8
 8005688:	e841 3000 	strex	r0, r3, [r1]
 800568c:	2800      	cmp	r0, #0
 800568e:	d1f3      	bne.n	8005678 <HAL_UART_Transmit_DMA+0x7c>
}
 8005690:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 8005692:	2002      	movs	r0, #2
 8005694:	e7fc      	b.n	8005690 <HAL_UART_Transmit_DMA+0x94>
 8005696:	bf00      	nop
 8005698:	080056a5 	.word	0x080056a5
 800569c:	080056ed 	.word	0x080056ed
 80056a0:	080056f9 	.word	0x080056f9

080056a4 <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 80056a4:	b508      	push	{r3, lr}
 80056a6:	4603      	mov	r3, r0
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80056a8:	6a80      	ldr	r0, [r0, #40]	; 0x28

  /* DMA Normal mode */
  if (HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC))
 80056aa:	681b      	ldr	r3, [r3, #0]
 80056ac:	681b      	ldr	r3, [r3, #0]
 80056ae:	f013 0320 	ands.w	r3, r3, #32
 80056b2:	d117      	bne.n	80056e4 <UART_DMATransmitCplt+0x40>
  {
    huart->TxXferCount = 0U;
 80056b4:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80056b8:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80056ba:	f102 0308 	add.w	r3, r2, #8
 80056be:	e853 3f00 	ldrex	r3, [r3]
 80056c2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80056c6:	3208      	adds	r2, #8
 80056c8:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 80056cc:	6802      	ldr	r2, [r0, #0]
 80056ce:	2900      	cmp	r1, #0
 80056d0:	d1f2      	bne.n	80056b8 <UART_DMATransmitCplt+0x14>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80056d2:	e852 3f00 	ldrex	r3, [r2]

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80056d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80056da:	e842 3100 	strex	r1, r3, [r2]
 80056de:	2900      	cmp	r1, #0
 80056e0:	d1f7      	bne.n	80056d2 <UART_DMATransmitCplt+0x2e>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 80056e2:	bd08      	pop	{r3, pc}
    HAL_UART_TxCpltCallback(huart);
 80056e4:	f7fc f9ae 	bl	8001a44 <HAL_UART_TxCpltCallback>
}
 80056e8:	e7fb      	b.n	80056e2 <UART_DMATransmitCplt+0x3e>

080056ea <HAL_UART_TxHalfCpltCallback>:
 80056ea:	4770      	bx	lr

080056ec <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 80056ec:	b508      	push	{r3, lr}
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 80056ee:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80056f0:	f7ff fffb 	bl	80056ea <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80056f4:	bd08      	pop	{r3, pc}

080056f6 <HAL_UART_ErrorCallback>:
 80056f6:	4770      	bx	lr

080056f8 <UART_DMAError>:
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80056f8:	6a80      	ldr	r0, [r0, #40]	; 0x28

  const HAL_UART_StateTypeDef gstate = huart->gState;
  const HAL_UART_StateTypeDef rxstate = huart->RxState;

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 80056fa:	6802      	ldr	r2, [r0, #0]
  const HAL_UART_StateTypeDef gstate = huart->gState;
 80056fc:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 8005700:	b510      	push	{r4, lr}
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 8005702:	f8d0 4088 	ldr.w	r4, [r0, #136]	; 0x88
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 8005706:	6892      	ldr	r2, [r2, #8]
 8005708:	0612      	lsls	r2, r2, #24
 800570a:	d506      	bpl.n	800571a <UART_DMAError+0x22>
 800570c:	2b21      	cmp	r3, #33	; 0x21
 800570e:	d104      	bne.n	800571a <UART_DMAError+0x22>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 8005710:	2300      	movs	r3, #0
 8005712:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
    UART_EndTxTransfer(huart);
 8005716:	f7ff ff2a 	bl	800556e <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 800571a:	6803      	ldr	r3, [r0, #0]
 800571c:	689b      	ldr	r3, [r3, #8]
 800571e:	065b      	lsls	r3, r3, #25
 8005720:	d506      	bpl.n	8005730 <UART_DMAError+0x38>
 8005722:	2c22      	cmp	r4, #34	; 0x22
 8005724:	d104      	bne.n	8005730 <UART_DMAError+0x38>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 8005726:	2300      	movs	r3, #0
 8005728:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 800572c:	f7ff ff3a 	bl	80055a4 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 8005730:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 8005734:	f043 0310 	orr.w	r3, r3, #16
 8005738:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800573c:	f7ff ffdb 	bl	80056f6 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005740:	bd10      	pop	{r4, pc}

08005742 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8005742:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 8005744:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 8005746:	2300      	movs	r3, #0
 8005748:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e
  huart->TxXferCount = 0U;
 800574c:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8005750:	f7ff ffd1 	bl	80056f6 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005754:	bd08      	pop	{r3, pc}

08005756 <HAL_UARTEx_RxEventCallback>:
}
 8005756:	4770      	bx	lr

08005758 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8005758:	6803      	ldr	r3, [r0, #0]
 800575a:	69da      	ldr	r2, [r3, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800575c:	6819      	ldr	r1, [r3, #0]
{
 800575e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (errorflags == 0U)
 8005762:	f640 060f 	movw	r6, #2063	; 0x80f
 8005766:	4232      	tst	r2, r6
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8005768:	689d      	ldr	r5, [r3, #8]
{
 800576a:	4604      	mov	r4, r0
  if (errorflags == 0U)
 800576c:	d110      	bne.n	8005790 <HAL_UART_IRQHandler+0x38>
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 800576e:	0696      	lsls	r6, r2, #26
 8005770:	f140 8096 	bpl.w	80058a0 <HAL_UART_IRQHandler+0x148>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8005774:	f001 0620 	and.w	r6, r1, #32
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8005778:	f005 5780 	and.w	r7, r5, #268435456	; 0x10000000
 800577c:	433e      	orrs	r6, r7
 800577e:	f000 808f 	beq.w	80058a0 <HAL_UART_IRQHandler+0x148>
      if (huart->RxISR != NULL)
 8005782:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8005784:	2b00      	cmp	r3, #0
 8005786:	f000 8084 	beq.w	8005892 <HAL_UART_IRQHandler+0x13a>
}
 800578a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800578e:	4718      	bx	r3
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 8005790:	4ea7      	ldr	r6, [pc, #668]	; (8005a30 <HAL_UART_IRQHandler+0x2d8>)
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8005792:	48a8      	ldr	r0, [pc, #672]	; (8005a34 <HAL_UART_IRQHandler+0x2dc>)
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 8005794:	402e      	ands	r6, r5
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 8005796:	4008      	ands	r0, r1
 8005798:	4330      	orrs	r0, r6
 800579a:	f000 8081 	beq.w	80058a0 <HAL_UART_IRQHandler+0x148>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800579e:	07d7      	lsls	r7, r2, #31
 80057a0:	d509      	bpl.n	80057b6 <HAL_UART_IRQHandler+0x5e>
 80057a2:	05c8      	lsls	r0, r1, #23
 80057a4:	d507      	bpl.n	80057b6 <HAL_UART_IRQHandler+0x5e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80057a6:	2001      	movs	r0, #1
 80057a8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80057aa:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 80057ae:	f040 0001 	orr.w	r0, r0, #1
 80057b2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80057b6:	0797      	lsls	r7, r2, #30
 80057b8:	d509      	bpl.n	80057ce <HAL_UART_IRQHandler+0x76>
 80057ba:	07e8      	lsls	r0, r5, #31
 80057bc:	d507      	bpl.n	80057ce <HAL_UART_IRQHandler+0x76>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80057be:	2002      	movs	r0, #2
 80057c0:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80057c2:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 80057c6:	f040 0004 	orr.w	r0, r0, #4
 80057ca:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80057ce:	0757      	lsls	r7, r2, #29
 80057d0:	d509      	bpl.n	80057e6 <HAL_UART_IRQHandler+0x8e>
 80057d2:	07e8      	lsls	r0, r5, #31
 80057d4:	d507      	bpl.n	80057e6 <HAL_UART_IRQHandler+0x8e>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80057d6:	2004      	movs	r0, #4
 80057d8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80057da:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 80057de:	f040 0002 	orr.w	r0, r0, #2
 80057e2:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_ORE) != 0U)
 80057e6:	0717      	lsls	r7, r2, #28
 80057e8:	d50b      	bpl.n	8005802 <HAL_UART_IRQHandler+0xaa>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 80057ea:	f001 0020 	and.w	r0, r1, #32
 80057ee:	4330      	orrs	r0, r6
 80057f0:	d007      	beq.n	8005802 <HAL_UART_IRQHandler+0xaa>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80057f2:	2008      	movs	r0, #8
 80057f4:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80057f6:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 80057fa:	f040 0008 	orr.w	r0, r0, #8
 80057fe:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8005802:	0516      	lsls	r6, r2, #20
 8005804:	d50a      	bpl.n	800581c <HAL_UART_IRQHandler+0xc4>
 8005806:	0148      	lsls	r0, r1, #5
 8005808:	d508      	bpl.n	800581c <HAL_UART_IRQHandler+0xc4>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800580a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800580e:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8005810:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005814:	f043 0320 	orr.w	r3, r3, #32
 8005818:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800581c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005820:	2b00      	cmp	r3, #0
 8005822:	d036      	beq.n	8005892 <HAL_UART_IRQHandler+0x13a>
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8005824:	0693      	lsls	r3, r2, #26
 8005826:	d50a      	bpl.n	800583e <HAL_UART_IRQHandler+0xe6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8005828:	f001 0120 	and.w	r1, r1, #32
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 800582c:	f005 5580 	and.w	r5, r5, #268435456	; 0x10000000
 8005830:	ea51 0305 	orrs.w	r3, r1, r5
 8005834:	d003      	beq.n	800583e <HAL_UART_IRQHandler+0xe6>
        if (huart->RxISR != NULL)
 8005836:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8005838:	b10b      	cbz	r3, 800583e <HAL_UART_IRQHandler+0xe6>
          huart->RxISR(huart);
 800583a:	4620      	mov	r0, r4
 800583c:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800583e:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 8005840:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8005844:	689b      	ldr	r3, [r3, #8]
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 8005846:	f005 0528 	and.w	r5, r5, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800584a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800584e:	431d      	orrs	r5, r3
        UART_EndRxTransfer(huart);
 8005850:	4620      	mov	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8005852:	d020      	beq.n	8005896 <HAL_UART_IRQHandler+0x13e>
        UART_EndRxTransfer(huart);
 8005854:	f7ff fea6 	bl	80055a4 <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8005858:	6822      	ldr	r2, [r4, #0]
 800585a:	6893      	ldr	r3, [r2, #8]
 800585c:	065f      	lsls	r7, r3, #25
 800585e:	d515      	bpl.n	800588c <HAL_UART_IRQHandler+0x134>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005860:	f102 0308 	add.w	r3, r2, #8
 8005864:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005868:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800586c:	f102 0008 	add.w	r0, r2, #8
 8005870:	e840 3100 	strex	r1, r3, [r0]
 8005874:	2900      	cmp	r1, #0
 8005876:	d1f3      	bne.n	8005860 <HAL_UART_IRQHandler+0x108>
          if (huart->hdmarx != NULL)
 8005878:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 800587a:	b138      	cbz	r0, 800588c <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800587c:	4b6e      	ldr	r3, [pc, #440]	; (8005a38 <HAL_UART_IRQHandler+0x2e0>)
 800587e:	6383      	str	r3, [r0, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8005880:	f7fd fe80 	bl	8003584 <HAL_DMA_Abort_IT>
 8005884:	b128      	cbz	r0, 8005892 <HAL_UART_IRQHandler+0x13a>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8005886:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8005888:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800588a:	e77e      	b.n	800578a <HAL_UART_IRQHandler+0x32>
            HAL_UART_ErrorCallback(huart);
 800588c:	4620      	mov	r0, r4
 800588e:	f7ff ff32 	bl	80056f6 <HAL_UART_ErrorCallback>
}
 8005892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        HAL_UART_ErrorCallback(huart);
 8005896:	f7ff ff2e 	bl	80056f6 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800589a:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
 800589e:	e7f8      	b.n	8005892 <HAL_UART_IRQHandler+0x13a>
  if (  (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80058a0:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80058a2:	2801      	cmp	r0, #1
 80058a4:	f040 8081 	bne.w	80059aa <HAL_UART_IRQHandler+0x252>
      &&((isrflags & USART_ISR_IDLE) != 0U)
 80058a8:	06d6      	lsls	r6, r2, #27
 80058aa:	d57e      	bpl.n	80059aa <HAL_UART_IRQHandler+0x252>
      &&((cr1its & USART_ISR_IDLE) != 0U))
 80058ac:	06c8      	lsls	r0, r1, #27
 80058ae:	d57c      	bpl.n	80059aa <HAL_UART_IRQHandler+0x252>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 80058b0:	2210      	movs	r2, #16
 80058b2:	621a      	str	r2, [r3, #32]
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80058b4:	689a      	ldr	r2, [r3, #8]
 80058b6:	0651      	lsls	r1, r2, #25
 80058b8:	d547      	bpl.n	800594a <HAL_UART_IRQHandler+0x1f2>
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 80058ba:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 80058bc:	6811      	ldr	r1, [r2, #0]
 80058be:	684a      	ldr	r2, [r1, #4]
 80058c0:	b292      	uxth	r2, r2
      if (  (nb_remaining_rx_data > 0U)
 80058c2:	2a00      	cmp	r2, #0
 80058c4:	d0e5      	beq.n	8005892 <HAL_UART_IRQHandler+0x13a>
          &&(nb_remaining_rx_data < huart->RxXferSize))
 80058c6:	f8b4 005c 	ldrh.w	r0, [r4, #92]	; 0x5c
 80058ca:	4290      	cmp	r0, r2
 80058cc:	d9e1      	bls.n	8005892 <HAL_UART_IRQHandler+0x13a>
        huart->RxXferCount = nb_remaining_rx_data;
 80058ce:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
        if (HAL_IS_BIT_CLR(huart->hdmarx->Instance->CCR, DMA_CCR_CIRC))
 80058d2:	680a      	ldr	r2, [r1, #0]
 80058d4:	0692      	lsls	r2, r2, #26
 80058d6:	d42e      	bmi.n	8005936 <HAL_UART_IRQHandler+0x1de>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80058d8:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80058dc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80058e0:	e843 2100 	strex	r1, r2, [r3]
 80058e4:	2900      	cmp	r1, #0
 80058e6:	d1f7      	bne.n	80058d8 <HAL_UART_IRQHandler+0x180>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80058e8:	f103 0208 	add.w	r2, r3, #8
 80058ec:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80058f0:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80058f4:	f103 0008 	add.w	r0, r3, #8
 80058f8:	e840 2100 	strex	r1, r2, [r0]
 80058fc:	2900      	cmp	r1, #0
 80058fe:	d1f3      	bne.n	80058e8 <HAL_UART_IRQHandler+0x190>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005900:	f103 0208 	add.w	r2, r3, #8
 8005904:	e852 2f00 	ldrex	r2, [r2]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8005908:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800590c:	f103 0008 	add.w	r0, r3, #8
 8005910:	e840 2100 	strex	r1, r2, [r0]
 8005914:	2900      	cmp	r1, #0
 8005916:	d1f3      	bne.n	8005900 <HAL_UART_IRQHandler+0x1a8>
          huart->RxState = HAL_UART_STATE_READY;
 8005918:	2220      	movs	r2, #32
 800591a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800591e:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005920:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005924:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005928:	e843 2100 	strex	r1, r2, [r3]
 800592c:	2900      	cmp	r1, #0
 800592e:	d1f7      	bne.n	8005920 <HAL_UART_IRQHandler+0x1c8>
          (void)HAL_DMA_Abort(huart->hdmarx);
 8005930:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8005932:	f7fd fdf2 	bl	800351a <HAL_DMA_Abort>
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8005936:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 800593a:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 800593e:	1ac9      	subs	r1, r1, r3
 8005940:	b289      	uxth	r1, r1
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8005942:	4620      	mov	r0, r4
 8005944:	f7ff ff07 	bl	8005756 <HAL_UARTEx_RxEventCallback>
 8005948:	e7a3      	b.n	8005892 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 800594a:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 800594e:	b28a      	uxth	r2, r1
      if (  (huart->RxXferCount > 0U)
 8005950:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 8005954:	b289      	uxth	r1, r1
 8005956:	2900      	cmp	r1, #0
 8005958:	d09b      	beq.n	8005892 <HAL_UART_IRQHandler+0x13a>
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 800595a:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
 800595e:	1a89      	subs	r1, r1, r2
 8005960:	b289      	uxth	r1, r1
          &&(nb_rx_data > 0U) )
 8005962:	2900      	cmp	r1, #0
 8005964:	d095      	beq.n	8005892 <HAL_UART_IRQHandler+0x13a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005966:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800596a:	f422 7290 	bic.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800596e:	e843 2000 	strex	r0, r2, [r3]
 8005972:	2800      	cmp	r0, #0
 8005974:	d1f7      	bne.n	8005966 <HAL_UART_IRQHandler+0x20e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005976:	4d31      	ldr	r5, [pc, #196]	; (8005a3c <HAL_UART_IRQHandler+0x2e4>)
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005978:	f103 0208 	add.w	r2, r3, #8
 800597c:	e852 2f00 	ldrex	r2, [r2]
 8005980:	402a      	ands	r2, r5
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005982:	f103 0608 	add.w	r6, r3, #8
 8005986:	e846 2000 	strex	r0, r2, [r6]
 800598a:	2800      	cmp	r0, #0
 800598c:	d1f4      	bne.n	8005978 <HAL_UART_IRQHandler+0x220>
        huart->RxState = HAL_UART_STATE_READY;
 800598e:	2220      	movs	r2, #32
 8005990:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 8005994:	6720      	str	r0, [r4, #112]	; 0x70
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005996:	66e0      	str	r0, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005998:	e853 2f00 	ldrex	r2, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800599c:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80059a0:	e843 2000 	strex	r0, r2, [r3]
 80059a4:	2800      	cmp	r0, #0
 80059a6:	d1f7      	bne.n	8005998 <HAL_UART_IRQHandler+0x240>
 80059a8:	e7cb      	b.n	8005942 <HAL_UART_IRQHandler+0x1ea>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 80059aa:	02d7      	lsls	r7, r2, #11
 80059ac:	d509      	bpl.n	80059c2 <HAL_UART_IRQHandler+0x26a>
 80059ae:	026e      	lsls	r6, r5, #9
 80059b0:	d507      	bpl.n	80059c2 <HAL_UART_IRQHandler+0x26a>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80059b2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    HAL_UARTEx_WakeupCallback(huart);
 80059b6:	4620      	mov	r0, r4
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 80059b8:	621a      	str	r2, [r3, #32]
}
 80059ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_WakeupCallback(huart);
 80059be:	f000 bd35 	b.w	800642c <HAL_UARTEx_WakeupCallback>
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 80059c2:	0610      	lsls	r0, r2, #24
 80059c4:	d50b      	bpl.n	80059de <HAL_UART_IRQHandler+0x286>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 80059c6:	f001 0080 	and.w	r0, r1, #128	; 0x80
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 80059ca:	f405 0500 	and.w	r5, r5, #8388608	; 0x800000
 80059ce:	4328      	orrs	r0, r5
 80059d0:	d005      	beq.n	80059de <HAL_UART_IRQHandler+0x286>
    if (huart->TxISR != NULL)
 80059d2:	6f63      	ldr	r3, [r4, #116]	; 0x74
 80059d4:	2b00      	cmp	r3, #0
 80059d6:	f43f af5c 	beq.w	8005892 <HAL_UART_IRQHandler+0x13a>
      huart->TxISR(huart);
 80059da:	4620      	mov	r0, r4
 80059dc:	e6d5      	b.n	800578a <HAL_UART_IRQHandler+0x32>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 80059de:	0657      	lsls	r7, r2, #25
 80059e0:	d511      	bpl.n	8005a06 <HAL_UART_IRQHandler+0x2ae>
 80059e2:	064e      	lsls	r6, r1, #25
 80059e4:	d50f      	bpl.n	8005a06 <HAL_UART_IRQHandler+0x2ae>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80059e6:	e853 2f00 	ldrex	r2, [r3]
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 80059ea:	f022 0240 	bic.w	r2, r2, #64	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80059ee:	e843 2100 	strex	r1, r2, [r3]
 80059f2:	2900      	cmp	r1, #0
 80059f4:	d1f7      	bne.n	80059e6 <HAL_UART_IRQHandler+0x28e>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 80059f6:	2320      	movs	r3, #32
 80059f8:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 80059fc:	6761      	str	r1, [r4, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 80059fe:	4620      	mov	r0, r4
 8005a00:	f7fc f820 	bl	8001a44 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8005a04:	e745      	b.n	8005892 <HAL_UART_IRQHandler+0x13a>
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8005a06:	0215      	lsls	r5, r2, #8
 8005a08:	d506      	bpl.n	8005a18 <HAL_UART_IRQHandler+0x2c0>
 8005a0a:	0048      	lsls	r0, r1, #1
 8005a0c:	d504      	bpl.n	8005a18 <HAL_UART_IRQHandler+0x2c0>
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8005a0e:	4620      	mov	r0, r4
}
 8005a10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8005a14:	f000 bd0c 	b.w	8006430 <HAL_UARTEx_TxFifoEmptyCallback>
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 8005a18:	01d3      	lsls	r3, r2, #7
 8005a1a:	f57f af3a 	bpl.w	8005892 <HAL_UART_IRQHandler+0x13a>
 8005a1e:	2900      	cmp	r1, #0
 8005a20:	f6bf af37 	bge.w	8005892 <HAL_UART_IRQHandler+0x13a>
    HAL_UARTEx_RxFifoFullCallback(huart);
 8005a24:	4620      	mov	r0, r4
}
 8005a26:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    HAL_UARTEx_RxFifoFullCallback(huart);
 8005a2a:	f000 bd00 	b.w	800642e <HAL_UARTEx_RxFifoFullCallback>
 8005a2e:	bf00      	nop
 8005a30:	10000001 	.word	0x10000001
 8005a34:	04000120 	.word	0x04000120
 8005a38:	08005743 	.word	0x08005743
 8005a3c:	effffffe 	.word	0xeffffffe

08005a40 <UART_RxISR_16BIT.part.0>:
/**
  * @brief RX interrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
 8005a40:	b508      	push	{r3, lr}
    huart->RxXferCount--;

    if (huart->RxXferCount == 0U)
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8005a42:	6802      	ldr	r2, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005a44:	e852 3f00 	ldrex	r3, [r2]
 8005a48:	f423 7390 	bic.w	r3, r3, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005a4c:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8005a50:	6803      	ldr	r3, [r0, #0]
 8005a52:	2900      	cmp	r1, #0
 8005a54:	d1f5      	bne.n	8005a42 <UART_RxISR_16BIT.part.0+0x2>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005a56:	f103 0208 	add.w	r2, r3, #8
 8005a5a:	e852 2f00 	ldrex	r2, [r2]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8005a5e:	f022 0201 	bic.w	r2, r2, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005a62:	f103 0c08 	add.w	ip, r3, #8
 8005a66:	e84c 2100 	strex	r1, r2, [ip]
 8005a6a:	2900      	cmp	r1, #0
 8005a6c:	d1f3      	bne.n	8005a56 <UART_RxISR_16BIT.part.0+0x16>

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8005a6e:	2220      	movs	r2, #32
 8005a70:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
      /* Clear RxISR function pointer */
      huart->RxISR = NULL;

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005a74:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
      huart->RxISR = NULL;
 8005a76:	6701      	str	r1, [r0, #112]	; 0x70
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005a78:	2a01      	cmp	r2, #1
 8005a7a:	d112      	bne.n	8005aa2 <UART_RxISR_16BIT.part.0+0x62>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005a7c:	66c1      	str	r1, [r0, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005a7e:	e853 2f00 	ldrex	r2, [r3]

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005a82:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005a86:	e843 2100 	strex	r1, r2, [r3]
 8005a8a:	2900      	cmp	r1, #0
 8005a8c:	d1f7      	bne.n	8005a7e <UART_RxISR_16BIT.part.0+0x3e>

        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005a8e:	69da      	ldr	r2, [r3, #28]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005a90:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005a94:	06d2      	lsls	r2, r2, #27
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8005a96:	bf44      	itt	mi
 8005a98:	2210      	movmi	r2, #16
 8005a9a:	621a      	strmi	r2, [r3, #32]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005a9c:	f7ff fe5b 	bl	8005756 <HAL_UARTEx_RxEventCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8005aa0:	bd08      	pop	{r3, pc}
        HAL_UART_RxCpltCallback(huart);
 8005aa2:	f7fb ffd5 	bl	8001a50 <HAL_UART_RxCpltCallback>
}
 8005aa6:	e7fb      	b.n	8005aa0 <UART_RxISR_16BIT.part.0+0x60>

08005aa8 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005aa8:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8005aac:	6802      	ldr	r2, [r0, #0]
 8005aae:	2922      	cmp	r1, #34	; 0x22
 8005ab0:	d113      	bne.n	8005ada <UART_RxISR_16BIT+0x32>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005ab2:	6a51      	ldr	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 8005ab4:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 8005ab8:	4011      	ands	r1, r2
 8005aba:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8005abc:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 8005ac0:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 8005ac2:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 8005ac6:	3a01      	subs	r2, #1
 8005ac8:	b292      	uxth	r2, r2
 8005aca:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 8005ace:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8005ad2:	b29b      	uxth	r3, r3
 8005ad4:	b92b      	cbnz	r3, 8005ae2 <UART_RxISR_16BIT+0x3a>
 8005ad6:	f7ff bfb3 	b.w	8005a40 <UART_RxISR_16BIT.part.0>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005ada:	6993      	ldr	r3, [r2, #24]
 8005adc:	f043 0308 	orr.w	r3, r3, #8
 8005ae0:	6193      	str	r3, [r2, #24]
  }
}
 8005ae2:	4770      	bx	lr

08005ae4 <UART_RxISR_8BIT>:
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005ae4:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
 8005ae8:	6802      	ldr	r2, [r0, #0]
 8005aea:	2922      	cmp	r1, #34	; 0x22
{
 8005aec:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005aee:	d115      	bne.n	8005b1c <UART_RxISR_8BIT+0x38>
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005af0:	6a52      	ldr	r2, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8005af2:	f890 4060 	ldrb.w	r4, [r0, #96]	; 0x60
 8005af6:	6d81      	ldr	r1, [r0, #88]	; 0x58
 8005af8:	4022      	ands	r2, r4
 8005afa:	700a      	strb	r2, [r1, #0]
    huart->pRxBuffPtr++;
 8005afc:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8005afe:	3201      	adds	r2, #1
 8005b00:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 8005b02:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 8005b06:	3a01      	subs	r2, #1
 8005b08:	b292      	uxth	r2, r2
 8005b0a:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
    if (huart->RxXferCount == 0U)
 8005b0e:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 8005b12:	b29b      	uxth	r3, r3
 8005b14:	b933      	cbnz	r3, 8005b24 <UART_RxISR_8BIT+0x40>
}
 8005b16:	bc10      	pop	{r4}
 8005b18:	f7ff bf92 	b.w	8005a40 <UART_RxISR_16BIT.part.0>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005b1c:	6993      	ldr	r3, [r2, #24]
 8005b1e:	f043 0308 	orr.w	r3, r3, #8
 8005b22:	6193      	str	r3, [r2, #24]
}
 8005b24:	bc10      	pop	{r4}
 8005b26:	4770      	bx	lr

08005b28 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8005b28:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8005b2c:	6803      	ldr	r3, [r0, #0]
 8005b2e:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8005b30:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8005b34:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005b36:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8005b3a:	2a22      	cmp	r2, #34	; 0x22
{
 8005b3c:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005b3e:	f040 80a7 	bne.w	8005c90 <UART_RxISR_8BIT_FIFOEN+0x168>
  uint16_t  uhMask = huart->Mask;
 8005b42:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 8005b46:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005b4a:	f8df b154 	ldr.w	fp, [pc, #340]	; 8005ca0 <UART_RxISR_8BIT_FIFOEN+0x178>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005b4e:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005b52:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8005b56:	f1b9 0f00 	cmp.w	r9, #0
 8005b5a:	d001      	beq.n	8005b60 <UART_RxISR_8BIT_FIFOEN+0x38>
 8005b5c:	06ab      	lsls	r3, r5, #26
 8005b5e:	d420      	bmi.n	8005ba2 <UART_RxISR_8BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 8005b60:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8005b64:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8005b66:	b1d3      	cbz	r3, 8005b9e <UART_RxISR_8BIT_FIFOEN+0x76>
 8005b68:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8005b6c:	429a      	cmp	r2, r3
 8005b6e:	d916      	bls.n	8005b9e <UART_RxISR_8BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8005b70:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005b72:	f102 0308 	add.w	r3, r2, #8
 8005b76:	e853 3f00 	ldrex	r3, [r3]
 8005b7a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005b7e:	3208      	adds	r2, #8
 8005b80:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8005b84:	6822      	ldr	r2, [r4, #0]
 8005b86:	2900      	cmp	r1, #0
 8005b88:	d1f2      	bne.n	8005b70 <UART_RxISR_8BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 8005b8a:	4b44      	ldr	r3, [pc, #272]	; (8005c9c <UART_RxISR_8BIT_FIFOEN+0x174>)
 8005b8c:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005b8e:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8005b92:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005b96:	e842 3100 	strex	r1, r3, [r2]
 8005b9a:	2900      	cmp	r1, #0
 8005b9c:	d1f7      	bne.n	8005b8e <UART_RxISR_8BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8005b9e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005ba2:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8005ba4:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005ba6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 8005ba8:	403b      	ands	r3, r7
 8005baa:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 8005bac:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8005bae:	3301      	adds	r3, #1
 8005bb0:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8005bb2:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8005bb6:	3b01      	subs	r3, #1
 8005bb8:	b29b      	uxth	r3, r3
 8005bba:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8005bbe:	6823      	ldr	r3, [r4, #0]
 8005bc0:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8005bc2:	0769      	lsls	r1, r5, #29
 8005bc4:	d02a      	beq.n	8005c1c <UART_RxISR_8BIT_FIFOEN+0xf4>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8005bc6:	07ea      	lsls	r2, r5, #31
 8005bc8:	d50a      	bpl.n	8005be0 <UART_RxISR_8BIT_FIFOEN+0xb8>
 8005bca:	f418 7f80 	tst.w	r8, #256	; 0x100
 8005bce:	d007      	beq.n	8005be0 <UART_RxISR_8BIT_FIFOEN+0xb8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8005bd0:	2201      	movs	r2, #1
 8005bd2:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8005bd4:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8005bd8:	f042 0201 	orr.w	r2, r2, #1
 8005bdc:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005be0:	07a8      	lsls	r0, r5, #30
 8005be2:	d508      	bpl.n	8005bf6 <UART_RxISR_8BIT_FIFOEN+0xce>
 8005be4:	b13e      	cbz	r6, 8005bf6 <UART_RxISR_8BIT_FIFOEN+0xce>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8005be6:	2202      	movs	r2, #2
 8005be8:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8005bea:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8005bee:	f042 0204 	orr.w	r2, r2, #4
 8005bf2:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005bf6:	0769      	lsls	r1, r5, #29
 8005bf8:	d508      	bpl.n	8005c0c <UART_RxISR_8BIT_FIFOEN+0xe4>
 8005bfa:	b13e      	cbz	r6, 8005c0c <UART_RxISR_8BIT_FIFOEN+0xe4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8005bfc:	2204      	movs	r2, #4
 8005bfe:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8005c00:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005c04:	f043 0302 	orr.w	r3, r3, #2
 8005c08:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8005c0c:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005c10:	b123      	cbz	r3, 8005c1c <UART_RxISR_8BIT_FIFOEN+0xf4>
          HAL_UART_ErrorCallback(huart);
 8005c12:	4620      	mov	r0, r4
 8005c14:	f7ff fd6f 	bl	80056f6 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005c18:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8005c1c:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8005c20:	b29b      	uxth	r3, r3
 8005c22:	2b00      	cmp	r3, #0
 8005c24:	d197      	bne.n	8005b56 <UART_RxISR_8BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005c26:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005c28:	e852 3f00 	ldrex	r3, [r2]
 8005c2c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005c30:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8005c34:	6823      	ldr	r3, [r4, #0]
 8005c36:	2900      	cmp	r1, #0
 8005c38:	d1f5      	bne.n	8005c26 <UART_RxISR_8BIT_FIFOEN+0xfe>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005c3a:	f103 0208 	add.w	r2, r3, #8
 8005c3e:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005c42:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005c46:	f103 0008 	add.w	r0, r3, #8
 8005c4a:	e840 2100 	strex	r1, r2, [r0]
 8005c4e:	2900      	cmp	r1, #0
 8005c50:	d1f3      	bne.n	8005c3a <UART_RxISR_8BIT_FIFOEN+0x112>
        huart->RxState = HAL_UART_STATE_READY;
 8005c52:	2220      	movs	r2, #32
 8005c54:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005c58:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 8005c5a:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005c5c:	2a01      	cmp	r2, #1
 8005c5e:	d113      	bne.n	8005c88 <UART_RxISR_8BIT_FIFOEN+0x160>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005c60:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005c62:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005c66:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005c6a:	e843 2100 	strex	r1, r2, [r3]
 8005c6e:	2900      	cmp	r1, #0
 8005c70:	d1f7      	bne.n	8005c62 <UART_RxISR_8BIT_FIFOEN+0x13a>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005c72:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005c74:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005c78:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8005c7a:	bf44      	itt	mi
 8005c7c:	2210      	movmi	r2, #16
 8005c7e:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005c80:	4620      	mov	r0, r4
 8005c82:	f7ff fd68 	bl	8005756 <HAL_UARTEx_RxEventCallback>
 8005c86:	e766      	b.n	8005b56 <UART_RxISR_8BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8005c88:	4620      	mov	r0, r4
 8005c8a:	f7fb fee1 	bl	8001a50 <HAL_UART_RxCpltCallback>
 8005c8e:	e762      	b.n	8005b56 <UART_RxISR_8BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005c90:	699a      	ldr	r2, [r3, #24]
 8005c92:	f042 0208 	orr.w	r2, r2, #8
 8005c96:	619a      	str	r2, [r3, #24]
}
 8005c98:	e781      	b.n	8005b9e <UART_RxISR_8BIT_FIFOEN+0x76>
 8005c9a:	bf00      	nop
 8005c9c:	08005ae5 	.word	0x08005ae5
 8005ca0:	effffffe 	.word	0xeffffffe

08005ca4 <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 8005ca4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 8005ca8:	6803      	ldr	r3, [r0, #0]
 8005caa:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 8005cac:	f8d3 8000 	ldr.w	r8, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 8005cb0:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005cb2:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 8005cb6:	2a22      	cmp	r2, #34	; 0x22
{
 8005cb8:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8005cba:	f040 80a5 	bne.w	8005e08 <UART_RxISR_16BIT_FIFOEN+0x164>
  uint16_t  uhMask = huart->Mask;
 8005cbe:	f8b0 7060 	ldrh.w	r7, [r0, #96]	; 0x60
  {
    nb_rx_data = huart->NbRxDataToProcess;
 8005cc2:	f8b0 9068 	ldrh.w	r9, [r0, #104]	; 0x68
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error)
           and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005cc6:	f8df b150 	ldr.w	fp, [pc, #336]	; 8005e18 <UART_RxISR_16BIT_FIFOEN+0x174>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005cca:	f04f 0a00 	mov.w	sl, #0
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005cce:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 8005cd2:	f1b9 0f00 	cmp.w	r9, #0
 8005cd6:	d001      	beq.n	8005cdc <UART_RxISR_16BIT_FIFOEN+0x38>
 8005cd8:	06ab      	lsls	r3, r5, #26
 8005cda:	d420      	bmi.n	8005d1e <UART_RxISR_16BIT_FIFOEN+0x7a>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 8005cdc:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8005ce0:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 8005ce2:	b1d3      	cbz	r3, 8005d1a <UART_RxISR_16BIT_FIFOEN+0x76>
 8005ce4:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 8005ce8:	429a      	cmp	r2, r3
 8005cea:	d916      	bls.n	8005d1a <UART_RxISR_16BIT_FIFOEN+0x76>
    {
      /* Disable the UART RXFT interrupt*/
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8005cec:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005cee:	f102 0308 	add.w	r3, r2, #8
 8005cf2:	e853 3f00 	ldrex	r3, [r3]
 8005cf6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005cfa:	3208      	adds	r2, #8
 8005cfc:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8005d00:	6822      	ldr	r2, [r4, #0]
 8005d02:	2900      	cmp	r1, #0
 8005d04:	d1f2      	bne.n	8005cec <UART_RxISR_16BIT_FIFOEN+0x48>

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 8005d06:	4b43      	ldr	r3, [pc, #268]	; (8005e14 <UART_RxISR_16BIT_FIFOEN+0x170>)
 8005d08:	6723      	str	r3, [r4, #112]	; 0x70
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005d0a:	e852 3f00 	ldrex	r3, [r2]

      /* Enable the UART Data Register Not Empty interrupt */
      ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8005d0e:	f043 0320 	orr.w	r3, r3, #32
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005d12:	e842 3100 	strex	r1, r3, [r2]
 8005d16:	2900      	cmp	r1, #0
 8005d18:	d1f7      	bne.n	8005d0a <UART_RxISR_16BIT_FIFOEN+0x66>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8005d1a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005d1e:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 8005d20:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8005d22:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 8005d24:	4039      	ands	r1, r7
 8005d26:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 8005d2a:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 8005d2c:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 8005d30:	3a01      	subs	r2, #1
 8005d32:	b292      	uxth	r2, r2
 8005d34:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 8005d38:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 8005d3a:	0769      	lsls	r1, r5, #29
 8005d3c:	d02a      	beq.n	8005d94 <UART_RxISR_16BIT_FIFOEN+0xf0>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8005d3e:	07ea      	lsls	r2, r5, #31
 8005d40:	d50a      	bpl.n	8005d58 <UART_RxISR_16BIT_FIFOEN+0xb4>
 8005d42:	f418 7f80 	tst.w	r8, #256	; 0x100
 8005d46:	d007      	beq.n	8005d58 <UART_RxISR_16BIT_FIFOEN+0xb4>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8005d48:	2201      	movs	r2, #1
 8005d4a:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 8005d4c:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8005d50:	f042 0201 	orr.w	r2, r2, #1
 8005d54:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005d58:	07a8      	lsls	r0, r5, #30
 8005d5a:	d508      	bpl.n	8005d6e <UART_RxISR_16BIT_FIFOEN+0xca>
 8005d5c:	b13e      	cbz	r6, 8005d6e <UART_RxISR_16BIT_FIFOEN+0xca>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 8005d5e:	2202      	movs	r2, #2
 8005d60:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 8005d62:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 8005d66:	f042 0204 	orr.w	r2, r2, #4
 8005d6a:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 8005d6e:	0769      	lsls	r1, r5, #29
 8005d70:	d508      	bpl.n	8005d84 <UART_RxISR_16BIT_FIFOEN+0xe0>
 8005d72:	b13e      	cbz	r6, 8005d84 <UART_RxISR_16BIT_FIFOEN+0xe0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 8005d74:	2204      	movs	r2, #4
 8005d76:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 8005d78:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005d7c:	f043 0302 	orr.w	r3, r3, #2
 8005d80:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8005d84:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8005d88:	b123      	cbz	r3, 8005d94 <UART_RxISR_16BIT_FIFOEN+0xf0>
          HAL_UART_ErrorCallback(huart);
 8005d8a:	4620      	mov	r0, r4
 8005d8c:	f7ff fcb3 	bl	80056f6 <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 8005d90:	f8c4 a08c 	str.w	sl, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 8005d94:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8005d98:	b29b      	uxth	r3, r3
 8005d9a:	2b00      	cmp	r3, #0
 8005d9c:	d199      	bne.n	8005cd2 <UART_RxISR_16BIT_FIFOEN+0x2e>
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8005d9e:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005da0:	e852 3f00 	ldrex	r3, [r2]
 8005da4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005da8:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8005dac:	6823      	ldr	r3, [r4, #0]
 8005dae:	2900      	cmp	r1, #0
 8005db0:	d1f5      	bne.n	8005d9e <UART_RxISR_16BIT_FIFOEN+0xfa>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005db2:	f103 0208 	add.w	r2, r3, #8
 8005db6:	e852 2f00 	ldrex	r2, [r2]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8005dba:	ea02 020b 	and.w	r2, r2, fp
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005dbe:	f103 0008 	add.w	r0, r3, #8
 8005dc2:	e840 2100 	strex	r1, r2, [r0]
 8005dc6:	2900      	cmp	r1, #0
 8005dc8:	d1f3      	bne.n	8005db2 <UART_RxISR_16BIT_FIFOEN+0x10e>
        huart->RxState = HAL_UART_STATE_READY;
 8005dca:	2220      	movs	r2, #32
 8005dcc:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005dd0:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
        huart->RxISR = NULL;
 8005dd2:	6721      	str	r1, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8005dd4:	2a01      	cmp	r2, #1
 8005dd6:	d113      	bne.n	8005e00 <UART_RxISR_16BIT_FIFOEN+0x15c>
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8005dd8:	66e1      	str	r1, [r4, #108]	; 0x6c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8005dda:	e853 2f00 	ldrex	r2, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8005dde:	f022 0210 	bic.w	r2, r2, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8005de2:	e843 2100 	strex	r1, r2, [r3]
 8005de6:	2900      	cmp	r1, #0
 8005de8:	d1f7      	bne.n	8005dda <UART_RxISR_16BIT_FIFOEN+0x136>
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005dea:	69da      	ldr	r2, [r3, #28]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005dec:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE) == SET)
 8005df0:	06d2      	lsls	r2, r2, #27
            __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8005df2:	bf44      	itt	mi
 8005df4:	2210      	movmi	r2, #16
 8005df6:	621a      	strmi	r2, [r3, #32]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8005df8:	4620      	mov	r0, r4
 8005dfa:	f7ff fcac 	bl	8005756 <HAL_UARTEx_RxEventCallback>
 8005dfe:	e768      	b.n	8005cd2 <UART_RxISR_16BIT_FIFOEN+0x2e>
          HAL_UART_RxCpltCallback(huart);
 8005e00:	4620      	mov	r0, r4
 8005e02:	f7fb fe25 	bl	8001a50 <HAL_UART_RxCpltCallback>
 8005e06:	e764      	b.n	8005cd2 <UART_RxISR_16BIT_FIFOEN+0x2e>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8005e08:	699a      	ldr	r2, [r3, #24]
 8005e0a:	f042 0208 	orr.w	r2, r2, #8
 8005e0e:	619a      	str	r2, [r3, #24]
}
 8005e10:	e783      	b.n	8005d1a <UART_RxISR_16BIT_FIFOEN+0x76>
 8005e12:	bf00      	nop
 8005e14:	08005aa9 	.word	0x08005aa9
 8005e18:	effffffe 	.word	0xeffffffe

08005e1c <UART_SetConfig>:
{
 8005e1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005e1e:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 8005e20:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005e22:	6921      	ldr	r1, [r4, #16]
 8005e24:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8005e26:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005e28:	69c0      	ldr	r0, [r0, #28]
 8005e2a:	430a      	orrs	r2, r1
 8005e2c:	6961      	ldr	r1, [r4, #20]
 8005e2e:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8005e30:	497e      	ldr	r1, [pc, #504]	; (800602c <UART_SetConfig+0x210>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8005e32:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8005e34:	4029      	ands	r1, r5
 8005e36:	430a      	orrs	r2, r1
 8005e38:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8005e3a:	685a      	ldr	r2, [r3, #4]
 8005e3c:	68e1      	ldr	r1, [r4, #12]
 8005e3e:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8005e42:	430a      	orrs	r2, r1
 8005e44:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8005e46:	4a7a      	ldr	r2, [pc, #488]	; (8006030 <UART_SetConfig+0x214>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8005e48:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8005e4a:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 8005e4c:	bf1c      	itt	ne
 8005e4e:	6a22      	ldrne	r2, [r4, #32]
 8005e50:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8005e52:	689a      	ldr	r2, [r3, #8]
 8005e54:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 8005e58:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8005e5c:	430a      	orrs	r2, r1
 8005e5e:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8005e60:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005e62:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8005e64:	f022 020f 	bic.w	r2, r2, #15
 8005e68:	430a      	orrs	r2, r1
 8005e6a:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005e6c:	4a71      	ldr	r2, [pc, #452]	; (8006034 <UART_SetConfig+0x218>)
 8005e6e:	4293      	cmp	r3, r2
 8005e70:	d11c      	bne.n	8005eac <UART_SetConfig+0x90>
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16));
 8005e72:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005e76:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005e7a:	f003 0303 	and.w	r3, r3, #3
 8005e7e:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8005e82:	f5a3 3340 	sub.w	r3, r3, #196608	; 0x30000
 8005e86:	3b01      	subs	r3, #1
 8005e88:	2b02      	cmp	r3, #2
 8005e8a:	f200 80c8 	bhi.w	800601e <UART_SetConfig+0x202>
 8005e8e:	4a6a      	ldr	r2, [pc, #424]	; (8006038 <UART_SetConfig+0x21c>)
 8005e90:	5c9b      	ldrb	r3, [r3, r2]
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005e92:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8005e96:	f040 808a 	bne.w	8005fae <UART_SetConfig+0x192>
    switch (clocksource)
 8005e9a:	2b08      	cmp	r3, #8
 8005e9c:	d824      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
 8005e9e:	e8df f003 	tbb	[pc, r3]
 8005ea2:	c161      	.short	0xc161
 8005ea4:	23812384 	.word	0x23812384
 8005ea8:	2323      	.short	0x2323
 8005eaa:	65          	.byte	0x65
 8005eab:	00          	.byte	0x00
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005eac:	4a63      	ldr	r2, [pc, #396]	; (800603c <UART_SetConfig+0x220>)
 8005eae:	4293      	cmp	r3, r2
 8005eb0:	d109      	bne.n	8005ec6 <UART_SetConfig+0xaa>
 8005eb2:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005eb6:	4a62      	ldr	r2, [pc, #392]	; (8006040 <UART_SetConfig+0x224>)
 8005eb8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005ebc:	f003 030c 	and.w	r3, r3, #12
 8005ec0:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8005ec4:	e7e4      	b.n	8005e90 <UART_SetConfig+0x74>
 8005ec6:	4a5a      	ldr	r2, [pc, #360]	; (8006030 <UART_SetConfig+0x214>)
 8005ec8:	4293      	cmp	r3, r2
 8005eca:	d10d      	bne.n	8005ee8 <UART_SetConfig+0xcc>
  return (uint32_t)(READ_BIT(RCC->CCIPR, LPUARTx));
 8005ecc:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8005ed0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005ed4:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 8005ed8:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005edc:	d01a      	beq.n	8005f14 <UART_SetConfig+0xf8>
 8005ede:	d805      	bhi.n	8005eec <UART_SetConfig+0xd0>
 8005ee0:	b153      	cbz	r3, 8005ef8 <UART_SetConfig+0xdc>
 8005ee2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8005ee6:	d012      	beq.n	8005f0e <UART_SetConfig+0xf2>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005ee8:	2001      	movs	r0, #1
 8005eea:	e009      	b.n	8005f00 <UART_SetConfig+0xe4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005eec:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005ef0:	d1fa      	bne.n	8005ee8 <UART_SetConfig+0xcc>
        pclk = (uint32_t) LSE_VALUE;
 8005ef2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8005ef6:	e00e      	b.n	8005f16 <UART_SetConfig+0xfa>
        pclk = HAL_RCC_GetPCLK1Freq();
 8005ef8:	f7fe fd40 	bl	800497c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8005efc:	b958      	cbnz	r0, 8005f16 <UART_SetConfig+0xfa>
 8005efe:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 8005f00:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8005f04:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 8005f06:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8005f08:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 8005f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 8005f0e:	f7fe f91f 	bl	8004150 <HAL_RCC_GetSysClockFreq>
        break;
 8005f12:	e7f3      	b.n	8005efc <UART_SetConfig+0xe0>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8005f14:	484b      	ldr	r0, [pc, #300]	; (8006044 <UART_SetConfig+0x228>)
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005f16:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8005f18:	4b4b      	ldr	r3, [pc, #300]	; (8006048 <UART_SetConfig+0x22c>)
 8005f1a:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005f1c:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8005f20:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
 8005f24:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8005f28:	4299      	cmp	r1, r3
 8005f2a:	d8dd      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
 8005f2c:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 8005f30:	d8da      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005f32:	2300      	movs	r3, #0
 8005f34:	2100      	movs	r1, #0
 8005f36:	f7fa fd3b 	bl	80009b0 <__aeabi_uldivmod>
 8005f3a:	020f      	lsls	r7, r1, #8
 8005f3c:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 8005f40:	0206      	lsls	r6, r0, #8
 8005f42:	0868      	lsrs	r0, r5, #1
 8005f44:	1830      	adds	r0, r6, r0
 8005f46:	462a      	mov	r2, r5
 8005f48:	f04f 0300 	mov.w	r3, #0
 8005f4c:	f147 0100 	adc.w	r1, r7, #0
 8005f50:	f7fa fd2e 	bl	80009b0 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 8005f54:	4b3d      	ldr	r3, [pc, #244]	; (800604c <UART_SetConfig+0x230>)
 8005f56:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8005f5a:	429a      	cmp	r2, r3
 8005f5c:	d8c4      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
        huart->Instance->BRR = usartdiv;
 8005f5e:	6823      	ldr	r3, [r4, #0]
 8005f60:	60d8      	str	r0, [r3, #12]
 8005f62:	e7cc      	b.n	8005efe <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetPCLK1Freq();
 8005f64:	f7fe fd0a 	bl	800497c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8005f68:	2800      	cmp	r0, #0
 8005f6a:	d0c8      	beq.n	8005efe <UART_SetConfig+0xe2>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005f6c:	6862      	ldr	r2, [r4, #4]
 8005f6e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8005f70:	4b35      	ldr	r3, [pc, #212]	; (8006048 <UART_SetConfig+0x22c>)
 8005f72:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8005f76:	fbb0 f3f3 	udiv	r3, r0, r3
 8005f7a:	0850      	lsrs	r0, r2, #1
 8005f7c:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 8005f80:	fbb0 f0f2 	udiv	r0, r0, r2
 8005f84:	b283      	uxth	r3, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8005f86:	f1a3 0110 	sub.w	r1, r3, #16
 8005f8a:	f64f 72ef 	movw	r2, #65519	; 0xffef
 8005f8e:	4291      	cmp	r1, r2
 8005f90:	d8aa      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8005f92:	f020 000f 	bic.w	r0, r0, #15
        huart->Instance->BRR = brrtemp;
 8005f96:	6822      	ldr	r2, [r4, #0]
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8005f98:	b280      	uxth	r0, r0
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8005f9a:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8005f9e:	4318      	orrs	r0, r3
 8005fa0:	60d0      	str	r0, [r2, #12]
 8005fa2:	e7ac      	b.n	8005efe <UART_SetConfig+0xe2>
        pclk = HAL_RCC_GetSysClockFreq();
 8005fa4:	f7fe f8d4 	bl	8004150 <HAL_RCC_GetSysClockFreq>
        break;
 8005fa8:	e7de      	b.n	8005f68 <UART_SetConfig+0x14c>
        pclk = (uint32_t) HSI_VALUE;
 8005faa:	4826      	ldr	r0, [pc, #152]	; (8006044 <UART_SetConfig+0x228>)
 8005fac:	e7de      	b.n	8005f6c <UART_SetConfig+0x150>
    switch (clocksource)
 8005fae:	2b08      	cmp	r3, #8
 8005fb0:	d89a      	bhi.n	8005ee8 <UART_SetConfig+0xcc>
 8005fb2:	a201      	add	r2, pc, #4	; (adr r2, 8005fb8 <UART_SetConfig+0x19c>)
 8005fb4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005fb8:	08006003 	.word	0x08006003
 8005fbc:	0800600f 	.word	0x0800600f
 8005fc0:	0800601b 	.word	0x0800601b
 8005fc4:	08005ee9 	.word	0x08005ee9
 8005fc8:	08006015 	.word	0x08006015
 8005fcc:	08005ee9 	.word	0x08005ee9
 8005fd0:	08005ee9 	.word	0x08005ee9
 8005fd4:	08005ee9 	.word	0x08005ee9
 8005fd8:	08005fdd 	.word	0x08005fdd
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8005fdc:	f44f 4000 	mov.w	r0, #32768	; 0x8000
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8005fe0:	6863      	ldr	r3, [r4, #4]
 8005fe2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8005fe4:	4a18      	ldr	r2, [pc, #96]	; (8006048 <UART_SetConfig+0x22c>)
 8005fe6:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 8005fea:	fbb0 f0f2 	udiv	r0, r0, r2
 8005fee:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8005ff2:	fbb0 f0f3 	udiv	r0, r0, r3
 8005ff6:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8005ff8:	f1a0 0210 	sub.w	r2, r0, #16
 8005ffc:	f64f 73ef 	movw	r3, #65519	; 0xffef
 8006000:	e7ab      	b.n	8005f5a <UART_SetConfig+0x13e>
        pclk = HAL_RCC_GetPCLK1Freq();
 8006002:	f7fe fcbb 	bl	800497c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8006006:	2800      	cmp	r0, #0
 8006008:	f43f af79 	beq.w	8005efe <UART_SetConfig+0xe2>
 800600c:	e7e8      	b.n	8005fe0 <UART_SetConfig+0x1c4>
        pclk = HAL_RCC_GetPCLK2Freq();
 800600e:	f7fe fcc5 	bl	800499c <HAL_RCC_GetPCLK2Freq>
        break;
 8006012:	e7f8      	b.n	8006006 <UART_SetConfig+0x1ea>
        pclk = HAL_RCC_GetSysClockFreq();
 8006014:	f7fe f89c 	bl	8004150 <HAL_RCC_GetSysClockFreq>
        break;
 8006018:	e7f5      	b.n	8006006 <UART_SetConfig+0x1ea>
        pclk = (uint32_t) HSI_VALUE;
 800601a:	480a      	ldr	r0, [pc, #40]	; (8006044 <UART_SetConfig+0x228>)
 800601c:	e7e0      	b.n	8005fe0 <UART_SetConfig+0x1c4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800601e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 8006022:	d1f4      	bne.n	800600e <UART_SetConfig+0x1f2>
        pclk = HAL_RCC_GetPCLK2Freq();
 8006024:	f7fe fcba 	bl	800499c <HAL_RCC_GetPCLK2Freq>
        break;
 8006028:	e79e      	b.n	8005f68 <UART_SetConfig+0x14c>
 800602a:	bf00      	nop
 800602c:	cfff69f3 	.word	0xcfff69f3
 8006030:	40008000 	.word	0x40008000
 8006034:	40013800 	.word	0x40013800
 8006038:	08010890 	.word	0x08010890
 800603c:	40004400 	.word	0x40004400
 8006040:	07f50893 	.word	0x07f50893
 8006044:	00f42400 	.word	0x00f42400
 8006048:	080108a0 	.word	0x080108a0
 800604c:	000ffcff 	.word	0x000ffcff

08006050 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006050:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8006052:	07da      	lsls	r2, r3, #31
{
 8006054:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8006056:	d506      	bpl.n	8006066 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8006058:	6801      	ldr	r1, [r0, #0]
 800605a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800605c:	684a      	ldr	r2, [r1, #4]
 800605e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8006062:	4322      	orrs	r2, r4
 8006064:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8006066:	079c      	lsls	r4, r3, #30
 8006068:	d506      	bpl.n	8006078 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800606a:	6801      	ldr	r1, [r0, #0]
 800606c:	6b04      	ldr	r4, [r0, #48]	; 0x30
 800606e:	684a      	ldr	r2, [r1, #4]
 8006070:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006074:	4322      	orrs	r2, r4
 8006076:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8006078:	0759      	lsls	r1, r3, #29
 800607a:	d506      	bpl.n	800608a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800607c:	6801      	ldr	r1, [r0, #0]
 800607e:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8006080:	684a      	ldr	r2, [r1, #4]
 8006082:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006086:	4322      	orrs	r2, r4
 8006088:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800608a:	071a      	lsls	r2, r3, #28
 800608c:	d506      	bpl.n	800609c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800608e:	6801      	ldr	r1, [r0, #0]
 8006090:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8006092:	684a      	ldr	r2, [r1, #4]
 8006094:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8006098:	4322      	orrs	r2, r4
 800609a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800609c:	06dc      	lsls	r4, r3, #27
 800609e:	d506      	bpl.n	80060ae <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80060a0:	6801      	ldr	r1, [r0, #0]
 80060a2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80060a4:	688a      	ldr	r2, [r1, #8]
 80060a6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80060aa:	4322      	orrs	r2, r4
 80060ac:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80060ae:	0699      	lsls	r1, r3, #26
 80060b0:	d506      	bpl.n	80060c0 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80060b2:	6801      	ldr	r1, [r0, #0]
 80060b4:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80060b6:	688a      	ldr	r2, [r1, #8]
 80060b8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80060bc:	4322      	orrs	r2, r4
 80060be:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80060c0:	065a      	lsls	r2, r3, #25
 80060c2:	d50f      	bpl.n	80060e4 <UART_AdvFeatureConfig+0x94>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80060c4:	6801      	ldr	r1, [r0, #0]
 80060c6:	6c44      	ldr	r4, [r0, #68]	; 0x44
 80060c8:	684a      	ldr	r2, [r1, #4]
 80060ca:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 80060ce:	4322      	orrs	r2, r4
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80060d0:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80060d4:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80060d6:	d105      	bne.n	80060e4 <UART_AdvFeatureConfig+0x94>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80060d8:	684a      	ldr	r2, [r1, #4]
 80060da:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80060dc:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80060e0:	4322      	orrs	r2, r4
 80060e2:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80060e4:	061b      	lsls	r3, r3, #24
 80060e6:	d506      	bpl.n	80060f6 <UART_AdvFeatureConfig+0xa6>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80060e8:	6802      	ldr	r2, [r0, #0]
 80060ea:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80060ec:	6853      	ldr	r3, [r2, #4]
 80060ee:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80060f2:	430b      	orrs	r3, r1
 80060f4:	6053      	str	r3, [r2, #4]
}
 80060f6:	bd10      	pop	{r4, pc}

080060f8 <UART_WaitOnFlagUntilTimeout>:
{
 80060f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80060fc:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8006100:	4604      	mov	r4, r0
 8006102:	460e      	mov	r6, r1
 8006104:	4615      	mov	r5, r2
 8006106:	461f      	mov	r7, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8006108:	6822      	ldr	r2, [r4, #0]
 800610a:	69d3      	ldr	r3, [r2, #28]
 800610c:	ea36 0303 	bics.w	r3, r6, r3
 8006110:	bf0c      	ite	eq
 8006112:	2301      	moveq	r3, #1
 8006114:	2300      	movne	r3, #0
 8006116:	42ab      	cmp	r3, r5
 8006118:	d001      	beq.n	800611e <UART_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 800611a:	2000      	movs	r0, #0
 800611c:	e027      	b.n	800616e <UART_WaitOnFlagUntilTimeout+0x76>
    if (Timeout != HAL_MAX_DELAY)
 800611e:	f1b8 3fff 	cmp.w	r8, #4294967295
 8006122:	d0f2      	beq.n	800610a <UART_WaitOnFlagUntilTimeout+0x12>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006124:	f7fb f9d6 	bl	80014d4 <HAL_GetTick>
 8006128:	1bc0      	subs	r0, r0, r7
 800612a:	4540      	cmp	r0, r8
 800612c:	6820      	ldr	r0, [r4, #0]
 800612e:	d802      	bhi.n	8006136 <UART_WaitOnFlagUntilTimeout+0x3e>
 8006130:	f1b8 0f00 	cmp.w	r8, #0
 8006134:	d11d      	bne.n	8006172 <UART_WaitOnFlagUntilTimeout+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006136:	e850 3f00 	ldrex	r3, [r0]
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 800613a:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800613e:	e840 3200 	strex	r2, r3, [r0]
 8006142:	2a00      	cmp	r2, #0
 8006144:	d1f7      	bne.n	8006136 <UART_WaitOnFlagUntilTimeout+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006146:	f100 0308 	add.w	r3, r0, #8
 800614a:	e853 3f00 	ldrex	r3, [r3]
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800614e:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006152:	f100 0108 	add.w	r1, r0, #8
 8006156:	e841 3200 	strex	r2, r3, [r1]
 800615a:	2a00      	cmp	r2, #0
 800615c:	d1f3      	bne.n	8006146 <UART_WaitOnFlagUntilTimeout+0x4e>
        huart->gState = HAL_UART_STATE_READY;
 800615e:	2320      	movs	r3, #32
 8006160:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 8006164:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 8006168:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
          return HAL_TIMEOUT;
 800616c:	2003      	movs	r0, #3
}
 800616e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8006172:	6803      	ldr	r3, [r0, #0]
 8006174:	075a      	lsls	r2, r3, #29
 8006176:	d5c7      	bpl.n	8006108 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8006178:	69c3      	ldr	r3, [r0, #28]
 800617a:	051b      	lsls	r3, r3, #20
 800617c:	d5c4      	bpl.n	8006108 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800617e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8006182:	6203      	str	r3, [r0, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006184:	e850 3f00 	ldrex	r3, [r0]
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8006188:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800618c:	e840 3200 	strex	r2, r3, [r0]
 8006190:	2a00      	cmp	r2, #0
 8006192:	d1f7      	bne.n	8006184 <UART_WaitOnFlagUntilTimeout+0x8c>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8006194:	f100 0308 	add.w	r3, r0, #8
 8006198:	e853 3f00 	ldrex	r3, [r3]
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800619c:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80061a0:	f100 0108 	add.w	r1, r0, #8
 80061a4:	e841 3200 	strex	r2, r3, [r1]
 80061a8:	2a00      	cmp	r2, #0
 80061aa:	d1f3      	bne.n	8006194 <UART_WaitOnFlagUntilTimeout+0x9c>
          huart->gState = HAL_UART_STATE_READY;
 80061ac:	2320      	movs	r3, #32
 80061ae:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 80061b2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 80061b6:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 80061ba:	e7d5      	b.n	8006168 <UART_WaitOnFlagUntilTimeout+0x70>

080061bc <UART_CheckIdleState>:
{
 80061bc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80061be:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80061c0:	2600      	movs	r6, #0
 80061c2:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 80061c6:	f7fb f985 	bl	80014d4 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80061ca:	6823      	ldr	r3, [r4, #0]
 80061cc:	681b      	ldr	r3, [r3, #0]
 80061ce:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 80061d0:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 80061d2:	d418      	bmi.n	8006206 <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 80061d4:	6823      	ldr	r3, [r4, #0]
 80061d6:	681b      	ldr	r3, [r3, #0]
 80061d8:	075b      	lsls	r3, r3, #29
 80061da:	d50a      	bpl.n	80061f2 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 80061dc:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 80061e0:	9300      	str	r3, [sp, #0]
 80061e2:	2200      	movs	r2, #0
 80061e4:	462b      	mov	r3, r5
 80061e6:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 80061ea:	4620      	mov	r0, r4
 80061ec:	f7ff ff84 	bl	80060f8 <UART_WaitOnFlagUntilTimeout>
 80061f0:	b9a8      	cbnz	r0, 800621e <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 80061f2:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80061f4:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 80061f6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80061fa:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 80061fe:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8006202:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 8006204:	e00c      	b.n	8006220 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006206:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800620a:	9300      	str	r3, [sp, #0]
 800620c:	4632      	mov	r2, r6
 800620e:	4603      	mov	r3, r0
 8006210:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8006214:	4620      	mov	r0, r4
 8006216:	f7ff ff6f 	bl	80060f8 <UART_WaitOnFlagUntilTimeout>
 800621a:	2800      	cmp	r0, #0
 800621c:	d0da      	beq.n	80061d4 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 800621e:	2003      	movs	r0, #3
}
 8006220:	b002      	add	sp, #8
 8006222:	bd70      	pop	{r4, r5, r6, pc}

08006224 <HAL_UART_Init>:
{
 8006224:	b510      	push	{r4, lr}
  if (huart == NULL)
 8006226:	4604      	mov	r4, r0
 8006228:	b350      	cbz	r0, 8006280 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 800622a:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 800622e:	b91b      	cbnz	r3, 8006238 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 8006230:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 8006234:	f7fb fb0a 	bl	800184c <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8006238:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 800623a:	2324      	movs	r3, #36	; 0x24
 800623c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8006240:	6813      	ldr	r3, [r2, #0]
 8006242:	f023 0301 	bic.w	r3, r3, #1
 8006246:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8006248:	4620      	mov	r0, r4
 800624a:	f7ff fde7 	bl	8005e1c <UART_SetConfig>
 800624e:	2801      	cmp	r0, #1
 8006250:	d016      	beq.n	8006280 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8006252:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006254:	b113      	cbz	r3, 800625c <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 8006256:	4620      	mov	r0, r4
 8006258:	f7ff fefa 	bl	8006050 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800625c:	6823      	ldr	r3, [r4, #0]
 800625e:	685a      	ldr	r2, [r3, #4]
 8006260:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8006264:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8006266:	689a      	ldr	r2, [r3, #8]
 8006268:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 800626c:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 800626e:	681a      	ldr	r2, [r3, #0]
 8006270:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8006274:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8006276:	601a      	str	r2, [r3, #0]
}
 8006278:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 800627c:	f7ff bf9e 	b.w	80061bc <UART_CheckIdleState>
}
 8006280:	2001      	movs	r0, #1
 8006282:	bd10      	pop	{r4, pc}

08006284 <UART_Start_Receive_IT>:
  UART_MASK_COMPUTATION(huart);
 8006284:	6883      	ldr	r3, [r0, #8]
{
 8006286:	b510      	push	{r4, lr}
  UART_MASK_COMPUTATION(huart);
 8006288:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  huart->pRxBuffPtr  = pData;
 800628c:	6581      	str	r1, [r0, #88]	; 0x58
  huart->RxISR       = NULL;
 800628e:	f04f 0100 	mov.w	r1, #0
  huart->RxXferSize  = Size;
 8006292:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  huart->RxXferCount = Size;
 8006296:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 800629a:	6701      	str	r1, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 800629c:	d147      	bne.n	800632e <UART_Start_Receive_IT+0xaa>
 800629e:	6903      	ldr	r3, [r0, #16]
 80062a0:	2b00      	cmp	r3, #0
 80062a2:	d142      	bne.n	800632a <UART_Start_Receive_IT+0xa6>
 80062a4:	f240 13ff 	movw	r3, #511	; 0x1ff
 80062a8:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80062ac:	2300      	movs	r3, #0
 80062ae:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 80062b2:	2322      	movs	r3, #34	; 0x22
 80062b4:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80062b8:	6801      	ldr	r1, [r0, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80062ba:	f101 0308 	add.w	r3, r1, #8
 80062be:	e853 3f00 	ldrex	r3, [r3]
 80062c2:	f043 0301 	orr.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80062c6:	3108      	adds	r1, #8
 80062c8:	e841 3400 	strex	r4, r3, [r1]
   return(result);
 80062cc:	6803      	ldr	r3, [r0, #0]
 80062ce:	2c00      	cmp	r4, #0
 80062d0:	d1f2      	bne.n	80062b8 <UART_Start_Receive_IT+0x34>
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 80062d2:	6e44      	ldr	r4, [r0, #100]	; 0x64
 80062d4:	6881      	ldr	r1, [r0, #8]
 80062d6:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 80062da:	d13b      	bne.n	8006354 <UART_Start_Receive_IT+0xd0>
 80062dc:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 80062e0:	4294      	cmp	r4, r2
 80062e2:	d837      	bhi.n	8006354 <UART_Start_Receive_IT+0xd0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80062e4:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80062e8:	d132      	bne.n	8006350 <UART_Start_Receive_IT+0xcc>
 80062ea:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 80062ec:	4a25      	ldr	r2, [pc, #148]	; (8006384 <UART_Start_Receive_IT+0x100>)
 80062ee:	4926      	ldr	r1, [pc, #152]	; (8006388 <UART_Start_Receive_IT+0x104>)
 80062f0:	2c00      	cmp	r4, #0
 80062f2:	bf08      	it	eq
 80062f4:	460a      	moveq	r2, r1
 80062f6:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 80062f8:	2200      	movs	r2, #0
 80062fa:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80062fe:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8006302:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006306:	e843 2100 	strex	r1, r2, [r3]
 800630a:	2900      	cmp	r1, #0
 800630c:	d1f7      	bne.n	80062fe <UART_Start_Receive_IT+0x7a>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800630e:	f103 0208 	add.w	r2, r3, #8
 8006312:	e852 2f00 	ldrex	r2, [r2]
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 8006316:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800631a:	f103 0008 	add.w	r0, r3, #8
 800631e:	e840 2100 	strex	r1, r2, [r0]
 8006322:	2900      	cmp	r1, #0
 8006324:	d1f3      	bne.n	800630e <UART_Start_Receive_IT+0x8a>
}
 8006326:	2000      	movs	r0, #0
 8006328:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 800632a:	23ff      	movs	r3, #255	; 0xff
 800632c:	e7bc      	b.n	80062a8 <UART_Start_Receive_IT+0x24>
 800632e:	b923      	cbnz	r3, 800633a <UART_Start_Receive_IT+0xb6>
 8006330:	6903      	ldr	r3, [r0, #16]
 8006332:	2b00      	cmp	r3, #0
 8006334:	d0f9      	beq.n	800632a <UART_Start_Receive_IT+0xa6>
 8006336:	237f      	movs	r3, #127	; 0x7f
 8006338:	e7b6      	b.n	80062a8 <UART_Start_Receive_IT+0x24>
 800633a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800633e:	d104      	bne.n	800634a <UART_Start_Receive_IT+0xc6>
 8006340:	6903      	ldr	r3, [r0, #16]
 8006342:	2b00      	cmp	r3, #0
 8006344:	d0f7      	beq.n	8006336 <UART_Start_Receive_IT+0xb2>
 8006346:	233f      	movs	r3, #63	; 0x3f
 8006348:	e7ae      	b.n	80062a8 <UART_Start_Receive_IT+0x24>
 800634a:	f8a0 1060 	strh.w	r1, [r0, #96]	; 0x60
 800634e:	e7ad      	b.n	80062ac <UART_Start_Receive_IT+0x28>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 8006350:	4a0c      	ldr	r2, [pc, #48]	; (8006384 <UART_Start_Receive_IT+0x100>)
 8006352:	e7d0      	b.n	80062f6 <UART_Start_Receive_IT+0x72>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8006354:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 8006358:	d112      	bne.n	8006380 <UART_Start_Receive_IT+0xfc>
 800635a:	6904      	ldr	r4, [r0, #16]
      huart->RxISR = UART_RxISR_16BIT;
 800635c:	4a0b      	ldr	r2, [pc, #44]	; (800638c <UART_Start_Receive_IT+0x108>)
 800635e:	490c      	ldr	r1, [pc, #48]	; (8006390 <UART_Start_Receive_IT+0x10c>)
 8006360:	2c00      	cmp	r4, #0
 8006362:	bf08      	it	eq
 8006364:	460a      	moveq	r2, r1
 8006366:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 8006368:	2200      	movs	r2, #0
 800636a:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800636e:	e853 2f00 	ldrex	r2, [r3]
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 8006372:	f442 7290 	orr.w	r2, r2, #288	; 0x120
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8006376:	e843 2100 	strex	r1, r2, [r3]
 800637a:	2900      	cmp	r1, #0
 800637c:	d1f7      	bne.n	800636e <UART_Start_Receive_IT+0xea>
 800637e:	e7d2      	b.n	8006326 <UART_Start_Receive_IT+0xa2>
      huart->RxISR = UART_RxISR_8BIT;
 8006380:	4a02      	ldr	r2, [pc, #8]	; (800638c <UART_Start_Receive_IT+0x108>)
 8006382:	e7f0      	b.n	8006366 <UART_Start_Receive_IT+0xe2>
 8006384:	08005b29 	.word	0x08005b29
 8006388:	08005ca5 	.word	0x08005ca5
 800638c:	08005ae5 	.word	0x08005ae5
 8006390:	08005aa9 	.word	0x08005aa9

08006394 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 8006394:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
 8006398:	2b20      	cmp	r3, #32
{
 800639a:	b430      	push	{r4, r5}
  if (huart->RxState == HAL_UART_STATE_READY)
 800639c:	d11f      	bne.n	80063de <HAL_UART_Receive_IT+0x4a>
    if ((pData == NULL) || (Size == 0U))
 800639e:	b1d9      	cbz	r1, 80063d8 <HAL_UART_Receive_IT+0x44>
 80063a0:	b1d2      	cbz	r2, 80063d8 <HAL_UART_Receive_IT+0x44>
    __HAL_LOCK(huart);
 80063a2:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 80063a6:	2b01      	cmp	r3, #1
 80063a8:	d019      	beq.n	80063de <HAL_UART_Receive_IT+0x4a>
 80063aa:	2301      	movs	r3, #1
 80063ac:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80063b0:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 80063b2:	6804      	ldr	r4, [r0, #0]
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80063b4:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 80063b6:	4b0b      	ldr	r3, [pc, #44]	; (80063e4 <HAL_UART_Receive_IT+0x50>)
 80063b8:	429c      	cmp	r4, r3
 80063ba:	d00a      	beq.n	80063d2 <HAL_UART_Receive_IT+0x3e>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 80063bc:	6863      	ldr	r3, [r4, #4]
 80063be:	021b      	lsls	r3, r3, #8
 80063c0:	d507      	bpl.n	80063d2 <HAL_UART_Receive_IT+0x3e>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80063c2:	e854 3f00 	ldrex	r3, [r4]
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 80063c6:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80063ca:	e844 3500 	strex	r5, r3, [r4]
 80063ce:	2d00      	cmp	r5, #0
 80063d0:	d1f7      	bne.n	80063c2 <HAL_UART_Receive_IT+0x2e>
}
 80063d2:	bc30      	pop	{r4, r5}
    return(UART_Start_Receive_IT(huart, pData, Size));
 80063d4:	f7ff bf56 	b.w	8006284 <UART_Start_Receive_IT>
      return HAL_ERROR;
 80063d8:	2001      	movs	r0, #1
}
 80063da:	bc30      	pop	{r4, r5}
 80063dc:	4770      	bx	lr
    return HAL_BUSY;
 80063de:	2002      	movs	r0, #2
 80063e0:	e7fb      	b.n	80063da <HAL_UART_Receive_IT+0x46>
 80063e2:	bf00      	nop
 80063e4:	40008000 	.word	0x40008000

080063e8 <UARTEx_SetNbDataToProcess>:
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80063e8:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
 80063ea:	b530      	push	{r4, r5, lr}
  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 80063ec:	b91b      	cbnz	r3, 80063f6 <UARTEx_SetNbDataToProcess+0xe>
  {
    huart->NbTxDataToProcess = 1U;
    huart->NbRxDataToProcess = 1U;
 80063ee:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 80063f2:	6683      	str	r3, [r0, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 80063f4:	bd30      	pop	{r4, r5, pc}
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80063f6:	6803      	ldr	r3, [r0, #0]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 80063f8:	4d0a      	ldr	r5, [pc, #40]	; (8006424 <UARTEx_SetNbDataToProcess+0x3c>)
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 80063fa:	689a      	ldr	r2, [r3, #8]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 80063fc:	6899      	ldr	r1, [r3, #8]
                               (uint16_t)denominator[tx_fifo_threshold];
 80063fe:	4c0a      	ldr	r4, [pc, #40]	; (8006428 <UARTEx_SetNbDataToProcess+0x40>)
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 8006400:	0f49      	lsrs	r1, r1, #29
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006402:	f3c2 6242 	ubfx	r2, r2, #25, #3
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 8006406:	5c6b      	ldrb	r3, [r5, r1]
                               (uint16_t)denominator[tx_fifo_threshold];
 8006408:	5c61      	ldrb	r1, [r4, r1]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800640a:	00db      	lsls	r3, r3, #3
 800640c:	fbb3 f3f1 	udiv	r3, r3, r1
 8006410:	f8a0 306a 	strh.w	r3, [r0, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006414:	5cab      	ldrb	r3, [r5, r2]
                               (uint16_t)denominator[rx_fifo_threshold];
 8006416:	5ca2      	ldrb	r2, [r4, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 8006418:	00db      	lsls	r3, r3, #3
 800641a:	fbb3 f3f2 	udiv	r3, r3, r2
 800641e:	f8a0 3068 	strh.w	r3, [r0, #104]	; 0x68
}
 8006422:	e7e7      	b.n	80063f4 <UARTEx_SetNbDataToProcess+0xc>
 8006424:	080108c0 	.word	0x080108c0
 8006428:	080108b8 	.word	0x080108b8

0800642c <HAL_UARTEx_WakeupCallback>:
}
 800642c:	4770      	bx	lr

0800642e <HAL_UARTEx_RxFifoFullCallback>:
 800642e:	4770      	bx	lr

08006430 <HAL_UARTEx_TxFifoEmptyCallback>:
 8006430:	4770      	bx	lr

08006432 <HAL_UARTEx_StopModeWakeUpSourceConfig>:
{
 8006432:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8006434:	ab04      	add	r3, sp, #16
 8006436:	e903 0006 	stmdb	r3, {r1, r2}
  __HAL_LOCK(huart);
 800643a:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 800643e:	9902      	ldr	r1, [sp, #8]
 8006440:	2b01      	cmp	r3, #1
{
 8006442:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8006444:	d03a      	beq.n	80064bc <HAL_UARTEx_StopModeWakeUpSourceConfig+0x8a>
 8006446:	2301      	movs	r3, #1
 8006448:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 800644c:	2324      	movs	r3, #36	; 0x24
 800644e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 8006452:	6803      	ldr	r3, [r0, #0]
 8006454:	681a      	ldr	r2, [r3, #0]
 8006456:	f022 0201 	bic.w	r2, r2, #1
 800645a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_WUS, WakeUpSelection.WakeUpEvent);
 800645c:	689a      	ldr	r2, [r3, #8]
 800645e:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8006462:	430a      	orrs	r2, r1
 8006464:	609a      	str	r2, [r3, #8]
  if (WakeUpSelection.WakeUpEvent == UART_WAKEUP_ON_ADDRESS)
 8006466:	b971      	cbnz	r1, 8006486 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x54>
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8006468:	6859      	ldr	r1, [r3, #4]
 800646a:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    UARTEx_Wakeup_AddressConfig(huart, WakeUpSelection);
 800646e:	f89d 000e 	ldrb.w	r0, [sp, #14]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADDM7, WakeUpSelection.AddressLength);
 8006472:	f021 0110 	bic.w	r1, r1, #16
 8006476:	4311      	orrs	r1, r2
 8006478:	6059      	str	r1, [r3, #4]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, ((uint32_t)WakeUpSelection.Address << UART_CR2_ADDRESS_LSB_POS));
 800647a:	685a      	ldr	r2, [r3, #4]
 800647c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8006480:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 8006484:	605a      	str	r2, [r3, #4]
  __HAL_UART_ENABLE(huart);
 8006486:	681a      	ldr	r2, [r3, #0]
 8006488:	f042 0201 	orr.w	r2, r2, #1
 800648c:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 800648e:	f7fb f821 	bl	80014d4 <HAL_GetTick>
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006492:	f06f 427e 	mvn.w	r2, #4261412864	; 0xfe000000
  tickstart = HAL_GetTick();
 8006496:	4603      	mov	r3, r0
  if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8006498:	9200      	str	r2, [sp, #0]
 800649a:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800649e:	2200      	movs	r2, #0
 80064a0:	4620      	mov	r0, r4
 80064a2:	f7ff fe29 	bl	80060f8 <UART_WaitOnFlagUntilTimeout>
 80064a6:	b938      	cbnz	r0, 80064b8 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x86>
    huart->gState = HAL_UART_STATE_READY;
 80064a8:	2320      	movs	r3, #32
 80064aa:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80064ae:	2300      	movs	r3, #0
 80064b0:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 80064b4:	b004      	add	sp, #16
 80064b6:	bd10      	pop	{r4, pc}
    status = HAL_TIMEOUT;
 80064b8:	2003      	movs	r0, #3
 80064ba:	e7f8      	b.n	80064ae <HAL_UARTEx_StopModeWakeUpSourceConfig+0x7c>
  __HAL_LOCK(huart);
 80064bc:	2002      	movs	r0, #2
 80064be:	e7f9      	b.n	80064b4 <HAL_UARTEx_StopModeWakeUpSourceConfig+0x82>

080064c0 <HAL_UARTEx_EnableStopMode>:
  __HAL_LOCK(huart);
 80064c0:	f890 2080 	ldrb.w	r2, [r0, #128]	; 0x80
 80064c4:	2a01      	cmp	r2, #1
{
 80064c6:	4603      	mov	r3, r0
  __HAL_LOCK(huart);
 80064c8:	d00e      	beq.n	80064e8 <HAL_UARTEx_EnableStopMode+0x28>
 80064ca:	2201      	movs	r2, #1
 80064cc:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
  ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_UESM);
 80064d0:	6819      	ldr	r1, [r3, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80064d2:	e851 2f00 	ldrex	r2, [r1]
 80064d6:	f042 0202 	orr.w	r2, r2, #2
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80064da:	e841 2000 	strex	r0, r2, [r1]
 80064de:	2800      	cmp	r0, #0
 80064e0:	d1f6      	bne.n	80064d0 <HAL_UARTEx_EnableStopMode+0x10>
  __HAL_UNLOCK(huart);
 80064e2:	f883 0080 	strb.w	r0, [r3, #128]	; 0x80
  return HAL_OK;
 80064e6:	4770      	bx	lr
  __HAL_LOCK(huart);
 80064e8:	2002      	movs	r0, #2
}
 80064ea:	4770      	bx	lr

080064ec <HAL_UARTEx_EnableFifoMode>:
{
 80064ec:	b510      	push	{r4, lr}
  __HAL_LOCK(huart);
 80064ee:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 80064f2:	2b01      	cmp	r3, #1
{
 80064f4:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 80064f6:	d01a      	beq.n	800652e <HAL_UARTEx_EnableFifoMode+0x42>
 80064f8:	2301      	movs	r3, #1
 80064fa:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 80064fe:	2324      	movs	r3, #36	; 0x24
 8006500:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006504:	6803      	ldr	r3, [r0, #0]
 8006506:	681a      	ldr	r2, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8006508:	6819      	ldr	r1, [r3, #0]
 800650a:	f021 0101 	bic.w	r1, r1, #1
 800650e:	6019      	str	r1, [r3, #0]
  SET_BIT(tmpcr1, USART_CR1_FIFOEN);
 8006510:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  huart->FifoMode = UART_FIFOMODE_ENABLE;
 8006514:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
 8006518:	6641      	str	r1, [r0, #100]	; 0x64
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800651a:	601a      	str	r2, [r3, #0]
  UARTEx_SetNbDataToProcess(huart);
 800651c:	f7ff ff64 	bl	80063e8 <UARTEx_SetNbDataToProcess>
  huart->gState = HAL_UART_STATE_READY;
 8006520:	2320      	movs	r3, #32
 8006522:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 8006526:	2000      	movs	r0, #0
 8006528:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 800652c:	bd10      	pop	{r4, pc}
  __HAL_LOCK(huart);
 800652e:	2002      	movs	r0, #2
 8006530:	e7fc      	b.n	800652c <HAL_UARTEx_EnableFifoMode+0x40>

08006532 <HAL_UARTEx_SetTxFifoThreshold>:
{
 8006532:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 8006534:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8006538:	2b01      	cmp	r3, #1
{
 800653a:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 800653c:	d01b      	beq.n	8006576 <HAL_UARTEx_SetTxFifoThreshold+0x44>
 800653e:	2301      	movs	r3, #1
 8006540:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 8006544:	2324      	movs	r3, #36	; 0x24
 8006546:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800654a:	6803      	ldr	r3, [r0, #0]
 800654c:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 800654e:	681a      	ldr	r2, [r3, #0]
 8006550:	f022 0201 	bic.w	r2, r2, #1
 8006554:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 8006556:	689a      	ldr	r2, [r3, #8]
 8006558:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 800655c:	4311      	orrs	r1, r2
 800655e:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 8006560:	f7ff ff42 	bl	80063e8 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 8006564:	6803      	ldr	r3, [r0, #0]
 8006566:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 8006568:	2320      	movs	r3, #32
 800656a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 800656e:	2000      	movs	r0, #0
 8006570:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 8006574:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 8006576:	2002      	movs	r0, #2
 8006578:	e7fc      	b.n	8006574 <HAL_UARTEx_SetTxFifoThreshold+0x42>

0800657a <HAL_UARTEx_SetRxFifoThreshold>:
{
 800657a:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(huart);
 800657c:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 8006580:	2b01      	cmp	r3, #1
{
 8006582:	4604      	mov	r4, r0
  __HAL_LOCK(huart);
 8006584:	d01b      	beq.n	80065be <HAL_UARTEx_SetRxFifoThreshold+0x44>
 8006586:	2301      	movs	r3, #1
 8006588:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
  huart->gState = HAL_UART_STATE_BUSY;
 800658c:	2324      	movs	r3, #36	; 0x24
 800658e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  tmpcr1 = READ_REG(huart->Instance->CR1);
 8006592:	6803      	ldr	r3, [r0, #0]
 8006594:	681d      	ldr	r5, [r3, #0]
  __HAL_UART_DISABLE(huart);
 8006596:	681a      	ldr	r2, [r3, #0]
 8006598:	f022 0201 	bic.w	r2, r2, #1
 800659c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800659e:	689a      	ldr	r2, [r3, #8]
 80065a0:	f022 6260 	bic.w	r2, r2, #234881024	; 0xe000000
 80065a4:	4311      	orrs	r1, r2
 80065a6:	6099      	str	r1, [r3, #8]
  UARTEx_SetNbDataToProcess(huart);
 80065a8:	f7ff ff1e 	bl	80063e8 <UARTEx_SetNbDataToProcess>
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 80065ac:	6803      	ldr	r3, [r0, #0]
 80065ae:	601d      	str	r5, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 80065b0:	2320      	movs	r3, #32
 80065b2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  __HAL_UNLOCK(huart);
 80065b6:	2000      	movs	r0, #0
 80065b8:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
}
 80065bc:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(huart);
 80065be:	2002      	movs	r0, #2
 80065c0:	e7fc      	b.n	80065bc <HAL_UARTEx_SetRxFifoThreshold+0x42>

080065c2 <LmHandlerDeviceTimeReq>:
        return LORAMAC_HANDLER_ERROR;
    }
}

LmHandlerErrorStatus_t LmHandlerDeviceTimeReq( void )
{
 80065c2:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_DEVICE_TIME;
 80065c4:	230a      	movs	r3, #10

    status = LoRaMacMlmeRequest( &mlmeReq );
 80065c6:	a801      	add	r0, sp, #4
    mlmeReq.Type = MLME_DEVICE_TIME;
 80065c8:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMlmeRequest( &mlmeReq );
 80065cc:	f002 feac 	bl	8009328 <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 80065d0:	3800      	subs	r0, #0
 80065d2:	bf18      	it	ne
 80065d4:	2001      	movne	r0, #1
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 80065d6:	4240      	negs	r0, r0
 80065d8:	b007      	add	sp, #28
 80065da:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080065e0 <McpsConfirm>:
 * LORAMAC NOTIFICATIONS HANDLING
 *=============================================================================
 */

static void McpsConfirm( McpsConfirm_t *mcpsConfirm )
{
 80065e0:	b570      	push	{r4, r5, r6, lr}
 80065e2:	4604      	mov	r4, r0
    TxParams.IsMcpsConfirm = 1;
 80065e4:	4810      	ldr	r0, [pc, #64]	; (8006628 <McpsConfirm+0x48>)
 80065e6:	4e11      	ldr	r6, [pc, #68]	; (800662c <McpsConfirm+0x4c>)
 80065e8:	2301      	movs	r3, #1
 80065ea:	7003      	strb	r3, [r0, #0]
    TxParams.Status = mcpsConfirm->Status;
 80065ec:	7863      	ldrb	r3, [r4, #1]
 80065ee:	7043      	strb	r3, [r0, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 80065f0:	78a3      	ldrb	r3, [r4, #2]
 80065f2:	7103      	strb	r3, [r0, #4]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 80065f4:	68e3      	ldr	r3, [r4, #12]
 80065f6:	6083      	str	r3, [r0, #8]
    TxParams.TxPower = mcpsConfirm->TxPower;
 80065f8:	78e3      	ldrb	r3, [r4, #3]
 80065fa:	7503      	strb	r3, [r0, #20]
    TxParams.Channel = mcpsConfirm->Channel;
 80065fc:	6923      	ldr	r3, [r4, #16]
 80065fe:	7543      	strb	r3, [r0, #21]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 8006600:	7923      	ldrb	r3, [r4, #4]
 8006602:	70c3      	strb	r3, [r0, #3]

    LmHandlerCallbacks->OnTxData( &TxParams );
 8006604:	4b0a      	ldr	r3, [pc, #40]	; (8006630 <McpsConfirm+0x50>)
 8006606:	681b      	ldr	r3, [r3, #0]
 8006608:	6a1b      	ldr	r3, [r3, #32]
 800660a:	4798      	blx	r3
    }
}

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800660c:	2500      	movs	r5, #0
    {
        if( LmHandlerPackages[i] != NULL )
 800660e:	f856 3b04 	ldr.w	r3, [r6], #4
 8006612:	b11b      	cbz	r3, 800661c <McpsConfirm+0x3c>
        {
            switch( notifyType )
            {
                case PACKAGE_MCPS_CONFIRM:
                {
                    if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 8006614:	699b      	ldr	r3, [r3, #24]
 8006616:	b10b      	cbz	r3, 800661c <McpsConfirm+0x3c>
                    {
                        LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t* ) params );
 8006618:	4620      	mov	r0, r4
 800661a:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 800661c:	3501      	adds	r5, #1
 800661e:	b2eb      	uxtb	r3, r5
 8006620:	2b05      	cmp	r3, #5
 8006622:	b26d      	sxtb	r5, r5
 8006624:	d1f3      	bne.n	800660e <McpsConfirm+0x2e>
}
 8006626:	bd70      	pop	{r4, r5, r6, pc}
 8006628:	20000468 	.word	0x20000468
 800662c:	20000420 	.word	0x20000420
 8006630:	2000041c 	.word	0x2000041c

08006634 <LmHandlerConfigure>:
{
 8006634:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8006638:	4e5e      	ldr	r6, [pc, #376]	; (80067b4 <LmHandlerConfigure+0x180>)
{
 800663a:	4601      	mov	r1, r0
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 800663c:	2210      	movs	r2, #16
{
 800663e:	b09e      	sub	sp, #120	; 0x78
    UTIL_MEM_cpy_8((void *)&LmHandlerParams, (const void *)handlerParams, sizeof(LmHandlerParams_t));
 8006640:	4630      	mov	r0, r6
 8006642:	f008 fd6b 	bl	800f11c <UTIL_MEM_cpy_8>
    loraInfo = LoraInfo_GetPtr();
 8006646:	f7fb fde5 	bl	8002214 <LoraInfo_GetPtr>
    if (0U != ((1 << (LmHandlerParams.ActiveRegion)) & (loraInfo->Region)))
 800664a:	7832      	ldrb	r2, [r6, #0]
 800664c:	6843      	ldr	r3, [r0, #4]
 800664e:	f04f 0801 	mov.w	r8, #1
 8006652:	fa08 f102 	lsl.w	r1, r8, r2
 8006656:	4019      	ands	r1, r3
 8006658:	d008      	beq.n	800666c <LmHandlerConfigure+0x38>
        if (LoRaMacInitialization(&LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion) != LORAMAC_STATUS_OK)
 800665a:	4957      	ldr	r1, [pc, #348]	; (80067b8 <LmHandlerConfigure+0x184>)
 800665c:	4857      	ldr	r0, [pc, #348]	; (80067bc <LmHandlerConfigure+0x188>)
 800665e:	f002 f96d 	bl	800893c <LoRaMacInitialization>
 8006662:	4605      	mov	r5, r0
 8006664:	b140      	cbz	r0, 8006678 <LmHandlerConfigure+0x44>
            return LORAMAC_HANDLER_ERROR;
 8006666:	f04f 30ff 	mov.w	r0, #4294967295
 800666a:	e09f      	b.n	80067ac <LmHandlerConfigure+0x178>
        MW_LOG(TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n");
 800666c:	4b54      	ldr	r3, [pc, #336]	; (80067c0 <LmHandlerConfigure+0x18c>)
 800666e:	4642      	mov	r2, r8
 8006670:	4608      	mov	r0, r1
 8006672:	f008 fc49 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
        while (1) {}  /* error: Region is not defined in the MW */
 8006676:	e7fe      	b.n	8006676 <LmHandlerConfigure+0x42>
    nbNvmData = NvmDataMgmtRestore( );
 8006678:	f003 ffc8 	bl	800a60c <NvmDataMgmtRestore>
    if( nbNvmData > 0 )
 800667c:	4b51      	ldr	r3, [pc, #324]	; (80067c4 <LmHandlerConfigure+0x190>)
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 800667e:	4c52      	ldr	r4, [pc, #328]	; (80067c8 <LmHandlerConfigure+0x194>)
    if( nbNvmData > 0 )
 8006680:	3800      	subs	r0, #0
 8006682:	bf18      	it	ne
 8006684:	2001      	movne	r0, #1
 8006686:	7018      	strb	r0, [r3, #0]
    mibReq.Type = MIB_DEV_EUI;
 8006688:	2702      	movs	r7, #2
    LoRaMacMibGetRequestConfirm( &mibReq );
 800668a:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_EUI;
 800668c:	f88d 7030 	strb.w	r7, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 8006690:	f002 fb6e 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.DevEui, mibReq.Param.DevEui, 8 );
 8006694:	990d      	ldr	r1, [sp, #52]	; 0x34
 8006696:	2208      	movs	r2, #8
 8006698:	4620      	mov	r0, r4
 800669a:	f006 fd4b 	bl	800d134 <memcpy1>
    mibReq.Type = MIB_JOIN_EUI;
 800669e:	2303      	movs	r3, #3
    LoRaMacMibGetRequestConfirm( &mibReq );
 80066a0:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_JOIN_EUI;
 80066a2:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibGetRequestConfirm( &mibReq );
 80066a6:	f002 fb63 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
    memcpy1( CommissioningParams.JoinEui, mibReq.Param.JoinEui, 8 );
 80066aa:	2208      	movs	r2, #8
 80066ac:	18a0      	adds	r0, r4, r2
 80066ae:	990d      	ldr	r1, [sp, #52]	; 0x34
 80066b0:	f006 fd40 	bl	800d134 <memcpy1>
    CommissioningParams.DevAddr = LmHandlerCallbacks->GetDevAddr();
 80066b4:	4b45      	ldr	r3, [pc, #276]	; (80067cc <LmHandlerConfigure+0x198>)
 80066b6:	681b      	ldr	r3, [r3, #0]
 80066b8:	68db      	ldr	r3, [r3, #12]
 80066ba:	4798      	blx	r3
    mibReq.Type = MIB_DEV_ADDR;
 80066bc:	2306      	movs	r3, #6
    CommissioningParams.DevAddr = LmHandlerCallbacks->GetDevAddr();
 80066be:	6160      	str	r0, [r4, #20]
    mibReq.Param.DevAddr = CommissioningParams.DevAddr;
 80066c0:	900d      	str	r0, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 80066c2:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_DEV_ADDR;
 80066c4:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm(&mibReq);
 80066c8:	f002 fc04 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80066cc:	79e3      	ldrb	r3, [r4, #7]
 80066ce:	9307      	str	r3, [sp, #28]
 80066d0:	79a3      	ldrb	r3, [r4, #6]
 80066d2:	9306      	str	r3, [sp, #24]
 80066d4:	7963      	ldrb	r3, [r4, #5]
 80066d6:	9305      	str	r3, [sp, #20]
 80066d8:	7923      	ldrb	r3, [r4, #4]
 80066da:	9304      	str	r3, [sp, #16]
 80066dc:	78e3      	ldrb	r3, [r4, #3]
 80066de:	9303      	str	r3, [sp, #12]
 80066e0:	78a3      	ldrb	r3, [r4, #2]
 80066e2:	9302      	str	r3, [sp, #8]
 80066e4:	7863      	ldrb	r3, [r4, #1]
 80066e6:	9301      	str	r3, [sp, #4]
 80066e8:	7823      	ldrb	r3, [r4, #0]
 80066ea:	9300      	str	r3, [sp, #0]
 80066ec:	462a      	mov	r2, r5
 80066ee:	4b38      	ldr	r3, [pc, #224]	; (80067d0 <LmHandlerConfigure+0x19c>)
 80066f0:	4629      	mov	r1, r5
 80066f2:	4638      	mov	r0, r7
 80066f4:	f008 fc08 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### AppEui:  %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 80066f8:	7be3      	ldrb	r3, [r4, #15]
 80066fa:	9307      	str	r3, [sp, #28]
 80066fc:	7ba3      	ldrb	r3, [r4, #14]
 80066fe:	9306      	str	r3, [sp, #24]
 8006700:	7b63      	ldrb	r3, [r4, #13]
 8006702:	9305      	str	r3, [sp, #20]
 8006704:	7b23      	ldrb	r3, [r4, #12]
 8006706:	9304      	str	r3, [sp, #16]
 8006708:	7ae3      	ldrb	r3, [r4, #11]
 800670a:	9303      	str	r3, [sp, #12]
 800670c:	7aa3      	ldrb	r3, [r4, #10]
 800670e:	9302      	str	r3, [sp, #8]
 8006710:	7a63      	ldrb	r3, [r4, #9]
 8006712:	9301      	str	r3, [sp, #4]
 8006714:	7a23      	ldrb	r3, [r4, #8]
 8006716:	9300      	str	r3, [sp, #0]
 8006718:	462a      	mov	r2, r5
 800671a:	4b2e      	ldr	r3, [pc, #184]	; (80067d4 <LmHandlerConfigure+0x1a0>)
 800671c:	4629      	mov	r1, r5
 800671e:	4638      	mov	r0, r7
 8006720:	f008 fbf2 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    MW_LOG(TS_OFF, VLEVEL_M, "###### DevAddr: %02X:%02X:%02X:%02X\r\n",
 8006724:	7d23      	ldrb	r3, [r4, #20]
 8006726:	9303      	str	r3, [sp, #12]
 8006728:	7d63      	ldrb	r3, [r4, #21]
 800672a:	9302      	str	r3, [sp, #8]
 800672c:	7da3      	ldrb	r3, [r4, #22]
 800672e:	9301      	str	r3, [sp, #4]
 8006730:	7de3      	ldrb	r3, [r4, #23]
 8006732:	9300      	str	r3, [sp, #0]
 8006734:	462a      	mov	r2, r5
 8006736:	4629      	mov	r1, r5
 8006738:	4b27      	ldr	r3, [pc, #156]	; (80067d8 <LmHandlerConfigure+0x1a4>)
 800673a:	4638      	mov	r0, r7
 800673c:	f008 fbe4 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8006740:	240f      	movs	r4, #15
    LoRaMacMibSetRequestConfirm(&mibReq);
 8006742:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8006744:	f88d 4030 	strb.w	r4, [sp, #48]	; 0x30
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 8006748:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 800674c:	f002 fbc2 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_NET_ID;
 8006750:	2305      	movs	r3, #5
    LoRaMacMibSetRequestConfirm(&mibReq);
 8006752:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_NET_ID;
 8006754:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 8006758:	950d      	str	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm(&mibReq);
 800675a:	f002 fbbb 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 800675e:	2310      	movs	r3, #16
    LoRaMacMibSetRequestConfirm( &mibReq );
 8006760:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Type = MIB_REPEATER_SUPPORT;
 8006762:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 8006766:	f88d 5034 	strb.w	r5, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 800676a:	f002 fbb3 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 800676e:	2304      	movs	r3, #4
 8006770:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
    LoRaMacMibSetRequestConfirm( &mibReq );
 8006774:	a80c      	add	r0, sp, #48	; 0x30
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 8006776:	78b3      	ldrb	r3, [r6, #2]
 8006778:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    LoRaMacMibSetRequestConfirm( &mibReq );
 800677c:	f002 fbaa 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 8006780:	a90a      	add	r1, sp, #40	; 0x28
 8006782:	7830      	ldrb	r0, [r6, #0]
    getPhy.Attribute = PHY_DUTY_CYCLE;
 8006784:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 8006788:	f003 ff4b 	bl	800a622 <RegionGetPhyParam>
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 800678c:	3800      	subs	r0, #0
 800678e:	bf18      	it	ne
 8006790:	2001      	movne	r0, #1
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8006792:	2322      	movs	r3, #34	; 0x22
    LmHandlerParams.DutyCycleEnabled = (bool) phyParam.Value;
 8006794:	7170      	strb	r0, [r6, #5]
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 8006796:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800679a:	a815      	add	r0, sp, #84	; 0x54
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 800679c:	2314      	movs	r3, #20
 800679e:	9316      	str	r3, [sp, #88]	; 0x58
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80067a0:	f002 fb98 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 80067a4:	7970      	ldrb	r0, [r6, #5]
 80067a6:	f003 f841 	bl	800982c <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 80067aa:	4628      	mov	r0, r5
}
 80067ac:	b01e      	add	sp, #120	; 0x78
 80067ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80067b2:	bf00      	nop
 80067b4:	20000434 	.word	0x20000434
 80067b8:	20000444 	.word	0x20000444
 80067bc:	20000458 	.word	0x20000458
 80067c0:	080108c8 	.word	0x080108c8
 80067c4:	20000419 	.word	0x20000419
 80067c8:	20000058 	.word	0x20000058
 80067cc:	2000041c 	.word	0x2000041c
 80067d0:	08010911 	.word	0x08010911
 80067d4:	0801094b 	.word	0x0801094b
 80067d8:	08010985 	.word	0x08010985

080067dc <LmHandlerProcess>:
{
 80067dc:	b538      	push	{r3, r4, r5, lr}
    LoRaMacProcess( );
 80067de:	f001 fbe3 	bl	8007fa8 <LoRaMacProcess>
    }
}

static void LmHandlerPackagesProcess( void )
{
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80067e2:	4d0c      	ldr	r5, [pc, #48]	; (8006814 <LmHandlerProcess+0x38>)
    LoRaMacProcess( );
 80067e4:	2405      	movs	r4, #5
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 80067e6:	f855 3b04 	ldr.w	r3, [r5], #4
 80067ea:	b15b      	cbz	r3, 8006804 <LmHandlerProcess+0x28>
 80067ec:	691b      	ldr	r3, [r3, #16]
 80067ee:	b14b      	cbz	r3, 8006804 <LmHandlerProcess+0x28>
    if (( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ))
 80067f0:	f855 3c04 	ldr.w	r3, [r5, #-4]
 80067f4:	689b      	ldr	r3, [r3, #8]
 80067f6:	b12b      	cbz	r3, 8006804 <LmHandlerProcess+0x28>
        return LmHandlerPackages[id]->IsInitialized( );
 80067f8:	4798      	blx	r3
            ( LmHandlerPackages[i]->Process != NULL ) &&
 80067fa:	b118      	cbz	r0, 8006804 <LmHandlerProcess+0x28>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
        {
            LmHandlerPackages[i]->Process( );
 80067fc:	f855 3c04 	ldr.w	r3, [r5, #-4]
 8006800:	691b      	ldr	r3, [r3, #16]
 8006802:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8006804:	3c01      	subs	r4, #1
 8006806:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 800680a:	d1ec      	bne.n	80067e6 <LmHandlerProcess+0xa>
}
 800680c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    NvmDataMgmtStore( );
 8006810:	f003 befa 	b.w	800a608 <NvmDataMgmtStore>
 8006814:	20000420 	.word	0x20000420

08006818 <LmHandlerJoinStatus>:
{
 8006818:	b500      	push	{lr}
 800681a:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 800681c:	2301      	movs	r3, #1
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 800681e:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 8006820:	f88d 3004 	strb.w	r3, [sp, #4]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 8006824:	f002 faa4 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 8006828:	b938      	cbnz	r0, 800683a <LmHandlerJoinStatus+0x22>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 800682a:	f89d 0008 	ldrb.w	r0, [sp, #8]
            return LORAMAC_HANDLER_RESET;
 800682e:	3800      	subs	r0, #0
 8006830:	bf18      	it	ne
 8006832:	2001      	movne	r0, #1
}
 8006834:	b00b      	add	sp, #44	; 0x2c
 8006836:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_HANDLER_RESET;
 800683a:	2000      	movs	r0, #0
 800683c:	e7fa      	b.n	8006834 <LmHandlerJoinStatus+0x1c>
	...

08006840 <LmHandlerRequestClass>:
{
 8006840:	b530      	push	{r4, r5, lr}
 8006842:	b08d      	sub	sp, #52	; 0x34
 8006844:	4605      	mov	r5, r0
    if (LoRaMacIsBusy() == true)
 8006846:	f001 fba1 	bl	8007f8c <LoRaMacIsBusy>
 800684a:	4604      	mov	r4, r0
 800684c:	2800      	cmp	r0, #0
 800684e:	d14a      	bne.n	80068e6 <LmHandlerRequestClass+0xa6>
    if (LmHandlerJoinStatus() != LORAMAC_HANDLER_SET)
 8006850:	f7ff ffe2 	bl	8006818 <LmHandlerJoinStatus>
 8006854:	2801      	cmp	r0, #1
 8006856:	d149      	bne.n	80068ec <LmHandlerRequestClass+0xac>
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8006858:	a803      	add	r0, sp, #12
    mibReq.Type = MIB_DEVICE_CLASS;
 800685a:	f88d 400c 	strb.w	r4, [sp, #12]
    if ( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 800685e:	f002 fa87 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
 8006862:	b110      	cbz	r0, 800686a <LmHandlerRequestClass+0x2a>
        switch( newClass )
 8006864:	f04f 30ff 	mov.w	r0, #4294967295
 8006868:	e004      	b.n	8006874 <LmHandlerRequestClass+0x34>
    currentClass = mibReq.Param.Class;
 800686a:	f89d 3010 	ldrb.w	r3, [sp, #16]
    if( currentClass != newClass )
 800686e:	42ab      	cmp	r3, r5
 8006870:	d102      	bne.n	8006878 <LmHandlerRequestClass+0x38>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8006872:	2000      	movs	r0, #0
}
 8006874:	b00d      	add	sp, #52	; 0x34
 8006876:	bd30      	pop	{r4, r5, pc}
        switch( newClass )
 8006878:	2d01      	cmp	r5, #1
 800687a:	d0f3      	beq.n	8006864 <LmHandlerRequestClass+0x24>
 800687c:	2d02      	cmp	r5, #2
 800687e:	d01a      	beq.n	80068b6 <LmHandlerRequestClass+0x76>
 8006880:	2d00      	cmp	r5, #0
 8006882:	d1f7      	bne.n	8006874 <LmHandlerRequestClass+0x34>
                if( currentClass != CLASS_A )
 8006884:	2b00      	cmp	r3, #0
 8006886:	d0f4      	beq.n	8006872 <LmHandlerRequestClass+0x32>
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 8006888:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 800688a:	f88d 5010 	strb.w	r5, [sp, #16]
                    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 800688e:	f002 fb21 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
 8006892:	4602      	mov	r2, r0
 8006894:	2800      	cmp	r0, #0
 8006896:	d1e5      	bne.n	8006864 <LmHandlerRequestClass+0x24>
    }
}

static void DisplayClassUpdate(DeviceClass_t deviceClass)
{
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 8006898:	2341      	movs	r3, #65	; 0x41
 800689a:	9300      	str	r3, [sp, #0]
 800689c:	4601      	mov	r1, r0
 800689e:	4b15      	ldr	r3, [pc, #84]	; (80068f4 <LmHandlerRequestClass+0xb4>)
 80068a0:	2002      	movs	r0, #2
 80068a2:	f008 fb31 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 80068a6:	4b14      	ldr	r3, [pc, #80]	; (80068f8 <LmHandlerRequestClass+0xb8>)
 80068a8:	681b      	ldr	r3, [r3, #0]
 80068aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80068ac:	2b00      	cmp	r3, #0
 80068ae:	d0e0      	beq.n	8006872 <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 80068b0:	2000      	movs	r0, #0
 80068b2:	4798      	blx	r3
 80068b4:	e7dd      	b.n	8006872 <LmHandlerRequestClass+0x32>
                if( currentClass != CLASS_A )
 80068b6:	2b00      	cmp	r3, #0
 80068b8:	d1d4      	bne.n	8006864 <LmHandlerRequestClass+0x24>
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 80068ba:	a803      	add	r0, sp, #12
                    mibReq.Param.Class = newClass;
 80068bc:	f88d 5010 	strb.w	r5, [sp, #16]
                    if (LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK)
 80068c0:	f002 fb08 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
 80068c4:	2800      	cmp	r0, #0
 80068c6:	d1cd      	bne.n	8006864 <LmHandlerRequestClass+0x24>
    MW_LOG(TS_OFF, VLEVEL_M, "Switch to Class %c done\r\n", "ABC"[deviceClass]);
 80068c8:	2343      	movs	r3, #67	; 0x43
 80068ca:	9300      	str	r3, [sp, #0]
 80068cc:	4602      	mov	r2, r0
 80068ce:	4b09      	ldr	r3, [pc, #36]	; (80068f4 <LmHandlerRequestClass+0xb4>)
 80068d0:	4601      	mov	r1, r0
 80068d2:	4628      	mov	r0, r5
 80068d4:	f008 fb18 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
                        if (LmHandlerCallbacks->OnClassChange != NULL)
 80068d8:	4b07      	ldr	r3, [pc, #28]	; (80068f8 <LmHandlerRequestClass+0xb8>)
 80068da:	681b      	ldr	r3, [r3, #0]
 80068dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80068de:	2b00      	cmp	r3, #0
 80068e0:	d0c7      	beq.n	8006872 <LmHandlerRequestClass+0x32>
                            LmHandlerCallbacks->OnClassChange( newClass );
 80068e2:	4628      	mov	r0, r5
 80068e4:	e7e5      	b.n	80068b2 <LmHandlerRequestClass+0x72>
        return LORAMAC_HANDLER_BUSY_ERROR;
 80068e6:	f06f 0001 	mvn.w	r0, #1
 80068ea:	e7c3      	b.n	8006874 <LmHandlerRequestClass+0x34>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 80068ec:	f06f 0002 	mvn.w	r0, #2
 80068f0:	e7c0      	b.n	8006874 <LmHandlerRequestClass+0x34>
 80068f2:	bf00      	nop
 80068f4:	080109ab 	.word	0x080109ab
 80068f8:	2000041c 	.word	0x2000041c

080068fc <LmHandlerJoin>:
{
 80068fc:	b530      	push	{r4, r5, lr}
    if ( mode == ACTIVATION_TYPE_OTAA )
 80068fe:	2802      	cmp	r0, #2
 8006900:	4b1a      	ldr	r3, [pc, #104]	; (800696c <LmHandlerJoin+0x70>)
 8006902:	4c1b      	ldr	r4, [pc, #108]	; (8006970 <LmHandlerJoin+0x74>)
{
 8006904:	b08b      	sub	sp, #44	; 0x2c
 8006906:	f04f 0501 	mov.w	r5, #1
    if ( mode == ACTIVATION_TYPE_OTAA )
 800690a:	d10c      	bne.n	8006926 <LmHandlerJoin+0x2a>
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 800690c:	7098      	strb	r0, [r3, #2]
        LoRaMacStart();
 800690e:	f002 f9cf 	bl	8008cb0 <LoRaMacStart>
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 8006912:	78e3      	ldrb	r3, [r4, #3]
        mlmeReq.Type = MLME_JOIN;
 8006914:	f88d 5004 	strb.w	r5, [sp, #4]
        LoRaMacMlmeRequest( &mlmeReq );
 8006918:	a801      	add	r0, sp, #4
        mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 800691a:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMlmeRequest( &mlmeReq );
 800691e:	f002 fd03 	bl	8009328 <LoRaMacMlmeRequest>
}
 8006922:	b00b      	add	sp, #44	; 0x2c
 8006924:	bd30      	pop	{r4, r5, pc}
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 8006926:	78e2      	ldrb	r2, [r4, #3]
 8006928:	701a      	strb	r2, [r3, #0]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 800692a:	2200      	movs	r2, #0
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 800692c:	709d      	strb	r5, [r3, #2]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 800692e:	705a      	strb	r2, [r3, #1]
        if (CtxRestoreDone == false)
 8006930:	4b10      	ldr	r3, [pc, #64]	; (8006974 <LmHandlerJoin+0x78>)
 8006932:	781b      	ldrb	r3, [r3, #0]
 8006934:	b93b      	cbnz	r3, 8006946 <LmHandlerJoin+0x4a>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 8006936:	2327      	movs	r3, #39	; 0x27
 8006938:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibSetRequestConfirm(&mibReq);
 800693c:	a801      	add	r0, sp, #4
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 800693e:	4b0e      	ldr	r3, [pc, #56]	; (8006978 <LmHandlerJoin+0x7c>)
 8006940:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm(&mibReq);
 8006942:	f002 fac7 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
        LoRaMacStart();
 8006946:	f002 f9b3 	bl	8008cb0 <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 800694a:	2301      	movs	r3, #1
        LoRaMacMibSetRequestConfirm( &mibReq );
 800694c:	a801      	add	r0, sp, #4
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 800694e:	f88d 3004 	strb.w	r3, [sp, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 8006952:	f88d 3008 	strb.w	r3, [sp, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8006956:	f002 fabd 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
        LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 800695a:	4b08      	ldr	r3, [pc, #32]	; (800697c <LmHandlerJoin+0x80>)
 800695c:	4803      	ldr	r0, [pc, #12]	; (800696c <LmHandlerJoin+0x70>)
 800695e:	681b      	ldr	r3, [r3, #0]
 8006960:	69db      	ldr	r3, [r3, #28]
 8006962:	4798      	blx	r3
        LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8006964:	7860      	ldrb	r0, [r4, #1]
 8006966:	f7ff ff6b 	bl	8006840 <LmHandlerRequestClass>
}
 800696a:	e7da      	b.n	8006922 <LmHandlerJoin+0x26>
 800696c:	20000070 	.word	0x20000070
 8006970:	20000434 	.word	0x20000434
 8006974:	20000419 	.word	0x20000419
 8006978:	01000300 	.word	0x01000300
 800697c:	2000041c 	.word	0x2000041c

08006980 <LmHandlerSend>:
{
 8006980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006984:	b086      	sub	sp, #24
 8006986:	4604      	mov	r4, r0
 8006988:	460d      	mov	r5, r1
 800698a:	4616      	mov	r6, r2
 800698c:	4698      	mov	r8, r3
    if (LoRaMacIsBusy() == true)
 800698e:	f001 fafd 	bl	8007f8c <LoRaMacIsBusy>
 8006992:	2800      	cmp	r0, #0
 8006994:	d150      	bne.n	8006a38 <LmHandlerSend+0xb8>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8006996:	f7ff ff3f 	bl	8006818 <LmHandlerJoinStatus>
 800699a:	2801      	cmp	r0, #1
 800699c:	d008      	beq.n	80069b0 <LmHandlerSend+0x30>
        LmHandlerJoin(JoinParams.Mode);
 800699e:	4b2b      	ldr	r3, [pc, #172]	; (8006a4c <LmHandlerSend+0xcc>)
 80069a0:	7898      	ldrb	r0, [r3, #2]
 80069a2:	f7ff ffab 	bl	80068fc <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 80069a6:	f06f 0002 	mvn.w	r0, #2
}
 80069aa:	b006      	add	sp, #24
 80069ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == true ) && ( appData->Port != LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->Port ) && ( appData->Port != 0 ) )
 80069b0:	4f27      	ldr	r7, [pc, #156]	; (8006a50 <LmHandlerSend+0xd0>)
 80069b2:	683b      	ldr	r3, [r7, #0]
 80069b4:	68db      	ldr	r3, [r3, #12]
 80069b6:	4798      	blx	r3
 80069b8:	b130      	cbz	r0, 80069c8 <LmHandlerSend+0x48>
 80069ba:	683a      	ldr	r2, [r7, #0]
 80069bc:	7823      	ldrb	r3, [r4, #0]
 80069be:	7812      	ldrb	r2, [r2, #0]
 80069c0:	429a      	cmp	r2, r3
 80069c2:	d001      	beq.n	80069c8 <LmHandlerSend+0x48>
 80069c4:	2b00      	cmp	r3, #0
 80069c6:	d13a      	bne.n	8006a3e <LmHandlerSend+0xbe>
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80069c8:	4f22      	ldr	r7, [pc, #136]	; (8006a54 <LmHandlerSend+0xd4>)
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80069ca:	7860      	ldrb	r0, [r4, #1]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 80069cc:	78fb      	ldrb	r3, [r7, #3]
 80069ce:	f88d 3012 	strb.w	r3, [sp, #18]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 80069d2:	4669      	mov	r1, sp
 80069d4:	f002 f974 	bl	8008cc0 <LoRaMacQueryTxPossible>
 80069d8:	4b1f      	ldr	r3, [pc, #124]	; (8006a58 <LmHandlerSend+0xd8>)
 80069da:	b1c8      	cbz	r0, 8006a10 <LmHandlerSend+0x90>
        TxParams.MsgType = LORAMAC_HANDLER_UNCONFIRMED_MSG;
 80069dc:	2200      	movs	r2, #0
 80069de:	709a      	strb	r2, [r3, #2]
        mcpsReq.Type = MCPS_UNCONFIRMED;
 80069e0:	f88d 2004 	strb.w	r2, [sp, #4]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 80069e4:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 80069e6:	f8ad 2010 	strh.w	r2, [sp, #16]
    TxParams.AppData = *appData;
 80069ea:	e894 0003 	ldmia.w	r4, {r0, r1}
 80069ee:	4a1b      	ldr	r2, [pc, #108]	; (8006a5c <LmHandlerSend+0xdc>)
 80069f0:	e882 0003 	stmia.w	r2, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 80069f4:	78fa      	ldrb	r2, [r7, #3]
 80069f6:	711a      	strb	r2, [r3, #4]
    status = LoRaMacMcpsRequest(&mcpsReq, allowDelayedTx);
 80069f8:	4641      	mov	r1, r8
 80069fa:	a801      	add	r0, sp, #4
 80069fc:	f002 fd8c 	bl	8009518 <LoRaMacMcpsRequest>
    if (nextTxIn != NULL)
 8006a00:	b10e      	cbz	r6, 8006a06 <LmHandlerSend+0x86>
        *nextTxIn = mcpsReq.ReqReturn.DutyCycleWaitTime;
 8006a02:	9b05      	ldr	r3, [sp, #20]
 8006a04:	6033      	str	r3, [r6, #0]
    switch (status)
 8006a06:	2811      	cmp	r0, #17
 8006a08:	d81c      	bhi.n	8006a44 <LmHandlerSend+0xc4>
 8006a0a:	4b15      	ldr	r3, [pc, #84]	; (8006a60 <LmHandlerSend+0xe0>)
 8006a0c:	5618      	ldrsb	r0, [r3, r0]
 8006a0e:	e7cc      	b.n	80069aa <LmHandlerSend+0x2a>
        TxParams.MsgType = isTxConfirmed;
 8006a10:	709d      	strb	r5, [r3, #2]
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 8006a12:	7822      	ldrb	r2, [r4, #0]
 8006a14:	f88d 2008 	strb.w	r2, [sp, #8]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 8006a18:	7862      	ldrb	r2, [r4, #1]
 8006a1a:	f8ad 2010 	strh.w	r2, [sp, #16]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 8006a1e:	6862      	ldr	r2, [r4, #4]
 8006a20:	9203      	str	r2, [sp, #12]
        if( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG )
 8006a22:	b915      	cbnz	r5, 8006a2a <LmHandlerSend+0xaa>
            mcpsReq.Type = MCPS_UNCONFIRMED;
 8006a24:	f88d 5004 	strb.w	r5, [sp, #4]
 8006a28:	e7df      	b.n	80069ea <LmHandlerSend+0x6a>
            mcpsReq.Type = MCPS_CONFIRMED;
 8006a2a:	2201      	movs	r2, #1
 8006a2c:	f88d 2004 	strb.w	r2, [sp, #4]
            mcpsReq.Req.Confirmed.NbTrials = 8;
 8006a30:	2208      	movs	r2, #8
 8006a32:	f88d 2013 	strb.w	r2, [sp, #19]
 8006a36:	e7d8      	b.n	80069ea <LmHandlerSend+0x6a>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8006a38:	f06f 0001 	mvn.w	r0, #1
 8006a3c:	e7b5      	b.n	80069aa <LmHandlerSend+0x2a>
        return LORAMAC_HANDLER_COMPLIANCE_RUNNING;
 8006a3e:	f06f 0003 	mvn.w	r0, #3
 8006a42:	e7b2      	b.n	80069aa <LmHandlerSend+0x2a>
 8006a44:	f04f 30ff 	mov.w	r0, #4294967295
 8006a48:	e7af      	b.n	80069aa <LmHandlerSend+0x2a>
 8006a4a:	bf00      	nop
 8006a4c:	20000070 	.word	0x20000070
 8006a50:	20000420 	.word	0x20000420
 8006a54:	20000434 	.word	0x20000434
 8006a58:	20000468 	.word	0x20000468
 8006a5c:	20000474 	.word	0x20000474
 8006a60:	080109c5 	.word	0x080109c5

08006a64 <MlmeIndication>:
{
 8006a64:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006a66:	4604      	mov	r4, r0
 8006a68:	460b      	mov	r3, r1
    RxParams.IsMcpsIndication = 0;
 8006a6a:	4912      	ldr	r1, [pc, #72]	; (8006ab4 <MlmeIndication+0x50>)
    RxParams.Status = mlmeIndication->Status;
 8006a6c:	7862      	ldrb	r2, [r4, #1]
 8006a6e:	704a      	strb	r2, [r1, #1]
    RxParams.IsMcpsIndication = 0;
 8006a70:	2000      	movs	r0, #0
 8006a72:	7008      	strb	r0, [r1, #0]
    RxParams.Rssi = RxStatus->Rssi;
 8006a74:	881d      	ldrh	r5, [r3, #0]
 8006a76:	70cd      	strb	r5, [r1, #3]
    RxParams.Snr = RxStatus->Snr;
 8006a78:	789d      	ldrb	r5, [r3, #2]
 8006a7a:	710d      	strb	r5, [r1, #4]
    RxParams.RxSlot = RxStatus->RxSlot;
 8006a7c:	78db      	ldrb	r3, [r3, #3]
 8006a7e:	730b      	strb	r3, [r1, #12]
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_BEACON_LOCKED )
 8006a80:	2a0e      	cmp	r2, #14
 8006a82:	d003      	beq.n	8006a8c <MlmeIndication+0x28>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 8006a84:	4b0c      	ldr	r3, [pc, #48]	; (8006ab8 <MlmeIndication+0x54>)
 8006a86:	681b      	ldr	r3, [r3, #0]
 8006a88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006a8a:	4798      	blx	r3
    switch( mlmeIndication->MlmeIndication )
 8006a8c:	7823      	ldrb	r3, [r4, #0]
 8006a8e:	2b07      	cmp	r3, #7
 8006a90:	d10e      	bne.n	8006ab0 <MlmeIndication+0x4c>
            LmHandlerAppData_t appData =
 8006a92:	2300      	movs	r3, #0
 8006a94:	f8ad 3000 	strh.w	r3, [sp]
 8006a98:	9301      	str	r3, [sp, #4]
            if( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning( ) == false )
 8006a9a:	4b08      	ldr	r3, [pc, #32]	; (8006abc <MlmeIndication+0x58>)
 8006a9c:	681b      	ldr	r3, [r3, #0]
 8006a9e:	68db      	ldr	r3, [r3, #12]
 8006aa0:	4798      	blx	r3
 8006aa2:	4602      	mov	r2, r0
 8006aa4:	b920      	cbnz	r0, 8006ab0 <MlmeIndication+0x4c>
                LmHandlerSend( &appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true );
 8006aa6:	4601      	mov	r1, r0
 8006aa8:	2301      	movs	r3, #1
 8006aaa:	4668      	mov	r0, sp
 8006aac:	f7ff ff68 	bl	8006980 <LmHandlerSend>
}
 8006ab0:	b003      	add	sp, #12
 8006ab2:	bd30      	pop	{r4, r5, pc}
 8006ab4:	20000080 	.word	0x20000080
 8006ab8:	2000041c 	.word	0x2000041c
 8006abc:	20000420 	.word	0x20000420

08006ac0 <LmHandlerGetCurrentClass>:
{
 8006ac0:	b510      	push	{r4, lr}
    if (deviceClass == NULL)
 8006ac2:	4604      	mov	r4, r0
{
 8006ac4:	b08a      	sub	sp, #40	; 0x28
    if (deviceClass == NULL)
 8006ac6:	b918      	cbnz	r0, 8006ad0 <LmHandlerGetCurrentClass+0x10>
        return LORAMAC_HANDLER_ERROR;
 8006ac8:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006acc:	b00a      	add	sp, #40	; 0x28
 8006ace:	bd10      	pop	{r4, pc}
    mibReq.Type = MIB_DEVICE_CLASS;
 8006ad0:	2300      	movs	r3, #0
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 8006ad2:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEVICE_CLASS;
 8006ad4:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK)
 8006ad8:	f002 f94a 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
 8006adc:	2800      	cmp	r0, #0
 8006ade:	d1f3      	bne.n	8006ac8 <LmHandlerGetCurrentClass+0x8>
    *deviceClass = mibReq.Param.Class;
 8006ae0:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8006ae4:	7023      	strb	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8006ae6:	e7f1      	b.n	8006acc <LmHandlerGetCurrentClass+0xc>

08006ae8 <McpsIndication>:
{
 8006ae8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006aea:	b087      	sub	sp, #28
    DeviceClass_t deviceClass = CLASS_A;
 8006aec:	2200      	movs	r2, #0
{
 8006aee:	460b      	mov	r3, r1
    RxParams.IsMcpsIndication = 1;
 8006af0:	492b      	ldr	r1, [pc, #172]	; (8006ba0 <McpsIndication+0xb8>)
    DeviceClass_t deviceClass = CLASS_A;
 8006af2:	f88d 2007 	strb.w	r2, [sp, #7]
    RxParams.IsMcpsIndication = 1;
 8006af6:	2201      	movs	r2, #1
 8006af8:	700a      	strb	r2, [r1, #0]
    RxParams.Status = mcpsIndication->Status;
 8006afa:	7842      	ldrb	r2, [r0, #1]
 8006afc:	704a      	strb	r2, [r1, #1]
{
 8006afe:	4604      	mov	r4, r0
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 8006b00:	2a00      	cmp	r2, #0
 8006b02:	d143      	bne.n	8006b8c <McpsIndication+0xa4>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 8006b04:	7902      	ldrb	r2, [r0, #4]
 8006b06:	708a      	strb	r2, [r1, #2]
    RxParams.Rssi = RxStatus->Rssi;
 8006b08:	881a      	ldrh	r2, [r3, #0]
 8006b0a:	70ca      	strb	r2, [r1, #3]
    RxParams.Snr = RxStatus->Snr;
 8006b0c:	789a      	ldrb	r2, [r3, #2]
 8006b0e:	710a      	strb	r2, [r1, #4]
    RxParams.RxSlot = RxStatus->RxSlot;
 8006b10:	78db      	ldrb	r3, [r3, #3]
 8006b12:	730b      	strb	r3, [r1, #12]
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 8006b14:	6903      	ldr	r3, [r0, #16]
 8006b16:	608b      	str	r3, [r1, #8]
    appData.Port = mcpsIndication->Port;
 8006b18:	78c3      	ldrb	r3, [r0, #3]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 8006b1a:	4d22      	ldr	r5, [pc, #136]	; (8006ba4 <McpsIndication+0xbc>)
    appData.Port = mcpsIndication->Port;
 8006b1c:	f88d 3008 	strb.w	r3, [sp, #8]
    appData.BufferSize = mcpsIndication->BufferSize;
 8006b20:	7b03      	ldrb	r3, [r0, #12]
 8006b22:	f88d 3009 	strb.w	r3, [sp, #9]
    appData.Buffer = mcpsIndication->Buffer;
 8006b26:	6883      	ldr	r3, [r0, #8]
 8006b28:	9303      	str	r3, [sp, #12]
    LmHandlerCallbacks->OnRxData(&appData, &RxParams);
 8006b2a:	682b      	ldr	r3, [r5, #0]
 8006b2c:	a802      	add	r0, sp, #8
 8006b2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006b30:	4798      	blx	r3
    if ((LmHandlerCallbacks->OnSysTimeUpdate != NULL) && (mcpsIndication->DeviceTimeAnsReceived == true))
 8006b32:	682b      	ldr	r3, [r5, #0]
 8006b34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006b36:	b113      	cbz	r3, 8006b3e <McpsIndication+0x56>
 8006b38:	7e22      	ldrb	r2, [r4, #24]
 8006b3a:	b102      	cbz	r2, 8006b3e <McpsIndication+0x56>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 8006b3c:	4798      	blx	r3
 8006b3e:	4e1a      	ldr	r6, [pc, #104]	; (8006ba8 <McpsIndication+0xc0>)
{
 8006b40:	2500      	movs	r5, #0
 8006b42:	4637      	mov	r7, r6
        if( LmHandlerPackages[i] != NULL )
 8006b44:	f856 3b04 	ldr.w	r3, [r6], #4
 8006b48:	b153      	cbz	r3, 8006b60 <McpsIndication+0x78>
                    if( ( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL ) &&
 8006b4a:	69da      	ldr	r2, [r3, #28]
 8006b4c:	b142      	cbz	r2, 8006b60 <McpsIndication+0x78>
 8006b4e:	781a      	ldrb	r2, [r3, #0]
 8006b50:	78e3      	ldrb	r3, [r4, #3]
 8006b52:	429a      	cmp	r2, r3
 8006b54:	d11c      	bne.n	8006b90 <McpsIndication+0xa8>
                        LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t* )params );
 8006b56:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8006b5a:	4620      	mov	r0, r4
 8006b5c:	69db      	ldr	r3, [r3, #28]
 8006b5e:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8006b60:	3501      	adds	r5, #1
 8006b62:	b2eb      	uxtb	r3, r5
 8006b64:	2b05      	cmp	r3, #5
 8006b66:	b26d      	sxtb	r5, r5
 8006b68:	d1ec      	bne.n	8006b44 <McpsIndication+0x5c>
    LmHandlerGetCurrentClass(&deviceClass);
 8006b6a:	f10d 0007 	add.w	r0, sp, #7
 8006b6e:	f7ff ffa7 	bl	8006ac0 <LmHandlerGetCurrentClass>
    if ((mcpsIndication->FramePending == true) && (deviceClass == CLASS_A))
 8006b72:	7963      	ldrb	r3, [r4, #5]
 8006b74:	2b01      	cmp	r3, #1
 8006b76:	d109      	bne.n	8006b8c <McpsIndication+0xa4>
 8006b78:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8006b7c:	b932      	cbnz	r2, 8006b8c <McpsIndication+0xa4>
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8006b7e:	4611      	mov	r1, r2
 8006b80:	a804      	add	r0, sp, #16
        LmHandlerAppData_t appData =
 8006b82:	f8ad 2010 	strh.w	r2, [sp, #16]
 8006b86:	9205      	str	r2, [sp, #20]
        LmHandlerSend(&appData, LORAMAC_HANDLER_UNCONFIRMED_MSG, NULL, true);
 8006b88:	f7ff fefa 	bl	8006980 <LmHandlerSend>
}
 8006b8c:	b007      	add	sp, #28
 8006b8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                        ( ( LmHandlerPackages[i]->Port == ((McpsIndication_t* )params)->Port ) ||
 8006b90:	2d00      	cmp	r5, #0
 8006b92:	d1e5      	bne.n	8006b60 <McpsIndication+0x78>
                          ( ( i == PACKAGE_ID_COMPLIANCE ) && ( LmHandlerPackages[PACKAGE_ID_COMPLIANCE]->IsRunning() ))))
 8006b94:	683b      	ldr	r3, [r7, #0]
 8006b96:	68db      	ldr	r3, [r3, #12]
 8006b98:	4798      	blx	r3
 8006b9a:	2800      	cmp	r0, #0
 8006b9c:	d1db      	bne.n	8006b56 <McpsIndication+0x6e>
 8006b9e:	e7df      	b.n	8006b60 <McpsIndication+0x78>
 8006ba0:	20000080 	.word	0x20000080
 8006ba4:	2000041c 	.word	0x2000041c
 8006ba8:	20000420 	.word	0x20000420

08006bac <LmHandlerGetTxDatarate>:
{
 8006bac:	b510      	push	{r4, lr}
    if (txDatarate == NULL)
 8006bae:	4604      	mov	r4, r0
{
 8006bb0:	b08a      	sub	sp, #40	; 0x28
    if (txDatarate == NULL)
 8006bb2:	b918      	cbnz	r0, 8006bbc <LmHandlerGetTxDatarate+0x10>
        return LORAMAC_HANDLER_ERROR;
 8006bb4:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006bb8:	b00a      	add	sp, #40	; 0x28
 8006bba:	bd10      	pop	{r4, pc}
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8006bbc:	231f      	movs	r3, #31
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 8006bbe:	a801      	add	r0, sp, #4
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8006bc0:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK)
 8006bc4:	f002 f8d4 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
 8006bc8:	2800      	cmp	r0, #0
 8006bca:	d1f3      	bne.n	8006bb4 <LmHandlerGetTxDatarate+0x8>
    LmHandlerParams.TxDatarate = *txDatarate;
 8006bcc:	4a02      	ldr	r2, [pc, #8]	; (8006bd8 <LmHandlerGetTxDatarate+0x2c>)
    *txDatarate = mibGet.Param.ChannelsDatarate;
 8006bce:	f99d 3008 	ldrsb.w	r3, [sp, #8]
 8006bd2:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 8006bd4:	70d3      	strb	r3, [r2, #3]
    return LORAMAC_HANDLER_SUCCESS;
 8006bd6:	e7ef      	b.n	8006bb8 <LmHandlerGetTxDatarate+0xc>
 8006bd8:	20000434 	.word	0x20000434

08006bdc <MlmeConfirm>:
{
 8006bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006bde:	4604      	mov	r4, r0
    LmHandlerCallbacks->OnTxData( &TxParams );
 8006be0:	4e20      	ldr	r6, [pc, #128]	; (8006c64 <MlmeConfirm+0x88>)
    TxParams.IsMcpsConfirm = 0;
 8006be2:	4821      	ldr	r0, [pc, #132]	; (8006c68 <MlmeConfirm+0x8c>)
    TxParams.Status = mlmeConfirm->Status;
 8006be4:	7863      	ldrb	r3, [r4, #1]
 8006be6:	7043      	strb	r3, [r0, #1]
    LmHandlerCallbacks->OnTxData( &TxParams );
 8006be8:	6833      	ldr	r3, [r6, #0]
 8006bea:	4f20      	ldr	r7, [pc, #128]	; (8006c6c <MlmeConfirm+0x90>)
 8006bec:	6a1b      	ldr	r3, [r3, #32]
    TxParams.IsMcpsConfirm = 0;
 8006bee:	2500      	movs	r5, #0
{
 8006bf0:	b08b      	sub	sp, #44	; 0x2c
    TxParams.IsMcpsConfirm = 0;
 8006bf2:	7005      	strb	r5, [r0, #0]
    LmHandlerCallbacks->OnTxData( &TxParams );
 8006bf4:	4798      	blx	r3
        if( LmHandlerPackages[i] != NULL )
 8006bf6:	f857 3b04 	ldr.w	r3, [r7], #4
 8006bfa:	b11b      	cbz	r3, 8006c04 <MlmeConfirm+0x28>
                    if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 8006bfc:	6a1b      	ldr	r3, [r3, #32]
 8006bfe:	b10b      	cbz	r3, 8006c04 <MlmeConfirm+0x28>
                        LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t* )params );
 8006c00:	4620      	mov	r0, r4
 8006c02:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8006c04:	3501      	adds	r5, #1
 8006c06:	b2eb      	uxtb	r3, r5
 8006c08:	2b05      	cmp	r3, #5
 8006c0a:	b26d      	sxtb	r5, r5
 8006c0c:	d1f3      	bne.n	8006bf6 <MlmeConfirm+0x1a>
    switch( mlmeConfirm->MlmeRequest )
 8006c0e:	7823      	ldrb	r3, [r4, #0]
 8006c10:	2b01      	cmp	r3, #1
 8006c12:	d003      	beq.n	8006c1c <MlmeConfirm+0x40>
 8006c14:	2b04      	cmp	r3, #4
 8006c16:	d01d      	beq.n	8006c54 <MlmeConfirm+0x78>
}
 8006c18:	b00b      	add	sp, #44	; 0x2c
 8006c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            mibReq.Type = MIB_DEV_ADDR;
 8006c1c:	2306      	movs	r3, #6
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 8006c1e:	4d14      	ldr	r5, [pc, #80]	; (8006c70 <MlmeConfirm+0x94>)
            mibReq.Type = MIB_DEV_ADDR;
 8006c20:	f88d 3004 	strb.w	r3, [sp, #4]
            LoRaMacMibGetRequestConfirm( &mibReq );
 8006c24:	a801      	add	r0, sp, #4
 8006c26:	f002 f8a3 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
            CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8006c2a:	4b12      	ldr	r3, [pc, #72]	; (8006c74 <MlmeConfirm+0x98>)
 8006c2c:	9a02      	ldr	r2, [sp, #8]
 8006c2e:	615a      	str	r2, [r3, #20]
            LmHandlerGetTxDatarate( &JoinParams.Datarate );
 8006c30:	4628      	mov	r0, r5
 8006c32:	f7ff ffbb 	bl	8006bac <LmHandlerGetTxDatarate>
            if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8006c36:	7863      	ldrb	r3, [r4, #1]
 8006c38:	b94b      	cbnz	r3, 8006c4e <MlmeConfirm+0x72>
                JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8006c3a:	706b      	strb	r3, [r5, #1]
                LmHandlerRequestClass(LmHandlerParams.DefaultClass);
 8006c3c:	4b0e      	ldr	r3, [pc, #56]	; (8006c78 <MlmeConfirm+0x9c>)
 8006c3e:	7858      	ldrb	r0, [r3, #1]
 8006c40:	f7ff fdfe 	bl	8006840 <LmHandlerRequestClass>
            LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 8006c44:	6833      	ldr	r3, [r6, #0]
 8006c46:	480a      	ldr	r0, [pc, #40]	; (8006c70 <MlmeConfirm+0x94>)
 8006c48:	69db      	ldr	r3, [r3, #28]
 8006c4a:	4798      	blx	r3
}
 8006c4c:	e7e4      	b.n	8006c18 <MlmeConfirm+0x3c>
                JoinParams.Status = LORAMAC_HANDLER_ERROR;
 8006c4e:	23ff      	movs	r3, #255	; 0xff
 8006c50:	706b      	strb	r3, [r5, #1]
 8006c52:	e7f7      	b.n	8006c44 <MlmeConfirm+0x68>
            RxParams.LinkCheck = true;
 8006c54:	4b09      	ldr	r3, [pc, #36]	; (8006c7c <MlmeConfirm+0xa0>)
 8006c56:	2201      	movs	r2, #1
 8006c58:	735a      	strb	r2, [r3, #13]
            RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 8006c5a:	7a22      	ldrb	r2, [r4, #8]
 8006c5c:	739a      	strb	r2, [r3, #14]
            RxParams.NbGateways = mlmeConfirm->NbGateways;
 8006c5e:	7a62      	ldrb	r2, [r4, #9]
 8006c60:	73da      	strb	r2, [r3, #15]
}
 8006c62:	e7d9      	b.n	8006c18 <MlmeConfirm+0x3c>
 8006c64:	2000041c 	.word	0x2000041c
 8006c68:	20000468 	.word	0x20000468
 8006c6c:	20000420 	.word	0x20000420
 8006c70:	20000070 	.word	0x20000070
 8006c74:	20000058 	.word	0x20000058
 8006c78:	20000434 	.word	0x20000434
 8006c7c:	20000080 	.word	0x20000080

08006c80 <LmHandlerPackageRegister>:
{
 8006c80:	b538      	push	{r3, r4, r5, lr}
 8006c82:	460d      	mov	r5, r1
    switch( id )
 8006c84:	4604      	mov	r4, r0
 8006c86:	b110      	cbz	r0, 8006c8e <LmHandlerPackageRegister+0xe>
        return LORAMAC_HANDLER_ERROR;
 8006c88:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006c8c:	bd38      	pop	{r3, r4, r5, pc}
            package = LmhpCompliancePackageFactory( );
 8006c8e:	f000 f9ed 	bl	800706c <LmhpCompliancePackageFactory>
    if( package != NULL )
 8006c92:	2800      	cmp	r0, #0
 8006c94:	d0f8      	beq.n	8006c88 <LmHandlerPackageRegister+0x8>
        LmHandlerPackages[id] = package;
 8006c96:	4b09      	ldr	r3, [pc, #36]	; (8006cbc <LmHandlerPackageRegister+0x3c>)
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8006c98:	4909      	ldr	r1, [pc, #36]	; (8006cc0 <LmHandlerPackageRegister+0x40>)
        LmHandlerPackages[id] = package;
 8006c9a:	6018      	str	r0, [r3, #0]
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8006c9c:	4b09      	ldr	r3, [pc, #36]	; (8006cc4 <LmHandlerPackageRegister+0x44>)
 8006c9e:	6243      	str	r3, [r0, #36]	; 0x24
        LmHandlerPackages[id]->OnSendRequest = LmHandlerSend;
 8006ca0:	4b09      	ldr	r3, [pc, #36]	; (8006cc8 <LmHandlerPackageRegister+0x48>)
 8006ca2:	6283      	str	r3, [r0, #40]	; 0x28
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8006ca4:	4b09      	ldr	r3, [pc, #36]	; (8006ccc <LmHandlerPackageRegister+0x4c>)
 8006ca6:	62c3      	str	r3, [r0, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 8006ca8:	4b09      	ldr	r3, [pc, #36]	; (8006cd0 <LmHandlerPackageRegister+0x50>)
 8006caa:	681b      	ldr	r3, [r3, #0]
 8006cac:	691b      	ldr	r3, [r3, #16]
 8006cae:	6143      	str	r3, [r0, #20]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 8006cb0:	22f2      	movs	r2, #242	; 0xf2
 8006cb2:	6843      	ldr	r3, [r0, #4]
 8006cb4:	4628      	mov	r0, r5
 8006cb6:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8006cb8:	4620      	mov	r0, r4
 8006cba:	e7e7      	b.n	8006c8c <LmHandlerPackageRegister+0xc>
 8006cbc:	20000420 	.word	0x20000420
 8006cc0:	20000327 	.word	0x20000327
 8006cc4:	080068fd 	.word	0x080068fd
 8006cc8:	08006981 	.word	0x08006981
 8006ccc:	080065c3 	.word	0x080065c3
 8006cd0:	2000041c 	.word	0x2000041c

08006cd4 <LmHandlerInit>:
{
 8006cd4:	b508      	push	{r3, lr}
    LmHandlerCallbacks = handlerCallbacks;
 8006cd6:	4b0f      	ldr	r3, [pc, #60]	; (8006d14 <LmHandlerInit+0x40>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8006cd8:	4a0f      	ldr	r2, [pc, #60]	; (8006d18 <LmHandlerInit+0x44>)
    LmHandlerCallbacks = handlerCallbacks;
 8006cda:	6018      	str	r0, [r3, #0]
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8006cdc:	4b0f      	ldr	r3, [pc, #60]	; (8006d1c <LmHandlerInit+0x48>)
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8006cde:	4910      	ldr	r1, [pc, #64]	; (8006d20 <LmHandlerInit+0x4c>)
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 8006ce0:	601a      	str	r2, [r3, #0]
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 8006ce2:	4a10      	ldr	r2, [pc, #64]	; (8006d24 <LmHandlerInit+0x50>)
 8006ce4:	605a      	str	r2, [r3, #4]
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 8006ce6:	4a10      	ldr	r2, [pc, #64]	; (8006d28 <LmHandlerInit+0x54>)
 8006ce8:	609a      	str	r2, [r3, #8]
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 8006cea:	4a10      	ldr	r2, [pc, #64]	; (8006d2c <LmHandlerInit+0x58>)
 8006cec:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 8006cee:	4b10      	ldr	r3, [pc, #64]	; (8006d30 <LmHandlerInit+0x5c>)
 8006cf0:	6802      	ldr	r2, [r0, #0]
 8006cf2:	601a      	str	r2, [r3, #0]
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 8006cf4:	6842      	ldr	r2, [r0, #4]
 8006cf6:	605a      	str	r2, [r3, #4]
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 8006cf8:	6882      	ldr	r2, [r0, #8]
 8006cfa:	609a      	str	r2, [r3, #8]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 8006cfc:	4a0d      	ldr	r2, [pc, #52]	; (8006d34 <LmHandlerInit+0x60>)
 8006cfe:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 8006d00:	6902      	ldr	r2, [r0, #16]
 8006d02:	611a      	str	r2, [r3, #16]
    if (LmHandlerPackageRegister(PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams) != LORAMAC_HANDLER_SUCCESS)
 8006d04:	2000      	movs	r0, #0
 8006d06:	f7ff ffbb 	bl	8006c80 <LmHandlerPackageRegister>
 8006d0a:	3800      	subs	r0, #0
 8006d0c:	bf18      	it	ne
 8006d0e:	2001      	movne	r0, #1
}
 8006d10:	4240      	negs	r0, r0
 8006d12:	bd08      	pop	{r3, pc}
 8006d14:	2000041c 	.word	0x2000041c
 8006d18:	080065e1 	.word	0x080065e1
 8006d1c:	20000458 	.word	0x20000458
 8006d20:	20000074 	.word	0x20000074
 8006d24:	08006ae9 	.word	0x08006ae9
 8006d28:	08006bdd 	.word	0x08006bdd
 8006d2c:	08006a65 	.word	0x08006a65
 8006d30:	20000444 	.word	0x20000444
 8006d34:	0800a607 	.word	0x0800a607

08006d38 <LmHandlerGetDevEUI>:
{
 8006d38:	b530      	push	{r4, r5, lr}
    if (devEUI == NULL)
 8006d3a:	4605      	mov	r5, r0
{
 8006d3c:	b08b      	sub	sp, #44	; 0x2c
    if (devEUI == NULL)
 8006d3e:	b918      	cbnz	r0, 8006d48 <LmHandlerGetDevEUI+0x10>
        return LORAMAC_HANDLER_ERROR;
 8006d40:	f04f 30ff 	mov.w	r0, #4294967295
}
 8006d44:	b00b      	add	sp, #44	; 0x2c
 8006d46:	bd30      	pop	{r4, r5, pc}
    mibReq.Type = MIB_DEV_EUI;
 8006d48:	2302      	movs	r3, #2
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8006d4a:	a801      	add	r0, sp, #4
    mibReq.Type = MIB_DEV_EUI;
 8006d4c:	f88d 3004 	strb.w	r3, [sp, #4]
    if (LoRaMacMibGetRequestConfirm(&mibReq) != LORAMAC_STATUS_OK)
 8006d50:	f002 f80e 	bl	8008d70 <LoRaMacMibGetRequestConfirm>
 8006d54:	4604      	mov	r4, r0
 8006d56:	2800      	cmp	r0, #0
 8006d58:	d1f2      	bne.n	8006d40 <LmHandlerGetDevEUI+0x8>
    UTIL_MEM_cpy_8(devEUI, mibReq.Param.DevEui, SE_EUI_SIZE);
 8006d5a:	4628      	mov	r0, r5
 8006d5c:	9902      	ldr	r1, [sp, #8]
 8006d5e:	2208      	movs	r2, #8
 8006d60:	f008 f9dc 	bl	800f11c <UTIL_MEM_cpy_8>
    return LORAMAC_HANDLER_SUCCESS;
 8006d64:	4620      	mov	r0, r4
 8006d66:	e7ed      	b.n	8006d44 <LmHandlerGetDevEUI+0xc>

08006d68 <LmhpComplianceInit>:
{
    return &LmhpCompliancePackage;
}

static void LmhpComplianceInit( void *params, uint8_t *dataBuffer, uint8_t dataBufferMaxSize )
{
 8006d68:	b510      	push	{r4, lr}
 8006d6a:	4b06      	ldr	r3, [pc, #24]	; (8006d84 <LmhpComplianceInit+0x1c>)
 8006d6c:	4c06      	ldr	r4, [pc, #24]	; (8006d88 <LmhpComplianceInit+0x20>)
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 8006d6e:	b130      	cbz	r0, 8006d7e <LmhpComplianceInit+0x16>
 8006d70:	b129      	cbz	r1, 8006d7e <LmhpComplianceInit+0x16>
    {
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
        ComplianceTestState.DataBuffer = dataBuffer;
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 8006d72:	715a      	strb	r2, [r3, #5]
        LmhpComplianceParams = ( LmhpComplianceParams_t* )params;
 8006d74:	6020      	str	r0, [r4, #0]
        ComplianceTestState.DataBuffer = dataBuffer;
 8006d76:	6099      	str	r1, [r3, #8]
        ComplianceTestState.Initialized = true;
 8006d78:	2201      	movs	r2, #1
    }
    else
    {
        LmhpComplianceParams = NULL;
        ComplianceTestState.Initialized = false;
 8006d7a:	701a      	strb	r2, [r3, #0]
    }
}
 8006d7c:	bd10      	pop	{r4, pc}
        LmhpComplianceParams = NULL;
 8006d7e:	2200      	movs	r2, #0
 8006d80:	6022      	str	r2, [r4, #0]
 8006d82:	e7fa      	b.n	8006d7a <LmhpComplianceInit+0x12>
 8006d84:	20000480 	.word	0x20000480
 8006d88:	200004ac 	.word	0x200004ac

08006d8c <LmhpComplianceIsInitialized>:

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
}
 8006d8c:	4b01      	ldr	r3, [pc, #4]	; (8006d94 <LmhpComplianceIsInitialized+0x8>)
 8006d8e:	7818      	ldrb	r0, [r3, #0]
 8006d90:	4770      	bx	lr
 8006d92:	bf00      	nop
 8006d94:	20000480 	.word	0x20000480

08006d98 <LmhpComplianceIsRunning>:

static bool LmhpComplianceIsRunning( void )
{
    if( ComplianceTestState.Initialized == false )
 8006d98:	4b02      	ldr	r3, [pc, #8]	; (8006da4 <LmhpComplianceIsRunning+0xc>)
 8006d9a:	7818      	ldrb	r0, [r3, #0]
 8006d9c:	b100      	cbz	r0, 8006da0 <LmhpComplianceIsRunning+0x8>
    {
        return false;
    }

    return ComplianceTestState.IsRunning;
 8006d9e:	7858      	ldrb	r0, [r3, #1]
}
 8006da0:	4770      	bx	lr
 8006da2:	bf00      	nop
 8006da4:	20000480 	.word	0x20000480

08006da8 <LmhpComplianceProcess>:
}

static void LmhpComplianceProcess( void )
{
    /* Nothing to process */
}
 8006da8:	4770      	bx	lr
	...

08006dac <LmhpComplianceOnMcpsConfirm>:
    if (ComplianceTestState.Initialized == false)
 8006dac:	4b06      	ldr	r3, [pc, #24]	; (8006dc8 <LmhpComplianceOnMcpsConfirm+0x1c>)
 8006dae:	781a      	ldrb	r2, [r3, #0]
 8006db0:	b14a      	cbz	r2, 8006dc6 <LmhpComplianceOnMcpsConfirm+0x1a>
    if ((ComplianceTestState.IsRunning == true) &&
 8006db2:	785a      	ldrb	r2, [r3, #1]
 8006db4:	b13a      	cbz	r2, 8006dc6 <LmhpComplianceOnMcpsConfirm+0x1a>
 8006db6:	7802      	ldrb	r2, [r0, #0]
 8006db8:	2a01      	cmp	r2, #1
 8006dba:	d104      	bne.n	8006dc6 <LmhpComplianceOnMcpsConfirm+0x1a>
        (mcpsConfirm->McpsRequest == MCPS_CONFIRMED) &&
 8006dbc:	7902      	ldrb	r2, [r0, #4]
 8006dbe:	b112      	cbz	r2, 8006dc6 <LmhpComplianceOnMcpsConfirm+0x1a>
        ComplianceTestState.DownLinkCounter++;
 8006dc0:	899a      	ldrh	r2, [r3, #12]
 8006dc2:	3201      	adds	r2, #1
 8006dc4:	819a      	strh	r2, [r3, #12]
}
 8006dc6:	4770      	bx	lr
 8006dc8:	20000480 	.word	0x20000480

08006dcc <LmhpComplianceOnMlmeConfirm>:
    if( ComplianceTestState.Initialized == false )
 8006dcc:	4b07      	ldr	r3, [pc, #28]	; (8006dec <LmhpComplianceOnMlmeConfirm+0x20>)
 8006dce:	781a      	ldrb	r2, [r3, #0]
 8006dd0:	b152      	cbz	r2, 8006de8 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( ComplianceTestState.IsRunning == false )
 8006dd2:	785a      	ldrb	r2, [r3, #1]
 8006dd4:	b142      	cbz	r2, 8006de8 <LmhpComplianceOnMlmeConfirm+0x1c>
    if( mlmeConfirm->MlmeRequest == MLME_LINK_CHECK )
 8006dd6:	7802      	ldrb	r2, [r0, #0]
 8006dd8:	2a04      	cmp	r2, #4
 8006dda:	d105      	bne.n	8006de8 <LmhpComplianceOnMlmeConfirm+0x1c>
        ComplianceTestState.LinkCheck = true;
 8006ddc:	2201      	movs	r2, #1
 8006dde:	739a      	strb	r2, [r3, #14]
        ComplianceTestState.DemodMargin = mlmeConfirm->DemodMargin;
 8006de0:	7a02      	ldrb	r2, [r0, #8]
 8006de2:	73da      	strb	r2, [r3, #15]
        ComplianceTestState.NbGateways = mlmeConfirm->NbGateways;
 8006de4:	7a42      	ldrb	r2, [r0, #9]
 8006de6:	741a      	strb	r2, [r3, #16]
}
 8006de8:	4770      	bx	lr
 8006dea:	bf00      	nop
 8006dec:	20000480 	.word	0x20000480

08006df0 <LmhpComplianceTxProcess>:
{
 8006df0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8006df2:	4c1b      	ldr	r4, [pc, #108]	; (8006e60 <LmhpComplianceTxProcess+0x70>)
 8006df4:	7823      	ldrb	r3, [r4, #0]
 8006df6:	b383      	cbz	r3, 8006e5a <LmhpComplianceTxProcess+0x6a>
    if( ComplianceTestState.IsRunning == false )
 8006df8:	7860      	ldrb	r0, [r4, #1]
 8006dfa:	b328      	cbz	r0, 8006e48 <LmhpComplianceTxProcess+0x58>
    if( ComplianceTestState.LinkCheck == true )
 8006dfc:	7ba2      	ldrb	r2, [r4, #14]
 8006dfe:	68a3      	ldr	r3, [r4, #8]
 8006e00:	b162      	cbz	r2, 8006e1c <LmhpComplianceTxProcess+0x2c>
        ComplianceTestState.LinkCheck = false;
 8006e02:	2200      	movs	r2, #0
 8006e04:	73a2      	strb	r2, [r4, #14]
        ComplianceTestState.DataBufferSize = 3;
 8006e06:	2203      	movs	r2, #3
 8006e08:	71a2      	strb	r2, [r4, #6]
        ComplianceTestState.DataBuffer[0] = 5;
 8006e0a:	2205      	movs	r2, #5
 8006e0c:	701a      	strb	r2, [r3, #0]
        ComplianceTestState.DataBuffer[1] = ComplianceTestState.DemodMargin;
 8006e0e:	7be2      	ldrb	r2, [r4, #15]
 8006e10:	705a      	strb	r2, [r3, #1]
        ComplianceTestState.DataBuffer[2] = ComplianceTestState.NbGateways;
 8006e12:	7c22      	ldrb	r2, [r4, #16]
 8006e14:	709a      	strb	r2, [r3, #2]
            ComplianceTestState.State = 1;
 8006e16:	2201      	movs	r2, #1
 8006e18:	70a2      	strb	r2, [r4, #2]
            break;
 8006e1a:	e004      	b.n	8006e26 <LmhpComplianceTxProcess+0x36>
        switch( ComplianceTestState.State )
 8006e1c:	78a2      	ldrb	r2, [r4, #2]
 8006e1e:	2a01      	cmp	r2, #1
 8006e20:	d014      	beq.n	8006e4c <LmhpComplianceTxProcess+0x5c>
 8006e22:	2a04      	cmp	r2, #4
 8006e24:	d0f7      	beq.n	8006e16 <LmhpComplianceTxProcess+0x26>
    LmHandlerAppData_t appData =
 8006e26:	22e0      	movs	r2, #224	; 0xe0
 8006e28:	f88d 2000 	strb.w	r2, [sp]
    TimerStart( &ComplianceTxNextPacketTimer );
 8006e2c:	480d      	ldr	r0, [pc, #52]	; (8006e64 <LmhpComplianceTxProcess+0x74>)
    LmHandlerAppData_t appData =
 8006e2e:	79a2      	ldrb	r2, [r4, #6]
 8006e30:	f88d 2001 	strb.w	r2, [sp, #1]
 8006e34:	9301      	str	r3, [sp, #4]
    TimerStart( &ComplianceTxNextPacketTimer );
 8006e36:	f008 fbf3 	bl	800f620 <UTIL_TIMER_Start>
    return LmhpCompliancePackage.OnSendRequest( &appData, ( LmHandlerMsgTypes_t )ComplianceTestState.IsTxConfirmed, NULL, true );
 8006e3a:	4b0b      	ldr	r3, [pc, #44]	; (8006e68 <LmhpComplianceTxProcess+0x78>)
 8006e3c:	78e1      	ldrb	r1, [r4, #3]
 8006e3e:	6a9d      	ldr	r5, [r3, #40]	; 0x28
 8006e40:	2200      	movs	r2, #0
 8006e42:	2301      	movs	r3, #1
 8006e44:	4668      	mov	r0, sp
 8006e46:	47a8      	blx	r5
}
 8006e48:	b003      	add	sp, #12
 8006e4a:	bd30      	pop	{r4, r5, pc}
            ComplianceTestState.DataBufferSize = 2;
 8006e4c:	2202      	movs	r2, #2
 8006e4e:	71a2      	strb	r2, [r4, #6]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8006e50:	89a2      	ldrh	r2, [r4, #12]
            ComplianceTestState.DataBuffer[1] = ComplianceTestState.DownLinkCounter;
 8006e52:	705a      	strb	r2, [r3, #1]
            ComplianceTestState.DataBuffer[0] = ComplianceTestState.DownLinkCounter >> 8;
 8006e54:	0a11      	lsrs	r1, r2, #8
 8006e56:	7019      	strb	r1, [r3, #0]
            break;
 8006e58:	e7e5      	b.n	8006e26 <LmhpComplianceTxProcess+0x36>
        return LORAMAC_HANDLER_ERROR;
 8006e5a:	f04f 30ff 	mov.w	r0, #4294967295
 8006e5e:	e7f3      	b.n	8006e48 <LmhpComplianceTxProcess+0x58>
 8006e60:	20000480 	.word	0x20000480
 8006e64:	20000494 	.word	0x20000494
 8006e68:	20000090 	.word	0x20000090

08006e6c <OnComplianceTxNextPacketTimerEvent>:

static void OnComplianceTxNextPacketTimerEvent( void* context )
{
    LmhpComplianceTxProcess( );
 8006e6c:	f7ff bfc0 	b.w	8006df0 <LmhpComplianceTxProcess>

08006e70 <LmhpComplianceOnMcpsIndication>:
{
 8006e70:	b530      	push	{r4, r5, lr}
    if( ComplianceTestState.Initialized == false )
 8006e72:	4c79      	ldr	r4, [pc, #484]	; (8007058 <LmhpComplianceOnMcpsIndication+0x1e8>)
 8006e74:	7823      	ldrb	r3, [r4, #0]
{
 8006e76:	b08d      	sub	sp, #52	; 0x34
    if( ComplianceTestState.Initialized == false )
 8006e78:	2b00      	cmp	r3, #0
 8006e7a:	d043      	beq.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
    if( mcpsIndication->RxData == false )
 8006e7c:	7b43      	ldrb	r3, [r0, #13]
 8006e7e:	2b00      	cmp	r3, #0
 8006e80:	d040      	beq.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
    if ((ComplianceTestState.IsRunning == true) &&
 8006e82:	7865      	ldrb	r5, [r4, #1]
 8006e84:	b125      	cbz	r5, 8006e90 <LmhpComplianceOnMcpsIndication+0x20>
 8006e86:	7b83      	ldrb	r3, [r0, #14]
 8006e88:	b913      	cbnz	r3, 8006e90 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.DownLinkCounter++;
 8006e8a:	89a3      	ldrh	r3, [r4, #12]
 8006e8c:	3301      	adds	r3, #1
 8006e8e:	81a3      	strh	r3, [r4, #12]
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 8006e90:	78c1      	ldrb	r1, [r0, #3]
 8006e92:	29e0      	cmp	r1, #224	; 0xe0
 8006e94:	d136      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
    if( ComplianceTestState.IsRunning == false )
 8006e96:	2d00      	cmp	r5, #0
 8006e98:	d136      	bne.n	8006f08 <LmhpComplianceOnMcpsIndication+0x98>
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8006e9a:	7b02      	ldrb	r2, [r0, #12]
 8006e9c:	2a04      	cmp	r2, #4
 8006e9e:	d131      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8006ea0:	6883      	ldr	r3, [r0, #8]
        if( ( mcpsIndication->BufferSize == 4 ) &&
 8006ea2:	7818      	ldrb	r0, [r3, #0]
 8006ea4:	2801      	cmp	r0, #1
 8006ea6:	d12d      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ( mcpsIndication->Buffer[0] == 0x01 ) &&
 8006ea8:	7858      	ldrb	r0, [r3, #1]
 8006eaa:	2801      	cmp	r0, #1
 8006eac:	d12a      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ( mcpsIndication->Buffer[1] == 0x01 ) &&
 8006eae:	7898      	ldrb	r0, [r3, #2]
 8006eb0:	2801      	cmp	r0, #1
 8006eb2:	d127      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ( mcpsIndication->Buffer[2] == 0x01 ) &&
 8006eb4:	78db      	ldrb	r3, [r3, #3]
 8006eb6:	2b01      	cmp	r3, #1
 8006eb8:	d124      	bne.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ComplianceTestState.DataBufferSize = 2;
 8006eba:	2002      	movs	r0, #2
            ComplianceTestState.State = 1;
 8006ebc:	8063      	strh	r3, [r4, #2]
            ComplianceTestState.DataBufferSize = 2;
 8006ebe:	71a0      	strb	r0, [r4, #6]
            ComplianceTestState.DownLinkCounter = 0;
 8006ec0:	60e5      	str	r5, [r4, #12]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8006ec2:	a803      	add	r0, sp, #12
            ComplianceTestState.IsRunning = true;
 8006ec4:	7063      	strb	r3, [r4, #1]
            mibReq.Param.AdrEnable = true;
 8006ec6:	f88d 3010 	strb.w	r3, [sp, #16]
            ComplianceTestState.Port = 224;
 8006eca:	7121      	strb	r1, [r4, #4]
            mibReq.Type = MIB_ADR;
 8006ecc:	f88d 200c 	strb.w	r2, [sp, #12]
            ComplianceTestState.NbGateways = 0;
 8006ed0:	7425      	strb	r5, [r4, #16]
            LoRaMacMibSetRequestConfirm( &mibReq );
 8006ed2:	f001 ffff 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
            LoRaMacTestSetDutyCycleOn( false );
 8006ed6:	4628      	mov	r0, r5
 8006ed8:	f002 fca8 	bl	800982c <LoRaMacTestSetDutyCycleOn>
            if( LmhpComplianceParams->StopPeripherals != NULL )
 8006edc:	4b5f      	ldr	r3, [pc, #380]	; (800705c <LmhpComplianceOnMcpsIndication+0x1ec>)
 8006ede:	681b      	ldr	r3, [r3, #0]
 8006ee0:	685b      	ldr	r3, [r3, #4]
 8006ee2:	b103      	cbz	r3, 8006ee6 <LmhpComplianceOnMcpsIndication+0x76>
                LmhpComplianceParams->StopPeripherals( );
 8006ee4:	4798      	blx	r3
            TimerInit( &ComplianceTxNextPacketTimer, OnComplianceTxNextPacketTimerEvent );
 8006ee6:	2200      	movs	r2, #0
 8006ee8:	4b5d      	ldr	r3, [pc, #372]	; (8007060 <LmhpComplianceOnMcpsIndication+0x1f0>)
 8006eea:	9200      	str	r2, [sp, #0]
 8006eec:	f04f 31ff 	mov.w	r1, #4294967295
 8006ef0:	485c      	ldr	r0, [pc, #368]	; (8007064 <LmhpComplianceOnMcpsIndication+0x1f4>)
 8006ef2:	f008 fae7 	bl	800f4c4 <UTIL_TIMER_Create>
            TimerSetValue( &ComplianceTxNextPacketTimer, COMPLIANCE_TX_DUTYCYCLE );
 8006ef6:	f241 3188 	movw	r1, #5000	; 0x1388
 8006efa:	485a      	ldr	r0, [pc, #360]	; (8007064 <LmhpComplianceOnMcpsIndication+0x1f4>)
 8006efc:	f008 fbca 	bl	800f694 <UTIL_TIMER_SetPeriod>
            LmhpComplianceTxProcess( );
 8006f00:	f7ff ff76 	bl	8006df0 <LmhpComplianceTxProcess>
}
 8006f04:	b00d      	add	sp, #52	; 0x34
 8006f06:	bd30      	pop	{r4, r5, pc}
        ComplianceTestState.State = mcpsIndication->Buffer[0];
 8006f08:	6883      	ldr	r3, [r0, #8]
 8006f0a:	781a      	ldrb	r2, [r3, #0]
 8006f0c:	70a2      	strb	r2, [r4, #2]
        switch( ComplianceTestState.State )
 8006f0e:	2a0a      	cmp	r2, #10
 8006f10:	d8f8      	bhi.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
 8006f12:	e8df f002 	tbb	[pc, r2]
 8006f16:	2106      	.short	0x2106
 8006f18:	3d2a2824 	.word	0x3d2a2824
 8006f1c:	8f8d6244 	.word	0x8f8d6244
 8006f20:	99          	.byte	0x99
 8006f21:	00          	.byte	0x00
                TimerStop( &ComplianceTxNextPacketTimer );
 8006f22:	4850      	ldr	r0, [pc, #320]	; (8007064 <LmhpComplianceOnMcpsIndication+0x1f4>)
 8006f24:	f008 fb2c 	bl	800f580 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8006f28:	2300      	movs	r3, #0
                ComplianceTestState.IsRunning = false;
 8006f2a:	7063      	strb	r3, [r4, #1]
                ComplianceTestState.DownLinkCounter = 0;
 8006f2c:	81a3      	strh	r3, [r4, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006f2e:	4c4b      	ldr	r4, [pc, #300]	; (800705c <LmhpComplianceOnMcpsIndication+0x1ec>)
                mibReq.Type = MIB_ADR;
 8006f30:	2304      	movs	r3, #4
 8006f32:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006f36:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8006f38:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006f3a:	781b      	ldrb	r3, [r3, #0]
 8006f3c:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8006f40:	f001 ffc8 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8006f44:	6823      	ldr	r3, [r4, #0]
 8006f46:	7858      	ldrb	r0, [r3, #1]
 8006f48:	f002 fc70 	bl	800982c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8006f4c:	6823      	ldr	r3, [r4, #0]
 8006f4e:	689b      	ldr	r3, [r3, #8]
 8006f50:	2b00      	cmp	r3, #0
 8006f52:	d0d7      	beq.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                    LmhpComplianceParams->StartPeripherals( );
 8006f54:	4798      	blx	r3
            break;
 8006f56:	e7d5      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ComplianceTestState.DataBufferSize = 2;
 8006f58:	2302      	movs	r3, #2
 8006f5a:	71a3      	strb	r3, [r4, #6]
            break;
 8006f5c:	e7d2      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ComplianceTestState.State = 1;
 8006f5e:	f240 1301 	movw	r3, #257	; 0x101
            ComplianceTestState.State = 1;
 8006f62:	8063      	strh	r3, [r4, #2]
            break;
 8006f64:	e7ce      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
            ComplianceTestState.State = 1;
 8006f66:	2301      	movs	r3, #1
 8006f68:	e7fb      	b.n	8006f62 <LmhpComplianceOnMcpsIndication+0xf2>
            ComplianceTestState.DataBuffer[0] = 4;
 8006f6a:	68a5      	ldr	r5, [r4, #8]
            ComplianceTestState.DataBufferSize = mcpsIndication->BufferSize;
 8006f6c:	7b03      	ldrb	r3, [r0, #12]
 8006f6e:	71a3      	strb	r3, [r4, #6]
            ComplianceTestState.DataBuffer[0] = 4;
 8006f70:	2204      	movs	r2, #4
 8006f72:	702a      	strb	r2, [r5, #0]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8006f74:	7962      	ldrb	r2, [r4, #5]
 8006f76:	429a      	cmp	r2, r3
 8006f78:	bf28      	it	cs
 8006f7a:	461a      	movcs	r2, r3
 8006f7c:	2300      	movs	r3, #0
 8006f7e:	3301      	adds	r3, #1
 8006f80:	b2d9      	uxtb	r1, r3
 8006f82:	428a      	cmp	r2, r1
 8006f84:	d9be      	bls.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                ComplianceTestState.DataBuffer[i] = mcpsIndication->Buffer[i] + 1;
 8006f86:	6881      	ldr	r1, [r0, #8]
 8006f88:	5cc9      	ldrb	r1, [r1, r3]
 8006f8a:	3101      	adds	r1, #1
 8006f8c:	54e9      	strb	r1, [r5, r3]
            for( uint8_t i = 1; i < MIN( ComplianceTestState.DataBufferSize, ComplianceTestState.DataBufferMaxSize ); i++ )
 8006f8e:	e7f6      	b.n	8006f7e <LmhpComplianceOnMcpsIndication+0x10e>
                mlmeReq.Type = MLME_LINK_CHECK;
 8006f90:	2304      	movs	r3, #4
                mlmeReq.Type = MLME_DEVICE_TIME;
 8006f92:	f88d 300c 	strb.w	r3, [sp, #12]
                LoRaMacMlmeRequest( &mlmeReq );
 8006f96:	a803      	add	r0, sp, #12
 8006f98:	f002 f9c6 	bl	8009328 <LoRaMacMlmeRequest>
            break;
 8006f9c:	e7b2      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                TimerStop(&ComplianceTxNextPacketTimer);
 8006f9e:	4831      	ldr	r0, [pc, #196]	; (8007064 <LmhpComplianceOnMcpsIndication+0x1f4>)
 8006fa0:	f008 faee 	bl	800f580 <UTIL_TIMER_Stop>
                ComplianceTestState.DownLinkCounter = 0;
 8006fa4:	2300      	movs	r3, #0
                ComplianceTestState.IsRunning = false;
 8006fa6:	7063      	strb	r3, [r4, #1]
                ComplianceTestState.DownLinkCounter = 0;
 8006fa8:	81a3      	strh	r3, [r4, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006faa:	4c2c      	ldr	r4, [pc, #176]	; (800705c <LmhpComplianceOnMcpsIndication+0x1ec>)
                mibReq.Type = MIB_ADR;
 8006fac:	2304      	movs	r3, #4
 8006fae:	f88d 300c 	strb.w	r3, [sp, #12]
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006fb2:	6823      	ldr	r3, [r4, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8006fb4:	a803      	add	r0, sp, #12
                mibReq.Param.AdrEnable = LmhpComplianceParams->AdrEnabled;
 8006fb6:	781b      	ldrb	r3, [r3, #0]
 8006fb8:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8006fbc:	f001 ff8a 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
                LoRaMacTestSetDutyCycleOn( LmhpComplianceParams->DutyCycleEnabled );
 8006fc0:	6823      	ldr	r3, [r4, #0]
 8006fc2:	7858      	ldrb	r0, [r3, #1]
 8006fc4:	f002 fc32 	bl	800982c <LoRaMacTestSetDutyCycleOn>
                if( LmhpComplianceParams->StartPeripherals != NULL )
 8006fc8:	6823      	ldr	r3, [r4, #0]
 8006fca:	689b      	ldr	r3, [r3, #8]
 8006fcc:	b103      	cbz	r3, 8006fd0 <LmhpComplianceOnMcpsIndication+0x160>
                    LmhpComplianceParams->StartPeripherals( );
 8006fce:	4798      	blx	r3
                LmhpCompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA );
 8006fd0:	4b25      	ldr	r3, [pc, #148]	; (8007068 <LmhpComplianceOnMcpsIndication+0x1f8>)
 8006fd2:	2002      	movs	r0, #2
 8006fd4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006fd6:	4798      	blx	r3
            break;
 8006fd8:	e794      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                if( mcpsIndication->BufferSize == 3 )
 8006fda:	7b02      	ldrb	r2, [r0, #12]
 8006fdc:	2a03      	cmp	r2, #3
 8006fde:	d10e      	bne.n	8006ffe <LmhpComplianceOnMcpsIndication+0x18e>
                    mlmeReq.Type = MLME_TXCW;
 8006fe0:	2205      	movs	r2, #5
 8006fe2:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8006fe6:	785a      	ldrb	r2, [r3, #1]
 8006fe8:	789b      	ldrb	r3, [r3, #2]
 8006fea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8006fee:	f8ad 3010 	strh.w	r3, [sp, #16]
                LoRaMacMlmeRequest( &mlmeReq );
 8006ff2:	a803      	add	r0, sp, #12
 8006ff4:	f002 f998 	bl	8009328 <LoRaMacMlmeRequest>
                ComplianceTestState.State = 1;
 8006ff8:	2301      	movs	r3, #1
 8006ffa:	70a3      	strb	r3, [r4, #2]
            break;
 8006ffc:	e782      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                else if( mcpsIndication->BufferSize == 7 )
 8006ffe:	2a07      	cmp	r2, #7
 8007000:	d1f7      	bne.n	8006ff2 <LmhpComplianceOnMcpsIndication+0x182>
                    mlmeReq.Type = MLME_TXCW_1;
 8007002:	2206      	movs	r2, #6
 8007004:	f88d 200c 	strb.w	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Timeout = ( uint16_t )( ( mcpsIndication->Buffer[1] << 8 ) | mcpsIndication->Buffer[2] );
 8007008:	7859      	ldrb	r1, [r3, #1]
 800700a:	789a      	ldrb	r2, [r3, #2]
 800700c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8007010:	f8ad 2010 	strh.w	r2, [sp, #16]
                    mlmeReq.Req.TxCw.Frequency = ( uint32_t )( ( mcpsIndication->Buffer[3] << 16 ) | ( mcpsIndication->Buffer[4] << 8 ) | mcpsIndication->Buffer[5] ) * 100;
 8007014:	791a      	ldrb	r2, [r3, #4]
 8007016:	78d9      	ldrb	r1, [r3, #3]
 8007018:	0212      	lsls	r2, r2, #8
 800701a:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800701e:	7959      	ldrb	r1, [r3, #5]
 8007020:	430a      	orrs	r2, r1
 8007022:	2164      	movs	r1, #100	; 0x64
 8007024:	434a      	muls	r2, r1
 8007026:	9205      	str	r2, [sp, #20]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[6];
 8007028:	799b      	ldrb	r3, [r3, #6]
 800702a:	f88d 3018 	strb.w	r3, [sp, #24]
 800702e:	e7e0      	b.n	8006ff2 <LmhpComplianceOnMcpsIndication+0x182>
                mlmeReq.Type = MLME_DEVICE_TIME;
 8007030:	230a      	movs	r3, #10
 8007032:	e7ae      	b.n	8006f92 <LmhpComplianceOnMcpsIndication+0x122>
                mibReq.Type = MIB_DEVICE_CLASS;
 8007034:	2200      	movs	r2, #0
 8007036:	f88d 200c 	strb.w	r2, [sp, #12]
                mibReq.Param.Class = ( DeviceClass_t )mcpsIndication->Buffer[1];;
 800703a:	785b      	ldrb	r3, [r3, #1]
 800703c:	f88d 3010 	strb.w	r3, [sp, #16]
                LoRaMacMibSetRequestConfirm( &mibReq );
 8007040:	a803      	add	r0, sp, #12
 8007042:	f001 ff47 	bl	8008ed4 <LoRaMacMibSetRequestConfirm>
            break;
 8007046:	e75d      	b.n	8006f04 <LmhpComplianceOnMcpsIndication+0x94>
                mlmeReq.Type = MLME_PING_SLOT_INFO;
 8007048:	220d      	movs	r2, #13
 800704a:	f88d 200c 	strb.w	r2, [sp, #12]
                mlmeReq.Req.PingSlotInfo.PingSlot.Value = mcpsIndication->Buffer[1];
 800704e:	785b      	ldrb	r3, [r3, #1]
 8007050:	f88d 3010 	strb.w	r3, [sp, #16]
 8007054:	e79f      	b.n	8006f96 <LmhpComplianceOnMcpsIndication+0x126>
 8007056:	bf00      	nop
 8007058:	20000480 	.word	0x20000480
 800705c:	200004ac 	.word	0x200004ac
 8007060:	08006e6d 	.word	0x08006e6d
 8007064:	20000494 	.word	0x20000494
 8007068:	20000090 	.word	0x20000090

0800706c <LmhpCompliancePackageFactory>:
}
 800706c:	4800      	ldr	r0, [pc, #0]	; (8007070 <LmhpCompliancePackageFactory+0x4>)
 800706e:	4770      	bx	lr
 8007070:	20000090 	.word	0x20000090

08007074 <OnRadioRxError>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
}

static void OnRadioRxError( void )
{
    LoRaMacRadioEvents.Events.RxError = 1;
 8007074:	4a06      	ldr	r2, [pc, #24]	; (8007090 <OnRadioRxError+0x1c>)
 8007076:	7813      	ldrb	r3, [r2, #0]
 8007078:	f043 0302 	orr.w	r3, r3, #2
 800707c:	7013      	strb	r3, [r2, #0]

    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800707e:	4b05      	ldr	r3, [pc, #20]	; (8007094 <OnRadioRxError+0x20>)
 8007080:	f8d3 3348 	ldr.w	r3, [r3, #840]	; 0x348
 8007084:	b113      	cbz	r3, 800708c <OnRadioRxError+0x18>
 8007086:	691b      	ldr	r3, [r3, #16]
 8007088:	b103      	cbz	r3, 800708c <OnRadioRxError+0x18>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 800708a:	4718      	bx	r3
    }
}
 800708c:	4770      	bx	lr
 800708e:	bf00      	nop
 8007090:	200004b0 	.word	0x200004b0
 8007094:	200004b4 	.word	0x200004b4

08007098 <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8007098:	4b04      	ldr	r3, [pc, #16]	; (80070ac <UpdateRxSlotIdleState+0x14>)
 800709a:	4a05      	ldr	r2, [pc, #20]	; (80070b0 <UpdateRxSlotIdleState+0x18>)
 800709c:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 80070a0:	2b02      	cmp	r3, #2
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 80070a2:	bf18      	it	ne
 80070a4:	2306      	movne	r3, #6
 80070a6:	f882 3480 	strb.w	r3, [r2, #1152]	; 0x480
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 80070aa:	4770      	bx	lr
 80070ac:	200009bc 	.word	0x200009bc
 80070b0:	200004b4 	.word	0x200004b4

080070b4 <StopRetransmission>:
    return false;
}

static bool StopRetransmission( void )
{
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 80070b4:	4b0f      	ldr	r3, [pc, #60]	; (80070f4 <StopRetransmission+0x40>)
 80070b6:	f893 2481 	ldrb.w	r2, [r3, #1153]	; 0x481
 80070ba:	0792      	lsls	r2, r2, #30
 80070bc:	d503      	bpl.n	80070c6 <StopRetransmission+0x12>
 80070be:	f893 247f 	ldrb.w	r2, [r3, #1151]	; 0x47f
 80070c2:	2a01      	cmp	r2, #1
 80070c4:	d906      	bls.n	80070d4 <StopRetransmission+0x20>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 80070c6:	4a0c      	ldr	r2, [pc, #48]	; (80070f8 <StopRetransmission+0x44>)
 80070c8:	f892 10fe 	ldrb.w	r1, [r2, #254]	; 0xfe
 80070cc:	b111      	cbz	r1, 80070d4 <StopRetransmission+0x20>
        {
            Nvm.MacGroup1.AdrAckCounter++;
 80070ce:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80070d0:	3101      	adds	r1, #1
 80070d2:	6291      	str	r1, [r2, #40]	; 0x28
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 80070d4:	2200      	movs	r2, #0
 80070d6:	f883 2410 	strb.w	r2, [r3, #1040]	; 0x410
    MacCtx.NodeAckRequested = false;
 80070da:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
    MacCtx.AckTimeoutRetry = false;
 80070de:	f883 2413 	strb.w	r2, [r3, #1043]	; 0x413
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 80070e2:	f8d3 2340 	ldr.w	r2, [r3, #832]	; 0x340
 80070e6:	f022 0202 	bic.w	r2, r2, #2
 80070ea:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340

    return true;
}
 80070ee:	2001      	movs	r0, #1
 80070f0:	4770      	bx	lr
 80070f2:	bf00      	nop
 80070f4:	200004b4 	.word	0x200004b4
 80070f8:	200009bc 	.word	0x200009bc

080070fc <GetMaxAppPayloadWithoutFOptsLength>:
{
 80070fc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80070fe:	4b0c      	ldr	r3, [pc, #48]	; (8007130 <GetMaxAppPayloadWithoutFOptsLength+0x34>)
    getPhy.Datarate = datarate;
 8007100:	f88d 0009 	strb.w	r0, [sp, #9]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8007104:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 8007108:	f88d 200a 	strb.w	r2, [sp, #10]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 800710c:	220d      	movs	r2, #13
 800710e:	f88d 2008 	strb.w	r2, [sp, #8]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8007112:	f893 2080 	ldrb.w	r2, [r3, #128]	; 0x80
 8007116:	b112      	cbz	r2, 800711e <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8007118:	220e      	movs	r2, #14
 800711a:	f88d 2008 	strb.w	r2, [sp, #8]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800711e:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 8007122:	a902      	add	r1, sp, #8
 8007124:	f003 fa7d 	bl	800a622 <RegionGetPhyParam>
}
 8007128:	b2c0      	uxtb	r0, r0
 800712a:	b005      	add	sp, #20
 800712c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007130:	200009bc 	.word	0x200009bc

08007134 <OnAckTimeoutTimerEvent>:
{
 8007134:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.AckTimeoutTimer );
 8007136:	4c10      	ldr	r4, [pc, #64]	; (8007178 <OnAckTimeoutTimerEvent+0x44>)
 8007138:	f504 707e 	add.w	r0, r4, #1016	; 0x3f8
 800713c:	f008 fa20 	bl	800f580 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 8007140:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 8007144:	4623      	mov	r3, r4
 8007146:	b112      	cbz	r2, 800714e <OnAckTimeoutTimerEvent+0x1a>
        MacCtx.AckTimeoutRetry = true;
 8007148:	2201      	movs	r2, #1
 800714a:	f884 2413 	strb.w	r2, [r4, #1043]	; 0x413
    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 800714e:	4a0b      	ldr	r2, [pc, #44]	; (800717c <OnAckTimeoutTimerEvent+0x48>)
 8007150:	f892 20fc 	ldrb.w	r2, [r2, #252]	; 0xfc
 8007154:	2a02      	cmp	r2, #2
        MacCtx.MacFlags.Bits.MacDone = 1;
 8007156:	bf02      	ittt	eq
 8007158:	f893 2481 	ldrbeq.w	r2, [r3, #1153]	; 0x481
 800715c:	f042 0220 	orreq.w	r2, r2, #32
 8007160:	f883 2481 	strbeq.w	r2, [r3, #1153]	; 0x481
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8007164:	f8d3 3348 	ldr.w	r3, [r3, #840]	; 0x348
 8007168:	b123      	cbz	r3, 8007174 <OnAckTimeoutTimerEvent+0x40>
 800716a:	691b      	ldr	r3, [r3, #16]
 800716c:	b113      	cbz	r3, 8007174 <OnAckTimeoutTimerEvent+0x40>
}
 800716e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        MacCtx.MacCallbacks->MacProcessNotify( );
 8007172:	4718      	bx	r3
}
 8007174:	bd10      	pop	{r4, pc}
 8007176:	bf00      	nop
 8007178:	200004b4 	.word	0x200004b4
 800717c:	200009bc 	.word	0x200009bc

08007180 <PrepareRxDoneAbort>:
{
 8007180:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 8007182:	4c0c      	ldr	r4, [pc, #48]	; (80071b4 <PrepareRxDoneAbort+0x34>)
 8007184:	f8d4 2340 	ldr.w	r2, [r4, #832]	; 0x340
 8007188:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800718c:	f8c4 2340 	str.w	r2, [r4, #832]	; 0x340
    if( MacCtx.NodeAckRequested == true )
 8007190:	f894 2414 	ldrb.w	r2, [r4, #1044]	; 0x414
 8007194:	b112      	cbz	r2, 800719c <PrepareRxDoneAbort+0x1c>
        OnAckTimeoutTimerEvent( NULL );
 8007196:	2000      	movs	r0, #0
 8007198:	f7ff ffcc 	bl	8007134 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 800719c:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80071a0:	f023 0322 	bic.w	r3, r3, #34	; 0x22
 80071a4:	f043 0322 	orr.w	r3, r3, #34	; 0x22
 80071a8:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
}
 80071ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    UpdateRxSlotIdleState( );
 80071b0:	f7ff bf72 	b.w	8007098 <UpdateRxSlotIdleState>
 80071b4:	200004b4 	.word	0x200004b4

080071b8 <HandleRadioRxErrorTimeout>:
{
 80071b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80071bc:	4d2c      	ldr	r5, [pc, #176]	; (8007270 <HandleRadioRxErrorTimeout+0xb8>)
 80071be:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80071c2:	2b02      	cmp	r3, #2
{
 80071c4:	4607      	mov	r7, r0
 80071c6:	460e      	mov	r6, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 80071c8:	d002      	beq.n	80071d0 <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 80071ca:	4b2a      	ldr	r3, [pc, #168]	; (8007274 <HandleRadioRxErrorTimeout+0xbc>)
 80071cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80071ce:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80071d0:	f002 fbb7 	bl	8009942 <LoRaMacClassBIsBeaconExpected>
 80071d4:	4604      	mov	r4, r0
 80071d6:	b128      	cbz	r0, 80071e4 <HandleRadioRxErrorTimeout+0x2c>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 80071d8:	2002      	movs	r0, #2
 80071da:	f002 fba8 	bl	800992e <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 80071de:	2000      	movs	r0, #0
 80071e0:	f002 fbaa 	bl	8009938 <LoRaMacClassBBeaconTimerEvent>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80071e4:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80071e8:	2b01      	cmp	r3, #1
 80071ea:	d117      	bne.n	800721c <HandleRadioRxErrorTimeout+0x64>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80071ec:	f002 fbab 	bl	8009946 <LoRaMacClassBIsPingExpected>
 80071f0:	4680      	mov	r8, r0
 80071f2:	b130      	cbz	r0, 8007202 <HandleRadioRxErrorTimeout+0x4a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80071f4:	2000      	movs	r0, #0
 80071f6:	f002 fb9b 	bl	8009930 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80071fa:	2000      	movs	r0, #0
 80071fc:	f002 fb9d 	bl	800993a <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 8007200:	4644      	mov	r4, r8
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 8007202:	f002 fba2 	bl	800994a <LoRaMacClassBIsMulticastExpected>
 8007206:	b148      	cbz	r0, 800721c <HandleRadioRxErrorTimeout+0x64>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8007208:	2000      	movs	r0, #0
 800720a:	f002 fb92 	bl	8009932 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 800720e:	2000      	movs	r0, #0
 8007210:	f002 fb94 	bl	800993c <LoRaMacClassBMulticastSlotTimerEvent>
}
 8007214:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    UpdateRxSlotIdleState( );
 8007218:	f7ff bf3e 	b.w	8007098 <UpdateRxSlotIdleState>
    if( classBRx == false )
 800721c:	2c00      	cmp	r4, #0
 800721e:	d1f9      	bne.n	8007214 <HandleRadioRxErrorTimeout+0x5c>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8007220:	4c15      	ldr	r4, [pc, #84]	; (8007278 <HandleRadioRxErrorTimeout+0xc0>)
 8007222:	f894 2480 	ldrb.w	r2, [r4, #1152]	; 0x480
 8007226:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 800722a:	b9b2      	cbnz	r2, 800725a <HandleRadioRxErrorTimeout+0xa2>
            if( MacCtx.NodeAckRequested == true )
 800722c:	b10b      	cbz	r3, 8007232 <HandleRadioRxErrorTimeout+0x7a>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 800722e:	f884 7439 	strb.w	r7, [r4, #1081]	; 0x439
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 8007232:	4638      	mov	r0, r7
 8007234:	f002 fd32 	bl	8009c9c <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 8007238:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 800723a:	f008 f967 	bl	800f50c <UTIL_TIMER_GetElapsedTime>
 800723e:	f8d4 33b4 	ldr.w	r3, [r4, #948]	; 0x3b4
 8007242:	4298      	cmp	r0, r3
 8007244:	d3e6      	bcc.n	8007214 <HandleRadioRxErrorTimeout+0x5c>
                TimerStop( &MacCtx.RxWindowTimer2 );
 8007246:	480d      	ldr	r0, [pc, #52]	; (800727c <HandleRadioRxErrorTimeout+0xc4>)
 8007248:	f008 f99a 	bl	800f580 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 800724c:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8007250:	f043 0320 	orr.w	r3, r3, #32
 8007254:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
 8007258:	e7dc      	b.n	8007214 <HandleRadioRxErrorTimeout+0x5c>
            if( MacCtx.NodeAckRequested == true )
 800725a:	b10b      	cbz	r3, 8007260 <HandleRadioRxErrorTimeout+0xa8>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 800725c:	f884 6439 	strb.w	r6, [r4, #1081]	; 0x439
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 8007260:	4630      	mov	r0, r6
 8007262:	f002 fd1b 	bl	8009c9c <LoRaMacConfirmQueueSetStatusCmn>
            if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8007266:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 800726a:	2b02      	cmp	r3, #2
 800726c:	d1ee      	bne.n	800724c <HandleRadioRxErrorTimeout+0x94>
 800726e:	e7d1      	b.n	8007214 <HandleRadioRxErrorTimeout+0x5c>
 8007270:	200009bc 	.word	0x200009bc
 8007274:	08010fe4 	.word	0x08010fe4
 8007278:	200004b4 	.word	0x200004b4
 800727c:	2000084c 	.word	0x2000084c

08007280 <OnRadioRxTimeout>:
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 8007280:	4a0a      	ldr	r2, [pc, #40]	; (80072ac <OnRadioRxTimeout+0x2c>)
 8007282:	7813      	ldrb	r3, [r2, #0]
 8007284:	f043 0301 	orr.w	r3, r3, #1
{
 8007288:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 800728a:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800728c:	4b08      	ldr	r3, [pc, #32]	; (80072b0 <OnRadioRxTimeout+0x30>)
 800728e:	f8d3 3348 	ldr.w	r3, [r3, #840]	; 0x348
 8007292:	b113      	cbz	r3, 800729a <OnRadioRxTimeout+0x1a>
 8007294:	691b      	ldr	r3, [r3, #16]
 8007296:	b103      	cbz	r3, 800729a <OnRadioRxTimeout+0x1a>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8007298:	4798      	blx	r3
}
 800729a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 800729e:	4b05      	ldr	r3, [pc, #20]	; (80072b4 <OnRadioRxTimeout+0x34>)
 80072a0:	2201      	movs	r2, #1
 80072a2:	2100      	movs	r1, #0
 80072a4:	2002      	movs	r0, #2
 80072a6:	f007 be2f 	b.w	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 80072aa:	bf00      	nop
 80072ac:	200004b0 	.word	0x200004b0
 80072b0:	200004b4 	.word	0x200004b4
 80072b4:	080109d7 	.word	0x080109d7

080072b8 <OnRadioTxTimeout>:
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80072b8:	4a0a      	ldr	r2, [pc, #40]	; (80072e4 <OnRadioTxTimeout+0x2c>)
 80072ba:	7813      	ldrb	r3, [r2, #0]
 80072bc:	f043 0304 	orr.w	r3, r3, #4
{
 80072c0:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 80072c2:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 80072c4:	4b08      	ldr	r3, [pc, #32]	; (80072e8 <OnRadioTxTimeout+0x30>)
 80072c6:	f8d3 3348 	ldr.w	r3, [r3, #840]	; 0x348
 80072ca:	b113      	cbz	r3, 80072d2 <OnRadioTxTimeout+0x1a>
 80072cc:	691b      	ldr	r3, [r3, #16]
 80072ce:	b103      	cbz	r3, 80072d2 <OnRadioTxTimeout+0x1a>
        MacCtx.MacCallbacks->MacProcessNotify( );
 80072d0:	4798      	blx	r3
}
 80072d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 80072d6:	4b05      	ldr	r3, [pc, #20]	; (80072ec <OnRadioTxTimeout+0x34>)
 80072d8:	2201      	movs	r2, #1
 80072da:	2100      	movs	r1, #0
 80072dc:	2002      	movs	r0, #2
 80072de:	f007 be13 	b.w	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 80072e2:	bf00      	nop
 80072e4:	200004b0 	.word	0x200004b0
 80072e8:	200004b4 	.word	0x200004b4
 80072ec:	080109e7 	.word	0x080109e7

080072f0 <OnRadioRxDone>:
{
 80072f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80072f4:	4616      	mov	r6, r2
 80072f6:	461d      	mov	r5, r3
 80072f8:	4680      	mov	r8, r0
 80072fa:	460f      	mov	r7, r1
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 80072fc:	f008 f8fc 	bl	800f4f8 <UTIL_TIMER_GetCurrentTime>
    LoRaMacRadioEvents.Events.RxDone = 1;
 8007300:	4a0c      	ldr	r2, [pc, #48]	; (8007334 <OnRadioRxDone+0x44>)
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 8007302:	4c0d      	ldr	r4, [pc, #52]	; (8007338 <OnRadioRxDone+0x48>)
    LoRaMacRadioEvents.Events.RxDone = 1;
 8007304:	7813      	ldrb	r3, [r2, #0]
    RxDoneParams.Size = size;
 8007306:	8127      	strh	r7, [r4, #8]
    LoRaMacRadioEvents.Events.RxDone = 1;
 8007308:	f043 0308 	orr.w	r3, r3, #8
 800730c:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800730e:	4b0b      	ldr	r3, [pc, #44]	; (800733c <OnRadioRxDone+0x4c>)
    RxDoneParams.Rssi = rssi;
 8007310:	8166      	strh	r6, [r4, #10]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 8007312:	f8d3 3348 	ldr.w	r3, [r3, #840]	; 0x348
    RxDoneParams.Snr = snr;
 8007316:	7325      	strb	r5, [r4, #12]
    RxDoneParams.Payload = payload;
 8007318:	e9c4 0800 	strd	r0, r8, [r4]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800731c:	b113      	cbz	r3, 8007324 <OnRadioRxDone+0x34>
 800731e:	691b      	ldr	r3, [r3, #16]
 8007320:	b103      	cbz	r3, 8007324 <OnRadioRxDone+0x34>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8007322:	4798      	blx	r3
}
 8007324:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 8007328:	4b05      	ldr	r3, [pc, #20]	; (8007340 <OnRadioRxDone+0x50>)
 800732a:	2201      	movs	r2, #1
 800732c:	2100      	movs	r1, #0
 800732e:	2002      	movs	r0, #2
 8007330:	f007 bdea 	b.w	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 8007334:	200004b0 	.word	0x200004b0
 8007338:	20001ae4 	.word	0x20001ae4
 800733c:	200004b4 	.word	0x200004b4
 8007340:	080109f7 	.word	0x080109f7

08007344 <OnRadioTxDone>:
{
 8007344:	b537      	push	{r0, r1, r2, r4, r5, lr}
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 8007346:	f008 f8d7 	bl	800f4f8 <UTIL_TIMER_GetCurrentTime>
 800734a:	4b10      	ldr	r3, [pc, #64]	; (800738c <OnRadioTxDone+0x48>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 800734c:	4d10      	ldr	r5, [pc, #64]	; (8007390 <OnRadioTxDone+0x4c>)
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 800734e:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 8007350:	466c      	mov	r4, sp
 8007352:	4620      	mov	r0, r4
 8007354:	f008 f826 	bl	800f3a4 <SysTimeGet>
 8007358:	e894 0003 	ldmia.w	r4, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 800735c:	4a0d      	ldr	r2, [pc, #52]	; (8007394 <OnRadioTxDone+0x50>)
    MacCtx.LastTxSysTime = SysTimeGet( );
 800735e:	f505 734e 	add.w	r3, r5, #824	; 0x338
 8007362:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacRadioEvents.Events.TxDone = 1;
 8007366:	7813      	ldrb	r3, [r2, #0]
 8007368:	f043 0310 	orr.w	r3, r3, #16
 800736c:	7013      	strb	r3, [r2, #0]
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 800736e:	f8d5 3348 	ldr.w	r3, [r5, #840]	; 0x348
 8007372:	b113      	cbz	r3, 800737a <OnRadioTxDone+0x36>
 8007374:	691b      	ldr	r3, [r3, #16]
 8007376:	b103      	cbz	r3, 800737a <OnRadioTxDone+0x36>
        MacCtx.MacCallbacks->MacProcessNotify( );
 8007378:	4798      	blx	r3
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 800737a:	4b07      	ldr	r3, [pc, #28]	; (8007398 <OnRadioTxDone+0x54>)
 800737c:	2201      	movs	r2, #1
 800737e:	2100      	movs	r1, #0
 8007380:	2002      	movs	r0, #2
}
 8007382:	b003      	add	sp, #12
 8007384:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 8007388:	f007 bdbe 	b.w	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 800738c:	20001ae0 	.word	0x20001ae0
 8007390:	200004b4 	.word	0x200004b4
 8007394:	200004b0 	.word	0x200004b0
 8007398:	08010a04 	.word	0x08010a04

0800739c <ResetMacParameters>:
{
 800739c:	b5f0      	push	{r4, r5, r6, r7, lr}
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 800739e:	4c40      	ldr	r4, [pc, #256]	; (80074a0 <ResetMacParameters+0x104>)
    MacCtx.ChannelsNbTransCounter = 0;
 80073a0:	4d40      	ldr	r5, [pc, #256]	; (80074a4 <ResetMacParameters+0x108>)
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 80073a2:	f8b4 20c4 	ldrh.w	r2, [r4, #196]	; 0xc4
 80073a6:	8722      	strh	r2, [r4, #56]	; 0x38
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80073a8:	e9d4 0129 	ldrd	r0, r1, [r4, #164]	; 0xa4
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 80073ac:	f894 20a1 	ldrb.w	r2, [r4, #161]	; 0xa1
 80073b0:	f884 2061 	strb.w	r2, [r4, #97]	; 0x61
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 80073b4:	f104 0264 	add.w	r2, r4, #100	; 0x64
 80073b8:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80073bc:	e9d4 012b 	ldrd	r0, r1, [r4, #172]	; 0xac
 80073c0:	f104 026c 	add.w	r2, r4, #108	; 0x6c
{
 80073c4:	b08f      	sub	sp, #60	; 0x3c
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 80073c6:	e882 0003 	stmia.w	r2, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 80073ca:	f8b4 20b4 	ldrh.w	r2, [r4, #180]	; 0xb4
 80073ce:	f8a4 2074 	strh.w	r2, [r4, #116]	; 0x74
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80073d2:	2301      	movs	r3, #1
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80073d4:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
    Nvm.MacGroup2.AggregatedDCycle = 1;
 80073d8:	f8a4 3102 	strh.w	r3, [r4, #258]	; 0x102
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 80073dc:	67a2      	str	r2, [r4, #120]	; 0x78
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 80073de:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80073e2:	f8d4 20bc 	ldr.w	r2, [r4, #188]	; 0xbc
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80073e6:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 80073ea:	67e2      	str	r2, [r4, #124]	; 0x7c
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80073ec:	f504 73ec 	add.w	r3, r4, #472	; 0x1d8
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80073f0:	2600      	movs	r6, #0
    MacCtx.ChannelsNbTransCounter = 0;
 80073f2:	4a2d      	ldr	r2, [pc, #180]	; (80074a8 <ResetMacParameters+0x10c>)
    params.NvmGroup1 = &Nvm.RegionGroup1;
 80073f4:	9303      	str	r3, [sp, #12]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 80073f6:	a903      	add	r1, sp, #12
    params.NvmGroup2 = &Nvm.RegionGroup2;
 80073f8:	f504 731f 	add.w	r3, r4, #636	; 0x27c
    Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 80073fc:	f884 6110 	strb.w	r6, [r4, #272]	; 0x110
    Nvm.MacGroup1.AdrAckCounter = 0;
 8007400:	62a6      	str	r6, [r4, #40]	; 0x28
    Nvm.MacGroup2.MaxDCycle = 0;
 8007402:	f884 60ff 	strb.w	r6, [r4, #255]	; 0xff
    MacCtx.ChannelsNbTransCounter = 0;
 8007406:	f8c5 2410 	str.w	r2, [r5, #1040]	; 0x410
    Nvm.MacGroup1.SrvAckRequested = false;
 800740a:	f884 603a 	strb.w	r6, [r4, #58]	; 0x3a
    params.NvmGroup2 = &Nvm.RegionGroup2;
 800740e:	9304      	str	r3, [sp, #16]
    MacCtx.NodeAckRequested = false;
 8007410:	f885 6414 	strb.w	r6, [r5, #1044]	; 0x414
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8007414:	f003 f920 	bl	800a658 <RegionInitDefaults>
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 8007418:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800741a:	f8c5 33d0 	str.w	r3, [r5, #976]	; 0x3d0
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800741e:	f894 3075 	ldrb.w	r3, [r4, #117]	; 0x75
 8007422:	f885 33dc 	strb.w	r3, [r5, #988]	; 0x3dc
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8007426:	f894 3080 	ldrb.w	r3, [r4, #128]	; 0x80
 800742a:	f885 33dd 	strb.w	r3, [r5, #989]	; 0x3dd
    MacCtx.RxWindow2Config.RxContinuous = false;
 800742e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8007432:	f8a5 33de 	strh.w	r3, [r5, #990]	; 0x3de
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 8007436:	f885 63cc 	strb.w	r6, [r5, #972]	; 0x3cc
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800743a:	f505 7773 	add.w	r7, r5, #972	; 0x3cc
 800743e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8007440:	f505 7478 	add.w	r4, r5, #992	; 0x3e0
 8007444:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8007446:	683b      	ldr	r3, [r7, #0]
 8007448:	6023      	str	r3, [r4, #0]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800744a:	f240 2301 	movw	r3, #513	; 0x201
 800744e:	f8a5 33f2 	strh.w	r3, [r5, #1010]	; 0x3f2
    if( MacCtx.MacCallbacks != NULL )
 8007452:	f8d5 3348 	ldr.w	r3, [r5, #840]	; 0x348
    MacCtx.Channel = 0;
 8007456:	f885 6415 	strb.w	r6, [r5, #1045]	; 0x415
    classBCallbacks.MacProcessNotify = NULL;
 800745a:	e9cd 6601 	strd	r6, r6, [sp, #4]
    if( MacCtx.MacCallbacks != NULL )
 800745e:	b11b      	cbz	r3, 8007468 <ResetMacParameters+0xcc>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8007460:	685a      	ldr	r2, [r3, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 8007462:	691b      	ldr	r3, [r3, #16]
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 8007464:	9201      	str	r2, [sp, #4]
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 8007466:	9302      	str	r3, [sp, #8]
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 8007468:	4b10      	ldr	r3, [pc, #64]	; (80074ac <ResetMacParameters+0x110>)
 800746a:	9306      	str	r3, [sp, #24]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 800746c:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
 8007470:	9207      	str	r2, [sp, #28]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 8007472:	f1a3 0214 	sub.w	r2, r3, #20
 8007476:	9208      	str	r2, [sp, #32]
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 8007478:	4a0d      	ldr	r2, [pc, #52]	; (80074b0 <ResetMacParameters+0x114>)
 800747a:	920a      	str	r2, [sp, #40]	; 0x28
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 800747c:	3321      	adds	r3, #33	; 0x21
 800747e:	9309      	str	r3, [sp, #36]	; 0x24
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 8007480:	f1a2 038c 	sub.w	r3, r2, #140	; 0x8c
 8007484:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 8007486:	f1a2 0388 	sub.w	r3, r2, #136	; 0x88
 800748a:	930c      	str	r3, [sp, #48]	; 0x30
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 800748c:	a901      	add	r1, sp, #4
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 800748e:	1d13      	adds	r3, r2, #4
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8007490:	a806      	add	r0, sp, #24
 8007492:	f202 522c 	addw	r2, r2, #1324	; 0x52c
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 8007496:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 8007498:	f002 fa48 	bl	800992c <LoRaMacClassBInit>
}
 800749c:	b00f      	add	sp, #60	; 0x3c
 800749e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80074a0:	200009bc 	.word	0x200009bc
 80074a4:	200004b4 	.word	0x200004b4
 80074a8:	00010100 	.word	0x00010100
 80074ac:	20000914 	.word	0x20000914
 80074b0:	20000a88 	.word	0x20000a88

080074b4 <ScheduleTx>:
{
 80074b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80074b8:	b092      	sub	sp, #72	; 0x48
 80074ba:	4607      	mov	r7, r0
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 80074bc:	f002 fa41 	bl	8009942 <LoRaMacClassBIsBeaconExpected>
 80074c0:	2800      	cmp	r0, #0
 80074c2:	f040 8154 	bne.w	800776e <ScheduleTx+0x2ba>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80074c6:	4dab      	ldr	r5, [pc, #684]	; (8007774 <ScheduleTx+0x2c0>)
 80074c8:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80074cc:	2b01      	cmp	r3, #1
 80074ce:	d009      	beq.n	80074e4 <ScheduleTx+0x30>
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 80074d0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80074d2:	4ca9      	ldr	r4, [pc, #676]	; (8007778 <ScheduleTx+0x2c4>)
 80074d4:	b19b      	cbz	r3, 80074fe <ScheduleTx+0x4a>
    switch( MacCtx.TxMsg.Type )
 80074d6:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
 80074da:	b1c3      	cbz	r3, 800750e <ScheduleTx+0x5a>
 80074dc:	2b04      	cmp	r3, #4
 80074de:	d071      	beq.n	80075c4 <ScheduleTx+0x110>
            return LORAMAC_STATUS_PARAMETER_INVALID;
 80074e0:	2603      	movs	r6, #3
 80074e2:	e003      	b.n	80074ec <ScheduleTx+0x38>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80074e4:	f002 fa2f 	bl	8009946 <LoRaMacClassBIsPingExpected>
 80074e8:	b120      	cbz	r0, 80074f4 <ScheduleTx+0x40>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 80074ea:	260f      	movs	r6, #15
}
 80074ec:	4630      	mov	r0, r6
 80074ee:	b012      	add	sp, #72	; 0x48
 80074f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 80074f4:	f002 fa29 	bl	800994a <LoRaMacClassBIsMulticastExpected>
 80074f8:	2800      	cmp	r0, #0
 80074fa:	d0e9      	beq.n	80074d0 <ScheduleTx+0x1c>
 80074fc:	e7f5      	b.n	80074ea <ScheduleTx+0x36>
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 80074fe:	f8b5 3102 	ldrh.w	r3, [r5, #258]	; 0x102
 8007502:	1e5a      	subs	r2, r3, #1
 8007504:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
 8007508:	4353      	muls	r3, r2
 800750a:	632b      	str	r3, [r5, #48]	; 0x30
 800750c:	e7e3      	b.n	80074d6 <ScheduleTx+0x22>
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 800750e:	489b      	ldr	r0, [pc, #620]	; (800777c <ScheduleTx+0x2c8>)
 8007510:	f002 ffd9 	bl	800a4c6 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 8007514:	2800      	cmp	r0, #0
 8007516:	f040 8126 	bne.w	8007766 <ScheduleTx+0x2b2>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 800751a:	f894 310c 	ldrb.w	r3, [r4, #268]	; 0x10c
 800751e:	8023      	strh	r3, [r4, #0]
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 8007520:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8007522:	930c      	str	r3, [sp, #48]	; 0x30
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8007524:	f10d 0818 	add.w	r8, sp, #24
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8007528:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 800752c:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8007530:	4640      	mov	r0, r8
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 8007532:	f895 3100 	ldrb.w	r3, [r5, #256]	; 0x100
 8007536:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800753a:	f007 ff59 	bl	800f3f0 <SysTimeGetMcuTime>
 800753e:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 8007542:	9300      	str	r3, [sp, #0]
 8007544:	ae02      	add	r6, sp, #8
 8007546:	e898 0006 	ldmia.w	r8, {r1, r2}
 800754a:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
 800754e:	4630      	mov	r0, r6
 8007550:	f007 fee4 	bl	800f31c <SysTimeSub>
 8007554:	e896 0003 	ldmia.w	r6, {r0, r1}
 8007558:	ab0f      	add	r3, sp, #60	; 0x3c
 800755a:	e883 0003 	stmia.w	r3, {r0, r1}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 800755e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8007560:	930d      	str	r3, [sp, #52]	; 0x34
    nextChan.LastTxIsJoinRequest = false;
 8007562:	2300      	movs	r3, #0
 8007564:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    nextChan.PktLen = MacCtx.PktBufferLen;
 8007568:	8823      	ldrh	r3, [r4, #0]
 800756a:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800756e:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
    nextChan.Joined = true;
 8007572:	2201      	movs	r2, #1
 8007574:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8007578:	b91b      	cbnz	r3, 8007582 <ScheduleTx+0xce>
        nextChan.LastTxIsJoinRequest = true;
 800757a:	f88d 2044 	strb.w	r2, [sp, #68]	; 0x44
        nextChan.Joined = false;
 800757e:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 8007582:	4b7f      	ldr	r3, [pc, #508]	; (8007780 <ScheduleTx+0x2cc>)
 8007584:	9300      	str	r3, [sp, #0]
 8007586:	4b7f      	ldr	r3, [pc, #508]	; (8007784 <ScheduleTx+0x2d0>)
 8007588:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 800758c:	f1a3 026f 	sub.w	r2, r3, #111	; 0x6f
 8007590:	a90c      	add	r1, sp, #48	; 0x30
 8007592:	f003 f914 	bl	800a7be <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 8007596:	4606      	mov	r6, r0
 8007598:	b1c0      	cbz	r0, 80075cc <ScheduleTx+0x118>
        if( ( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED ) &&
 800759a:	280b      	cmp	r0, #11
 800759c:	d1a6      	bne.n	80074ec <ScheduleTx+0x38>
 800759e:	2f00      	cmp	r7, #0
 80075a0:	d0a4      	beq.n	80074ec <ScheduleTx+0x38>
            if( MacCtx.DutyCycleWaitTime != 0 )
 80075a2:	f8d4 1484 	ldr.w	r1, [r4, #1156]	; 0x484
 80075a6:	b159      	cbz	r1, 80075c0 <ScheduleTx+0x10c>
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80075a8:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80075ac:	4876      	ldr	r0, [pc, #472]	; (8007788 <ScheduleTx+0x2d4>)
                MacCtx.MacState |= LORAMAC_TX_DELAYED;
 80075ae:	f043 0320 	orr.w	r3, r3, #32
 80075b2:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
                TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 80075b6:	f008 f86d 	bl	800f694 <UTIL_TIMER_SetPeriod>
                TimerStart( &MacCtx.TxDelayedTimer );
 80075ba:	4873      	ldr	r0, [pc, #460]	; (8007788 <ScheduleTx+0x2d4>)
 80075bc:	f008 f830 	bl	800f620 <UTIL_TIMER_Start>
            return LORAMAC_STATUS_OK;
 80075c0:	2600      	movs	r6, #0
 80075c2:	e793      	b.n	80074ec <ScheduleTx+0x38>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 80075c4:	486d      	ldr	r0, [pc, #436]	; (800777c <ScheduleTx+0x2c8>)
 80075c6:	f002 ffb2 	bl	800a52e <LoRaMacSerializerData>
 80075ca:	e7a3      	b.n	8007514 <ScheduleTx+0x60>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075cc:	f895 8040 	ldrb.w	r8, [r5, #64]	; 0x40
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 80075d0:	f995 3061 	ldrsb.w	r3, [r5, #97]	; 0x61
 80075d4:	f995 2039 	ldrsb.w	r2, [r5, #57]	; 0x39
 80075d8:	f895 1075 	ldrb.w	r1, [r5, #117]	; 0x75
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075dc:	4f6b      	ldr	r7, [pc, #428]	; (800778c <ScheduleTx+0x2d8>)
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 80075de:	4640      	mov	r0, r8
 80075e0:	f003 f90b 	bl	800a7fa <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075e4:	9700      	str	r7, [sp, #0]
 80075e6:	b241      	sxtb	r1, r0
 80075e8:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80075ea:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 80075ee:	4640      	mov	r0, r8
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075f0:	3714      	adds	r7, #20
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075f2:	f003 f860 	bl	800a6b6 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80075f6:	9700      	str	r7, [sp, #0]
 80075f8:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80075fa:	f995 1068 	ldrsb.w	r1, [r5, #104]	; 0x68
 80075fe:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 8007602:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 8007606:	f003 f856 	bl	800a6b6 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800760a:	f8d4 03d8 	ldr.w	r0, [r4, #984]	; 0x3d8
 800760e:	6d69      	ldr	r1, [r5, #84]	; 0x54
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8007610:	f8d4 73c4 	ldr.w	r7, [r4, #964]	; 0x3c4
 8007614:	6d2b      	ldr	r3, [r5, #80]	; 0x50
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8007616:	4401      	add	r1, r0
 8007618:	f8c4 13b4 	str.w	r1, [r4, #948]	; 0x3b4
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 800761c:	f895 1110 	ldrb.w	r1, [r5, #272]	; 0x110
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8007620:	443b      	add	r3, r7
 8007622:	f8c4 33b0 	str.w	r3, [r4, #944]	; 0x3b0
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8007626:	b939      	cbnz	r1, 8007638 <ScheduleTx+0x184>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8007628:	6daa      	ldr	r2, [r5, #88]	; 0x58
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800762a:	6deb      	ldr	r3, [r5, #92]	; 0x5c
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 800762c:	443a      	add	r2, r7
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 800762e:	4403      	add	r3, r0
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 8007630:	f8c4 23b0 	str.w	r2, [r4, #944]	; 0x3b0
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 8007634:	f8c4 33b4 	str.w	r3, [r4, #948]	; 0x3b4
    size_t macCmdsSize = 0;
 8007638:	2300      	movs	r3, #0
 800763a:	9308      	str	r3, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800763c:	b181      	cbz	r1, 8007660 <ScheduleTx+0x1ac>
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800763e:	a808      	add	r0, sp, #32
 8007640:	f002 fa44 	bl	8009acc <LoRaMacCommandsGetSizeSerializedCmds>
 8007644:	2800      	cmp	r0, #0
 8007646:	d148      	bne.n	80076da <ScheduleTx+0x226>
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8007648:	f995 0039 	ldrsb.w	r0, [r5, #57]	; 0x39
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 800764c:	f894 7237 	ldrb.w	r7, [r4, #567]	; 0x237
 8007650:	f89d 8020 	ldrb.w	r8, [sp, #32]
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8007654:	f7ff fd52 	bl	80070fc <GetMaxAppPayloadWithoutFOptsLength>
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 8007658:	4447      	add	r7, r8
 800765a:	b280      	uxth	r0, r0
 800765c:	42b8      	cmp	r0, r7
 800765e:	d33a      	bcc.n	80076d6 <ScheduleTx+0x222>
    int8_t txPower = 0;
 8007660:	2300      	movs	r3, #0
 8007662:	f88d 3013 	strb.w	r3, [sp, #19]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8007666:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 800766a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 800766e:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 8007672:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 8007676:	6fab      	ldr	r3, [r5, #120]	; 0x78
 8007678:	9309      	str	r3, [sp, #36]	; 0x24
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800767a:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 800767c:	930a      	str	r3, [sp, #40]	; 0x28
    txConfig.PktLen = MacCtx.PktBufferLen;
 800767e:	8823      	ldrh	r3, [r4, #0]
    return SendFrameOnChannel( MacCtx.Channel );
 8007680:	f894 7415 	ldrb.w	r7, [r4, #1045]	; 0x415
    txConfig.PktLen = MacCtx.PktBufferLen;
 8007684:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 8007688:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 800768c:	4b40      	ldr	r3, [pc, #256]	; (8007790 <ScheduleTx+0x2dc>)
    txConfig.Channel = channel;
 800768e:	f88d 7020 	strb.w	r7, [sp, #32]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 8007692:	f10d 0213 	add.w	r2, sp, #19
 8007696:	a908      	add	r1, sp, #32
 8007698:	f003 f82c 	bl	800a6f4 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800769c:	2301      	movs	r3, #1
 800769e:	f884 3439 	strb.w	r3, [r4, #1081]	; 0x439
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80076a2:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 80076a6:	f884 343a 	strb.w	r3, [r4, #1082]	; 0x43a
    MacCtx.McpsConfirm.TxPower = txPower;
 80076aa:	f89d 3013 	ldrb.w	r3, [sp, #19]
 80076ae:	f884 343b 	strb.w	r3, [r4, #1083]	; 0x43b
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80076b2:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
    MacCtx.McpsConfirm.Channel = channel;
 80076b6:	f8c4 7448 	str.w	r7, [r4, #1096]	; 0x448
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80076ba:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 80076be:	f8c4 3450 	str.w	r3, [r4, #1104]	; 0x450
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 80076c2:	f002 f944 	bl	800994e <LoRaMacClassBIsBeaconModeActive>
 80076c6:	b150      	cbz	r0, 80076de <ScheduleTx+0x22a>
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 80076c8:	f8d4 0418 	ldr.w	r0, [r4, #1048]	; 0x418
 80076cc:	f002 f951 	bl	8009972 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 80076d0:	b128      	cbz	r0, 80076de <ScheduleTx+0x22a>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 80076d2:	2610      	movs	r6, #16
    return SendFrameOnChannel( MacCtx.Channel );
 80076d4:	e70a      	b.n	80074ec <ScheduleTx+0x38>
            return LORAMAC_STATUS_LENGTH_ERROR;
 80076d6:	2608      	movs	r6, #8
 80076d8:	e708      	b.n	80074ec <ScheduleTx+0x38>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80076da:	2613      	movs	r6, #19
 80076dc:	e706      	b.n	80074ec <ScheduleTx+0x38>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80076de:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80076e2:	2b01      	cmp	r3, #1
 80076e4:	d101      	bne.n	80076ea <ScheduleTx+0x236>
        LoRaMacClassBStopRxSlots( );
 80076e6:	f002 f946 	bl	8009976 <LoRaMacClassBStopRxSlots>
    LoRaMacClassBHaltBeaconing( );
 80076ea:	f002 f933 	bl	8009954 <LoRaMacClassBHaltBeaconing>
    uint32_t fCntUp = 0;
 80076ee:	2300      	movs	r3, #0
 80076f0:	9305      	str	r3, [sp, #20]
    switch( MacCtx.TxMsg.Type )
 80076f2:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 80076f6:	f995 5039 	ldrsb.w	r5, [r5, #57]	; 0x39
 80076fa:	f894 7415 	ldrb.w	r7, [r4, #1045]	; 0x415
    switch( MacCtx.TxMsg.Type )
 80076fe:	b1bb      	cbz	r3, 8007730 <ScheduleTx+0x27c>
 8007700:	2b04      	cmp	r3, #4
 8007702:	f47f aeed 	bne.w	80074e0 <ScheduleTx+0x2c>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8007706:	a805      	add	r0, sp, #20
 8007708:	f002 fc44 	bl	8009f94 <LoRaMacCryptoGetFCntUp>
 800770c:	bb68      	cbnz	r0, 800776a <ScheduleTx+0x2b6>
            if( ( MacCtx.ChannelsNbTransCounter >= 1 ) || ( MacCtx.AckTimeoutRetriesCounter > 1 ) )
 800770e:	f894 3410 	ldrb.w	r3, [r4, #1040]	; 0x410
 8007712:	b91b      	cbnz	r3, 800771c <ScheduleTx+0x268>
 8007714:	f894 3412 	ldrb.w	r3, [r4, #1042]	; 0x412
 8007718:	2b01      	cmp	r3, #1
 800771a:	d902      	bls.n	8007722 <ScheduleTx+0x26e>
                fCntUp -= 1;
 800771c:	9b05      	ldr	r3, [sp, #20]
 800771e:	3b01      	subs	r3, #1
 8007720:	9305      	str	r3, [sp, #20]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 8007722:	4b16      	ldr	r3, [pc, #88]	; (800777c <ScheduleTx+0x2c8>)
 8007724:	9805      	ldr	r0, [sp, #20]
 8007726:	463a      	mov	r2, r7
 8007728:	b2e9      	uxtb	r1, r5
 800772a:	f002 fca9 	bl	800a080 <LoRaMacCryptoSecureMessage>
 800772e:	e002      	b.n	8007736 <ScheduleTx+0x282>
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 8007730:	4812      	ldr	r0, [pc, #72]	; (800777c <ScheduleTx+0x2c8>)
 8007732:	f002 fc7d 	bl	800a030 <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 8007736:	b9b0      	cbnz	r0, 8007766 <ScheduleTx+0x2b2>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 8007738:	f894 310c 	ldrb.w	r3, [r4, #268]	; 0x10c
 800773c:	8023      	strh	r3, [r4, #0]
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800773e:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 8007742:	f043 0302 	orr.w	r3, r3, #2
 8007746:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
    if( MacCtx.NodeAckRequested == false )
 800774a:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 800774e:	b923      	cbnz	r3, 800775a <ScheduleTx+0x2a6>
        MacCtx.ChannelsNbTransCounter++;
 8007750:	f894 3410 	ldrb.w	r3, [r4, #1040]	; 0x410
 8007754:	3301      	adds	r3, #1
 8007756:	f884 3410 	strb.w	r3, [r4, #1040]	; 0x410
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 800775a:	4b0e      	ldr	r3, [pc, #56]	; (8007794 <ScheduleTx+0x2e0>)
 800775c:	7821      	ldrb	r1, [r4, #0]
 800775e:	480e      	ldr	r0, [pc, #56]	; (8007798 <ScheduleTx+0x2e4>)
 8007760:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007762:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 8007764:	e6c2      	b.n	80074ec <ScheduleTx+0x38>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 8007766:	2611      	movs	r6, #17
 8007768:	e6c0      	b.n	80074ec <ScheduleTx+0x38>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 800776a:	2612      	movs	r6, #18
 800776c:	e6be      	b.n	80074ec <ScheduleTx+0x38>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 800776e:	260e      	movs	r6, #14
 8007770:	e6bc      	b.n	80074ec <ScheduleTx+0x38>
 8007772:	bf00      	nop
 8007774:	200009bc 	.word	0x200009bc
 8007778:	200004b4 	.word	0x200004b4
 800777c:	200005bc 	.word	0x200005bc
 8007780:	200009ec 	.word	0x200009ec
 8007784:	20000938 	.word	0x20000938
 8007788:	2000081c 	.word	0x2000081c
 800778c:	2000086c 	.word	0x2000086c
 8007790:	200008cc 	.word	0x200008cc
 8007794:	08010fe4 	.word	0x08010fe4
 8007798:	200004b6 	.word	0x200004b6

0800779c <OnTxDelayedTimerEvent>:
{
 800779c:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 800779e:	4c12      	ldr	r4, [pc, #72]	; (80077e8 <OnTxDelayedTimerEvent+0x4c>)
 80077a0:	f504 705a 	add.w	r0, r4, #872	; 0x368
 80077a4:	f007 feec 	bl	800f580 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80077a8:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
    switch( ScheduleTx( true ) )
 80077ac:	2001      	movs	r0, #1
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 80077ae:	f023 0320 	bic.w	r3, r3, #32
 80077b2:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
    switch( ScheduleTx( true ) )
 80077b6:	f7ff fe7d 	bl	80074b4 <ScheduleTx>
 80077ba:	b198      	cbz	r0, 80077e4 <OnTxDelayedTimerEvent+0x48>
 80077bc:	280b      	cmp	r0, #11
 80077be:	d011      	beq.n	80077e4 <OnTxDelayedTimerEvent+0x48>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80077c0:	4b0a      	ldr	r3, [pc, #40]	; (80077ec <OnTxDelayedTimerEvent+0x50>)
 80077c2:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 80077c6:	f884 343a 	strb.w	r3, [r4, #1082]	; 0x43a
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80077ca:	2009      	movs	r0, #9
            MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 80077cc:	f894 3412 	ldrb.w	r3, [r4, #1042]	; 0x412
 80077d0:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 80077d4:	f884 0439 	strb.w	r0, [r4, #1081]	; 0x439
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 80077d8:	f002 fa60 	bl	8009c9c <LoRaMacConfirmQueueSetStatusCmn>
}
 80077dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            StopRetransmission( );
 80077e0:	f7ff bc68 	b.w	80070b4 <StopRetransmission>
}
 80077e4:	bd10      	pop	{r4, pc}
 80077e6:	bf00      	nop
 80077e8:	200004b4 	.word	0x200004b4
 80077ec:	200009bc 	.word	0x200009bc

080077f0 <OpenContinuousRxCWindow>:
{
 80077f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 80077f2:	4c12      	ldr	r4, [pc, #72]	; (800783c <OpenContinuousRxCWindow+0x4c>)
 80077f4:	4d12      	ldr	r5, [pc, #72]	; (8007840 <OpenContinuousRxCWindow+0x50>)
 80077f6:	f504 7678 	add.w	r6, r4, #992	; 0x3e0
 80077fa:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80077fc:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
 8007800:	f995 1070 	ldrsb.w	r1, [r5, #112]	; 0x70
 8007804:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 8007808:	9600      	str	r6, [sp, #0]
 800780a:	f002 ff54 	bl	800a6b6 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxContinuous = true;
 800780e:	f240 2301 	movw	r3, #513	; 0x201
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8007812:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
    MacCtx.RxWindowCConfig.RxContinuous = true;
 8007816:	f8a4 33f2 	strh.w	r3, [r4, #1010]	; 0x3f2
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 800781a:	f504 6284 	add.w	r2, r4, #1056	; 0x420
 800781e:	4631      	mov	r1, r6
 8007820:	f002 ff5b 	bl	800a6da <RegionRxConfig>
 8007824:	b138      	cbz	r0, 8007836 <OpenContinuousRxCWindow+0x46>
        Radio.Rx( 0 ); // Continuous mode
 8007826:	4b07      	ldr	r3, [pc, #28]	; (8007844 <OpenContinuousRxCWindow+0x54>)
 8007828:	2000      	movs	r0, #0
 800782a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800782c:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 800782e:	f894 33f3 	ldrb.w	r3, [r4, #1011]	; 0x3f3
 8007832:	f884 3480 	strb.w	r3, [r4, #1152]	; 0x480
}
 8007836:	b002      	add	sp, #8
 8007838:	bd70      	pop	{r4, r5, r6, pc}
 800783a:	bf00      	nop
 800783c:	200004b4 	.word	0x200004b4
 8007840:	200009bc 	.word	0x200009bc
 8007844:	08010fe4 	.word	0x08010fe4

08007848 <SwitchClass>:
{
 8007848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    switch( Nvm.MacGroup2.DeviceClass )
 800784a:	4d2f      	ldr	r5, [pc, #188]	; (8007908 <SwitchClass+0xc0>)
 800784c:	f895 40fc 	ldrb.w	r4, [r5, #252]	; 0xfc
 8007850:	2c01      	cmp	r4, #1
{
 8007852:	4606      	mov	r6, r0
    switch( Nvm.MacGroup2.DeviceClass )
 8007854:	d047      	beq.n	80078e6 <SwitchClass+0x9e>
 8007856:	2c02      	cmp	r4, #2
 8007858:	d04d      	beq.n	80078f6 <SwitchClass+0xae>
 800785a:	b934      	cbnz	r4, 800786a <SwitchClass+0x22>
            if( deviceClass == CLASS_A )
 800785c:	b938      	cbnz	r0, 800786e <SwitchClass+0x26>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 800785e:	e9d5 0119 	ldrd	r0, r1, [r5, #100]	; 0x64
 8007862:	f105 036c 	add.w	r3, r5, #108	; 0x6c
 8007866:	e883 0003 	stmia.w	r3, {r0, r1}
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 800786a:	2403      	movs	r4, #3
 800786c:	e039      	b.n	80078e2 <SwitchClass+0x9a>
            if( deviceClass == CLASS_B )
 800786e:	2801      	cmp	r0, #1
 8007870:	d039      	beq.n	80078e6 <SwitchClass+0x9e>
            if( deviceClass == CLASS_C )
 8007872:	2802      	cmp	r0, #2
 8007874:	d1f9      	bne.n	800786a <SwitchClass+0x22>
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8007876:	4f25      	ldr	r7, [pc, #148]	; (800790c <SwitchClass+0xc4>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 8007878:	f885 00fc 	strb.w	r0, [r5, #252]	; 0xfc
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 800787c:	f507 7e73 	add.w	lr, r7, #972	; 0x3cc
 8007880:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8007884:	f507 7c78 	add.w	ip, r7, #992	; 0x3e0
 8007888:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 800788c:	f895 20d2 	ldrb.w	r2, [r5, #210]	; 0xd2
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 8007890:	f8de 3000 	ldr.w	r3, [lr]
 8007894:	f8cc 3000 	str.w	r3, [ip]
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 8007898:	f887 63f3 	strb.w	r6, [r7, #1011]	; 0x3f3
                    if( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true )
 800789c:	463b      	mov	r3, r7
 800789e:	b1c2      	cbz	r2, 80078d2 <SwitchClass+0x8a>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Frequency;
 80078a0:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 80078a4:	66ea      	str	r2, [r5, #108]	; 0x6c
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 80078a6:	f8c7 23e4 	str.w	r2, [r7, #996]	; 0x3e4
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80078aa:	f895 2075 	ldrb.w	r2, [r5, #117]	; 0x75
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80078ae:	f895 10ec 	ldrb.w	r1, [r5, #236]	; 0xec
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80078b2:	f887 23f0 	strb.w	r2, [r7, #1008]	; 0x3f0
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80078b6:	f895 2080 	ldrb.w	r2, [r5, #128]	; 0x80
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.ClassC.Datarate;
 80078ba:	f885 1070 	strb.w	r1, [r5, #112]	; 0x70
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80078be:	f887 23f1 	strb.w	r2, [r7, #1009]	; 0x3f1
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 80078c2:	f897 1415 	ldrb.w	r1, [r7, #1045]	; 0x415
 80078c6:	f887 13e0 	strb.w	r1, [r7, #992]	; 0x3e0
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 80078ca:	f240 3201 	movw	r2, #769	; 0x301
 80078ce:	f8a7 23f2 	strh.w	r2, [r7, #1010]	; 0x3f2
                MacCtx.NodeAckRequested = false;
 80078d2:	2200      	movs	r2, #0
 80078d4:	f883 2414 	strb.w	r2, [r3, #1044]	; 0x414
                Radio.Sleep( );
 80078d8:	4b0d      	ldr	r3, [pc, #52]	; (8007910 <SwitchClass+0xc8>)
 80078da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80078dc:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 80078de:	f7ff ff87 	bl	80077f0 <OpenContinuousRxCWindow>
}
 80078e2:	4620      	mov	r0, r4
 80078e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            status = LoRaMacClassBSwitchClass( deviceClass );
 80078e6:	f002 f837 	bl	8009958 <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 80078ea:	4604      	mov	r4, r0
 80078ec:	2800      	cmp	r0, #0
 80078ee:	d1f8      	bne.n	80078e2 <SwitchClass+0x9a>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 80078f0:	f885 60fc 	strb.w	r6, [r5, #252]	; 0xfc
 80078f4:	e7f5      	b.n	80078e2 <SwitchClass+0x9a>
            if( deviceClass == CLASS_A )
 80078f6:	2800      	cmp	r0, #0
 80078f8:	d1b7      	bne.n	800786a <SwitchClass+0x22>
                Radio.Sleep( );
 80078fa:	4b05      	ldr	r3, [pc, #20]	; (8007910 <SwitchClass+0xc8>)
                Nvm.MacGroup2.DeviceClass = deviceClass;
 80078fc:	f885 00fc 	strb.w	r0, [r5, #252]	; 0xfc
                Radio.Sleep( );
 8007900:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007902:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 8007904:	4634      	mov	r4, r6
 8007906:	e7ec      	b.n	80078e2 <SwitchClass+0x9a>
 8007908:	200009bc 	.word	0x200009bc
 800790c:	200004b4 	.word	0x200004b4
 8007910:	08010fe4 	.word	0x08010fe4

08007914 <RxWindowSetup.constprop.0>:
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 8007914:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    Radio.Standby( );
 8007916:	4f0b      	ldr	r7, [pc, #44]	; (8007944 <RxWindowSetup.constprop.0+0x30>)
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8007918:	4d0b      	ldr	r5, [pc, #44]	; (8007948 <RxWindowSetup.constprop.0+0x34>)
 800791a:	4e0c      	ldr	r6, [pc, #48]	; (800794c <RxWindowSetup.constprop.0+0x38>)
static void RxWindowSetup( TimerEvent_t* rxTimer, RxConfigParams_t* rxConfig )
 800791c:	460c      	mov	r4, r1
    TimerStop( rxTimer );
 800791e:	f007 fe2f 	bl	800f580 <UTIL_TIMER_Stop>
    Radio.Standby( );
 8007922:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007924:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 8007926:	f896 0040 	ldrb.w	r0, [r6, #64]	; 0x40
 800792a:	f505 6284 	add.w	r2, r5, #1056	; 0x420
 800792e:	4621      	mov	r1, r4
 8007930:	f002 fed3 	bl	800a6da <RegionRxConfig>
 8007934:	b128      	cbz	r0, 8007942 <RxWindowSetup.constprop.0+0x2e>
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 8007936:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8007938:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
 800793a:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 800793c:	7ce3      	ldrb	r3, [r4, #19]
 800793e:	f885 3480 	strb.w	r3, [r5, #1152]	; 0x480
}
 8007942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007944:	08010fe4 	.word	0x08010fe4
 8007948:	200004b4 	.word	0x200004b4
 800794c:	200009bc 	.word	0x200009bc

08007950 <OnRxWindow1TimerEvent>:
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 8007950:	480d      	ldr	r0, [pc, #52]	; (8007988 <OnRxWindow1TimerEvent+0x38>)
 8007952:	f890 3415 	ldrb.w	r3, [r0, #1045]	; 0x415
 8007956:	f880 33b8 	strb.w	r3, [r0, #952]	; 0x3b8
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 800795a:	4b0c      	ldr	r3, [pc, #48]	; (800798c <OnRxWindow1TimerEvent+0x3c>)
 800795c:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
 8007960:	f880 23bb 	strb.w	r2, [r0, #955]	; 0x3bb
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8007964:	f893 2075 	ldrb.w	r2, [r3, #117]	; 0x75
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 8007968:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800796c:	f880 33c9 	strb.w	r3, [r0, #969]	; 0x3c9
    MacCtx.RxWindow1Config.RxContinuous = false;
 8007970:	2300      	movs	r3, #0
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8007972:	f880 23c8 	strb.w	r2, [r0, #968]	; 0x3c8
    MacCtx.RxWindow1Config.RxContinuous = false;
 8007976:	f8a0 33ca 	strh.w	r3, [r0, #970]	; 0x3ca
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 800797a:	f500 716e 	add.w	r1, r0, #952	; 0x3b8
 800797e:	f500 7060 	add.w	r0, r0, #896	; 0x380
 8007982:	f7ff bfc7 	b.w	8007914 <RxWindowSetup.constprop.0>
 8007986:	bf00      	nop
 8007988:	200004b4 	.word	0x200004b4
 800798c:	200009bc 	.word	0x200009bc

08007990 <OnRxWindow2TimerEvent>:
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 8007990:	480f      	ldr	r0, [pc, #60]	; (80079d0 <OnRxWindow2TimerEvent+0x40>)
 8007992:	f890 3480 	ldrb.w	r3, [r0, #1152]	; 0x480
 8007996:	b1cb      	cbz	r3, 80079cc <OnRxWindow2TimerEvent+0x3c>
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 8007998:	f890 3415 	ldrb.w	r3, [r0, #1045]	; 0x415
 800799c:	f880 33cc 	strb.w	r3, [r0, #972]	; 0x3cc
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 80079a0:	4b0c      	ldr	r3, [pc, #48]	; (80079d4 <OnRxWindow2TimerEvent+0x44>)
 80079a2:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80079a4:	f8c0 23d0 	str.w	r2, [r0, #976]	; 0x3d0
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80079a8:	f893 2075 	ldrb.w	r2, [r3, #117]	; 0x75
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport; /* ST_WORKAROUND: Keep repeater feature */
 80079ac:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 80079b0:	f880 33dd 	strb.w	r3, [r0, #989]	; 0x3dd
    MacCtx.RxWindow2Config.RxContinuous = false;
 80079b4:	f44f 7380 	mov.w	r3, #256	; 0x100
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80079b8:	f880 23dc 	strb.w	r2, [r0, #988]	; 0x3dc
    MacCtx.RxWindow2Config.RxContinuous = false;
 80079bc:	f8a0 33de 	strh.w	r3, [r0, #990]	; 0x3de
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 80079c0:	f500 7173 	add.w	r1, r0, #972	; 0x3cc
 80079c4:	f500 7066 	add.w	r0, r0, #920	; 0x398
 80079c8:	f7ff bfa4 	b.w	8007914 <RxWindowSetup.constprop.0>
}
 80079cc:	4770      	bx	lr
 80079ce:	bf00      	nop
 80079d0:	200004b4 	.word	0x200004b4
 80079d4:	200009bc 	.word	0x200009bc

080079d8 <ProcessMacCommands.isra.0.constprop.0>:
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80079d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80079dc:	b091      	sub	sp, #68	; 0x44
    uint8_t status = 0;
 80079de:	2700      	movs	r7, #0
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 80079e0:	4ec5      	ldr	r6, [pc, #788]	; (8007cf8 <ProcessMacCommands.isra.0.constprop.0+0x320>)
    uint8_t status = 0;
 80079e2:	f88d 7015 	strb.w	r7, [sp, #21]
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 80079e6:	4605      	mov	r5, r0
 80079e8:	4688      	mov	r8, r1
 80079ea:	4693      	mov	fp, r2
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 80079ec:	f8ad 7018 	strh.w	r7, [sp, #24]
    while( macIndex < commandsSize )
 80079f0:	46b9      	mov	r9, r7
 80079f2:	45c1      	cmp	r9, r8
 80079f4:	d302      	bcc.n	80079fc <ProcessMacCommands.isra.0.constprop.0+0x24>
}
 80079f6:	b011      	add	sp, #68	; 0x44
 80079f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 80079fc:	f815 0009 	ldrb.w	r0, [r5, r9]
 8007a00:	f002 f8b6 	bl	8009b70 <LoRaMacCommandsGetCmdSize>
 8007a04:	4448      	add	r0, r9
 8007a06:	4540      	cmp	r0, r8
 8007a08:	dcf5      	bgt.n	80079f6 <ProcessMacCommands.isra.0.constprop.0+0x1e>
        switch( payload[macIndex++] )
 8007a0a:	f815 3009 	ldrb.w	r3, [r5, r9]
 8007a0e:	f109 0401 	add.w	r4, r9, #1
 8007a12:	3b02      	subs	r3, #2
 8007a14:	b2e4      	uxtb	r4, r4
 8007a16:	2b11      	cmp	r3, #17
 8007a18:	d8ed      	bhi.n	80079f6 <ProcessMacCommands.isra.0.constprop.0+0x1e>
 8007a1a:	a201      	add	r2, pc, #4	; (adr r2, 8007a20 <ProcessMacCommands.isra.0.constprop.0+0x48>)
 8007a1c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007a20:	08007a69 	.word	0x08007a69
 8007a24:	08007a99 	.word	0x08007a99
 8007a28:	08007b57 	.word	0x08007b57
 8007a2c:	08007b81 	.word	0x08007b81
 8007a30:	08007c1d 	.word	0x08007c1d
 8007a34:	08007c45 	.word	0x08007c45
 8007a38:	08007cb9 	.word	0x08007cb9
 8007a3c:	08007d01 	.word	0x08007d01
 8007a40:	08007d89 	.word	0x08007d89
 8007a44:	080079f7 	.word	0x080079f7
 8007a48:	080079f7 	.word	0x080079f7
 8007a4c:	08007de9 	.word	0x08007de9
 8007a50:	080079f7 	.word	0x080079f7
 8007a54:	080079f7 	.word	0x080079f7
 8007a58:	08007e9f 	.word	0x08007e9f
 8007a5c:	08007ec5 	.word	0x08007ec5
 8007a60:	08007f09 	.word	0x08007f09
 8007a64:	08007f47 	.word	0x08007f47
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 8007a68:	2004      	movs	r0, #4
 8007a6a:	f002 f931 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8007a6e:	b188      	cbz	r0, 8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 8007a70:	2104      	movs	r1, #4
 8007a72:	2000      	movs	r0, #0
 8007a74:	f002 f8f0 	bl	8009c58 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8007a78:	5d2b      	ldrb	r3, [r5, r4]
 8007a7a:	f886 3454 	strb.w	r3, [r6, #1108]	; 0x454
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8007a7e:	f109 0403 	add.w	r4, r9, #3
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 8007a82:	f109 0902 	add.w	r9, r9, #2
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 8007a86:	fa5f f989 	uxtb.w	r9, r9
 8007a8a:	b2e4      	uxtb	r4, r4
 8007a8c:	f815 3009 	ldrb.w	r3, [r5, r9]
 8007a90:	f886 3455 	strb.w	r3, [r6, #1109]	; 0x455
                uint8_t eirpDwellTime = payload[macIndex++];
 8007a94:	46a1      	mov	r9, r4
 8007a96:	e7ac      	b.n	80079f2 <ProcessMacCommands.isra.0.constprop.0+0x1a>
                int8_t linkAdrDatarate = DR_0;
 8007a98:	2300      	movs	r3, #0
 8007a9a:	f88d 3016 	strb.w	r3, [sp, #22]
                int8_t linkAdrTxPower = TX_POWER_0;
 8007a9e:	f88d 3017 	strb.w	r3, [sp, #23]
                uint8_t linkAdrNbRep = 0;
 8007aa2:	f88d 301c 	strb.w	r3, [sp, #28]
                uint8_t linkAdrNbBytesParsed = 0;
 8007aa6:	f88d 3020 	strb.w	r3, [sp, #32]
                if( adrBlockFound == false )
 8007aaa:	2f00      	cmp	r7, #0
 8007aac:	d151      	bne.n	8007b52 <ProcessMacCommands.isra.0.constprop.0+0x17a>
                    linkAdrReq.Payload = &payload[macIndex - 1];
 8007aae:	3c01      	subs	r4, #1
 8007ab0:	442c      	add	r4, r5
 8007ab2:	940d      	str	r4, [sp, #52]	; 0x34
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8007ab4:	4c91      	ldr	r4, [pc, #580]	; (8007cfc <ProcessMacCommands.isra.0.constprop.0+0x324>)
                    linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 8007ab6:	eba8 0309 	sub.w	r3, r8, r9
 8007aba:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                    linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8007abe:	f894 30fe 	ldrb.w	r3, [r4, #254]	; 0xfe
 8007ac2:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
                    linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8007ac6:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8007aca:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
                    linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8007ace:	f894 3039 	ldrb.w	r3, [r4, #57]	; 0x39
 8007ad2:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
                    linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8007ad6:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8007ada:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
                    linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8007ade:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 8007ae2:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
                    linkAdrReq.Version = Nvm.MacGroup2.Version;
 8007ae6:	f8d4 310c 	ldr.w	r3, [r4, #268]	; 0x10c
 8007aea:	930c      	str	r3, [sp, #48]	; 0x30
                    status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 8007aec:	ab08      	add	r3, sp, #32
 8007aee:	9301      	str	r3, [sp, #4]
 8007af0:	ab07      	add	r3, sp, #28
 8007af2:	9300      	str	r3, [sp, #0]
 8007af4:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
 8007af8:	f10d 0317 	add.w	r3, sp, #23
 8007afc:	f10d 0216 	add.w	r2, sp, #22
 8007b00:	a90c      	add	r1, sp, #48	; 0x30
 8007b02:	f002 fe09 	bl	800a718 <RegionLinkAdrReq>
 8007b06:	f88d 0015 	strb.w	r0, [sp, #21]
                    if( ( status & 0x07 ) == 0x07 )
 8007b0a:	f000 0007 	and.w	r0, r0, #7
 8007b0e:	2807      	cmp	r0, #7
 8007b10:	d10b      	bne.n	8007b2a <ProcessMacCommands.isra.0.constprop.0+0x152>
                        Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 8007b12:	f89d 3016 	ldrb.w	r3, [sp, #22]
 8007b16:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
                        Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 8007b1a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8007b1e:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
                        Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 8007b22:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8007b26:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
static void ProcessMacCommands( uint8_t *payload, uint8_t macIndex, uint8_t commandsSize, int8_t snr, LoRaMacRxSlot_t rxSlot )
 8007b2a:	2700      	movs	r7, #0
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8007b2c:	f04f 0a05 	mov.w	sl, #5
 8007b30:	e006      	b.n	8007b40 <ProcessMacCommands.isra.0.constprop.0+0x168>
                        LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 8007b32:	2201      	movs	r2, #1
 8007b34:	f10d 0115 	add.w	r1, sp, #21
 8007b38:	2003      	movs	r0, #3
 8007b3a:	f001 ff2d 	bl	8009998 <LoRaMacCommandsAddCmd>
                    for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 8007b3e:	3701      	adds	r7, #1
 8007b40:	b2fb      	uxtb	r3, r7
 8007b42:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8007b46:	fbb4 f2fa 	udiv	r2, r4, sl
 8007b4a:	429a      	cmp	r2, r3
 8007b4c:	d8f1      	bhi.n	8007b32 <ProcessMacCommands.isra.0.constprop.0+0x15a>
                    macIndex += linkAdrNbBytesParsed - 1;
 8007b4e:	444c      	add	r4, r9
 8007b50:	b2e4      	uxtb	r4, r4
                break;
 8007b52:	2701      	movs	r7, #1
 8007b54:	e79e      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8007b56:	5d2b      	ldrb	r3, [r5, r4]
 8007b58:	4968      	ldr	r1, [pc, #416]	; (8007cfc <ProcessMacCommands.isra.0.constprop.0+0x324>)
 8007b5a:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8007b5e:	2201      	movs	r2, #1
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8007b60:	f881 30ff 	strb.w	r3, [r1, #255]	; 0xff
 8007b64:	f109 0902 	add.w	r9, r9, #2
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 8007b68:	fa02 f303 	lsl.w	r3, r2, r3
 8007b6c:	f8a1 3102 	strh.w	r3, [r1, #258]	; 0x102
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 8007b70:	fa5f f989 	uxtb.w	r9, r9
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 8007b74:	2200      	movs	r2, #0
 8007b76:	a906      	add	r1, sp, #24
 8007b78:	2004      	movs	r0, #4
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8007b7a:	f001 ff0d 	bl	8009998 <LoRaMacCommandsAddCmd>
                break;
 8007b7e:	e0b9      	b.n	8007cf4 <ProcessMacCommands.isra.0.constprop.0+0x31c>
                status = 0x07;
 8007b80:	2307      	movs	r3, #7
 8007b82:	f88d 3015 	strb.w	r3, [sp, #21]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8007b86:	5d2b      	ldrb	r3, [r5, r4]
 8007b88:	f3c3 1202 	ubfx	r2, r3, #4, #3
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8007b8c:	f003 030f 	and.w	r3, r3, #15
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 8007b90:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 8007b94:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007b98:	f109 0204 	add.w	r2, r9, #4
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8007b9c:	f109 0303 	add.w	r3, r9, #3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007ba0:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007ba2:	b2d2      	uxtb	r2, r2
 8007ba4:	f109 0405 	add.w	r4, r9, #5
                macIndex++;
 8007ba8:	f109 0902 	add.w	r9, r9, #2
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007bac:	5ce9      	ldrb	r1, [r5, r3]
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007bae:	5cab      	ldrb	r3, [r5, r2]
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8007bb0:	fa5f f989 	uxtb.w	r9, r9
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007bb4:	041b      	lsls	r3, r3, #16
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 8007bb6:	f815 2009 	ldrb.w	r2, [r5, r9]
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8007bba:	f8df 9140 	ldr.w	r9, [pc, #320]	; 8007cfc <ProcessMacCommands.isra.0.constprop.0+0x324>
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007bbe:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007bc2:	4313      	orrs	r3, r2
                rxParamSetupReq.Frequency *= 100;
 8007bc4:	2264      	movs	r2, #100	; 0x64
 8007bc6:	4353      	muls	r3, r2
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8007bc8:	f899 0040 	ldrb.w	r0, [r9, #64]	; 0x40
                rxParamSetupReq.Frequency *= 100;
 8007bcc:	930d      	str	r3, [sp, #52]	; 0x34
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8007bce:	a90c      	add	r1, sp, #48	; 0x30
 8007bd0:	f002 fdb8 	bl	800a744 <RegionRxParamSetupReq>
                if( ( status & 0x07 ) == 0x07 )
 8007bd4:	f000 0307 	and.w	r3, r0, #7
 8007bd8:	2b07      	cmp	r3, #7
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007bda:	b2e4      	uxtb	r4, r4
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 8007bdc:	f88d 0015 	strb.w	r0, [sp, #21]
                if( ( status & 0x07 ) == 0x07 )
 8007be0:	d10e      	bne.n	8007c00 <ProcessMacCommands.isra.0.constprop.0+0x228>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 8007be2:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8007be6:	f889 3068 	strb.w	r3, [r9, #104]	; 0x68
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 8007bea:	f889 3070 	strb.w	r3, [r9, #112]	; 0x70
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 8007bee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8007bf0:	f8c9 3064 	str.w	r3, [r9, #100]	; 0x64
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 8007bf4:	f8c9 306c 	str.w	r3, [r9, #108]	; 0x6c
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 8007bf8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
 8007bfc:	f889 3061 	strb.w	r3, [r9, #97]	; 0x61
                macCmdPayload[0] = status;
 8007c00:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 8007c04:	2201      	movs	r2, #1
 8007c06:	a906      	add	r1, sp, #24
 8007c08:	2005      	movs	r0, #5
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8007c0a:	f001 fec5 	bl	8009998 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8007c0e:	f896 3481 	ldrb.w	r3, [r6, #1153]	; 0x481
 8007c12:	f043 0310 	orr.w	r3, r3, #16
 8007c16:	f886 3481 	strb.w	r3, [r6, #1153]	; 0x481
}
 8007c1a:	e73b      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 8007c1c:	f8d6 3348 	ldr.w	r3, [r6, #840]	; 0x348
 8007c20:	b173      	cbz	r3, 8007c40 <ProcessMacCommands.isra.0.constprop.0+0x268>
 8007c22:	681b      	ldr	r3, [r3, #0]
 8007c24:	b163      	cbz	r3, 8007c40 <ProcessMacCommands.isra.0.constprop.0+0x268>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 8007c26:	4798      	blx	r3
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8007c28:	f00b 033f 	and.w	r3, fp, #63	; 0x3f
                macCmdPayload[0] = batteryLevel;
 8007c2c:	f88d 0018 	strb.w	r0, [sp, #24]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 8007c30:	f88d 3019 	strb.w	r3, [sp, #25]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 8007c34:	2202      	movs	r2, #2
 8007c36:	a906      	add	r1, sp, #24
 8007c38:	2006      	movs	r0, #6
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8007c3a:	f001 fead 	bl	8009998 <LoRaMacCommandsAddCmd>
                break;
 8007c3e:	e729      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 8007c40:	20ff      	movs	r0, #255	; 0xff
 8007c42:	e7f1      	b.n	8007c28 <ProcessMacCommands.isra.0.constprop.0+0x250>
                status = 0x03;
 8007c44:	2303      	movs	r3, #3
 8007c46:	f88d 3015 	strb.w	r3, [sp, #21]
                newChannelReq.ChannelId = payload[macIndex++];
 8007c4a:	5d2b      	ldrb	r3, [r5, r4]
 8007c4c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
                newChannelReq.NewChannel = &chParam;
 8007c50:	ab0c      	add	r3, sp, #48	; 0x30
 8007c52:	9308      	str	r3, [sp, #32]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007c54:	f109 0204 	add.w	r2, r9, #4
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8007c58:	f109 0303 	add.w	r3, r9, #3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007c5c:	b2db      	uxtb	r3, r3
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007c5e:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007c60:	5ce9      	ldrb	r1, [r5, r3]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007c62:	5cab      	ldrb	r3, [r5, r2]
                newChannelReq.ChannelId = payload[macIndex++];
 8007c64:	f109 0202 	add.w	r2, r9, #2
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8007c68:	b2d2      	uxtb	r2, r2
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007c6a:	041b      	lsls	r3, r3, #16
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 8007c6c:	5caa      	ldrb	r2, [r5, r2]
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007c6e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007c72:	4313      	orrs	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8007c74:	f109 0406 	add.w	r4, r9, #6
                chParam.Frequency *= 100;
 8007c78:	2264      	movs	r2, #100	; 0x64
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007c7a:	f109 0905 	add.w	r9, r9, #5
                chParam.Frequency *= 100;
 8007c7e:	4353      	muls	r3, r2
                chParam.DrRange.Value = payload[macIndex++];
 8007c80:	fa5f f989 	uxtb.w	r9, r9
                chParam.Frequency *= 100;
 8007c84:	930c      	str	r3, [sp, #48]	; 0x30
                chParam.Rx1Frequency = 0;
 8007c86:	2300      	movs	r3, #0
 8007c88:	930d      	str	r3, [sp, #52]	; 0x34
                chParam.DrRange.Value = payload[macIndex++];
 8007c8a:	f815 3009 	ldrb.w	r3, [r5, r9]
 8007c8e:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8007c92:	4b1a      	ldr	r3, [pc, #104]	; (8007cfc <ProcessMacCommands.isra.0.constprop.0+0x324>)
 8007c94:	a908      	add	r1, sp, #32
 8007c96:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 8007c9a:	f002 fd5f 	bl	800a75c <RegionNewChannelReq>
 8007c9e:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8007ca0:	2800      	cmp	r0, #0
                chParam.DrRange.Value = payload[macIndex++];
 8007ca2:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 8007ca4:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8007ca8:	f6ff aef4 	blt.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8007cac:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 8007cb0:	2201      	movs	r2, #1
 8007cb2:	a906      	add	r1, sp, #24
 8007cb4:	2007      	movs	r0, #7
 8007cb6:	e7c0      	b.n	8007c3a <ProcessMacCommands.isra.0.constprop.0+0x262>
                uint8_t delay = payload[macIndex++] & 0x0F;
 8007cb8:	5d2b      	ldrb	r3, [r5, r4]
 8007cba:	f003 030f 	and.w	r3, r3, #15
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 8007cbe:	2b01      	cmp	r3, #1
 8007cc0:	bf38      	it	cc
 8007cc2:	2301      	movcc	r3, #1
 8007cc4:	461a      	mov	r2, r3
 8007cc6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8007cca:	4353      	muls	r3, r2
 8007ccc:	4a0b      	ldr	r2, [pc, #44]	; (8007cfc <ProcessMacCommands.isra.0.constprop.0+0x324>)
 8007cce:	6513      	str	r3, [r2, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 8007cd0:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8007cd4:	6553      	str	r3, [r2, #84]	; 0x54
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 8007cd6:	a906      	add	r1, sp, #24
 8007cd8:	2200      	movs	r2, #0
 8007cda:	2008      	movs	r0, #8
 8007cdc:	f001 fe5c 	bl	8009998 <LoRaMacCommandsAddCmd>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8007ce0:	f896 3481 	ldrb.w	r3, [r6, #1153]	; 0x481
                uint8_t delay = payload[macIndex++] & 0x0F;
 8007ce4:	f109 0902 	add.w	r9, r9, #2
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8007ce8:	f043 0310 	orr.w	r3, r3, #16
                uint8_t delay = payload[macIndex++] & 0x0F;
 8007cec:	fa5f f989 	uxtb.w	r9, r9
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8007cf0:	f886 3481 	strb.w	r3, [r6, #1153]	; 0x481
                uint8_t delay = payload[macIndex++] & 0x0F;
 8007cf4:	464c      	mov	r4, r9
}
 8007cf6:	e6cd      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
 8007cf8:	200004b4 	.word	0x200004b4
 8007cfc:	200009bc 	.word	0x200009bc
                uint8_t eirpDwellTime = payload[macIndex++];
 8007d00:	5d2b      	ldrb	r3, [r5, r4]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d02:	4c9f      	ldr	r4, [pc, #636]	; (8007f80 <ProcessMacCommands.isra.0.constprop.0+0x5a8>)
                txParamSetupReq.UplinkDwellTime = 0;
 8007d04:	2200      	movs	r2, #0
 8007d06:	f88d 201c 	strb.w	r2, [sp, #28]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 8007d0a:	f013 0220 	ands.w	r2, r3, #32
                    txParamSetupReq.DownlinkDwellTime = 1;
 8007d0e:	bf18      	it	ne
 8007d10:	2201      	movne	r2, #1
 8007d12:	f88d 201d 	strb.w	r2, [sp, #29]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 8007d16:	06da      	lsls	r2, r3, #27
                    txParamSetupReq.UplinkDwellTime = 1;
 8007d18:	bf48      	it	mi
 8007d1a:	2201      	movmi	r2, #1
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8007d1c:	f003 030f 	and.w	r3, r3, #15
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d20:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
                    txParamSetupReq.UplinkDwellTime = 1;
 8007d24:	bf48      	it	mi
 8007d26:	f88d 201c 	strbmi.w	r2, [sp, #28]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d2a:	a907      	add	r1, sp, #28
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 8007d2c:	f88d 301e 	strb.w	r3, [sp, #30]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d30:	f002 fd20 	bl	800a774 <RegionTxParamSetupReq>
                uint8_t eirpDwellTime = payload[macIndex++];
 8007d34:	f109 0902 	add.w	r9, r9, #2
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d38:	3001      	adds	r0, #1
                uint8_t eirpDwellTime = payload[macIndex++];
 8007d3a:	fa5f f989 	uxtb.w	r9, r9
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 8007d3e:	d0d9      	beq.n	8007cf4 <ProcessMacCommands.isra.0.constprop.0+0x31c>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8007d40:	f8bd 301c 	ldrh.w	r3, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8007d44:	4a8f      	ldr	r2, [pc, #572]	; (8007f84 <ProcessMacCommands.isra.0.constprop.0+0x5ac>)
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8007d46:	f8a4 3074 	strh.w	r3, [r4, #116]	; 0x74
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8007d4a:	f89d 301e 	ldrb.w	r3, [sp, #30]
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 8007d4e:	f89d a01c 	ldrb.w	sl, [sp, #28]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8007d52:	5cd0      	ldrb	r0, [r2, r3]
 8007d54:	f7f8 fd8e 	bl	8000874 <__aeabi_ui2f>
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8007d58:	2302      	movs	r3, #2
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 8007d5a:	67a0      	str	r0, [r4, #120]	; 0x78
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8007d5c:	a90c      	add	r1, sp, #48	; 0x30
 8007d5e:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
                    getPhy.Attribute = PHY_MIN_TX_DR;
 8007d62:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8007d66:	f88d a032 	strb.w	sl, [sp, #50]	; 0x32
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8007d6a:	f002 fc5a 	bl	800a622 <RegionGetPhyParam>
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8007d6e:	f994 3039 	ldrsb.w	r3, [r4, #57]	; 0x39
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8007d72:	9008      	str	r0, [sp, #32]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 8007d74:	b240      	sxtb	r0, r0
 8007d76:	4298      	cmp	r0, r3
 8007d78:	bfb8      	it	lt
 8007d7a:	4618      	movlt	r0, r3
 8007d7c:	f884 0039 	strb.w	r0, [r4, #57]	; 0x39
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 8007d80:	2200      	movs	r2, #0
 8007d82:	a906      	add	r1, sp, #24
 8007d84:	2009      	movs	r0, #9
 8007d86:	e6f8      	b.n	8007b7a <ProcessMacCommands.isra.0.constprop.0+0x1a2>
                status = 0x03;
 8007d88:	2303      	movs	r3, #3
 8007d8a:	f88d 3015 	strb.w	r3, [sp, #21]
                dlChannelReq.ChannelId = payload[macIndex++];
 8007d8e:	5d2b      	ldrb	r3, [r5, r4]
 8007d90:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007d94:	f109 0204 	add.w	r2, r9, #4
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8007d98:	f109 0303 	add.w	r3, r9, #3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007d9c:	b2db      	uxtb	r3, r3
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007d9e:	b2d2      	uxtb	r2, r2
 8007da0:	f109 0405 	add.w	r4, r9, #5
                dlChannelReq.ChannelId = payload[macIndex++];
 8007da4:	f109 0902 	add.w	r9, r9, #2
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 8007da8:	5ce9      	ldrb	r1, [r5, r3]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007daa:	5cab      	ldrb	r3, [r5, r2]
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8007dac:	fa5f f989 	uxtb.w	r9, r9
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007db0:	041b      	lsls	r3, r3, #16
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 8007db2:	f815 2009 	ldrb.w	r2, [r5, r9]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007db6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007dba:	4313      	orrs	r3, r2
                dlChannelReq.Rx1Frequency *= 100;
 8007dbc:	2264      	movs	r2, #100	; 0x64
 8007dbe:	4353      	muls	r3, r2
 8007dc0:	930d      	str	r3, [sp, #52]	; 0x34
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8007dc2:	4b6f      	ldr	r3, [pc, #444]	; (8007f80 <ProcessMacCommands.isra.0.constprop.0+0x5a8>)
 8007dc4:	a90c      	add	r1, sp, #48	; 0x30
 8007dc6:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 8007dca:	f002 fcdf 	bl	800a78c <RegionDlChannelReq>
 8007dce:	b2c3      	uxtb	r3, r0
                if( ( int8_t )status >= 0 )
 8007dd0:	2800      	cmp	r0, #0
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 8007dd2:	b2e4      	uxtb	r4, r4
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 8007dd4:	f88d 3015 	strb.w	r3, [sp, #21]
                if( ( int8_t )status >= 0 )
 8007dd8:	f6ff ae5c 	blt.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    macCmdPayload[0] = status;
 8007ddc:	f88d 3018 	strb.w	r3, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 8007de0:	2201      	movs	r2, #1
 8007de2:	a906      	add	r1, sp, #24
 8007de4:	200a      	movs	r0, #10
 8007de6:	e710      	b.n	8007c0a <ProcessMacCommands.isra.0.constprop.0+0x232>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 8007de8:	200a      	movs	r0, #10
 8007dea:	f001 ff71 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8007dee:	2800      	cmp	r0, #0
 8007df0:	f43f ae50 	beq.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 8007df4:	210a      	movs	r1, #10
 8007df6:	2000      	movs	r0, #0
 8007df8:	f001 ff2e 	bl	8009c58 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t sysTime = { 0 };
 8007dfc:	2300      	movs	r3, #0
 8007dfe:	f8ad 3026 	strh.w	r3, [sp, #38]	; 0x26
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8007e02:	f109 0203 	add.w	r2, r9, #3
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8007e06:	f109 0302 	add.w	r3, r9, #2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8007e0a:	b2db      	uxtb	r3, r3
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8007e0c:	b2d2      	uxtb	r2, r2
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 8007e0e:	5ce9      	ldrb	r1, [r5, r3]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8007e10:	5cab      	ldrb	r3, [r5, r2]
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 8007e12:	5d2a      	ldrb	r2, [r5, r4]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 8007e14:	041b      	lsls	r3, r3, #16
 8007e16:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007e1a:	4313      	orrs	r3, r2
 8007e1c:	f109 0204 	add.w	r2, r9, #4
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8007e20:	f109 0406 	add.w	r4, r9, #6
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8007e24:	b2d2      	uxtb	r2, r2
 8007e26:	f109 0905 	add.w	r9, r9, #5
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8007e2a:	fa5f f989 	uxtb.w	r9, r9
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8007e2e:	5caa      	ldrb	r2, [r5, r2]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8007e30:	f815 1009 	ldrb.w	r1, [r5, r9]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8007e34:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8007e38:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8007e3c:	434a      	muls	r2, r1
                    sysTimeCurrent = SysTimeGet( );
 8007e3e:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8007e42:	1212      	asrs	r2, r2, #8
                    sysTimeCurrent = SysTimeGet( );
 8007e44:	4650      	mov	r0, sl
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 8007e46:	9303      	str	r3, [sp, #12]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 8007e48:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
                    sysTimeCurrent = SysTimeGet( );
 8007e4c:	f007 faaa 	bl	800f3a4 <SysTimeGet>
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 8007e50:	9b03      	ldr	r3, [sp, #12]
 8007e52:	f103 5396 	add.w	r3, r3, #314572800	; 0x12c00000
 8007e56:	f503 13a9 	add.w	r3, r3, #1384448	; 0x152000
 8007e5a:	f503 53ec 	add.w	r3, r3, #7552	; 0x1d80
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 8007e5e:	9308      	str	r3, [sp, #32]
 8007e60:	f8d6 333c 	ldr.w	r3, [r6, #828]	; 0x33c
 8007e64:	9300      	str	r3, [sp, #0]
 8007e66:	f10d 0920 	add.w	r9, sp, #32
 8007e6a:	e899 0006 	ldmia.w	r9, {r1, r2}
 8007e6e:	f8d6 3338 	ldr.w	r3, [r6, #824]	; 0x338
 8007e72:	a80a      	add	r0, sp, #40	; 0x28
 8007e74:	f007 fa52 	bl	800f31c <SysTimeSub>
 8007e78:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8007e7a:	9300      	str	r3, [sp, #0]
 8007e7c:	e89a 0006 	ldmia.w	sl, {r1, r2}
 8007e80:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8007e82:	4648      	mov	r0, r9
 8007e84:	f007 fa2e 	bl	800f2e4 <SysTimeAdd>
                    SysTimeSet( sysTime );
 8007e88:	e899 0003 	ldmia.w	r9, {r0, r1}
 8007e8c:	f007 fa62 	bl	800f354 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 8007e90:	f001 fd6c 	bl	800996c <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8007e94:	2301      	movs	r3, #1
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 8007e96:	b2e4      	uxtb	r4, r4
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 8007e98:	f886 3434 	strb.w	r3, [r6, #1076]	; 0x434
 8007e9c:	e5fa      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 8007e9e:	200d      	movs	r0, #13
 8007ea0:	f001 ff16 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8007ea4:	2800      	cmp	r0, #0
 8007ea6:	f43f adf5 	beq.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 8007eaa:	210d      	movs	r1, #13
 8007eac:	2000      	movs	r0, #0
 8007eae:	f001 fed3 	bl	8009c58 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 8007eb2:	f896 3480 	ldrb.w	r3, [r6, #1152]	; 0x480
 8007eb6:	3b04      	subs	r3, #4
 8007eb8:	2b01      	cmp	r3, #1
 8007eba:	f67f adeb 	bls.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                        LoRaMacClassBPingSlotInfoAns( );
 8007ebe:	f001 fd51 	bl	8009964 <LoRaMacClassBPingSlotInfoAns>
 8007ec2:	e5e7      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                frequency = ( uint32_t )payload[macIndex++];
 8007ec4:	f109 0302 	add.w	r3, r9, #2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8007ec8:	f109 0203 	add.w	r2, r9, #3
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007ecc:	b2d2      	uxtb	r2, r2
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8007ece:	b2db      	uxtb	r3, r3
                frequency = ( uint32_t )payload[macIndex++];
 8007ed0:	5d29      	ldrb	r1, [r5, r4]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 8007ed2:	5ce8      	ldrb	r0, [r5, r3]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007ed4:	5cab      	ldrb	r3, [r5, r2]
                datarate = payload[macIndex++] & 0x0F;
 8007ed6:	f109 0405 	add.w	r4, r9, #5
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007eda:	f109 0904 	add.w	r9, r9, #4
                datarate = payload[macIndex++] & 0x0F;
 8007ede:	fa5f f989 	uxtb.w	r9, r9
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007ee2:	041b      	lsls	r3, r3, #16
 8007ee4:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                datarate = payload[macIndex++] & 0x0F;
 8007ee8:	f815 0009 	ldrb.w	r0, [r5, r9]
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007eec:	430b      	orrs	r3, r1
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 8007eee:	2164      	movs	r1, #100	; 0x64
 8007ef0:	4359      	muls	r1, r3
 8007ef2:	f000 000f 	and.w	r0, r0, #15
 8007ef6:	f001 fd36 	bl	8009966 <LoRaMacClassBPingSlotChannelReq>
                datarate = payload[macIndex++] & 0x0F;
 8007efa:	b2e4      	uxtb	r4, r4
                macCmdPayload[0] = status;
 8007efc:	f88d 0018 	strb.w	r0, [sp, #24]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_FREQ_ANS, macCmdPayload, 1 );
 8007f00:	2201      	movs	r2, #1
 8007f02:	a906      	add	r1, sp, #24
 8007f04:	2011      	movs	r0, #17
 8007f06:	e698      	b.n	8007c3a <ProcessMacCommands.isra.0.constprop.0+0x262>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 8007f08:	200e      	movs	r0, #14
 8007f0a:	f001 fee1 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8007f0e:	2800      	cmp	r0, #0
 8007f10:	f43f adc0 	beq.w	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 8007f14:	210e      	movs	r1, #14
 8007f16:	2000      	movs	r0, #0
 8007f18:	f001 fe9e 	bl	8009c58 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 8007f1c:	f109 0302 	add.w	r3, r9, #2
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8007f20:	b2db      	uxtb	r3, r3
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8007f22:	4a19      	ldr	r2, [pc, #100]	; (8007f88 <ProcessMacCommands.isra.0.constprop.0+0x5b0>)
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8007f24:	5ce8      	ldrb	r0, [r5, r3]
 8007f26:	5d2b      	ldrb	r3, [r5, r4]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8007f28:	6812      	ldr	r2, [r2, #0]
                    beaconTimingChannel = payload[macIndex++];
 8007f2a:	f109 0404 	add.w	r4, r9, #4
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 8007f2e:	f109 0903 	add.w	r9, r9, #3
                    beaconTimingChannel = payload[macIndex++];
 8007f32:	fa5f f989 	uxtb.w	r9, r9
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8007f36:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8007f3a:	f815 1009 	ldrb.w	r1, [r5, r9]
                    beaconTimingChannel = payload[macIndex++];
 8007f3e:	b2e4      	uxtb	r4, r4
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 8007f40:	f001 fd13 	bl	800996a <LoRaMacClassBBeaconTimingAns>
 8007f44:	e5a6      	b.n	8007a94 <ProcessMacCommands.isra.0.constprop.0+0xbc>
                    frequency = ( uint32_t )payload[macIndex++];
 8007f46:	5d28      	ldrb	r0, [r5, r4]
 8007f48:	f109 0302 	add.w	r3, r9, #2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007f4c:	f109 0404 	add.w	r4, r9, #4
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8007f50:	f109 0903 	add.w	r9, r9, #3
 8007f54:	b2db      	uxtb	r3, r3
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007f56:	fa5f f989 	uxtb.w	r9, r9
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 8007f5a:	5cea      	ldrb	r2, [r5, r3]
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007f5c:	f815 3009 	ldrb.w	r3, [r5, r9]
 8007f60:	041b      	lsls	r3, r3, #16
 8007f62:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8007f66:	4303      	orrs	r3, r0
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8007f68:	2064      	movs	r0, #100	; 0x64
 8007f6a:	4358      	muls	r0, r3
 8007f6c:	f001 fcff 	bl	800996e <LoRaMacClassBBeaconFreqReq>
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 8007f70:	b2e4      	uxtb	r4, r4
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 8007f72:	f88d 0018 	strb.w	r0, [sp, #24]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 8007f76:	2201      	movs	r2, #1
 8007f78:	a906      	add	r1, sp, #24
 8007f7a:	2013      	movs	r0, #19
 8007f7c:	e65d      	b.n	8007c3a <ProcessMacCommands.isra.0.constprop.0+0x262>
 8007f7e:	bf00      	nop
 8007f80:	200009bc 	.word	0x200009bc
 8007f84:	08010a11 	.word	0x08010a11
 8007f88:	20001ae4 	.word	0x20001ae4

08007f8c <LoRaMacIsBusy>:
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 8007f8c:	4b05      	ldr	r3, [pc, #20]	; (8007fa4 <LoRaMacIsBusy+0x18>)
 8007f8e:	f8d3 2340 	ldr.w	r2, [r3, #832]	; 0x340
 8007f92:	b92a      	cbnz	r2, 8007fa0 <LoRaMacIsBusy+0x14>
 8007f94:	f893 0482 	ldrb.w	r0, [r3, #1154]	; 0x482
 8007f98:	3801      	subs	r0, #1
 8007f9a:	bf18      	it	ne
 8007f9c:	2001      	movne	r0, #1
 8007f9e:	4770      	bx	lr
    return true;
 8007fa0:	2001      	movs	r0, #1
}
 8007fa2:	4770      	bx	lr
 8007fa4:	200004b4 	.word	0x200004b4

08007fa8 <LoRaMacProcess>:
{
 8007fa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007fac:	b0a5      	sub	sp, #148	; 0x94
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8007fae:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8007fb2:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 8007fb4:	4acb      	ldr	r2, [pc, #812]	; (80082e4 <LoRaMacProcess+0x33c>)
    LoRaMacRadioEvents.Value = 0;
 8007fb6:	2000      	movs	r0, #0
    events = LoRaMacRadioEvents;
 8007fb8:	6813      	ldr	r3, [r2, #0]
    LoRaMacRadioEvents.Value = 0;
 8007fba:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8007fbc:	f381 8810 	msr	PRIMASK, r1
    if( events.Value != 0 )
 8007fc0:	4cc9      	ldr	r4, [pc, #804]	; (80082e8 <LoRaMacProcess+0x340>)
 8007fc2:	2b00      	cmp	r3, #0
 8007fc4:	f000 80cf 	beq.w	8008166 <LoRaMacProcess+0x1be>
        if( events.Events.TxDone == 1 )
 8007fc8:	fa5f fb83 	uxtb.w	fp, r3
 8007fcc:	06db      	lsls	r3, r3, #27
 8007fce:	d560      	bpl.n	8008092 <LoRaMacProcess+0xea>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8007fd0:	4dc6      	ldr	r5, [pc, #792]	; (80082ec <LoRaMacProcess+0x344>)
 8007fd2:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 8007fd6:	2b02      	cmp	r3, #2
 8007fd8:	d002      	beq.n	8007fe0 <LoRaMacProcess+0x38>
        Radio.Sleep( );
 8007fda:	4bc5      	ldr	r3, [pc, #788]	; (80082f0 <LoRaMacProcess+0x348>)
 8007fdc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007fde:	4798      	blx	r3
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay );
 8007fe0:	f8d4 13b0 	ldr.w	r1, [r4, #944]	; 0x3b0
 8007fe4:	48c3      	ldr	r0, [pc, #780]	; (80082f4 <LoRaMacProcess+0x34c>)
 8007fe6:	f007 fb55 	bl	800f694 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 8007fea:	48c2      	ldr	r0, [pc, #776]	; (80082f4 <LoRaMacProcess+0x34c>)
 8007fec:	f007 fb18 	bl	800f620 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay );
 8007ff0:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
 8007ff4:	48c0      	ldr	r0, [pc, #768]	; (80082f8 <LoRaMacProcess+0x350>)
 8007ff6:	f007 fb4d 	bl	800f694 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 8007ffa:	48bf      	ldr	r0, [pc, #764]	; (80082f8 <LoRaMacProcess+0x350>)
 8007ffc:	f007 fb10 	bl	800f620 <UTIL_TIMER_Start>
    if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) || ( MacCtx.NodeAckRequested == true ) )
 8008000:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 8008004:	2b02      	cmp	r3, #2
 8008006:	d002      	beq.n	800800e <LoRaMacProcess+0x66>
 8008008:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 800800c:	b18b      	cbz	r3, 8008032 <LoRaMacProcess+0x8a>
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 800800e:	2316      	movs	r3, #22
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008010:	a90e      	add	r1, sp, #56	; 0x38
 8008012:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
        getPhy.Attribute = PHY_ACK_TIMEOUT;
 8008016:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800801a:	f002 fb02 	bl	800a622 <RegionGetPhyParam>
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 800801e:	f8d4 13b4 	ldr.w	r1, [r4, #948]	; 0x3b4
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008022:	900c      	str	r0, [sp, #48]	; 0x30
        TimerSetValue( &MacCtx.AckTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 8008024:	4401      	add	r1, r0
 8008026:	48b5      	ldr	r0, [pc, #724]	; (80082fc <LoRaMacProcess+0x354>)
 8008028:	f007 fb34 	bl	800f694 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.AckTimeoutTimer );
 800802c:	48b3      	ldr	r0, [pc, #716]	; (80082fc <LoRaMacProcess+0x354>)
 800802e:	f007 faf7 	bl	800f620 <UTIL_TIMER_Start>
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8008032:	4bb3      	ldr	r3, [pc, #716]	; (8008300 <LoRaMacProcess+0x358>)
    txDone.Channel = MacCtx.Channel;
 8008034:	f894 2415 	ldrb.w	r2, [r4, #1045]	; 0x415
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 8008038:	681b      	ldr	r3, [r3, #0]
 800803a:	62eb      	str	r3, [r5, #44]	; 0x2c
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 800803c:	af0a      	add	r7, sp, #40	; 0x28
 800803e:	4638      	mov	r0, r7
    txDone.Channel = MacCtx.Channel;
 8008040:	f88d 2060 	strb.w	r2, [sp, #96]	; 0x60
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 8008044:	9319      	str	r3, [sp, #100]	; 0x64
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 8008046:	f007 f9d3 	bl	800f3f0 <SysTimeGetMcuTime>
 800804a:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
 800804e:	9300      	str	r3, [sp, #0]
 8008050:	ae04      	add	r6, sp, #16
 8008052:	e897 0006 	ldmia.w	r7, {r1, r2}
 8008056:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
 800805a:	4630      	mov	r0, r6
 800805c:	f007 f95e 	bl	800f31c <SysTimeSub>
 8008060:	e896 0003 	ldmia.w	r6, {r0, r1}
 8008064:	ab1b      	add	r3, sp, #108	; 0x6c
 8008066:	e883 0003 	stmia.w	r3, {r0, r1}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 800806a:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
 800806e:	931a      	str	r3, [sp, #104]	; 0x68
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 8008070:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8008074:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
        txDone.Joined  = false;
 8008078:	2b00      	cmp	r3, #0
 800807a:	bf18      	it	ne
 800807c:	2301      	movne	r3, #1
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 800807e:	a918      	add	r1, sp, #96	; 0x60
        txDone.Joined  = false;
 8008080:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 8008084:	f002 fadd 	bl	800a642 <RegionSetBandTxDone>
    if( MacCtx.NodeAckRequested == false )
 8008088:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 800808c:	b90b      	cbnz	r3, 8008092 <LoRaMacProcess+0xea>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800808e:	f884 3439 	strb.w	r3, [r4, #1081]	; 0x439
        if( events.Events.RxDone == 1 )
 8008092:	f01b 0f08 	tst.w	fp, #8
 8008096:	d03a      	beq.n	800810e <LoRaMacProcess+0x166>
    uint8_t *payload = RxDoneParams.Payload;
 8008098:	4b9a      	ldr	r3, [pc, #616]	; (8008304 <LoRaMacProcess+0x35c>)
    uint32_t address = Nvm.MacGroup2.DevAddr;
 800809a:	4d94      	ldr	r5, [pc, #592]	; (80082ec <LoRaMacProcess+0x344>)
    uint8_t *payload = RxDoneParams.Payload;
 800809c:	685f      	ldr	r7, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 800809e:	891e      	ldrh	r6, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 80080a0:	f9b3 800a 	ldrsh.w	r8, [r3, #10]
    int8_t snr = RxDoneParams.Snr;
 80080a4:	f993 a00c 	ldrsb.w	sl, [r3, #12]
    uint32_t address = Nvm.MacGroup2.DevAddr;
 80080a8:	f8d5 20cc 	ldr.w	r2, [r5, #204]	; 0xcc
 80080ac:	9203      	str	r2, [sp, #12]
    uint32_t downLinkCounter = 0;
 80080ae:	2300      	movs	r3, #0
 80080b0:	9307      	str	r3, [sp, #28]
    MacCtx.McpsConfirm.AckReceived = false;
 80080b2:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
    MacCtx.McpsIndication.Multicast = 0;
 80080b6:	f8a4 341e 	strh.w	r3, [r4, #1054]	; 0x41e
    MacCtx.McpsIndication.FramePending = 0;
 80080ba:	f884 3421 	strb.w	r3, [r4, #1057]	; 0x421
    MacCtx.McpsIndication.Buffer = NULL;
 80080be:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
    MacCtx.McpsIndication.BufferSize = 0;
 80080c2:	f8a4 3428 	strh.w	r3, [r4, #1064]	; 0x428
    MacCtx.McpsIndication.AckReceived = false;
 80080c6:	f884 342a 	strb.w	r3, [r4, #1066]	; 0x42a
    MacCtx.McpsIndication.DownLinkCounter = 0;
 80080ca:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 80080ce:	f884 341c 	strb.w	r3, [r4, #1052]	; 0x41c
    MacCtx.McpsIndication.DevAddress = 0;
 80080d2:	f8c4 3430 	str.w	r3, [r4, #1072]	; 0x430
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 80080d6:	f884 3434 	strb.w	r3, [r4, #1076]	; 0x434
    Radio.Sleep( );
 80080da:	4b85      	ldr	r3, [pc, #532]	; (80082f0 <LoRaMacProcess+0x348>)
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 80080dc:	f894 2480 	ldrb.w	r2, [r4, #1152]	; 0x480
    Radio.Sleep( );
 80080e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 80080e2:	f884 247f 	strb.w	r2, [r4, #1151]	; 0x47f
    MacCtx.RxStatus.Rssi = rssi;
 80080e6:	f8a4 847c 	strh.w	r8, [r4, #1148]	; 0x47c
    MacCtx.RxStatus.Snr = snr;
 80080ea:	f884 a47e 	strb.w	sl, [r4, #1150]	; 0x47e
    Radio.Sleep( );
 80080ee:	4798      	blx	r3
    TimerStop( &MacCtx.RxWindowTimer2 );
 80080f0:	4881      	ldr	r0, [pc, #516]	; (80082f8 <LoRaMacProcess+0x350>)
 80080f2:	f007 fa45 	bl	800f580 <UTIL_TIMER_Stop>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 80080f6:	4631      	mov	r1, r6
 80080f8:	4638      	mov	r0, r7
 80080fa:	f001 fc20 	bl	800993e <LoRaMacClassBRxBeacon>
 80080fe:	4681      	mov	r9, r0
 8008100:	2800      	cmp	r0, #0
 8008102:	f000 8169 	beq.w	80083d8 <LoRaMacProcess+0x430>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 8008106:	f8a4 8472 	strh.w	r8, [r4, #1138]	; 0x472
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 800810a:	f884 a474 	strb.w	sl, [r4, #1140]	; 0x474
        if( events.Events.TxTimeout == 1 )
 800810e:	f01b 0f04 	tst.w	fp, #4
 8008112:	d01a      	beq.n	800814a <LoRaMacProcess+0x1a2>
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 8008114:	4b75      	ldr	r3, [pc, #468]	; (80082ec <LoRaMacProcess+0x344>)
 8008116:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 800811a:	2b02      	cmp	r3, #2
 800811c:	d002      	beq.n	8008124 <LoRaMacProcess+0x17c>
        Radio.Sleep( );
 800811e:	4b74      	ldr	r3, [pc, #464]	; (80082f0 <LoRaMacProcess+0x348>)
 8008120:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008122:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 8008124:	f7fe ffb8 	bl	8007098 <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 8008128:	2002      	movs	r0, #2
 800812a:	f884 0439 	strb.w	r0, [r4, #1081]	; 0x439
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 800812e:	f001 fdb5 	bl	8009c9c <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 8008132:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 8008136:	b113      	cbz	r3, 800813e <LoRaMacProcess+0x196>
        MacCtx.AckTimeoutRetry = true;
 8008138:	2301      	movs	r3, #1
 800813a:	f884 3413 	strb.w	r3, [r4, #1043]	; 0x413
    MacCtx.MacFlags.Bits.MacDone = 1;
 800813e:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8008142:	f043 0320 	orr.w	r3, r3, #32
 8008146:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
        if( events.Events.RxError == 1 )
 800814a:	f01b 0f02 	tst.w	fp, #2
 800814e:	d003      	beq.n	8008158 <LoRaMacProcess+0x1b0>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 8008150:	2106      	movs	r1, #6
 8008152:	2005      	movs	r0, #5
 8008154:	f7ff f830 	bl	80071b8 <HandleRadioRxErrorTimeout>
        if( events.Events.RxTimeout == 1 )
 8008158:	f01b 0f01 	tst.w	fp, #1
 800815c:	d003      	beq.n	8008166 <LoRaMacProcess+0x1be>
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 800815e:	2104      	movs	r1, #4
 8008160:	2003      	movs	r0, #3
 8008162:	f7ff f829 	bl	80071b8 <HandleRadioRxErrorTimeout>
    LoRaMacClassBProcess( );
 8008166:	f001 fc07 	bl	8009978 <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 800816a:	f894 2481 	ldrb.w	r2, [r4, #1153]	; 0x481
 800816e:	0690      	lsls	r0, r2, #26
 8008170:	f140 80f8 	bpl.w	8008364 <LoRaMacProcess+0x3bc>
    MacCtx.AllowRequests = requestState;
 8008174:	2300      	movs	r3, #0
 8008176:	f884 3482 	strb.w	r3, [r4, #1154]	; 0x482
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 800817a:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 800817e:	0619      	lsls	r1, r3, #24
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8008180:	bf44      	itt	mi
 8008182:	f023 0382 	bicmi.w	r3, r3, #130	; 0x82
 8008186:	f8c4 3340 	strmi.w	r3, [r4, #832]	; 0x340
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
}

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 800818a:	f012 0f05 	tst.w	r2, #5
 800818e:	f000 832c 	beq.w	80087ea <LoRaMacProcess+0x842>
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 8008192:	200c      	movs	r0, #12
 8008194:	f001 fd9c 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8008198:	2800      	cmp	r0, #0
 800819a:	f000 8326 	beq.w	80087ea <LoRaMacProcess+0x842>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 800819e:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 80081a2:	07df      	lsls	r7, r3, #31
 80081a4:	f100 8321 	bmi.w	80087ea <LoRaMacProcess+0x842>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80081a8:	075e      	lsls	r6, r3, #29
 80081aa:	f140 8332 	bpl.w	8008812 <LoRaMacProcess+0x86a>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 80081ae:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 80081b2:	f023 0302 	bic.w	r3, r3, #2
 80081b6:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
    if( MacCtx.MacState == LORAMAC_IDLE )
 80081ba:	f8d4 2340 	ldr.w	r2, [r4, #832]	; 0x340
 80081be:	2a00      	cmp	r2, #0
 80081c0:	f040 80cd 	bne.w	800835e <LoRaMacProcess+0x3b6>
 80081c4:	f894 5481 	ldrb.w	r5, [r4, #1153]	; 0x481
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 80081c8:	f015 0101 	ands.w	r1, r5, #1
            MacCtx.MacFlags.Bits.McpsReq = 0;
 80081cc:	bf1e      	ittt	ne
 80081ce:	462b      	movne	r3, r5
 80081d0:	f362 0300 	bfine	r3, r2, #0, #1
 80081d4:	f884 3481 	strbne.w	r3, [r4, #1153]	; 0x481
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80081d8:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80081dc:	075e      	lsls	r6, r3, #29
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 80081de:	bf44      	itt	mi
 80081e0:	f36f 0382 	bfcmi	r3, #2, #1
 80081e4:	f884 3481 	strbmi.w	r3, [r4, #1153]	; 0x481
    MacCtx.AllowRequests = requestState;
 80081e8:	2301      	movs	r3, #1
 80081ea:	f884 3482 	strb.w	r3, [r4, #1154]	; 0x482
        if( reqEvents.Bits.McpsReq == 1 )
 80081ee:	b121      	cbz	r1, 80081fa <LoRaMacProcess+0x252>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 80081f0:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80081f4:	4844      	ldr	r0, [pc, #272]	; (8008308 <LoRaMacProcess+0x360>)
 80081f6:	681b      	ldr	r3, [r3, #0]
 80081f8:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 80081fa:	076d      	lsls	r5, r5, #29
 80081fc:	d50b      	bpl.n	8008216 <LoRaMacProcess+0x26e>
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 80081fe:	4843      	ldr	r0, [pc, #268]	; (800830c <LoRaMacProcess+0x364>)
 8008200:	f001 fd72 	bl	8009ce8 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 8008204:	f001 fd9a 	bl	8009d3c <LoRaMacConfirmQueueGetCnt>
 8008208:	b128      	cbz	r0, 8008216 <LoRaMacProcess+0x26e>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 800820a:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 800820e:	f043 0304 	orr.w	r3, r3, #4
 8008212:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
        LoRaMacClassBResumeBeaconing( );
 8008216:	f001 fb9e 	bl	8009956 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 800821a:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 800821e:	f36f 1345 	bfc	r3, #5, #1
 8008222:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
    if( MacCtx.MacState == LORAMAC_IDLE )
 8008226:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 800822a:	2b00      	cmp	r3, #0
 800822c:	f040 8097 	bne.w	800835e <LoRaMacProcess+0x3b6>
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 8008230:	a818      	add	r0, sp, #96	; 0x60
        bool isStickyMacCommandPending = false;
 8008232:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
        LoRaMacCommandsStickyCmdsPending( &isStickyMacCommandPending );
 8008236:	f001 fc87 	bl	8009b48 <LoRaMacCommandsStickyCmdsPending>
        if( isStickyMacCommandPending == true )
 800823a:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 800823e:	b12b      	cbz	r3, 800824c <LoRaMacProcess+0x2a4>
    MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 1;
 8008240:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8008244:	f043 0310 	orr.w	r3, r3, #16
 8008248:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
    if( MacCtx.MacState != LORAMAC_IDLE )
 800824c:	f8d4 5340 	ldr.w	r5, [r4, #832]	; 0x340
 8008250:	2d00      	cmp	r5, #0
 8008252:	f040 8084 	bne.w	800835e <LoRaMacProcess+0x3b6>
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 8008256:	4e25      	ldr	r6, [pc, #148]	; (80082ec <LoRaMacProcess+0x344>)
 8008258:	2124      	movs	r1, #36	; 0x24
 800825a:	4630      	mov	r0, r6
 800825c:	f004 ff86 	bl	800d16c <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 8008260:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8008262:	4298      	cmp	r0, r3
        nvmData->Crypto.Crc32 = crc;
 8008264:	bf18      	it	ne
 8008266:	6270      	strne	r0, [r6, #36]	; 0x24
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 8008268:	f04f 0114 	mov.w	r1, #20
 800826c:	4828      	ldr	r0, [pc, #160]	; (8008310 <LoRaMacProcess+0x368>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 800826e:	bf18      	it	ne
 8008270:	2501      	movne	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 8008272:	f004 ff7b 	bl	800d16c <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 8008276:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8008278:	4298      	cmp	r0, r3
        nvmData->MacGroup1.Crc32 = crc;
 800827a:	bf18      	it	ne
 800827c:	63f0      	strne	r0, [r6, #60]	; 0x3c
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 800827e:	f04f 01d4 	mov.w	r1, #212	; 0xd4
 8008282:	4824      	ldr	r0, [pc, #144]	; (8008314 <LoRaMacProcess+0x36c>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 8008284:	bf18      	it	ne
 8008286:	f045 0502 	orrne.w	r5, r5, #2
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 800828a:	f004 ff6f 	bl	800d16c <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 800828e:	f8d6 3114 	ldr.w	r3, [r6, #276]	; 0x114
 8008292:	4298      	cmp	r0, r3
        nvmData->MacGroup2.Crc32 = crc;
 8008294:	bf18      	it	ne
 8008296:	f8c6 0114 	strne.w	r0, [r6, #276]	; 0x114
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 800829a:	f04f 01bc 	mov.w	r1, #188	; 0xbc
 800829e:	481e      	ldr	r0, [pc, #120]	; (8008318 <LoRaMacProcess+0x370>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 80082a0:	bf18      	it	ne
 80082a2:	f045 0504 	orrne.w	r5, r5, #4
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 80082a6:	f004 ff61 	bl	800d16c <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 80082aa:	f8d6 31d4 	ldr.w	r3, [r6, #468]	; 0x1d4
 80082ae:	4298      	cmp	r0, r3
        nvmData->SecureElement.Crc32 = crc;
 80082b0:	bf18      	it	ne
 80082b2:	f8c6 01d4 	strne.w	r0, [r6, #468]	; 0x1d4
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80082b6:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 80082ba:	4818      	ldr	r0, [pc, #96]	; (800831c <LoRaMacProcess+0x374>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 80082bc:	bf18      	it	ne
 80082be:	f045 0508 	orrne.w	r5, r5, #8
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 80082c2:	f004 ff53 	bl	800d16c <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 80082c6:	f8d6 3278 	ldr.w	r3, [r6, #632]	; 0x278
 80082ca:	4298      	cmp	r0, r3
        nvmData->RegionGroup1.Crc32 = crc;
 80082cc:	bf18      	it	ne
 80082ce:	f8c6 0278 	strne.w	r0, [r6, #632]	; 0x278
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80082d2:	f44f 715e 	mov.w	r1, #888	; 0x378
 80082d6:	4812      	ldr	r0, [pc, #72]	; (8008320 <LoRaMacProcess+0x378>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 80082d8:	bf18      	it	ne
 80082da:	f045 0510 	orrne.w	r5, r5, #16
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 80082de:	f004 ff45 	bl	800d16c <Crc32>
 80082e2:	e01f      	b.n	8008324 <LoRaMacProcess+0x37c>
 80082e4:	200004b0 	.word	0x200004b0
 80082e8:	200004b4 	.word	0x200004b4
 80082ec:	200009bc 	.word	0x200009bc
 80082f0:	08010fe4 	.word	0x08010fe4
 80082f4:	20000834 	.word	0x20000834
 80082f8:	2000084c 	.word	0x2000084c
 80082fc:	200008ac 	.word	0x200008ac
 8008300:	20001ae0 	.word	0x20001ae0
 8008304:	20001ae4 	.word	0x20001ae4
 8008308:	200008ec 	.word	0x200008ec
 800830c:	20000900 	.word	0x20000900
 8008310:	200009e4 	.word	0x200009e4
 8008314:	200009fc 	.word	0x200009fc
 8008318:	20000ad4 	.word	0x20000ad4
 800831c:	20000b94 	.word	0x20000b94
 8008320:	20000c38 	.word	0x20000c38
    if( crc != nvmData->RegionGroup2.Crc32 )
 8008324:	f8d6 35f4 	ldr.w	r3, [r6, #1524]	; 0x5f4
 8008328:	4298      	cmp	r0, r3
        nvmData->RegionGroup2.Crc32 = crc;
 800832a:	bf18      	it	ne
 800832c:	f8c6 05f4 	strne.w	r0, [r6, #1524]	; 0x5f4
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 8008330:	f04f 0114 	mov.w	r1, #20
 8008334:	487d      	ldr	r0, [pc, #500]	; (800852c <LoRaMacProcess+0x584>)
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 8008336:	bf18      	it	ne
 8008338:	f045 0520 	orrne.w	r5, r5, #32
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 800833c:	f004 ff16 	bl	800d16c <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 8008340:	f8d6 360c 	ldr.w	r3, [r6, #1548]	; 0x60c
 8008344:	4298      	cmp	r0, r3
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8008346:	f8d4 3348 	ldr.w	r3, [r4, #840]	; 0x348
        nvmData->ClassB.Crc32 = crc;
 800834a:	bf1c      	itt	ne
 800834c:	f8c6 060c 	strne.w	r0, [r6, #1548]	; 0x60c
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 8008350:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8008354:	b11b      	cbz	r3, 800835e <LoRaMacProcess+0x3b6>
        ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 8008356:	68db      	ldr	r3, [r3, #12]
    if( ( MacCtx.MacCallbacks != NULL ) &&
 8008358:	b10b      	cbz	r3, 800835e <LoRaMacProcess+0x3b6>
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 800835a:	4628      	mov	r0, r5
 800835c:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 800835e:	2301      	movs	r3, #1
 8008360:	f884 3482 	strb.w	r3, [r4, #1154]	; 0x482
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 8008364:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8008368:	0718      	lsls	r0, r3, #28
 800836a:	d50a      	bpl.n	8008382 <LoRaMacProcess+0x3da>
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 800836c:	f36f 03c3 	bfc	r3, #3, #1
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8008370:	496f      	ldr	r1, [pc, #444]	; (8008530 <LoRaMacProcess+0x588>)
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 8008372:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 8008376:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 800837a:	f1a1 001c 	sub.w	r0, r1, #28
 800837e:	68db      	ldr	r3, [r3, #12]
 8008380:	4798      	blx	r3
    if( MacCtx.MacFlags.Bits.MlmeSchedUplinkInd == 1 )
 8008382:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8008386:	06d9      	lsls	r1, r3, #27
 8008388:	d50e      	bpl.n	80083a8 <LoRaMacProcess+0x400>
        schduleUplinkIndication.MlmeIndication = MLME_SCHEDULE_UPLINK;
 800838a:	2307      	movs	r3, #7
 800838c:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
        MacCtx.MacPrimitives->MacMlmeIndication( &schduleUplinkIndication, &MacCtx.RxStatus );
 8008390:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 8008394:	4966      	ldr	r1, [pc, #408]	; (8008530 <LoRaMacProcess+0x588>)
 8008396:	68db      	ldr	r3, [r3, #12]
 8008398:	a818      	add	r0, sp, #96	; 0x60
 800839a:	4798      	blx	r3
        MacCtx.MacFlags.Bits.MlmeSchedUplinkInd = 0;
 800839c:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80083a0:	f36f 1304 	bfc	r3, #4, #1
 80083a4:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 80083a8:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80083ac:	079a      	lsls	r2, r3, #30
 80083ae:	d50a      	bpl.n	80083c6 <LoRaMacProcess+0x41e>
        MacCtx.MacFlags.Bits.McpsInd = 0;
 80083b0:	f36f 0341 	bfc	r3, #1, #1
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 80083b4:	495e      	ldr	r1, [pc, #376]	; (8008530 <LoRaMacProcess+0x588>)
        MacCtx.MacFlags.Bits.McpsInd = 0;
 80083b6:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 80083ba:	f8d4 3344 	ldr.w	r3, [r4, #836]	; 0x344
 80083be:	f1a1 0060 	sub.w	r0, r1, #96	; 0x60
 80083c2:	685b      	ldr	r3, [r3, #4]
 80083c4:	4798      	blx	r3
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 80083c6:	f894 3480 	ldrb.w	r3, [r4, #1152]	; 0x480
 80083ca:	2b02      	cmp	r3, #2
 80083cc:	d101      	bne.n	80083d2 <LoRaMacProcess+0x42a>
        OpenContinuousRxCWindow( );
 80083ce:	f7ff fa0f 	bl	80077f0 <OpenContinuousRxCWindow>
}
 80083d2:	b025      	add	sp, #148	; 0x94
 80083d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80083d8:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80083dc:	2b01      	cmp	r3, #1
 80083de:	d10c      	bne.n	80083fa <LoRaMacProcess+0x452>
        if( LoRaMacClassBIsPingExpected( ) == true )
 80083e0:	f001 fab1 	bl	8009946 <LoRaMacClassBIsPingExpected>
 80083e4:	4680      	mov	r8, r0
 80083e6:	b1c0      	cbz	r0, 800841a <LoRaMacProcess+0x472>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 80083e8:	4648      	mov	r0, r9
 80083ea:	f001 faa1 	bl	8009930 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 80083ee:	4648      	mov	r0, r9
 80083f0:	f001 faa3 	bl	800993a <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 80083f4:	2304      	movs	r3, #4
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 80083f6:	f884 347f 	strb.w	r3, [r4, #1151]	; 0x47f
    macHdr.Value = payload[pktHeaderLen++];
 80083fa:	783b      	ldrb	r3, [r7, #0]
 80083fc:	9302      	str	r3, [sp, #8]
    switch( macHdr.Bits.MType )
 80083fe:	095b      	lsrs	r3, r3, #5
 8008400:	3b01      	subs	r3, #1
 8008402:	2b06      	cmp	r3, #6
 8008404:	f200 81e5 	bhi.w	80087d2 <LoRaMacProcess+0x82a>
 8008408:	e8df f013 	tbh	[pc, r3, lsl #1]
 800840c:	01e30013 	.word	0x01e30013
 8008410:	01e30097 	.word	0x01e30097
 8008414:	01e30094 	.word	0x01e30094
 8008418:	01d3      	.short	0x01d3
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 800841a:	f001 fa96 	bl	800994a <LoRaMacClassBIsMulticastExpected>
 800841e:	2800      	cmp	r0, #0
 8008420:	d0eb      	beq.n	80083fa <LoRaMacProcess+0x452>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 8008422:	4640      	mov	r0, r8
 8008424:	f001 fa85 	bl	8009932 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 8008428:	4640      	mov	r0, r8
 800842a:	f001 fa87 	bl	800993c <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 800842e:	2305      	movs	r3, #5
 8008430:	e7e1      	b.n	80083f6 <LoRaMacProcess+0x44e>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 8008432:	2e10      	cmp	r6, #16
 8008434:	d803      	bhi.n	800843e <LoRaMacProcess+0x496>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8008436:	2301      	movs	r3, #1
 8008438:	f884 341d 	strb.w	r3, [r4, #1053]	; 0x41d
 800843c:	e122      	b.n	8008684 <LoRaMacProcess+0x6dc>
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800843e:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
            macMsgJoinAccept.Buffer = payload;
 8008442:	970e      	str	r7, [sp, #56]	; 0x38
            macMsgJoinAccept.BufSize = size;
 8008444:	b2f6      	uxtb	r6, r6
 8008446:	f88d 603c 	strb.w	r6, [sp, #60]	; 0x3c
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 800844a:	2b00      	cmp	r3, #0
 800844c:	d1f3      	bne.n	8008436 <LoRaMacProcess+0x48e>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, SecureElementGetJoinEui( ), &macMsgJoinAccept );
 800844e:	f004 fe49 	bl	800d0e4 <SecureElementGetJoinEui>
 8008452:	aa0e      	add	r2, sp, #56	; 0x38
 8008454:	4601      	mov	r1, r0
 8008456:	20ff      	movs	r0, #255	; 0xff
 8008458:	f001 ff1a 	bl	800a290 <LoRaMacCryptoHandleJoinAccept>
            if( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus )
 800845c:	2800      	cmp	r0, #0
 800845e:	d15c      	bne.n	800851a <LoRaMacProcess+0x572>
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8008460:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 8008464:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8008468:	041b      	lsls	r3, r3, #16
 800846a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 800846e:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 8008472:	4313      	orrs	r3, r2
 8008474:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 8008478:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800847a:	f8c5 30cc 	str.w	r3, [r5, #204]	; 0xcc
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 800847e:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
 8008482:	f3c3 1202 	ubfx	r2, r3, #4, #3
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 8008486:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800848a:	f885 3068 	strb.w	r3, [r5, #104]	; 0x68
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 800848e:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 8008492:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 8008496:	f885 2061 	strb.w	r2, [r5, #97]	; 0x61
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 800849a:	2b00      	cmp	r3, #0
 800849c:	d03b      	beq.n	8008516 <LoRaMacProcess+0x56e>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 800849e:	652b      	str	r3, [r5, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 80084a0:	6d2a      	ldr	r2, [r5, #80]	; 0x50
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80084a2:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 80084a6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80084aa:	4353      	muls	r3, r2
 80084ac:	652b      	str	r3, [r5, #80]	; 0x50
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 80084ae:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80084b2:	656b      	str	r3, [r5, #84]	; 0x54
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80084b4:	2700      	movs	r7, #0
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80084b6:	f10d 034a 	add.w	r3, sp, #74	; 0x4a
                applyCFList.Size = size - 17;
 80084ba:	3e11      	subs	r6, #17
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80084bc:	a90c      	add	r1, sp, #48	; 0x30
                applyCFList.Payload = macMsgJoinAccept.CFList;
 80084be:	930c      	str	r3, [sp, #48]	; 0x30
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 80084c0:	f885 710e 	strb.w	r7, [r5, #270]	; 0x10e
                applyCFList.Size = size - 17;
 80084c4:	f88d 6034 	strb.w	r6, [sp, #52]	; 0x34
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 80084c8:	f002 f8de 	bl	800a688 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80084cc:	2302      	movs	r3, #2
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80084ce:	2001      	movs	r0, #1
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 80084d0:	f885 3110 	strb.w	r3, [r5, #272]	; 0x110
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80084d4:	f001 fbfc 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 80084d8:	b118      	cbz	r0, 80084e2 <LoRaMacProcess+0x53a>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_JOIN );
 80084da:	2101      	movs	r1, #1
 80084dc:	4638      	mov	r0, r7
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 80084de:	f001 fbbb 	bl	8009c58 <LoRaMacConfirmQueueSetStatus>
            MacCtx.MacFlags.Bits.MlmeInd = 1;
 80084e2:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80084e6:	f043 0308 	orr.w	r3, r3, #8
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80084ea:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
    if( MacCtx.NodeAckRequested == true )
 80084ee:	f894 3414 	ldrb.w	r3, [r4, #1044]	; 0x414
 80084f2:	2b00      	cmp	r3, #0
 80084f4:	f000 8173 	beq.w	80087de <LoRaMacProcess+0x836>
        if( MacCtx.McpsConfirm.AckReceived == true )
 80084f8:	f894 343c 	ldrb.w	r3, [r4, #1084]	; 0x43c
 80084fc:	b113      	cbz	r3, 8008504 <LoRaMacProcess+0x55c>
            OnAckTimeoutTimerEvent( NULL );
 80084fe:	2000      	movs	r0, #0
 8008500:	f7fe fe18 	bl	8007134 <OnAckTimeoutTimerEvent>
    MacCtx.MacFlags.Bits.MacDone = 1;
 8008504:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 8008508:	f043 0320 	orr.w	r3, r3, #32
 800850c:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
    UpdateRxSlotIdleState( );
 8008510:	f7fe fdc2 	bl	8007098 <UpdateRxSlotIdleState>
 8008514:	e5fb      	b.n	800810e <LoRaMacProcess+0x166>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 8008516:	2301      	movs	r3, #1
 8008518:	e7c1      	b.n	800849e <LoRaMacProcess+0x4f6>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 800851a:	2001      	movs	r0, #1
 800851c:	f001 fbd8 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8008520:	2800      	cmp	r0, #0
 8008522:	d0de      	beq.n	80084e2 <LoRaMacProcess+0x53a>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 8008524:	2101      	movs	r1, #1
 8008526:	2007      	movs	r0, #7
 8008528:	e7d9      	b.n	80084de <LoRaMacProcess+0x536>
 800852a:	bf00      	nop
 800852c:	20000fb4 	.word	0x20000fb4
 8008530:	20000930 	.word	0x20000930
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 8008534:	2301      	movs	r3, #1
 8008536:	f884 341c 	strb.w	r3, [r4, #1052]	; 0x41c
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800853a:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
 800853e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 8008542:	f894 3420 	ldrb.w	r3, [r4, #1056]	; 0x420
 8008546:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 800854a:	230d      	movs	r3, #13
 800854c:	f88d 3020 	strb.w	r3, [sp, #32]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 8008550:	f895 3080 	ldrb.w	r3, [r5, #128]	; 0x80
 8008554:	b113      	cbz	r3, 800855c <LoRaMacProcess+0x5b4>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 8008556:	230e      	movs	r3, #14
 8008558:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800855c:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 8008560:	a908      	add	r1, sp, #32
 8008562:	f002 f85e 	bl	800a622 <RegionGetPhyParam>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 8008566:	f1a6 030d 	sub.w	r3, r6, #13
 800856a:	b21b      	sxth	r3, r3
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800856c:	9006      	str	r0, [sp, #24]
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 800856e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8008572:	b200      	sxth	r0, r0
 8008574:	4283      	cmp	r3, r0
 8008576:	f73f af5e 	bgt.w	8008436 <LoRaMacProcess+0x48e>
 800857a:	2e0b      	cmp	r6, #11
 800857c:	f67f af5b 	bls.w	8008436 <LoRaMacProcess+0x48e>
            macMsgData.FRMPayload = MacCtx.RxPayload;
 8008580:	4bbc      	ldr	r3, [pc, #752]	; (8008874 <LoRaMacProcess+0x8cc>)
 8008582:	9321      	str	r3, [sp, #132]	; 0x84
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8008584:	a818      	add	r0, sp, #96	; 0x60
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 8008586:	23ff      	movs	r3, #255	; 0xff
            macMsgData.Buffer = payload;
 8008588:	9718      	str	r7, [sp, #96]	; 0x60
            macMsgData.BufSize = size;
 800858a:	f88d 6064 	strb.w	r6, [sp, #100]	; 0x64
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 800858e:	f88d 3088 	strb.w	r3, [sp, #136]	; 0x88
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 8008592:	f001 ff3d 	bl	800a410 <LoRaMacParserData>
 8008596:	4607      	mov	r7, r0
 8008598:	2800      	cmp	r0, #0
 800859a:	f47f af4c 	bne.w	8008436 <LoRaMacProcess+0x48e>
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 800859e:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 80085a2:	991a      	ldr	r1, [sp, #104]	; 0x68
 80085a4:	f8c4 1430 	str.w	r1, [r4, #1072]	; 0x430
    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 80085a8:	f013 020f 	ands.w	r2, r3, #15
 80085ac:	d003      	beq.n	80085b6 <LoRaMacProcess+0x60e>
 80085ae:	f89d 0080 	ldrb.w	r0, [sp, #128]	; 0x80
 80085b2:	2800      	cmp	r0, #0
 80085b4:	d169      	bne.n	800868a <LoRaMacProcess+0x6e2>
    else if( macMsg->FRMPayloadSize == 0 )
 80085b6:	f89d 0088 	ldrb.w	r0, [sp, #136]	; 0x88
 80085ba:	2800      	cmp	r0, #0
 80085bc:	d067      	beq.n	800868e <LoRaMacProcess+0x6e6>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 80085be:	2a00      	cmp	r2, #0
 80085c0:	f47f af39 	bne.w	8008436 <LoRaMacProcess+0x48e>
 80085c4:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
        *fType = FRAME_TYPE_D;
 80085c8:	2a00      	cmp	r2, #0
 80085ca:	bf0c      	ite	eq
 80085cc:	2602      	moveq	r6, #2
 80085ce:	2603      	movne	r6, #3
            downLinkCounter = 0;
 80085d0:	2200      	movs	r2, #0
 80085d2:	9207      	str	r2, [sp, #28]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 80085d4:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
 80085d8:	4291      	cmp	r1, r2
 80085da:	d15a      	bne.n	8008692 <LoRaMacProcess+0x6ea>
 80085dc:	f895 10d2 	ldrb.w	r1, [r5, #210]	; 0xd2
 80085e0:	2900      	cmp	r1, #0
 80085e2:	d056      	beq.n	8008692 <LoRaMacProcess+0x6ea>
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80085e4:	f8d5 10f0 	ldr.w	r1, [r5, #240]	; 0xf0
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 80085e8:	f895 90d3 	ldrb.w	r9, [r5, #211]	; 0xd3
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 80085ec:	6809      	ldr	r1, [r1, #0]
 80085ee:	9107      	str	r1, [sp, #28]
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80085f0:	f895 10fc 	ldrb.w	r1, [r5, #252]	; 0xfc
 80085f4:	2902      	cmp	r1, #2
 80085f6:	d102      	bne.n	80085fe <LoRaMacProcess+0x656>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 80085f8:	2103      	movs	r1, #3
 80085fa:	f884 147f 	strb.w	r1, [r4, #1151]	; 0x47f
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 80085fe:	2e03      	cmp	r6, #3
 8008600:	f47f af19 	bne.w	8008436 <LoRaMacProcess+0x48e>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 8008604:	f013 0f60 	tst.w	r3, #96	; 0x60
 8008608:	f47f af15 	bne.w	8008436 <LoRaMacProcess+0x48e>
 800860c:	9203      	str	r2, [sp, #12]
 800860e:	2701      	movs	r7, #1
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8008610:	2315      	movs	r3, #21
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008612:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            getPhy.Attribute = PHY_MAX_FCNT_GAP;
 8008616:	f88d 3020 	strb.w	r3, [sp, #32]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800861a:	a908      	add	r1, sp, #32
 800861c:	f002 f801 	bl	800a622 <RegionGetPhyParam>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, phyParam.Value, &fCntID, &downLinkCounter );
 8008620:	f895 810e 	ldrb.w	r8, [r5, #270]	; 0x10e
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008624:	9006      	str	r0, [sp, #24]
    switch( addrID )
 8008626:	f1b9 0f00 	cmp.w	r9, #0
 800862a:	d035      	beq.n	8008698 <LoRaMacProcess+0x6f0>
 800862c:	f1b9 0f01 	cmp.w	r9, #1
 8008630:	d141      	bne.n	80086b6 <LoRaMacProcess+0x70e>
            if( lrWanVersion.Fields.Minor == 1 )
 8008632:	f1b8 0f01 	cmp.w	r8, #1
 8008636:	d132      	bne.n	800869e <LoRaMacProcess+0x6f6>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 8008638:	b3a6      	cbz	r6, 80086a4 <LoRaMacProcess+0x6fc>
                    *fCntID = A_FCNT_DOWN;
 800863a:	2e03      	cmp	r6, #3
 800863c:	bf14      	ite	ne
 800863e:	46c8      	movne	r8, r9
 8008640:	f04f 0802 	moveq.w	r8, #2
    return LoRaMacCryptoGetFCntDown( *fCntID, maxFCntGap, macMsg->FHDR.FCnt, currentDown );
 8008644:	f8bd 206e 	ldrh.w	r2, [sp, #110]	; 0x6e
 8008648:	f8bd 1018 	ldrh.w	r1, [sp, #24]
 800864c:	ab07      	add	r3, sp, #28
 800864e:	4640      	mov	r0, r8
 8008650:	f001 fcac 	bl	8009fac <LoRaMacCryptoGetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8008654:	b388      	cbz	r0, 80086ba <LoRaMacProcess+0x712>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 8008656:	2807      	cmp	r0, #7
 8008658:	d127      	bne.n	80086aa <LoRaMacProcess+0x702>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 800865a:	2308      	movs	r3, #8
 800865c:	f884 341d 	strb.w	r3, [r4, #1053]	; 0x41d
                    if( ( Nvm.MacGroup2.Version.Fields.Minor == 0 ) && ( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( Nvm.MacGroup1.LastRxMic == macMsgData.MIC ) )
 8008660:	f895 310e 	ldrb.w	r3, [r5, #270]	; 0x10e
 8008664:	b95b      	cbnz	r3, 800867e <LoRaMacProcess+0x6d6>
 8008666:	9b02      	ldr	r3, [sp, #8]
 8008668:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 800866c:	2ba0      	cmp	r3, #160	; 0xa0
 800866e:	d106      	bne.n	800867e <LoRaMacProcess+0x6d6>
 8008670:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8008672:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8008674:	429a      	cmp	r2, r3
 8008676:	d102      	bne.n	800867e <LoRaMacProcess+0x6d6>
                        Nvm.MacGroup1.SrvAckRequested = true;
 8008678:	2301      	movs	r3, #1
 800867a:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 800867e:	9b07      	ldr	r3, [sp, #28]
 8008680:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
                PrepareRxDoneAbort( );
 8008684:	f7fe fd7c 	bl	8007180 <PrepareRxDoneAbort>
                return;
 8008688:	e541      	b.n	800810e <LoRaMacProcess+0x166>
        *fType = FRAME_TYPE_A;
 800868a:	463e      	mov	r6, r7
 800868c:	e7a0      	b.n	80085d0 <LoRaMacProcess+0x628>
        *fType = FRAME_TYPE_B;
 800868e:	2601      	movs	r6, #1
 8008690:	e79e      	b.n	80085d0 <LoRaMacProcess+0x628>
 8008692:	f04f 0901 	mov.w	r9, #1
 8008696:	e7bb      	b.n	8008610 <LoRaMacProcess+0x668>
    switch( addrID )
 8008698:	f04f 0804 	mov.w	r8, #4
 800869c:	e7d2      	b.n	8008644 <LoRaMacProcess+0x69c>
                *fCntID = FCNT_DOWN;
 800869e:	f04f 0803 	mov.w	r8, #3
 80086a2:	e7cf      	b.n	8008644 <LoRaMacProcess+0x69c>
                    *fCntID = A_FCNT_DOWN;
 80086a4:	f04f 0802 	mov.w	r8, #2
 80086a8:	e7cc      	b.n	8008644 <LoRaMacProcess+0x69c>
                else if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT )
 80086aa:	2808      	cmp	r0, #8
 80086ac:	d103      	bne.n	80086b6 <LoRaMacProcess+0x70e>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS;
 80086ae:	230a      	movs	r3, #10
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80086b0:	f884 341d 	strb.w	r3, [r4, #1053]	; 0x41d
 80086b4:	e7e3      	b.n	800867e <LoRaMacProcess+0x6d6>
 80086b6:	2301      	movs	r3, #1
 80086b8:	e7fa      	b.n	80086b0 <LoRaMacProcess+0x708>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 80086ba:	ab18      	add	r3, sp, #96	; 0x60
 80086bc:	9300      	str	r3, [sp, #0]
 80086be:	9903      	ldr	r1, [sp, #12]
 80086c0:	9b07      	ldr	r3, [sp, #28]
 80086c2:	4642      	mov	r2, r8
 80086c4:	4648      	mov	r0, r9
 80086c6:	f001 fd41 	bl	800a14c <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 80086ca:	b120      	cbz	r0, 80086d6 <LoRaMacProcess+0x72e>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 80086cc:	2802      	cmp	r0, #2
 80086ce:	bf0c      	ite	eq
 80086d0:	230b      	moveq	r3, #11
 80086d2:	230c      	movne	r3, #12
 80086d4:	e6b0      	b.n	8008438 <LoRaMacProcess+0x490>
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80086d6:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 80086da:	f884 041d 	strb.w	r0, [r4, #1053]	; 0x41d
            MacCtx.McpsIndication.FramePending = macMsgData.FHDR.FCtrl.Bits.FPending;
 80086de:	f3c3 1200 	ubfx	r2, r3, #4, #1
 80086e2:	f884 2421 	strb.w	r2, [r4, #1057]	; 0x421
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 80086e6:	9a07      	ldr	r2, [sp, #28]
 80086e8:	f8c4 242c 	str.w	r2, [r4, #1068]	; 0x42c
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80086ec:	f894 247f 	ldrb.w	r2, [r4, #1151]	; 0x47f
            MacCtx.McpsIndication.Multicast = multicast;
 80086f0:	f884 741e 	strb.w	r7, [r4, #1054]	; 0x41e
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 80086f4:	2a01      	cmp	r2, #1
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 80086f6:	f3c3 1340 	ubfx	r3, r3, #5, #1
                Nvm.MacGroup1.AdrAckCounter = 0;
 80086fa:	bf98      	it	ls
 80086fc:	62a8      	strls	r0, [r5, #40]	; 0x28
            if( multicast == 1 )
 80086fe:	2f01      	cmp	r7, #1
            MacCtx.McpsIndication.Buffer = NULL;
 8008700:	f8c4 0424 	str.w	r0, [r4, #1060]	; 0x424
            MacCtx.McpsIndication.BufferSize = 0;
 8008704:	f884 0428 	strb.w	r0, [r4, #1064]	; 0x428
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8008708:	f884 342a 	strb.w	r3, [r4, #1066]	; 0x42a
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 800870c:	f884 0439 	strb.w	r0, [r4, #1081]	; 0x439
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 8008710:	f884 343c 	strb.w	r3, [r4, #1084]	; 0x43c
            if( multicast == 1 )
 8008714:	d12b      	bne.n	800876e <LoRaMacProcess+0x7c6>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 8008716:	2302      	movs	r3, #2
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8008718:	2a01      	cmp	r2, #1
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 800871a:	f884 341c 	strb.w	r3, [r4, #1052]	; 0x41c
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 800871e:	f894 1438 	ldrb.w	r1, [r4, #1080]	; 0x438
 8008722:	f89d 306c 	ldrb.w	r3, [sp, #108]	; 0x6c
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 8008726:	d805      	bhi.n	8008734 <LoRaMacProcess+0x78c>
        if( request == MCPS_CONFIRMED )
 8008728:	2901      	cmp	r1, #1
 800872a:	d101      	bne.n	8008730 <LoRaMacProcess+0x788>
            if( fCtrl.Bits.Ack == 1 )
 800872c:	069f      	lsls	r7, r3, #26
 800872e:	d501      	bpl.n	8008734 <LoRaMacProcess+0x78c>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 8008730:	f001 f9ba 	bl	8009aa8 <LoRaMacCommandsRemoveStickyAnsCmds>
            switch( fType )
 8008734:	2e02      	cmp	r6, #2
 8008736:	d02d      	beq.n	8008794 <LoRaMacProcess+0x7ec>
 8008738:	2e03      	cmp	r6, #3
 800873a:	d009      	beq.n	8008750 <LoRaMacProcess+0x7a8>
 800873c:	f89d 106c 	ldrb.w	r1, [sp, #108]	; 0x6c
 8008740:	2e01      	cmp	r6, #1
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 8008742:	4652      	mov	r2, sl
 8008744:	f001 010f 	and.w	r1, r1, #15
 8008748:	a81c      	add	r0, sp, #112	; 0x70
 800874a:	d027      	beq.n	800879c <LoRaMacProcess+0x7f4>
 800874c:	f7ff f944 	bl	80079d8 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 8008750:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 8008754:	f884 341f 	strb.w	r3, [r4, #1055]	; 0x41f
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 8008758:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800875a:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 800875e:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
 8008762:	f884 3428 	strb.w	r3, [r4, #1064]	; 0x428
                    MacCtx.McpsIndication.RxData = true;
 8008766:	2301      	movs	r3, #1
 8008768:	f884 3429 	strb.w	r3, [r4, #1065]	; 0x429
                    break;
 800876c:	e01c      	b.n	80087a8 <LoRaMacProcess+0x800>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 800876e:	9b02      	ldr	r3, [sp, #8]
 8008770:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8008774:	2ba0      	cmp	r3, #160	; 0xa0
 8008776:	d109      	bne.n	800878c <LoRaMacProcess+0x7e4>
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8008778:	f895 110e 	ldrb.w	r1, [r5, #270]	; 0x10e
                    Nvm.MacGroup1.SrvAckRequested = true;
 800877c:	2301      	movs	r3, #1
 800877e:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 8008782:	2900      	cmp	r1, #0
 8008784:	d1c8      	bne.n	8008718 <LoRaMacProcess+0x770>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 8008786:	9923      	ldr	r1, [sp, #140]	; 0x8c
 8008788:	6369      	str	r1, [r5, #52]	; 0x34
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 800878a:	e7c5      	b.n	8008718 <LoRaMacProcess+0x770>
                    Nvm.MacGroup1.SrvAckRequested = false;
 800878c:	2300      	movs	r3, #0
 800878e:	f885 303a 	strb.w	r3, [r5, #58]	; 0x3a
 8008792:	e7c1      	b.n	8008718 <LoRaMacProcess+0x770>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 8008794:	f89d 1088 	ldrb.w	r1, [sp, #136]	; 0x88
 8008798:	9821      	ldr	r0, [sp, #132]	; 0x84
 800879a:	4652      	mov	r2, sl
 800879c:	f7ff f91c 	bl	80079d8 <ProcessMacCommands.isra.0.constprop.0>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 80087a0:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
 80087a4:	f884 341f 	strb.w	r3, [r4, #1055]	; 0x41f
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80087a8:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80087ac:	f043 0302 	orr.w	r3, r3, #2
 80087b0:	e69b      	b.n	80084ea <LoRaMacProcess+0x542>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 80087b2:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8008874 <LoRaMacProcess+0x8cc>
 80087b6:	3e01      	subs	r6, #1
 80087b8:	b2b2      	uxth	r2, r6
 80087ba:	1c79      	adds	r1, r7, #1
 80087bc:	4640      	mov	r0, r8
 80087be:	f004 fcb9 	bl	800d134 <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 80087c2:	2303      	movs	r3, #3
 80087c4:	f8a4 341c 	strh.w	r3, [r4, #1052]	; 0x41c
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 80087c8:	f8c4 8424 	str.w	r8, [r4, #1060]	; 0x424
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 80087cc:	f884 6428 	strb.w	r6, [r4, #1064]	; 0x428
            MacCtx.MacFlags.Bits.McpsInd = 1;
 80087d0:	e7ea      	b.n	80087a8 <LoRaMacProcess+0x800>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 80087d2:	2301      	movs	r3, #1
 80087d4:	f884 341d 	strb.w	r3, [r4, #1053]	; 0x41d
            PrepareRxDoneAbort( );
 80087d8:	f7fe fcd2 	bl	8007180 <PrepareRxDoneAbort>
            break;
 80087dc:	e687      	b.n	80084ee <LoRaMacProcess+0x546>
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 80087de:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80087e2:	2b02      	cmp	r3, #2
 80087e4:	f47f ae8e 	bne.w	8008504 <LoRaMacProcess+0x55c>
 80087e8:	e689      	b.n	80084fe <LoRaMacProcess+0x556>
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 80087ea:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 80087ee:	075d      	lsls	r5, r3, #29
 80087f0:	d50f      	bpl.n	8008812 <LoRaMacProcess+0x86a>
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 80087f2:	2001      	movs	r0, #1
 80087f4:	f001 fa6c 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 80087f8:	b388      	cbz	r0, 800885e <LoRaMacProcess+0x8b6>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 80087fa:	2001      	movs	r0, #1
 80087fc:	f001 fa3e 	bl	8009c7c <LoRaMacConfirmQueueGetStatus>
 8008800:	b908      	cbnz	r0, 8008806 <LoRaMacProcess+0x85e>
                MacCtx.ChannelsNbTransCounter = 0;
 8008802:	f884 0410 	strb.w	r0, [r4, #1040]	; 0x410
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 8008806:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 800880a:	f023 0302 	bic.w	r3, r3, #2
 800880e:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 8008812:	f894 1481 	ldrb.w	r1, [r4, #1153]	; 0x481
 8008816:	07c8      	lsls	r0, r1, #31
 8008818:	f57f accf 	bpl.w	80081ba <LoRaMacProcess+0x212>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 800881c:	f894 3438 	ldrb.w	r3, [r4, #1080]	; 0x438
 8008820:	b10b      	cbz	r3, 8008826 <LoRaMacProcess+0x87e>
 8008822:	2b03      	cmp	r3, #3
 8008824:	d12c      	bne.n	8008880 <LoRaMacProcess+0x8d8>
        Nvm.MacGroup2.MacParams.ChannelsNbTrans )
 8008826:	4b14      	ldr	r3, [pc, #80]	; (8008878 <LoRaMacProcess+0x8d0>)
    if( MacCtx.ChannelsNbTransCounter >=
 8008828:	f894 0410 	ldrb.w	r0, [r4, #1040]	; 0x410
 800882c:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
 8008830:	4290      	cmp	r0, r2
 8008832:	d208      	bcs.n	8008846 <LoRaMacProcess+0x89e>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 8008834:	078a      	lsls	r2, r1, #30
 8008836:	d556      	bpl.n	80088e6 <LoRaMacProcess+0x93e>
        if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 8008838:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 800883c:	b11b      	cbz	r3, 8008846 <LoRaMacProcess+0x89e>
            if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 800883e:	f894 347f 	ldrb.w	r3, [r4, #1151]	; 0x47f
 8008842:	2b00      	cmp	r3, #0
 8008844:	d14f      	bne.n	80088e6 <LoRaMacProcess+0x93e>
            TimerStop( &MacCtx.TxDelayedTimer );
 8008846:	480d      	ldr	r0, [pc, #52]	; (800887c <LoRaMacProcess+0x8d4>)
 8008848:	f006 fe9a 	bl	800f580 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 800884c:	f8d4 3340 	ldr.w	r3, [r4, #832]	; 0x340
 8008850:	f023 0320 	bic.w	r3, r3, #32
 8008854:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
            StopRetransmission( );
 8008858:	f7fe fc2c 	bl	80070b4 <StopRetransmission>
 800885c:	e4ad      	b.n	80081ba <LoRaMacProcess+0x212>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 800885e:	2005      	movs	r0, #5
 8008860:	f001 fa36 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
 8008864:	2800      	cmp	r0, #0
 8008866:	d1ce      	bne.n	8008806 <LoRaMacProcess+0x85e>
                 ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW_1 ) == true ) )
 8008868:	2006      	movs	r0, #6
 800886a:	f001 fa31 	bl	8009cd0 <LoRaMacConfirmQueueIsCmdActive>
        else if( ( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true ) ||
 800886e:	2800      	cmp	r0, #0
 8008870:	d1c9      	bne.n	8008806 <LoRaMacProcess+0x85e>
 8008872:	e7ce      	b.n	8008812 <LoRaMacProcess+0x86a>
 8008874:	200006ec 	.word	0x200006ec
 8008878:	200009bc 	.word	0x200009bc
 800887c:	2000081c 	.word	0x2000081c
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 8008880:	2b01      	cmp	r3, #1
 8008882:	d130      	bne.n	80088e6 <LoRaMacProcess+0x93e>
            if( MacCtx.AckTimeoutRetry == true )
 8008884:	f894 2413 	ldrb.w	r2, [r4, #1043]	; 0x413
 8008888:	2a00      	cmp	r2, #0
 800888a:	f43f ac96 	beq.w	80081ba <LoRaMacProcess+0x212>
    if( MacCtx.AckTimeoutRetriesCounter >=
 800888e:	f894 3412 	ldrb.w	r3, [r4, #1042]	; 0x412
        MacCtx.AckTimeoutRetries )
 8008892:	f894 0411 	ldrb.w	r0, [r4, #1041]	; 0x411
    if( MacCtx.AckTimeoutRetriesCounter >=
 8008896:	4283      	cmp	r3, r0
 8008898:	d204      	bcs.n	80088a4 <LoRaMacProcess+0x8fc>
    else if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 800889a:	f011 0202 	ands.w	r2, r1, #2
        if( MacCtx.McpsConfirm.AckReceived == true )
 800889e:	bf18      	it	ne
 80088a0:	f894 243c 	ldrbne.w	r2, [r4, #1084]	; 0x43c
                if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 80088a4:	4d24      	ldr	r5, [pc, #144]	; (8008938 <LoRaMacProcess+0x990>)
 80088a6:	f895 110e 	ldrb.w	r1, [r5, #270]	; 0x10e
 80088aa:	2900      	cmp	r1, #0
 80088ac:	d141      	bne.n	8008932 <LoRaMacProcess+0x98a>
                    if( stopRetransmission == false )
 80088ae:	bb32      	cbnz	r2, 80088fe <LoRaMacProcess+0x956>
    if( MacCtx.AckTimeoutRetriesCounter < MacCtx.AckTimeoutRetries )
 80088b0:	4283      	cmp	r3, r0
 80088b2:	d218      	bcs.n	80088e6 <LoRaMacProcess+0x93e>
        MacCtx.AckTimeoutRetriesCounter++;
 80088b4:	3301      	adds	r3, #1
 80088b6:	b2db      	uxtb	r3, r3
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 80088b8:	07df      	lsls	r7, r3, #31
        MacCtx.AckTimeoutRetriesCounter++;
 80088ba:	f884 3412 	strb.w	r3, [r4, #1042]	; 0x412
        if( ( MacCtx.AckTimeoutRetriesCounter % 2 ) == 1 )
 80088be:	d512      	bpl.n	80088e6 <LoRaMacProcess+0x93e>
            getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 80088c0:	2322      	movs	r3, #34	; 0x22
 80088c2:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80088c6:	f895 3074 	ldrb.w	r3, [r5, #116]	; 0x74
 80088ca:	f88d 3062 	strb.w	r3, [sp, #98]	; 0x62
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80088ce:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            getPhy.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 80088d2:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
 80088d6:	f88d 3061 	strb.w	r3, [sp, #97]	; 0x61
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80088da:	a918      	add	r1, sp, #96	; 0x60
 80088dc:	f001 fea1 	bl	800a622 <RegionGetPhyParam>
 80088e0:	900e      	str	r0, [sp, #56]	; 0x38
            Nvm.MacGroup1.ChannelsDatarate = phyParam.Value;
 80088e2:	f885 0039 	strb.w	r0, [r5, #57]	; 0x39
            MacCtx.MacFlags.Bits.MacDone = 0;
 80088e6:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
            MacCtx.AckTimeoutRetry = false;
 80088ea:	2000      	movs	r0, #0
            MacCtx.MacFlags.Bits.MacDone = 0;
 80088ec:	f36f 1345 	bfc	r3, #5, #1
 80088f0:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
            MacCtx.AckTimeoutRetry = false;
 80088f4:	f884 0413 	strb.w	r0, [r4, #1043]	; 0x413
            OnTxDelayedTimerEvent( NULL );
 80088f8:	f7fe ff50 	bl	800779c <OnTxDelayedTimerEvent>
 80088fc:	e45d      	b.n	80081ba <LoRaMacProcess+0x212>
    if( MacCtx.McpsConfirm.AckReceived == false )
 80088fe:	f894 643c 	ldrb.w	r6, [r4, #1084]	; 0x43c
 8008902:	b98e      	cbnz	r6, 8008928 <LoRaMacProcess+0x980>
        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8008904:	2302      	movs	r3, #2
 8008906:	f88d 3068 	strb.w	r3, [sp, #104]	; 0x68
        params.NvmGroup1 = &Nvm.RegionGroup1;
 800890a:	f505 73ec 	add.w	r3, r5, #472	; 0x1d8
 800890e:	9318      	str	r3, [sp, #96]	; 0x60
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8008910:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
        params.NvmGroup2 = &Nvm.RegionGroup2;
 8008914:	f505 731f 	add.w	r3, r5, #636	; 0x27c
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8008918:	a918      	add	r1, sp, #96	; 0x60
        params.NvmGroup2 = &Nvm.RegionGroup2;
 800891a:	9319      	str	r3, [sp, #100]	; 0x64
        RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 800891c:	f001 fe9c 	bl	800a658 <RegionInitDefaults>
        MacCtx.NodeAckRequested = false;
 8008920:	f884 6414 	strb.w	r6, [r4, #1044]	; 0x414
        MacCtx.McpsConfirm.AckReceived = false;
 8008924:	f884 643c 	strb.w	r6, [r4, #1084]	; 0x43c
    MacCtx.McpsConfirm.NbRetries = MacCtx.AckTimeoutRetriesCounter;
 8008928:	f894 3412 	ldrb.w	r3, [r4, #1042]	; 0x412
 800892c:	f884 343d 	strb.w	r3, [r4, #1085]	; 0x43d
        if( stopRetransmission == true )
 8008930:	e789      	b.n	8008846 <LoRaMacProcess+0x89e>
 8008932:	2a00      	cmp	r2, #0
 8008934:	d0d7      	beq.n	80088e6 <LoRaMacProcess+0x93e>
 8008936:	e786      	b.n	8008846 <LoRaMacProcess+0x89e>
 8008938:	200009bc 	.word	0x200009bc

0800893c <LoRaMacInitialization>:
    return 0;
}


LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 800893c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008940:	4689      	mov	r9, r1
 8008942:	b08b      	sub	sp, #44	; 0x2c
 8008944:	4692      	mov	sl, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 8008946:	4607      	mov	r7, r0
 8008948:	2800      	cmp	r0, #0
 800894a:	f000 818f 	beq.w	8008c6c <LoRaMacInitialization+0x330>
 800894e:	2900      	cmp	r1, #0
 8008950:	f000 818c 	beq.w	8008c6c <LoRaMacInitialization+0x330>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 8008954:	6803      	ldr	r3, [r0, #0]
 8008956:	2b00      	cmp	r3, #0
 8008958:	f000 8188 	beq.w	8008c6c <LoRaMacInitialization+0x330>
 800895c:	6843      	ldr	r3, [r0, #4]
 800895e:	2b00      	cmp	r3, #0
 8008960:	f000 8184 	beq.w	8008c6c <LoRaMacInitialization+0x330>
        ( primitives->MacMcpsIndication == NULL ) ||
 8008964:	6883      	ldr	r3, [r0, #8]
 8008966:	2b00      	cmp	r3, #0
 8008968:	f000 8180 	beq.w	8008c6c <LoRaMacInitialization+0x330>
        ( primitives->MacMlmeConfirm == NULL ) ||
 800896c:	68c3      	ldr	r3, [r0, #12]
 800896e:	2b00      	cmp	r3, #0
 8008970:	f000 817c 	beq.w	8008c6c <LoRaMacInitialization+0x330>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 8008974:	4610      	mov	r0, r2
 8008976:	f001 fe4b 	bl	800a610 <RegionIsActive>
 800897a:	2800      	cmp	r0, #0
 800897c:	f000 8178 	beq.w	8008c70 <LoRaMacInitialization+0x334>

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 8008980:	4cbd      	ldr	r4, [pc, #756]	; (8008c78 <LoRaMacInitialization+0x33c>)
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8008982:	4dbe      	ldr	r5, [pc, #760]	; (8008c7c <LoRaMacInitialization+0x340>)
    LoRaMacConfirmQueueInit( primitives );
 8008984:	4638      	mov	r0, r7
 8008986:	f001 f91b 	bl	8009bc0 <LoRaMacConfirmQueueInit>
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 800898a:	f44f 62c2 	mov.w	r2, #1552	; 0x610
 800898e:	2100      	movs	r1, #0
 8008990:	4620      	mov	r0, r4
 8008992:	f004 fbe3 	bl	800d15c <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 8008996:	f44f 62a1 	mov.w	r2, #1288	; 0x508
 800899a:	2100      	movs	r1, #0
 800899c:	4628      	mov	r0, r5
 800899e:	f004 fbdd 	bl	800d15c <memset1>
    Nvm.MacGroup2.Region = region;
    Nvm.MacGroup2.DeviceClass = CLASS_A;
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 80089a2:	4bb7      	ldr	r3, [pc, #732]	; (8008c80 <LoRaMacInitialization+0x344>)
 80089a4:	f8c4 310c 	str.w	r3, [r4, #268]	; 0x10c
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 80089a8:	2600      	movs	r6, #0
    MacCtx.AckTimeoutRetriesCounter = 1;
 80089aa:	f04f 0801 	mov.w	r8, #1

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 80089ae:	230f      	movs	r3, #15
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089b0:	a905      	add	r1, sp, #20
 80089b2:	4650      	mov	r0, sl
    getPhy.Attribute = PHY_DUTY_CYCLE;
 80089b4:	f88d 3014 	strb.w	r3, [sp, #20]
    Nvm.MacGroup2.Region = region;
 80089b8:	f884 a040 	strb.w	sl, [r4, #64]	; 0x40
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 80089bc:	f884 60fc 	strb.w	r6, [r4, #252]	; 0xfc
    Nvm.MacGroup2.MacParams.RepeaterSupport = false; /* ST_WORKAROUND: Keep repeater feature */
 80089c0:	f884 6080 	strb.w	r6, [r4, #128]	; 0x80
    MacCtx.AckTimeoutRetriesCounter = 1;
 80089c4:	f885 8412 	strb.w	r8, [r5, #1042]	; 0x412
    MacCtx.AckTimeoutRetries = 1;
 80089c8:	f885 8411 	strb.w	r8, [r5, #1041]	; 0x411
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089cc:	f001 fe29 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80089d0:	1b80      	subs	r0, r0, r6
 80089d2:	bf18      	it	ne
 80089d4:	2001      	movne	r0, #1

    getPhy.Attribute = PHY_DEF_TX_POWER;
 80089d6:	f04f 0b0a 	mov.w	fp, #10
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 80089da:	f884 0100 	strb.w	r0, [r4, #256]	; 0x100
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089de:	a905      	add	r1, sp, #20
 80089e0:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_TX_POWER;
 80089e4:	f88d b014 	strb.w	fp, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089e8:	f001 fe1b 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;

    getPhy.Attribute = PHY_DEF_TX_DR;
 80089ec:	f04f 0a06 	mov.w	sl, #6
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 80089f0:	f884 00c4 	strb.w	r0, [r4, #196]	; 0xc4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089f4:	a905      	add	r1, sp, #20
 80089f6:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_TX_DR;
 80089fa:	f88d a014 	strb.w	sl, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 80089fe:	f001 fe10 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8008a02:	2310      	movs	r3, #16
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 8008a04:	f884 00c5 	strb.w	r0, [r4, #197]	; 0xc5
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a08:	a905      	add	r1, sp, #20
 8008a0a:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 8008a0e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a12:	f001 fe06 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 8008a16:	2311      	movs	r3, #17
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 8008a18:	f8c4 008c 	str.w	r0, [r4, #140]	; 0x8c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a1c:	a905      	add	r1, sp, #20
 8008a1e:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 8008a22:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a26:	f001 fdfc 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8008a2a:	2312      	movs	r3, #18
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 8008a2c:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a30:	a905      	add	r1, sp, #20
 8008a32:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 8008a36:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a3a:	f001 fdf2 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 8008a3e:	2313      	movs	r3, #19
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 8008a40:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a44:	a905      	add	r1, sp, #20
 8008a46:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 8008a4a:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a4e:	f001 fde8 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 8008a52:	2314      	movs	r3, #20
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a54:	eb0d 0103 	add.w	r1, sp, r3
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 8008a58:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a5c:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 8008a60:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a64:	f001 fddd 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 8008a68:	2317      	movs	r3, #23
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 8008a6a:	f8c4 009c 	str.w	r0, [r4, #156]	; 0x9c
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a6e:	a905      	add	r1, sp, #20
 8008a70:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 8008a74:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a78:	f001 fdd3 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8008a7c:	2318      	movs	r3, #24
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 8008a7e:	f884 00a1 	strb.w	r0, [r4, #161]	; 0xa1
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a82:	a905      	add	r1, sp, #20
 8008a84:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 8008a88:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a8c:	f001 fdc9 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;

    getPhy.Attribute = PHY_DEF_RX2_DR;
 8008a90:	2319      	movs	r3, #25
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 8008a92:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 8008a96:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008a9a:	a905      	add	r1, sp, #20
 8008a9c:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_RX2_DR;
 8008aa0:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008aa4:	f001 fdbd 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8008aa8:	b2c0      	uxtb	r0, r0
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8008aaa:	231e      	movs	r3, #30
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 8008aac:	f884 00a8 	strb.w	r0, [r4, #168]	; 0xa8
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 8008ab0:	f884 00b0 	strb.w	r0, [r4, #176]	; 0xb0
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008ab4:	a905      	add	r1, sp, #20
 8008ab6:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 8008aba:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008abe:	f001 fdb0 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 8008ac2:	231f      	movs	r3, #31
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 8008ac4:	f884 00b4 	strb.w	r0, [r4, #180]	; 0xb4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008ac8:	a905      	add	r1, sp, #20
 8008aca:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 8008ace:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008ad2:	f001 fda6 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8008ad6:	2320      	movs	r3, #32
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 8008ad8:	f884 00b5 	strb.w	r0, [r4, #181]	; 0xb5
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008adc:	a905      	add	r1, sp, #20
 8008ade:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 8008ae2:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008ae6:	f001 fd9c 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8008aea:	2321      	movs	r3, #33	; 0x21
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 8008aec:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008af0:	a905      	add	r1, sp, #20
 8008af2:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 8008af6:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008afa:	f001 fd92 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 8008afe:	230b      	movs	r3, #11
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 8008b00:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008b04:	a905      	add	r1, sp, #20
 8008b06:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 8008b0a:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008b0e:	f001 fd88 	bl	800a622 <RegionGetPhyParam>
    MacCtx.AdrAckLimit = phyParam.Value;

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 8008b12:	230c      	movs	r3, #12
    MacCtx.AdrAckLimit = phyParam.Value;
 8008b14:	f8a5 03f4 	strh.w	r0, [r5, #1012]	; 0x3f4
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008b18:	a905      	add	r1, sp, #20
 8008b1a:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 8008b1e:	f88d 3014 	strb.w	r3, [sp, #20]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008b22:	f001 fd7e 	bl	800a622 <RegionGetPhyParam>
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 8008b26:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 8008b2a:	64e3      	str	r3, [r4, #76]	; 0x4c
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 8008b2c:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8008b30:	6523      	str	r3, [r4, #80]	; 0x50
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 8008b32:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8008b36:	6563      	str	r3, [r4, #84]	; 0x54
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 8008b38:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8008b3c:	65a3      	str	r3, [r4, #88]	; 0x58
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 8008b3e:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 8008b42:	65e3      	str	r3, [r4, #92]	; 0x5c
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;

    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8008b44:	f504 73ec 	add.w	r3, r4, #472	; 0x1d8
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8008b48:	a907      	add	r1, sp, #28
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008b4a:	9004      	str	r0, [sp, #16]
    MacCtx.AdrAckDelay = phyParam.Value;
 8008b4c:	f8a5 03f6 	strh.w	r0, [r5, #1014]	; 0x3f6
    params.NvmGroup1 = &Nvm.RegionGroup1;
 8008b50:	9307      	str	r3, [sp, #28]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8008b52:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
    params.Type = INIT_TYPE_DEFAULTS;
 8008b56:	f88d 6024 	strb.w	r6, [sp, #36]	; 0x24
    params.NvmGroup2 = &Nvm.RegionGroup2;
 8008b5a:	f504 731f 	add.w	r3, r4, #636	; 0x27c
 8008b5e:	9308      	str	r3, [sp, #32]
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 8008b60:	f884 80a0 	strb.w	r8, [r4, #160]	; 0xa0
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 8008b64:	f8c4 b084 	str.w	fp, [r4, #132]	; 0x84
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 8008b68:	f884 a088 	strb.w	sl, [r4, #136]	; 0x88
    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 8008b6c:	f8c4 b044 	str.w	fp, [r4, #68]	; 0x44
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 8008b70:	f884 a048 	strb.w	sl, [r4, #72]	; 0x48
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 8008b74:	f884 8060 	strb.w	r8, [r4, #96]	; 0x60
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 8008b78:	f001 fd6e 	bl	800a658 <RegionInitDefaults>

    MacCtx.MacCallbacks = callbacks;
 8008b7c:	f8c5 9348 	str.w	r9, [r5, #840]	; 0x348
    ResetMacParameters( );
 8008b80:	f7fe fc0c 	bl	800739c <ResetMacParameters>
    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
    Nvm.MacGroup1.AggregatedTimeOff = 0;

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8008b84:	4632      	mov	r2, r6
 8008b86:	4b3f      	ldr	r3, [pc, #252]	; (8008c84 <LoRaMacInitialization+0x348>)
 8008b88:	9600      	str	r6, [sp, #0]
 8008b8a:	f04f 31ff 	mov.w	r1, #4294967295
 8008b8e:	f505 705a 	add.w	r0, r5, #872	; 0x368
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 8008b92:	e9c4 660b 	strd	r6, r6, [r4, #44]	; 0x2c
    MacCtx.MacPrimitives = primitives;
 8008b96:	f8c5 7344 	str.w	r7, [r5, #836]	; 0x344
    MacCtx.MacFlags.Value = 0;
 8008b9a:	f885 6481 	strb.w	r6, [r5, #1153]	; 0x481
    Nvm.MacGroup2.PublicNetwork = true;
 8008b9e:	f884 80fd 	strb.w	r8, [r4, #253]	; 0xfd
    MacCtx.MacState = LORAMAC_STOPPED;
 8008ba2:	f8c5 8340 	str.w	r8, [r5, #832]	; 0x340
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 8008ba6:	f006 fc8d 	bl	800f4c4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 8008baa:	4632      	mov	r2, r6
 8008bac:	4b36      	ldr	r3, [pc, #216]	; (8008c88 <LoRaMacInitialization+0x34c>)
 8008bae:	9600      	str	r6, [sp, #0]
 8008bb0:	f04f 31ff 	mov.w	r1, #4294967295
 8008bb4:	f505 7060 	add.w	r0, r5, #896	; 0x380
 8008bb8:	f006 fc84 	bl	800f4c4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 8008bbc:	4632      	mov	r2, r6
 8008bbe:	4b33      	ldr	r3, [pc, #204]	; (8008c8c <LoRaMacInitialization+0x350>)
 8008bc0:	9600      	str	r6, [sp, #0]
 8008bc2:	f04f 31ff 	mov.w	r1, #4294967295
 8008bc6:	f505 7066 	add.w	r0, r5, #920	; 0x398
 8008bca:	f006 fc7b 	bl	800f4c4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8008bce:	4632      	mov	r2, r6
 8008bd0:	4b2f      	ldr	r3, [pc, #188]	; (8008c90 <LoRaMacInitialization+0x354>)
 8008bd2:	9600      	str	r6, [sp, #0]
 8008bd4:	f04f 31ff 	mov.w	r1, #4294967295

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8008bd8:	ae02      	add	r6, sp, #8
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
 8008bda:	f505 707e 	add.w	r0, r5, #1016	; 0x3f8
 8008bde:	f006 fc71 	bl	800f4c4 <UTIL_TIMER_Create>
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 8008be2:	4630      	mov	r0, r6
 8008be4:	f006 fc04 	bl	800f3f0 <SysTimeGetMcuTime>
 8008be8:	e896 0003 	ldmia.w	r6, {r0, r1}
 8008bec:	f504 7382 	add.w	r3, r4, #260	; 0x104
 8008bf0:	e883 0003 	stmia.w	r3, {r0, r1}

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 8008bf4:	4b27      	ldr	r3, [pc, #156]	; (8008c94 <LoRaMacInitialization+0x358>)
 8008bf6:	f8c5 334c 	str.w	r3, [r5, #844]	; 0x34c
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 8008bfa:	4b27      	ldr	r3, [pc, #156]	; (8008c98 <LoRaMacInitialization+0x35c>)
 8008bfc:	f8c5 3354 	str.w	r3, [r5, #852]	; 0x354
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 8008c00:	4b26      	ldr	r3, [pc, #152]	; (8008c9c <LoRaMacInitialization+0x360>)
 8008c02:	f8c5 335c 	str.w	r3, [r5, #860]	; 0x35c
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
    Radio.Init( &MacCtx.RadioEvents );
 8008c06:	4f26      	ldr	r7, [pc, #152]	; (8008ca0 <LoRaMacInitialization+0x364>)
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 8008c08:	4b26      	ldr	r3, [pc, #152]	; (8008ca4 <LoRaMacInitialization+0x368>)
 8008c0a:	f8c5 3350 	str.w	r3, [r5, #848]	; 0x350
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 8008c0e:	4b26      	ldr	r3, [pc, #152]	; (8008ca8 <LoRaMacInitialization+0x36c>)
 8008c10:	f8c5 3358 	str.w	r3, [r5, #856]	; 0x358
    Radio.Init( &MacCtx.RadioEvents );
 8008c14:	f505 7053 	add.w	r0, r5, #844	; 0x34c
 8008c18:	683b      	ldr	r3, [r7, #0]
 8008c1a:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement, callbacks->GetUniqueId ) != SECURE_ELEMENT_SUCCESS ) /* ST_WORKAROUND: Add unique ID callback as input parameter */
 8008c1c:	f8d9 1008 	ldr.w	r1, [r9, #8]
 8008c20:	f504 708c 	add.w	r0, r4, #280	; 0x118
 8008c24:	f004 f8bc 	bl	800cda0 <SecureElementInit>
 8008c28:	b120      	cbz	r0, 8008c34 <LoRaMacInitialization+0x2f8>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
 8008c2a:	2611      	movs	r6, #17
    Radio.Sleep( );

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );

    return LORAMAC_STATUS_OK;
}
 8008c2c:	4630      	mov	r0, r6
 8008c2e:	b00b      	add	sp, #44	; 0x2c
 8008c30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 8008c34:	4620      	mov	r0, r4
 8008c36:	f001 f989 	bl	8009f4c <LoRaMacCryptoInit>
 8008c3a:	2800      	cmp	r0, #0
 8008c3c:	d1f5      	bne.n	8008c2a <LoRaMacInitialization+0x2ee>
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 8008c3e:	f000 fe9d 	bl	800997c <LoRaMacCommandsInit>
 8008c42:	b9b8      	cbnz	r0, 8008c74 <LoRaMacInitialization+0x338>
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 8008c44:	4819      	ldr	r0, [pc, #100]	; (8008cac <LoRaMacInitialization+0x370>)
 8008c46:	f001 f9e7 	bl	800a018 <LoRaMacCryptoSetMulticastReference>
 8008c4a:	4606      	mov	r6, r0
 8008c4c:	2800      	cmp	r0, #0
 8008c4e:	d1ec      	bne.n	8008c2a <LoRaMacInitialization+0x2ee>
    srand1( Radio.Random( ) );
 8008c50:	697b      	ldr	r3, [r7, #20]
 8008c52:	4798      	blx	r3
 8008c54:	f004 fa4c 	bl	800d0f0 <srand1>
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8008c58:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8008c5a:	f894 00fd 	ldrb.w	r0, [r4, #253]	; 0xfd
 8008c5e:	4798      	blx	r3
    Radio.Sleep( );
 8008c60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008c62:	4798      	blx	r3
    MacCtx.AllowRequests = requestState;
 8008c64:	2301      	movs	r3, #1
 8008c66:	f885 3482 	strb.w	r3, [r5, #1154]	; 0x482
    return LORAMAC_STATUS_OK;
 8008c6a:	e7df      	b.n	8008c2c <LoRaMacInitialization+0x2f0>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8008c6c:	2603      	movs	r6, #3
 8008c6e:	e7dd      	b.n	8008c2c <LoRaMacInitialization+0x2f0>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 8008c70:	2609      	movs	r6, #9
 8008c72:	e7db      	b.n	8008c2c <LoRaMacInitialization+0x2f0>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8008c74:	2613      	movs	r6, #19
 8008c76:	e7d9      	b.n	8008c2c <LoRaMacInitialization+0x2f0>
 8008c78:	200009bc 	.word	0x200009bc
 8008c7c:	200004b4 	.word	0x200004b4
 8008c80:	01000300 	.word	0x01000300
 8008c84:	0800779d 	.word	0x0800779d
 8008c88:	08007951 	.word	0x08007951
 8008c8c:	08007991 	.word	0x08007991
 8008c90:	08007135 	.word	0x08007135
 8008c94:	08007345 	.word	0x08007345
 8008c98:	080072f1 	.word	0x080072f1
 8008c9c:	08007075 	.word	0x08007075
 8008ca0:	08010fe4 	.word	0x08010fe4
 8008ca4:	080072b9 	.word	0x080072b9
 8008ca8:	08007281 	.word	0x08007281
 8008cac:	20000a8c 	.word	0x20000a8c

08008cb0 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
    MacCtx.MacState = LORAMAC_IDLE;
 8008cb0:	4b02      	ldr	r3, [pc, #8]	; (8008cbc <LoRaMacStart+0xc>)
 8008cb2:	2000      	movs	r0, #0
 8008cb4:	f8c3 0340 	str.w	r0, [r3, #832]	; 0x340
    return LORAMAC_STATUS_OK;
}
 8008cb8:	4770      	bx	lr
 8008cba:	bf00      	nop
 8008cbc:	200004b4 	.word	0x200004b4

08008cc0 <LoRaMacQueryTxPossible>:
    }
    return LORAMAC_STATUS_BUSY;
}

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 8008cc0:	b530      	push	{r4, r5, lr}
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8008cc2:	4b29      	ldr	r3, [pc, #164]	; (8008d68 <LoRaMacQueryTxPossible+0xa8>)
{
 8008cc4:	b089      	sub	sp, #36	; 0x24
 8008cc6:	4605      	mov	r5, r0
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8008cc8:	f893 00c5 	ldrb.w	r0, [r3, #197]	; 0xc5
 8008ccc:	f88d 0002 	strb.w	r0, [sp, #2]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8008cd0:	f893 00c4 	ldrb.w	r0, [r3, #196]	; 0xc4
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8008cd4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8008cd6:	f88d 0003 	strb.w	r0, [sp, #3]
    size_t macCmdsSize = 0;
 8008cda:	2000      	movs	r0, #0
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8008cdc:	9201      	str	r2, [sp, #4]
    size_t macCmdsSize = 0;
 8008cde:	9002      	str	r0, [sp, #8]

    if( txInfo == NULL )
 8008ce0:	460c      	mov	r4, r1
 8008ce2:	2900      	cmp	r1, #0
 8008ce4:	d03c      	beq.n	8008d60 <LoRaMacQueryTxPossible+0xa0>

    // Setup ADR request
    adrNext.Version = Nvm.MacGroup2.Version;
    adrNext.UpdateChanMask = false;
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8008ce6:	9205      	str	r2, [sp, #20]
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8008ce8:	4a20      	ldr	r2, [pc, #128]	; (8008d6c <LoRaMacQueryTxPossible+0xac>)
    adrNext.Version = Nvm.MacGroup2.Version;
 8008cea:	f8d3 110c 	ldr.w	r1, [r3, #268]	; 0x10c
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8008cee:	f8d2 23f4 	ldr.w	r2, [r2, #1012]	; 0x3f4
 8008cf2:	9206      	str	r2, [sp, #24]
    adrNext.AdrAckDelay = MacCtx.AdrAckDelay;
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8008cf4:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
    adrNext.Version = Nvm.MacGroup2.Version;
 8008cf6:	9103      	str	r1, [sp, #12]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8008cf8:	ba52      	rev16	r2, r2
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8008cfa:	f893 10fe 	ldrb.w	r1, [r3, #254]	; 0xfe
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8008cfe:	f8ad 201c 	strh.w	r2, [sp, #28]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8008d02:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
    adrNext.Region = Nvm.MacGroup2.Region;
 8008d06:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
    adrNext.UpdateChanMask = false;
 8008d0a:	f88d 0010 	strb.w	r0, [sp, #16]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 8008d0e:	f88d 1011 	strb.w	r1, [sp, #17]
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8008d12:	f88d 201e 	strb.w	r2, [sp, #30]
    adrNext.Region = Nvm.MacGroup2.Region;
 8008d16:	f88d 301f 	strb.w	r3, [sp, #31]

    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
 8008d1a:	f10d 0203 	add.w	r2, sp, #3
 8008d1e:	ab01      	add	r3, sp, #4
 8008d20:	f10d 0102 	add.w	r1, sp, #2
 8008d24:	a803      	add	r0, sp, #12
 8008d26:	f000 fd93 	bl	8009850 <LoRaMacAdrCalcNext>

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 8008d2a:	f99d 0002 	ldrsb.w	r0, [sp, #2]
 8008d2e:	f7fe f9e5 	bl	80070fc <GetMaxAppPayloadWithoutFOptsLength>
 8008d32:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8008d34:	a802      	add	r0, sp, #8
 8008d36:	f000 fec9 	bl	8009acc <LoRaMacCommandsGetSizeSerializedCmds>
 8008d3a:	b998      	cbnz	r0, 8008d64 <LoRaMacQueryTxPossible+0xa4>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 8008d3c:	9b02      	ldr	r3, [sp, #8]
 8008d3e:	2b0f      	cmp	r3, #15
 8008d40:	d80a      	bhi.n	8008d58 <LoRaMacQueryTxPossible+0x98>
 8008d42:	7862      	ldrb	r2, [r4, #1]
 8008d44:	4293      	cmp	r3, r2
 8008d46:	d807      	bhi.n	8008d58 <LoRaMacQueryTxPossible+0x98>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8008d48:	1ad1      	subs	r1, r2, r3

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 8008d4a:	441d      	add	r5, r3
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 8008d4c:	7021      	strb	r1, [r4, #0]
        {
            return LORAMAC_STATUS_OK;
        }
        else
        {
           return LORAMAC_STATUS_LENGTH_ERROR;
 8008d4e:	42aa      	cmp	r2, r5
 8008d50:	bf38      	it	cc
 8008d52:	2008      	movcc	r0, #8
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 8008d54:	b009      	add	sp, #36	; 0x24
 8008d56:	bd30      	pop	{r4, r5, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 8008d58:	2300      	movs	r3, #0
 8008d5a:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 8008d5c:	2008      	movs	r0, #8
 8008d5e:	e7f9      	b.n	8008d54 <LoRaMacQueryTxPossible+0x94>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8008d60:	2003      	movs	r0, #3
 8008d62:	e7f7      	b.n	8008d54 <LoRaMacQueryTxPossible+0x94>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8008d64:	2013      	movs	r0, #19
 8008d66:	e7f5      	b.n	8008d54 <LoRaMacQueryTxPossible+0x94>
 8008d68:	200009bc 	.word	0x200009bc
 8008d6c:	200004b4 	.word	0x200004b4

08008d70 <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 8008d70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 8008d72:	4604      	mov	r4, r0
 8008d74:	2800      	cmp	r0, #0
 8008d76:	f000 80a1 	beq.w	8008ebc <LoRaMacMibGetRequestConfirm+0x14c>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 8008d7a:	7800      	ldrb	r0, [r0, #0]
 8008d7c:	2828      	cmp	r0, #40	; 0x28
 8008d7e:	f200 8099 	bhi.w	8008eb4 <LoRaMacMibGetRequestConfirm+0x144>
 8008d82:	e8df f000 	tbb	[pc, r0]
 8008d86:	1b15      	.short	0x1b15
 8008d88:	2c282520 	.word	0x2c282520
 8008d8c:	97979731 	.word	0x97979731
 8008d90:	97979797 	.word	0x97979797
 8008d94:	3d393597 	.word	0x3d393597
 8008d98:	54514e47 	.word	0x54514e47
 8008d9c:	5f5b5759 	.word	0x5f5b5759
 8008da0:	6b686562 	.word	0x6b686562
 8008da4:	767a726e 	.word	0x767a726e
 8008da8:	8b85817e 	.word	0x8b85817e
 8008dac:	9789      	.short	0x9789
 8008dae:	8f          	.byte	0x8f
 8008daf:	00          	.byte	0x00
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 8008db0:	4b43      	ldr	r3, [pc, #268]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008db2:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 8008db6:	7123      	strb	r3, [r4, #4]
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
            break;
        }
    }
    return status;
}
 8008db8:	b004      	add	sp, #16
 8008dba:	bd10      	pop	{r4, pc}
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 8008dbc:	4b40      	ldr	r3, [pc, #256]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008dbe:	f893 3110 	ldrb.w	r3, [r3, #272]	; 0x110
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8008dc2:	7123      	strb	r3, [r4, #4]
            break;
 8008dc4:	e002      	b.n	8008dcc <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevEui = SecureElementGetDevEui( );
 8008dc6:	f004 f977 	bl	800d0b8 <SecureElementGetDevEui>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8008dca:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 8008dcc:	2000      	movs	r0, #0
            break;
 8008dce:	e7f3      	b.n	8008db8 <LoRaMacMibGetRequestConfirm+0x48>
            mibGet->Param.JoinEui = SecureElementGetJoinEui( );
 8008dd0:	f004 f988 	bl	800d0e4 <SecureElementGetJoinEui>
 8008dd4:	e7f9      	b.n	8008dca <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 8008dd6:	4b3a      	ldr	r3, [pc, #232]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008dd8:	f893 30fe 	ldrb.w	r3, [r3, #254]	; 0xfe
 8008ddc:	e7f1      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 8008dde:	4b38      	ldr	r3, [pc, #224]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008de0:	f8d3 30c8 	ldr.w	r3, [r3, #200]	; 0xc8
            mibGet->Param.Contexts = GetNvmData( );
 8008de4:	6063      	str	r3, [r4, #4]
            break;
 8008de6:	e7f1      	b.n	8008dcc <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.DevAddr = Nvm.MacGroup2.DevAddr;
 8008de8:	4b35      	ldr	r3, [pc, #212]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008dea:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 8008dee:	e7f9      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 8008df0:	4b33      	ldr	r3, [pc, #204]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008df2:	f893 30fd 	ldrb.w	r3, [r3, #253]	; 0xfd
 8008df6:	e7e4      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 8008df8:	4b31      	ldr	r3, [pc, #196]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008dfa:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8008dfe:	e7e0      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            getPhy.Attribute = PHY_CHANNELS;
 8008e00:	231d      	movs	r3, #29
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8008e02:	f88d 3008 	strb.w	r3, [sp, #8]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8008e06:	4b2e      	ldr	r3, [pc, #184]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e08:	a902      	add	r1, sp, #8
 8008e0a:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 8008e0e:	f001 fc08 	bl	800a622 <RegionGetPhyParam>
 8008e12:	e7da      	b.n	8008dca <LoRaMacMibGetRequestConfirm+0x5a>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 8008e14:	4b2b      	ldr	r3, [pc, #172]	; (8008ec4 <LoRaMacMibGetRequestConfirm+0x154>)
 8008e16:	3404      	adds	r4, #4
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8008e18:	e893 0003 	ldmia.w	r3, {r0, r1}
 8008e1c:	e884 0003 	stmia.w	r4, {r0, r1}
            break;
 8008e20:	e7d4      	b.n	8008dcc <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 8008e22:	4b29      	ldr	r3, [pc, #164]	; (8008ec8 <LoRaMacMibGetRequestConfirm+0x158>)
 8008e24:	3404      	adds	r4, #4
 8008e26:	e7f7      	b.n	8008e18 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 8008e28:	4b28      	ldr	r3, [pc, #160]	; (8008ecc <LoRaMacMibGetRequestConfirm+0x15c>)
 8008e2a:	3404      	adds	r4, #4
 8008e2c:	e7f4      	b.n	8008e18 <LoRaMacMibGetRequestConfirm+0xa8>
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 8008e2e:	4b28      	ldr	r3, [pc, #160]	; (8008ed0 <LoRaMacMibGetRequestConfirm+0x160>)
 8008e30:	3404      	adds	r4, #4
 8008e32:	e7f1      	b.n	8008e18 <LoRaMacMibGetRequestConfirm+0xa8>
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 8008e34:	231b      	movs	r3, #27
 8008e36:	e7e4      	b.n	8008e02 <LoRaMacMibGetRequestConfirm+0x92>
            getPhy.Attribute = PHY_CHANNELS_MASK;
 8008e38:	231a      	movs	r3, #26
 8008e3a:	e7e2      	b.n	8008e02 <LoRaMacMibGetRequestConfirm+0x92>
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 8008e3c:	4b20      	ldr	r3, [pc, #128]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e3e:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8008e42:	e7be      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 8008e44:	4b1e      	ldr	r3, [pc, #120]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e46:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8008e48:	e7cc      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 8008e4a:	4b1d      	ldr	r3, [pc, #116]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e4c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008e4e:	e7c9      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 8008e50:	4b1b      	ldr	r3, [pc, #108]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e52:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8008e54:	e7c6      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 8008e56:	4b1a      	ldr	r3, [pc, #104]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e58:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008e5a:	e7c3      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 8008e5c:	4b18      	ldr	r3, [pc, #96]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e5e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8008e60:	e7c0      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 8008e62:	4b17      	ldr	r3, [pc, #92]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e64:	f893 30c5 	ldrb.w	r3, [r3, #197]	; 0xc5
 8008e68:	e7ab      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 8008e6a:	4b15      	ldr	r3, [pc, #84]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e6c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8008e70:	e7a7      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 8008e72:	4b13      	ldr	r3, [pc, #76]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e74:	f893 30c4 	ldrb.w	r3, [r3, #196]	; 0xc4
 8008e78:	e7a3      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 8008e7a:	4b11      	ldr	r3, [pc, #68]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e7c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8008e80:	e79f      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 8008e82:	4b0f      	ldr	r3, [pc, #60]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8008e86:	e7ad      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 8008e88:	4b0d      	ldr	r3, [pc, #52]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e8a:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 8008e8e:	e798      	b.n	8008dc2 <LoRaMacMibGetRequestConfirm+0x52>
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 8008e90:	4b0b      	ldr	r3, [pc, #44]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e92:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8008e94:	6063      	str	r3, [r4, #4]
            break;
 8008e96:	e799      	b.n	8008dcc <LoRaMacMibGetRequestConfirm+0x5c>
            mibGet->Param.Contexts = GetNvmData( );
 8008e98:	4b09      	ldr	r3, [pc, #36]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e9a:	e7a3      	b.n	8008de4 <LoRaMacMibGetRequestConfirm+0x74>
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 8008e9c:	4b08      	ldr	r3, [pc, #32]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008e9e:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
 8008ea2:	e7f7      	b.n	8008e94 <LoRaMacMibGetRequestConfirm+0x124>
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 8008ea4:	4b06      	ldr	r3, [pc, #24]	; (8008ec0 <LoRaMacMibGetRequestConfirm+0x150>)
 8008ea6:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8008eaa:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 8008eac:	f001 fcb8 	bl	800a820 <RegionGetVersion>
 8008eb0:	60a0      	str	r0, [r4, #8]
 8008eb2:	e78b      	b.n	8008dcc <LoRaMacMibGetRequestConfirm+0x5c>
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 8008eb4:	4620      	mov	r0, r4
 8008eb6:	f000 fd51 	bl	800995c <LoRaMacClassBMibGetRequestConfirm>
            break;
 8008eba:	e77d      	b.n	8008db8 <LoRaMacMibGetRequestConfirm+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8008ebc:	2003      	movs	r0, #3
 8008ebe:	e77b      	b.n	8008db8 <LoRaMacMibGetRequestConfirm+0x48>
 8008ec0:	200009bc 	.word	0x200009bc
 8008ec4:	20000a20 	.word	0x20000a20
 8008ec8:	20000a60 	.word	0x20000a60
 8008ecc:	20000a28 	.word	0x20000a28
 8008ed0:	20000a68 	.word	0x20000a68

08008ed4 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 8008ed4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 8008ed6:	4604      	mov	r4, r0
 8008ed8:	2800      	cmp	r0, #0
 8008eda:	d045      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 8008edc:	4da2      	ldr	r5, [pc, #648]	; (8009168 <LoRaMacMibSetRequestConfirm+0x294>)
 8008ede:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8008ee2:	079a      	lsls	r2, r3, #30
 8008ee4:	f100 8214 	bmi.w	8009310 <LoRaMacMibSetRequestConfirm+0x43c>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 8008ee8:	7802      	ldrb	r2, [r0, #0]
 8008eea:	2a27      	cmp	r2, #39	; 0x27
 8008eec:	f200 820d 	bhi.w	800930a <LoRaMacMibSetRequestConfirm+0x436>
 8008ef0:	e8df f012 	tbh	[pc, r2, lsl #1]
 8008ef4:	002d0028 	.word	0x002d0028
 8008ef8:	003c0035 	.word	0x003c0035
 8008efc:	00450040 	.word	0x00450040
 8008f00:	004f004a 	.word	0x004f004a
 8008f04:	005e0059 	.word	0x005e0059
 8008f08:	00680063 	.word	0x00680063
 8008f0c:	0072006d 	.word	0x0072006d
 8008f10:	007c0077 	.word	0x007c0077
 8008f14:	020b0086 	.word	0x020b0086
 8008f18:	00ab008b 	.word	0x00ab008b
 8008f1c:	00e500be 	.word	0x00e500be
 8008f20:	00f80107 	.word	0x00f80107
 8008f24:	0114010b 	.word	0x0114010b
 8008f28:	011c0118 	.word	0x011c0118
 8008f2c:	01240120 	.word	0x01240120
 8008f30:	01400128 	.word	0x01400128
 8008f34:	01560168 	.word	0x01560168
 8008f38:	0180017a 	.word	0x0180017a
 8008f3c:	018b0187 	.word	0x018b0187
 8008f40:	01ff0190 	.word	0x01ff0190
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 8008f44:	7900      	ldrb	r0, [r0, #4]
 8008f46:	f7fe fc7f 	bl	8007848 <SwitchClass>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
            break;
        }
    }
    return status;
}
 8008f4a:	b003      	add	sp, #12
 8008f4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 8008f4e:	7903      	ldrb	r3, [r0, #4]
 8008f50:	2b02      	cmp	r3, #2
 8008f52:	d009      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 8008f54:	4a85      	ldr	r2, [pc, #532]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8008f56:	f882 3110 	strb.w	r3, [r2, #272]	; 0x110
    return LORAMAC_STATUS_OK;
 8008f5a:	2000      	movs	r0, #0
 8008f5c:	e7f5      	b.n	8008f4a <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 8008f5e:	6840      	ldr	r0, [r0, #4]
 8008f60:	f004 f89c 	bl	800d09c <SecureElementSetDevEui>
 8008f64:	2800      	cmp	r0, #0
 8008f66:	d0f8      	beq.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 8008f68:	2003      	movs	r0, #3
 8008f6a:	e7ee      	b.n	8008f4a <LoRaMacMibSetRequestConfirm+0x76>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 8008f6c:	6840      	ldr	r0, [r0, #4]
 8008f6e:	f004 f8a9 	bl	800d0c4 <SecureElementSetJoinEui>
 8008f72:	e7f7      	b.n	8008f64 <LoRaMacMibSetRequestConfirm+0x90>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 8008f74:	4b7d      	ldr	r3, [pc, #500]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8008f76:	7902      	ldrb	r2, [r0, #4]
 8008f78:	f883 20fe 	strb.w	r2, [r3, #254]	; 0xfe
            break;
 8008f7c:	e7ed      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 8008f7e:	4b7b      	ldr	r3, [pc, #492]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8008f80:	6842      	ldr	r2, [r0, #4]
 8008f82:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
            break;
 8008f86:	e7e8      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 8008f88:	4b78      	ldr	r3, [pc, #480]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8008f8a:	6842      	ldr	r2, [r0, #4]
 8008f8c:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
            break;
 8008f90:	e7e3      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( mibSet->Param.AppKey != NULL )
 8008f92:	6841      	ldr	r1, [r0, #4]
 8008f94:	2900      	cmp	r1, #0
 8008f96:	d0e7      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 8008f98:	2000      	movs	r0, #0
 8008f9a:	f001 f963 	bl	800a264 <LoRaMacCryptoSetKey>
 8008f9e:	2800      	cmp	r0, #0
 8008fa0:	d0db      	beq.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 8008fa2:	2011      	movs	r0, #17
 8008fa4:	e7d1      	b.n	8008f4a <LoRaMacMibSetRequestConfirm+0x76>
            if( mibSet->Param.NwkKey != NULL )
 8008fa6:	6841      	ldr	r1, [r0, #4]
 8008fa8:	2900      	cmp	r1, #0
 8008faa:	d0dd      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 8008fac:	2001      	movs	r0, #1
 8008fae:	e7f4      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.NwkSKey != NULL )
 8008fb0:	6841      	ldr	r1, [r0, #4]
 8008fb2:	2900      	cmp	r1, #0
 8008fb4:	d0d8      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 8008fb6:	2002      	movs	r0, #2
 8008fb8:	e7ef      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.AppSKey != NULL )
 8008fba:	6841      	ldr	r1, [r0, #4]
 8008fbc:	2900      	cmp	r1, #0
 8008fbe:	d0d3      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 8008fc0:	2003      	movs	r0, #3
 8008fc2:	e7ea      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.McKEKey != NULL )
 8008fc4:	6841      	ldr	r1, [r0, #4]
 8008fc6:	2900      	cmp	r1, #0
 8008fc8:	d0ce      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 8008fca:	207f      	movs	r0, #127	; 0x7f
 8008fcc:	e7e5      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.McKey0 != NULL )
 8008fce:	6841      	ldr	r1, [r0, #4]
 8008fd0:	2900      	cmp	r1, #0
 8008fd2:	d0c9      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 8008fd4:	2080      	movs	r0, #128	; 0x80
 8008fd6:	e7e0      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.McAppSKey0 != NULL )
 8008fd8:	6841      	ldr	r1, [r0, #4]
 8008fda:	2900      	cmp	r1, #0
 8008fdc:	d0c4      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 8008fde:	2081      	movs	r0, #129	; 0x81
 8008fe0:	e7db      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            if( mibSet->Param.McNwkSKey0 != NULL )
 8008fe2:	6841      	ldr	r1, [r0, #4]
 8008fe4:	2900      	cmp	r1, #0
 8008fe6:	d0bf      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 8008fe8:	2082      	movs	r0, #130	; 0x82
 8008fea:	e7d6      	b.n	8008f9a <LoRaMacMibSetRequestConfirm+0xc6>
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8008fec:	4c60      	ldr	r4, [pc, #384]	; (8009170 <LoRaMacMibSetRequestConfirm+0x29c>)
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 8008fee:	4b5f      	ldr	r3, [pc, #380]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8008ff0:	7900      	ldrb	r0, [r0, #4]
 8008ff2:	f883 00fd 	strb.w	r0, [r3, #253]	; 0xfd
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 8008ff6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8008ff8:	4798      	blx	r3
            Radio.Sleep( );
 8008ffa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008ffc:	4798      	blx	r3
            break;
 8008ffe:	e7ac      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 8009000:	4b5a      	ldr	r3, [pc, #360]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8009002:	7902      	ldrb	r2, [r0, #4]
 8009004:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
            break;
 8009008:	e7a7      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800900a:	4d58      	ldr	r5, [pc, #352]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800900c:	7a03      	ldrb	r3, [r0, #8]
 800900e:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 8009012:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8009016:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
 800901a:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 800901e:	2207      	movs	r2, #7
 8009020:	4669      	mov	r1, sp
 8009022:	f001 fb24 	bl	800a66e <RegionVerify>
 8009026:	2800      	cmp	r0, #0
 8009028:	d09e      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 800902a:	6863      	ldr	r3, [r4, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 800902c:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 8009030:	9300      	str	r3, [sp, #0]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 8009032:	2200      	movs	r2, #0
 8009034:	4669      	mov	r1, sp
 8009036:	f001 fb1a 	bl	800a66e <RegionVerify>
 800903a:	2800      	cmp	r0, #0
 800903c:	d094      	beq.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 800903e:	3564      	adds	r5, #100	; 0x64
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 8009040:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8009044:	e885 0003 	stmia.w	r5, {r0, r1}
 8009048:	e787      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800904a:	4d48      	ldr	r5, [pc, #288]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 800904c:	7a03      	ldrb	r3, [r0, #8]
 800904e:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8009052:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8009056:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
 800905a:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 800905e:	2207      	movs	r2, #7
 8009060:	4669      	mov	r1, sp
 8009062:	f001 fb04 	bl	800a66e <RegionVerify>
 8009066:	2800      	cmp	r0, #0
 8009068:	f43f af7e 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 800906c:	35a4      	adds	r5, #164	; 0xa4
 800906e:	e7e7      	b.n	8009040 <LoRaMacMibSetRequestConfirm+0x16c>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8009070:	4d3e      	ldr	r5, [pc, #248]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 8009072:	7a03      	ldrb	r3, [r0, #8]
 8009074:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8009078:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 800907c:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
 8009080:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 8009084:	2207      	movs	r2, #7
 8009086:	4669      	mov	r1, sp
 8009088:	f001 faf1 	bl	800a66e <RegionVerify>
 800908c:	2800      	cmp	r0, #0
 800908e:	f43f af6b 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 8009092:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 8009096:	f105 036c 	add.w	r3, r5, #108	; 0x6c
 800909a:	e883 0003 	stmia.w	r3, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 800909e:	f895 30fc 	ldrb.w	r3, [r5, #252]	; 0xfc
 80090a2:	2b02      	cmp	r3, #2
 80090a4:	f47f af59 	bne.w	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
 80090a8:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 80090ac:	2b00      	cmp	r3, #0
 80090ae:	f43f af54 	beq.w	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
                    Radio.Sleep( );
 80090b2:	4b2f      	ldr	r3, [pc, #188]	; (8009170 <LoRaMacMibSetRequestConfirm+0x29c>)
 80090b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80090b6:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 80090b8:	f7fe fb9a 	bl	80077f0 <OpenContinuousRxCWindow>
 80090bc:	e74d      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80090be:	4d2b      	ldr	r5, [pc, #172]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 80090c0:	7a03      	ldrb	r3, [r0, #8]
 80090c2:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80090c6:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 80090ca:	f895 3075 	ldrb.w	r3, [r5, #117]	; 0x75
 80090ce:	f88d 3001 	strb.w	r3, [sp, #1]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 80090d2:	2207      	movs	r2, #7
 80090d4:	4669      	mov	r1, sp
 80090d6:	f001 faca 	bl	800a66e <RegionVerify>
 80090da:	2800      	cmp	r0, #0
 80090dc:	f43f af44 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 80090e0:	35ac      	adds	r5, #172	; 0xac
 80090e2:	e7ad      	b.n	8009040 <LoRaMacMibSetRequestConfirm+0x16c>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 80090e4:	6843      	ldr	r3, [r0, #4]
 80090e6:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 80090e8:	2301      	movs	r3, #1
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 80090ea:	f88d 3004 	strb.w	r3, [sp, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 80090ee:	4b1f      	ldr	r3, [pc, #124]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 80090f0:	4669      	mov	r1, sp
 80090f2:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 80090f6:	f001 fad2 	bl	800a69e <RegionChanMaskSet>
 80090fa:	2800      	cmp	r0, #0
 80090fc:	f47f af2d 	bne.w	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
 8009100:	e732      	b.n	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 8009102:	6843      	ldr	r3, [r0, #4]
 8009104:	9300      	str	r3, [sp, #0]
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 8009106:	2300      	movs	r3, #0
 8009108:	e7ef      	b.n	80090ea <LoRaMacMibSetRequestConfirm+0x216>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 800910a:	7903      	ldrb	r3, [r0, #4]
 800910c:	1e5a      	subs	r2, r3, #1
 800910e:	2a0e      	cmp	r2, #14
 8009110:	f63f af2a 	bhi.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 8009114:	4a15      	ldr	r2, [pc, #84]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8009116:	f882 3060 	strb.w	r3, [r2, #96]	; 0x60
 800911a:	e71e      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 800911c:	4b13      	ldr	r3, [pc, #76]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 800911e:	6842      	ldr	r2, [r0, #4]
 8009120:	64da      	str	r2, [r3, #76]	; 0x4c
            break;
 8009122:	e71a      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 8009124:	4b11      	ldr	r3, [pc, #68]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8009126:	6842      	ldr	r2, [r0, #4]
 8009128:	651a      	str	r2, [r3, #80]	; 0x50
            break;
 800912a:	e716      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 800912c:	4b0f      	ldr	r3, [pc, #60]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 800912e:	6842      	ldr	r2, [r0, #4]
 8009130:	655a      	str	r2, [r3, #84]	; 0x54
            break;
 8009132:	e712      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 8009134:	4b0d      	ldr	r3, [pc, #52]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 8009136:	6842      	ldr	r2, [r0, #4]
 8009138:	659a      	str	r2, [r3, #88]	; 0x58
            break;
 800913a:	e70e      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 800913c:	4b0b      	ldr	r3, [pc, #44]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
 800913e:	6842      	ldr	r2, [r0, #4]
 8009140:	65da      	str	r2, [r3, #92]	; 0x5c
            break;
 8009142:	e70a      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8009144:	4c09      	ldr	r4, [pc, #36]	; (800916c <LoRaMacMibSetRequestConfirm+0x298>)
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 8009146:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8009148:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 800914c:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 8009150:	2206      	movs	r2, #6
 8009152:	4669      	mov	r1, sp
 8009154:	f001 fa8b 	bl	800a66e <RegionVerify>
 8009158:	2800      	cmp	r0, #0
 800915a:	f43f af05 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 800915e:	f89d 3000 	ldrb.w	r3, [sp]
 8009162:	f884 30c5 	strb.w	r3, [r4, #197]	; 0xc5
 8009166:	e6f8      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
 8009168:	200004b4 	.word	0x200004b4
 800916c:	200009bc 	.word	0x200009bc
 8009170:	08010fe4 	.word	0x08010fe4
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8009174:	4c67      	ldr	r4, [pc, #412]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 8009176:	7903      	ldrb	r3, [r0, #4]
 8009178:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 800917c:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8009180:	f894 3074 	ldrb.w	r3, [r4, #116]	; 0x74
 8009184:	f88d 3002 	strb.w	r3, [sp, #2]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 8009188:	2205      	movs	r2, #5
 800918a:	4669      	mov	r1, sp
 800918c:	f001 fa6f 	bl	800a66e <RegionVerify>
 8009190:	2800      	cmp	r0, #0
 8009192:	f43f aee9 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 8009196:	f89d 3000 	ldrb.w	r3, [sp]
 800919a:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
 800919e:	e6dc      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 80091a0:	4c5c      	ldr	r4, [pc, #368]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 80091a2:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 80091a4:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 80091a8:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 80091ac:	220a      	movs	r2, #10
 80091ae:	4669      	mov	r1, sp
 80091b0:	f001 fa5d 	bl	800a66e <RegionVerify>
 80091b4:	2800      	cmp	r0, #0
 80091b6:	f43f aed7 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 80091ba:	f89d 3000 	ldrb.w	r3, [sp]
 80091be:	f884 30c4 	strb.w	r3, [r4, #196]	; 0xc4
 80091c2:	e6ca      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80091c4:	4c53      	ldr	r4, [pc, #332]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80091c6:	7903      	ldrb	r3, [r0, #4]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80091c8:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 80091cc:	f88d 3000 	strb.w	r3, [sp]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 80091d0:	2209      	movs	r2, #9
 80091d2:	4669      	mov	r1, sp
 80091d4:	f001 fa4b 	bl	800a66e <RegionVerify>
 80091d8:	2800      	cmp	r0, #0
 80091da:	f43f aec5 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 80091de:	f89d 3000 	ldrb.w	r3, [sp]
 80091e2:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
 80091e6:	e6b8      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 80091e8:	4b4a      	ldr	r3, [pc, #296]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 80091ea:	6842      	ldr	r2, [r0, #4]
 80091ec:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 80091f0:	645a      	str	r2, [r3, #68]	; 0x44
            break;
 80091f2:	e6b2      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 80091f4:	4b47      	ldr	r3, [pc, #284]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 80091f6:	7902      	ldrb	r2, [r0, #4]
 80091f8:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
 80091fc:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
            break;
 8009200:	e6ab      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 8009202:	4b44      	ldr	r3, [pc, #272]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 8009204:	6842      	ldr	r2, [r0, #4]
 8009206:	67da      	str	r2, [r3, #124]	; 0x7c
            break;
 8009208:	e6a7      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 800920a:	4b42      	ldr	r3, [pc, #264]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 800920c:	6842      	ldr	r2, [r0, #4]
 800920e:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
            break;
 8009212:	e6a2      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( mibSet->Param.Contexts != 0 )
 8009214:	6844      	ldr	r4, [r0, #4]
 8009216:	2c00      	cmp	r4, #0
 8009218:	f43f aea6 	beq.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
    if( MacCtx.MacState != LORAMAC_STOPPED )
 800921c:	2b01      	cmp	r3, #1
 800921e:	d177      	bne.n	8009310 <LoRaMacMibSetRequestConfirm+0x43c>
    crc = Crc32( ( uint8_t* ) &nvm->Crypto, sizeof( nvm->Crypto ) -
 8009220:	2124      	movs	r1, #36	; 0x24
 8009222:	4620      	mov	r0, r4
 8009224:	f003 ffa2 	bl	800d16c <Crc32>
    if( crc == nvm->Crypto.Crc32 )
 8009228:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800922a:	4298      	cmp	r0, r3
 800922c:	d104      	bne.n	8009238 <LoRaMacMibSetRequestConfirm+0x364>
        memcpy1( ( uint8_t* ) &Nvm.Crypto, ( uint8_t* ) &nvm->Crypto,
 800922e:	4839      	ldr	r0, [pc, #228]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 8009230:	2228      	movs	r2, #40	; 0x28
 8009232:	4621      	mov	r1, r4
 8009234:	f003 ff7e 	bl	800d134 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup1, sizeof( nvm->MacGroup1 ) -
 8009238:	f104 0628 	add.w	r6, r4, #40	; 0x28
 800923c:	2114      	movs	r1, #20
 800923e:	4630      	mov	r0, r6
 8009240:	f003 ff94 	bl	800d16c <Crc32>
    if( crc == nvm->MacGroup1.Crc32 )
 8009244:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009246:	4298      	cmp	r0, r3
 8009248:	d104      	bne.n	8009254 <LoRaMacMibSetRequestConfirm+0x380>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup1, ( uint8_t* ) &nvm->MacGroup1,
 800924a:	4833      	ldr	r0, [pc, #204]	; (8009318 <LoRaMacMibSetRequestConfirm+0x444>)
 800924c:	2218      	movs	r2, #24
 800924e:	4631      	mov	r1, r6
 8009250:	f003 ff70 	bl	800d134 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->MacGroup2, sizeof( nvm->MacGroup2 ) -
 8009254:	f104 0740 	add.w	r7, r4, #64	; 0x40
 8009258:	21d4      	movs	r1, #212	; 0xd4
 800925a:	4638      	mov	r0, r7
 800925c:	f003 ff86 	bl	800d16c <Crc32>
    if( crc == nvm->MacGroup2.Crc32 )
 8009260:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 8009264:	4298      	cmp	r0, r3
 8009266:	d115      	bne.n	8009294 <LoRaMacMibSetRequestConfirm+0x3c0>
        memcpy1( ( uint8_t* ) &Nvm.MacGroup2, ( uint8_t* ) &nvm->MacGroup2,
 8009268:	4e2a      	ldr	r6, [pc, #168]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 800926a:	22d8      	movs	r2, #216	; 0xd8
 800926c:	4639      	mov	r1, r7
 800926e:	f106 0040 	add.w	r0, r6, #64	; 0x40
 8009272:	f003 ff5f 	bl	800d134 <memcpy1>
        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 8009276:	f895 3415 	ldrb.w	r3, [r5, #1045]	; 0x415
 800927a:	f885 33e0 	strb.w	r3, [r5, #992]	; 0x3e0
        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 800927e:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
 8009280:	f8c5 33e4 	str.w	r3, [r5, #996]	; 0x3e4
        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 8009284:	f896 3075 	ldrb.w	r3, [r6, #117]	; 0x75
 8009288:	f885 33f0 	strb.w	r3, [r5, #1008]	; 0x3f0
        MacCtx.RxWindowCConfig.RxContinuous = true;
 800928c:	f240 2301 	movw	r3, #513	; 0x201
 8009290:	f8a5 33f2 	strh.w	r3, [r5, #1010]	; 0x3f2
    crc = Crc32( ( uint8_t* ) &nvm->SecureElement, sizeof( nvm->SecureElement ) -
 8009294:	f504 758c 	add.w	r5, r4, #280	; 0x118
 8009298:	21bc      	movs	r1, #188	; 0xbc
 800929a:	4628      	mov	r0, r5
 800929c:	f003 ff66 	bl	800d16c <Crc32>
    if( crc == nvm->SecureElement.Crc32 )
 80092a0:	f8d4 31d4 	ldr.w	r3, [r4, #468]	; 0x1d4
 80092a4:	4298      	cmp	r0, r3
 80092a6:	d104      	bne.n	80092b2 <LoRaMacMibSetRequestConfirm+0x3de>
        memcpy1( ( uint8_t* ) &Nvm.SecureElement,( uint8_t* ) &nvm->SecureElement,
 80092a8:	481c      	ldr	r0, [pc, #112]	; (800931c <LoRaMacMibSetRequestConfirm+0x448>)
 80092aa:	22c0      	movs	r2, #192	; 0xc0
 80092ac:	4629      	mov	r1, r5
 80092ae:	f003 ff41 	bl	800d134 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->RegionGroup1, sizeof( nvm->RegionGroup1 ) -
 80092b2:	f504 75ec 	add.w	r5, r4, #472	; 0x1d8
 80092b6:	21a0      	movs	r1, #160	; 0xa0
 80092b8:	4628      	mov	r0, r5
 80092ba:	f003 ff57 	bl	800d16c <Crc32>
    if( crc == nvm->RegionGroup1.Crc32 )
 80092be:	f8d4 3278 	ldr.w	r3, [r4, #632]	; 0x278
 80092c2:	4298      	cmp	r0, r3
 80092c4:	d104      	bne.n	80092d0 <LoRaMacMibSetRequestConfirm+0x3fc>
        memcpy1( ( uint8_t* ) &Nvm.RegionGroup1,( uint8_t* ) &nvm->RegionGroup1,
 80092c6:	4816      	ldr	r0, [pc, #88]	; (8009320 <LoRaMacMibSetRequestConfirm+0x44c>)
 80092c8:	22a4      	movs	r2, #164	; 0xa4
 80092ca:	4629      	mov	r1, r5
 80092cc:	f003 ff32 	bl	800d134 <memcpy1>
    crc = Crc32( ( uint8_t* ) &nvm->ClassB, sizeof( nvm->ClassB ) -
 80092d0:	f504 65bf 	add.w	r5, r4, #1528	; 0x5f8
 80092d4:	2114      	movs	r1, #20
 80092d6:	4628      	mov	r0, r5
 80092d8:	f003 ff48 	bl	800d16c <Crc32>
    if( crc == nvm->ClassB.Crc32 )
 80092dc:	f8d4 360c 	ldr.w	r3, [r4, #1548]	; 0x60c
 80092e0:	4298      	cmp	r0, r3
 80092e2:	f47f ae3a 	bne.w	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
        memcpy1( ( uint8_t* ) &Nvm.ClassB,( uint8_t* ) &nvm->ClassB,
 80092e6:	480f      	ldr	r0, [pc, #60]	; (8009324 <LoRaMacMibSetRequestConfirm+0x450>)
 80092e8:	2218      	movs	r2, #24
 80092ea:	4629      	mov	r1, r5
 80092ec:	f003 ff22 	bl	800d134 <memcpy1>
 80092f0:	e633      	b.n	8008f5a <LoRaMacMibSetRequestConfirm+0x86>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 80092f2:	7983      	ldrb	r3, [r0, #6]
 80092f4:	2b01      	cmp	r3, #1
 80092f6:	f63f ae37 	bhi.w	8008f68 <LoRaMacMibSetRequestConfirm+0x94>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 80092fa:	4b06      	ldr	r3, [pc, #24]	; (8009314 <LoRaMacMibSetRequestConfirm+0x440>)
 80092fc:	6842      	ldr	r2, [r0, #4]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 80092fe:	6840      	ldr	r0, [r0, #4]
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 8009300:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 8009304:	f000 fe3e 	bl	8009f84 <LoRaMacCryptoSetLrWanVersion>
 8009308:	e649      	b.n	8008f9e <LoRaMacMibSetRequestConfirm+0xca>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 800930a:	f000 fb29 	bl	8009960 <LoRaMacMibClassBSetRequestConfirm>
            break;
 800930e:	e61c      	b.n	8008f4a <LoRaMacMibSetRequestConfirm+0x76>
        return LORAMAC_STATUS_BUSY;
 8009310:	2001      	movs	r0, #1
 8009312:	e61a      	b.n	8008f4a <LoRaMacMibSetRequestConfirm+0x76>
 8009314:	200009bc 	.word	0x200009bc
 8009318:	200009e4 	.word	0x200009e4
 800931c:	20000ad4 	.word	0x20000ad4
 8009320:	20000b94 	.word	0x20000b94
 8009324:	20000fb4 	.word	0x20000fb4

08009328 <LoRaMacMlmeRequest>:
    }
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 8009328:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800932c:	b086      	sub	sp, #24
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 800932e:	2300      	movs	r3, #0
 8009330:	f8ad 3000 	strh.w	r3, [sp]

    if( mlmeRequest == NULL )
 8009334:	4606      	mov	r6, r0
 8009336:	2800      	cmp	r0, #0
 8009338:	f000 80e2 	beq.w	8009500 <LoRaMacMlmeRequest+0x1d8>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( LoRaMacIsBusy( ) == true )
 800933c:	f7fe fe26 	bl	8007f8c <LoRaMacIsBusy>
 8009340:	b120      	cbz	r0, 800934c <LoRaMacMlmeRequest+0x24>
    {
        return LORAMAC_STATUS_BUSY;
 8009342:	2401      	movs	r4, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 8009344:	4620      	mov	r0, r4
 8009346:	b006      	add	sp, #24
 8009348:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 800934c:	f000 fcfc 	bl	8009d48 <LoRaMacConfirmQueueIsFull>
 8009350:	2800      	cmp	r0, #0
 8009352:	d1f6      	bne.n	8009342 <LoRaMacMlmeRequest+0x1a>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 8009354:	f000 fcf2 	bl	8009d3c <LoRaMacConfirmQueueGetCnt>
 8009358:	4601      	mov	r1, r0
 800935a:	b918      	cbnz	r0, 8009364 <LoRaMacMlmeRequest+0x3c>
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 800935c:	4869      	ldr	r0, [pc, #420]	; (8009504 <LoRaMacMlmeRequest+0x1dc>)
 800935e:	2214      	movs	r2, #20
 8009360:	f003 fefc 	bl	800d15c <memset1>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8009364:	4d68      	ldr	r5, [pc, #416]	; (8009508 <LoRaMacMlmeRequest+0x1e0>)
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 8009366:	f895 2481 	ldrb.w	r2, [r5, #1153]	; 0x481
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800936a:	2301      	movs	r3, #1
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 800936c:	f042 0204 	orr.w	r2, r2, #4
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8009370:	f885 344d 	strb.w	r3, [r5, #1101]	; 0x44d
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 8009374:	f885 2481 	strb.w	r2, [r5, #1153]	; 0x481
    queueElement.Request = mlmeRequest->Type;
 8009378:	7832      	ldrb	r2, [r6, #0]
 800937a:	f88d 2004 	strb.w	r2, [sp, #4]
    queueElement.RestrictCommonReadyToHandle = false;
 800937e:	2100      	movs	r1, #0
 8009380:	3a01      	subs	r2, #1
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8009382:	f88d 3005 	strb.w	r3, [sp, #5]
    queueElement.RestrictCommonReadyToHandle = false;
 8009386:	f88d 1007 	strb.w	r1, [sp, #7]
    switch( mlmeRequest->Type )
 800938a:	2a0d      	cmp	r2, #13
 800938c:	f200 80b0 	bhi.w	80094f0 <LoRaMacMlmeRequest+0x1c8>
 8009390:	e8df f002 	tbb	[pc, r2]
 8009394:	59aeae07 	.word	0x59aeae07
 8009398:	aeae8363 	.word	0xaeae8363
 800939c:	a2ae8bae 	.word	0xa2ae8bae
 80093a0:	9e8f      	.short	0x9e8f
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 80093a2:	f8d5 4340 	ldr.w	r4, [r5, #832]	; 0x340
 80093a6:	f014 0420 	ands.w	r4, r4, #32
 80093aa:	d1ca      	bne.n	8009342 <LoRaMacMlmeRequest+0x1a>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80093ac:	f8df 8160 	ldr.w	r8, [pc, #352]	; 8009510 <LoRaMacMlmeRequest+0x1e8>
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 80093b0:	4f56      	ldr	r7, [pc, #344]	; (800950c <LoRaMacMlmeRequest+0x1e4>)
            ResetMacParameters( );
 80093b2:	f7fd fff3 	bl	800739c <ResetMacParameters>
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80093b6:	4622      	mov	r2, r4
 80093b8:	f996 1004 	ldrsb.w	r1, [r6, #4]
 80093bc:	f898 0040 	ldrb.w	r0, [r8, #64]	; 0x40
 80093c0:	f001 f9f0 	bl	800a7a4 <RegionAlternateDr>
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80093c4:	2307      	movs	r3, #7
            Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 80093c6:	f888 0039 	strb.w	r0, [r8, #57]	; 0x39
            SwitchClass( CLASS_A );
 80093ca:	4620      	mov	r0, r4
            queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 80093cc:	f88d 3005 	strb.w	r3, [sp, #5]
            SwitchClass( CLASS_A );
 80093d0:	f7fe fa3a 	bl	8007848 <SwitchClass>
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 80093d4:	23ff      	movs	r3, #255	; 0xff
 80093d6:	f885 310c 	strb.w	r3, [r5, #268]	; 0x10c
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 80093da:	f885 4104 	strb.w	r4, [r5, #260]	; 0x104
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 80093de:	f885 410d 	strb.w	r4, [r5, #269]	; 0x10d
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 80093e2:	f8c5 7108 	str.w	r7, [r5, #264]	; 0x108
            memcpy1( MacCtx.TxMsg.Message.JoinReq.JoinEUI, SecureElementGetJoinEui( ), LORAMAC_JOIN_EUI_FIELD_SIZE );
 80093e6:	f003 fe7d 	bl	800d0e4 <SecureElementGetJoinEui>
 80093ea:	2208      	movs	r2, #8
 80093ec:	4601      	mov	r1, r0
 80093ee:	f507 7086 	add.w	r0, r7, #268	; 0x10c
 80093f2:	f003 fe9f 	bl	800d134 <memcpy1>
            memcpy1( MacCtx.TxMsg.Message.JoinReq.DevEUI, SecureElementGetDevEui( ), LORAMAC_DEV_EUI_FIELD_SIZE );
 80093f6:	f003 fe5f 	bl	800d0b8 <SecureElementGetDevEui>
 80093fa:	2208      	movs	r2, #8
 80093fc:	4601      	mov	r1, r0
 80093fe:	f507 708a 	add.w	r0, r7, #276	; 0x114
 8009402:	f003 fe97 	bl	800d134 <memcpy1>
    status = ScheduleTx( allowDelayedTx );
 8009406:	4620      	mov	r0, r4
 8009408:	f7fe f854 	bl	80074b4 <ScheduleTx>
            if( status != LORAMAC_STATUS_OK )
 800940c:	4604      	mov	r4, r0
 800940e:	b140      	cbz	r0, 8009422 <LoRaMacMlmeRequest+0xfa>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 8009410:	f996 1004 	ldrsb.w	r1, [r6, #4]
 8009414:	f898 0040 	ldrb.w	r0, [r8, #64]	; 0x40
 8009418:	2201      	movs	r2, #1
 800941a:	f001 f9c3 	bl	800a7a4 <RegionAlternateDr>
 800941e:	f888 0039 	strb.w	r0, [r8, #57]	; 0x39
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 8009422:	f8d5 3484 	ldr.w	r3, [r5, #1156]	; 0x484
 8009426:	6133      	str	r3, [r6, #16]
    if( status != LORAMAC_STATUS_OK )
 8009428:	2c00      	cmp	r4, #0
 800942a:	d065      	beq.n	80094f8 <LoRaMacMlmeRequest+0x1d0>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 800942c:	f000 fc86 	bl	8009d3c <LoRaMacConfirmQueueGetCnt>
 8009430:	2800      	cmp	r0, #0
 8009432:	d187      	bne.n	8009344 <LoRaMacMlmeRequest+0x1c>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 8009434:	f895 3481 	ldrb.w	r3, [r5, #1153]	; 0x481
            MacCtx.NodeAckRequested = false;
 8009438:	f885 0414 	strb.w	r0, [r5, #1044]	; 0x414
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 800943c:	f360 0382 	bfi	r3, r0, #2, #1
 8009440:	f885 3481 	strb.w	r3, [r5, #1153]	; 0x481
 8009444:	e77e      	b.n	8009344 <LoRaMacMlmeRequest+0x1c>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 8009446:	2200      	movs	r2, #0
 8009448:	4669      	mov	r1, sp
 800944a:	2002      	movs	r0, #2
 800944c:	f000 faa4 	bl	8009998 <LoRaMacCommandsAddCmd>
 8009450:	b908      	cbnz	r0, 8009456 <LoRaMacMlmeRequest+0x12e>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 8009452:	2400      	movs	r4, #0
            break;
 8009454:	e7e5      	b.n	8009422 <LoRaMacMlmeRequest+0xfa>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 8009456:	2413      	movs	r4, #19
 8009458:	e7e3      	b.n	8009422 <LoRaMacMlmeRequest+0xfa>
    continuousWave.Channel = MacCtx.Channel;
 800945a:	f895 3415 	ldrb.w	r3, [r5, #1045]	; 0x415
 800945e:	f88d 3008 	strb.w	r3, [sp, #8]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8009462:	4b2b      	ldr	r3, [pc, #172]	; (8009510 <LoRaMacMlmeRequest+0x1e8>)
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout );
 8009464:	88b2      	ldrh	r2, [r6, #4]
    continuousWave.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8009466:	f893 1039 	ldrb.w	r1, [r3, #57]	; 0x39
 800946a:	f88d 1009 	strb.w	r1, [sp, #9]
    continuousWave.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 800946e:	f893 1038 	ldrb.w	r1, [r3, #56]	; 0x38
 8009472:	f88d 100a 	strb.w	r1, [sp, #10]
    continuousWave.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 8009476:	6f99      	ldr	r1, [r3, #120]	; 0x78
 8009478:	9103      	str	r1, [sp, #12]
    continuousWave.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 800947a:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 800947c:	9104      	str	r1, [sp, #16]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 800947e:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
    continuousWave.Timeout = timeout;
 8009482:	f8ad 2014 	strh.w	r2, [sp, #20]
    RegionSetContinuousWave( Nvm.MacGroup2.Region, &continuousWave );
 8009486:	a902      	add	r1, sp, #8
 8009488:	f001 f9ac 	bl	800a7e4 <RegionSetContinuousWave>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 800948c:	f8d5 3340 	ldr.w	r3, [r5, #832]	; 0x340
 8009490:	f043 0302 	orr.w	r3, r3, #2
 8009494:	f8c5 3340 	str.w	r3, [r5, #832]	; 0x340
 8009498:	e7db      	b.n	8009452 <LoRaMacMlmeRequest+0x12a>
    Radio.SetTxContinuousWave( frequency, power, timeout );
 800949a:	4b1e      	ldr	r3, [pc, #120]	; (8009514 <LoRaMacMlmeRequest+0x1ec>)
 800949c:	88b2      	ldrh	r2, [r6, #4]
 800949e:	f996 100c 	ldrsb.w	r1, [r6, #12]
 80094a2:	68b0      	ldr	r0, [r6, #8]
 80094a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80094a6:	4798      	blx	r3
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 80094a8:	e7f0      	b.n	800948c <LoRaMacMlmeRequest+0x164>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80094aa:	2200      	movs	r2, #0
 80094ac:	4669      	mov	r1, sp
 80094ae:	200d      	movs	r0, #13
 80094b0:	e7cc      	b.n	800944c <LoRaMacMlmeRequest+0x124>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 80094b2:	4b17      	ldr	r3, [pc, #92]	; (8009510 <LoRaMacMlmeRequest+0x1e8>)
 80094b4:	f893 30fc 	ldrb.w	r3, [r3, #252]	; 0xfc
 80094b8:	b9d3      	cbnz	r3, 80094f0 <LoRaMacMlmeRequest+0x1c8>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 80094ba:	7934      	ldrb	r4, [r6, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 80094bc:	f004 0007 	and.w	r0, r4, #7
 80094c0:	f000 fa47 	bl	8009952 <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 80094c4:	f88d 4000 	strb.w	r4, [sp]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 80094c8:	2201      	movs	r2, #1
 80094ca:	4669      	mov	r1, sp
 80094cc:	2010      	movs	r0, #16
 80094ce:	e7bd      	b.n	800944c <LoRaMacMlmeRequest+0x124>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 80094d0:	2200      	movs	r2, #0
 80094d2:	4669      	mov	r1, sp
 80094d4:	2012      	movs	r0, #18
 80094d6:	e7b9      	b.n	800944c <LoRaMacMlmeRequest+0x124>
            queueElement.RestrictCommonReadyToHandle = true;
 80094d8:	f88d 3007 	strb.w	r3, [sp, #7]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 80094dc:	f000 fa2a 	bl	8009934 <LoRaMacClassBIsAcquisitionInProgress>
 80094e0:	4604      	mov	r4, r0
 80094e2:	b938      	cbnz	r0, 80094f4 <LoRaMacMlmeRequest+0x1cc>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 80094e4:	f000 fa23 	bl	800992e <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 80094e8:	4620      	mov	r0, r4
 80094ea:	f000 fa25 	bl	8009938 <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 80094ee:	e798      	b.n	8009422 <LoRaMacMlmeRequest+0xfa>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 80094f0:	2402      	movs	r4, #2
 80094f2:	e796      	b.n	8009422 <LoRaMacMlmeRequest+0xfa>
                status = LORAMAC_STATUS_BUSY;
 80094f4:	2401      	movs	r4, #1
 80094f6:	e794      	b.n	8009422 <LoRaMacMlmeRequest+0xfa>
        LoRaMacConfirmQueueAdd( &queueElement );
 80094f8:	a801      	add	r0, sp, #4
 80094fa:	f000 fb75 	bl	8009be8 <LoRaMacConfirmQueueAdd>
 80094fe:	e721      	b.n	8009344 <LoRaMacMlmeRequest+0x1c>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8009500:	2403      	movs	r4, #3
 8009502:	e71f      	b.n	8009344 <LoRaMacMlmeRequest+0x1c>
 8009504:	20000900 	.word	0x20000900
 8009508:	200004b4 	.word	0x200004b4
 800950c:	200004b6 	.word	0x200004b6
 8009510:	200009bc 	.word	0x200009bc
 8009514:	08010fe4 	.word	0x08010fe4

08009518 <LoRaMacMcpsRequest>:

/* ST_WORKAROUND_BEGIN: Update MCPS request with new input parameter to allow delayed tx */
LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 8009518:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800951c:	b08f      	sub	sp, #60	; 0x3c
 800951e:	2700      	movs	r7, #0
 8009520:	9101      	str	r1, [sp, #4]
    /* ST_WORKAROUND_END */
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 8009522:	4605      	mov	r5, r0
 8009524:	b918      	cbnz	r0, 800952e <LoRaMacMcpsRequest+0x16>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8009526:	2003      	movs	r0, #3

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 8009528:	b00f      	add	sp, #60	; 0x3c
 800952a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( LoRaMacIsBusy( ) == true )
 800952e:	f7fe fd2d 	bl	8007f8c <LoRaMacIsBusy>
 8009532:	4681      	mov	r9, r0
 8009534:	2800      	cmp	r0, #0
 8009536:	f040 8163 	bne.w	8009800 <LoRaMacMcpsRequest+0x2e8>
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 800953a:	4cb7      	ldr	r4, [pc, #732]	; (8009818 <LoRaMacMcpsRequest+0x300>)
 800953c:	4601      	mov	r1, r0
    macHdr.Value = 0;
 800953e:	4680      	mov	r8, r0
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 8009540:	2214      	movs	r2, #20
 8009542:	f504 6087 	add.w	r0, r4, #1080	; 0x438
 8009546:	f003 fe09 	bl	800d15c <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 800954a:	2301      	movs	r3, #1
 800954c:	f884 3439 	strb.w	r3, [r4, #1081]	; 0x439
    MacCtx.AckTimeoutRetriesCounter = 1;
 8009550:	f884 3412 	strb.w	r3, [r4, #1042]	; 0x412
    switch( mcpsRequest->Type )
 8009554:	7829      	ldrb	r1, [r5, #0]
 8009556:	4299      	cmp	r1, r3
 8009558:	f000 80af 	beq.w	80096ba <LoRaMacMcpsRequest+0x1a2>
 800955c:	2903      	cmp	r1, #3
 800955e:	f000 80be 	beq.w	80096de <LoRaMacMcpsRequest+0x1c6>
 8009562:	2900      	cmp	r1, #0
 8009564:	f040 80c8 	bne.w	80096f8 <LoRaMacMcpsRequest+0x1e0>
            MacCtx.AckTimeoutRetries = 1;
 8009568:	f884 3411 	strb.w	r3, [r4, #1041]	; 0x411
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 800956c:	2202      	movs	r2, #2
 800956e:	f362 1847 	bfi	r8, r2, #5, #3
            fPort = mcpsRequest->Req.Unconfirmed.fPort;
 8009572:	f895 b004 	ldrb.w	fp, [r5, #4]
            fBuffer = mcpsRequest->Req.Unconfirmed.fBuffer;
 8009576:	f8d5 a008 	ldr.w	sl, [r5, #8]
            fBufferSize = mcpsRequest->Req.Unconfirmed.fBufferSize;
 800957a:	89af      	ldrh	r7, [r5, #12]
            datarate = mcpsRequest->Req.Unconfirmed.Datarate;
 800957c:	f995 200e 	ldrsb.w	r2, [r5, #14]
            readyToSend = true;
 8009580:	4699      	mov	r9, r3
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8009582:	4ba6      	ldr	r3, [pc, #664]	; (800981c <LoRaMacMcpsRequest+0x304>)
 8009584:	9200      	str	r2, [sp, #0]
 8009586:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800958a:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 800958e:	f88d 101e 	strb.w	r1, [sp, #30]
    getPhy.Attribute = PHY_MIN_TX_DR;
 8009592:	2602      	movs	r6, #2
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 8009594:	a907      	add	r1, sp, #28
    getPhy.Attribute = PHY_MIN_TX_DR;
 8009596:	f88d 601c 	strb.w	r6, [sp, #28]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 800959a:	f001 f842 	bl	800a622 <RegionGetPhyParam>
    if( readyToSend == true )
 800959e:	4b9f      	ldr	r3, [pc, #636]	; (800981c <LoRaMacMcpsRequest+0x304>)
 80095a0:	f1b9 0f00 	cmp.w	r9, #0
 80095a4:	f000 812a 	beq.w	80097fc <LoRaMacMcpsRequest+0x2e4>
        if( Nvm.MacGroup2.AdrCtrlOn == false )
 80095a8:	f893 10fe 	ldrb.w	r1, [r3, #254]	; 0xfe
 80095ac:	b9b9      	cbnz	r1, 80095de <LoRaMacMcpsRequest+0xc6>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 80095ae:	9a00      	ldr	r2, [sp, #0]
 80095b0:	b240      	sxtb	r0, r0
 80095b2:	4282      	cmp	r2, r0
 80095b4:	bfb8      	it	lt
 80095b6:	4602      	movlt	r2, r0
            verify.DatarateParams.Datarate = datarate;
 80095b8:	f88d 200c 	strb.w	r2, [sp, #12]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 80095bc:	f893 2074 	ldrb.w	r2, [r3, #116]	; 0x74
 80095c0:	f88d 200e 	strb.w	r2, [sp, #14]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 80095c4:	f893 0040 	ldrb.w	r0, [r3, #64]	; 0x40
 80095c8:	2205      	movs	r2, #5
 80095ca:	a903      	add	r1, sp, #12
 80095cc:	f001 f84f 	bl	800a66e <RegionVerify>
 80095d0:	2800      	cmp	r0, #0
 80095d2:	d0a8      	beq.n	8009526 <LoRaMacMcpsRequest+0xe>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 80095d4:	4b91      	ldr	r3, [pc, #580]	; (800981c <LoRaMacMcpsRequest+0x304>)
 80095d6:	f89d 200c 	ldrb.w	r2, [sp, #12]
 80095da:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 80095de:	8f19      	ldrh	r1, [r3, #56]	; 0x38
 80095e0:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80095e2:	9100      	str	r1, [sp, #0]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80095e4:	f893 1110 	ldrb.w	r1, [r3, #272]	; 0x110
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 80095e8:	6a98      	ldr	r0, [r3, #40]	; 0x28
 80095ea:	9004      	str	r0, [sp, #16]
 80095ec:	ba52      	rev16	r2, r2
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 80095ee:	2900      	cmp	r1, #0
 80095f0:	f000 8102 	beq.w	80097f8 <LoRaMacMcpsRequest+0x2e0>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 80095f4:	f893 10ff 	ldrb.w	r1, [r3, #255]	; 0xff
 80095f8:	b901      	cbnz	r1, 80095fc <LoRaMacMcpsRequest+0xe4>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 80095fa:	6319      	str	r1, [r3, #48]	; 0x30
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 80095fc:	f893 10fc 	ldrb.w	r1, [r3, #252]	; 0xfc
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8009600:	f893 c0fe 	ldrb.w	ip, [r3, #254]	; 0xfe
    if( Nvm.MacGroup1.SrvAckRequested == true )
 8009604:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8009608:	1e4e      	subs	r6, r1, #1
    fCtrl.Value = 0;
 800960a:	f04f 0900 	mov.w	r9, #0
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 800960e:	4271      	negs	r1, r6
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 8009610:	f36c 19c7 	bfi	r9, ip, #7, #1
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 8009614:	4171      	adcs	r1, r6
 8009616:	f361 1904 	bfi	r9, r1, #4, #1
    if( Nvm.MacGroup1.SrvAckRequested == true )
 800961a:	b10b      	cbz	r3, 8009620 <LoRaMacMcpsRequest+0x108>
        fCtrl.Bits.Ack = 1;
 800961c:	f049 0920 	orr.w	r9, r9, #32
    adrNext.Version = Nvm.MacGroup2.Version;
 8009620:	4e7e      	ldr	r6, [pc, #504]	; (800981c <LoRaMacMcpsRequest+0x304>)
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 8009622:	900b      	str	r0, [sp, #44]	; 0x2c
    adrNext.Version = Nvm.MacGroup2.Version;
 8009624:	f8d6 310c 	ldr.w	r3, [r6, #268]	; 0x10c
 8009628:	9309      	str	r3, [sp, #36]	; 0x24
    adrNext.UpdateChanMask = true;
 800962a:	f04f 0301 	mov.w	r3, #1
 800962e:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    adrNext.AdrAckLimit = MacCtx.AdrAckLimit;
 8009632:	f8d4 33f4 	ldr.w	r3, [r4, #1012]	; 0x3f4
 8009636:	930c      	str	r3, [sp, #48]	; 0x30
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 8009638:	f896 3074 	ldrb.w	r3, [r6, #116]	; 0x74
 800963c:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    adrNext.Region = Nvm.MacGroup2.Region;
 8009640:	f896 3040 	ldrb.w	r3, [r6, #64]	; 0x40
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 8009644:	f8ad 2034 	strh.w	r2, [sp, #52]	; 0x34
    adrNext.Region = Nvm.MacGroup2.Region;
 8009648:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800964c:	f106 0238 	add.w	r2, r6, #56	; 0x38
 8009650:	ab04      	add	r3, sp, #16
 8009652:	f106 0139 	add.w	r1, r6, #57	; 0x39
 8009656:	a809      	add	r0, sp, #36	; 0x24
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 8009658:	f88d c029 	strb.w	ip, [sp, #41]	; 0x29
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800965c:	f000 f8f8 	bl	8009850 <LoRaMacAdrCalcNext>
    MacCtx.PktBufferLen = 0;
 8009660:	2300      	movs	r3, #0
        fBufferSize = 0;
 8009662:	459a      	cmp	sl, r3
 8009664:	bf08      	it	eq
 8009666:	461f      	moveq	r7, r3
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 8009668:	463a      	mov	r2, r7
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 800966a:	f360 1986 	bfi	r9, r0, #6, #1
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 800966e:	4651      	mov	r1, sl
 8009670:	486b      	ldr	r0, [pc, #428]	; (8009820 <LoRaMacMcpsRequest+0x308>)
    MacCtx.PktBufferLen = 0;
 8009672:	8023      	strh	r3, [r4, #0]
    size_t macCmdsSize = 0;
 8009674:	e9cd 3305 	strd	r3, r3, [sp, #20]
    MacCtx.NodeAckRequested = false;
 8009678:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 800967c:	f003 fd5a 	bl	800d134 <memcpy1>
    MacCtx.PktBuffer[0] = macHdr->Value;
 8009680:	fa5f f388 	uxtb.w	r3, r8
 8009684:	f884 8002 	strb.w	r8, [r4, #2]
    switch( macHdr->Bits.MType )
 8009688:	f3c8 1842 	ubfx	r8, r8, #5, #3
    MacCtx.AppDataSize = fBufferSize;
 800968c:	b2fa      	uxtb	r2, r7
    switch( macHdr->Bits.MType )
 800968e:	f1b8 0f04 	cmp.w	r8, #4
    MacCtx.AppDataSize = fBufferSize;
 8009692:	f884 2237 	strb.w	r2, [r4, #567]	; 0x237
    switch( macHdr->Bits.MType )
 8009696:	d033      	beq.n	8009700 <LoRaMacMcpsRequest+0x1e8>
 8009698:	f1b8 0f07 	cmp.w	r8, #7
 800969c:	f000 809c 	beq.w	80097d8 <LoRaMacMcpsRequest+0x2c0>
 80096a0:	f1b8 0f02 	cmp.w	r8, #2
 80096a4:	d030      	beq.n	8009708 <LoRaMacMcpsRequest+0x1f0>
            return LORAMAC_STATUS_SERVICE_UNKNOWN;
 80096a6:	2002      	movs	r0, #2
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 80096a8:	9b00      	ldr	r3, [sp, #0]
 80096aa:	8733      	strh	r3, [r6, #56]	; 0x38
            MacCtx.NodeAckRequested = false;
 80096ac:	2300      	movs	r3, #0
 80096ae:	f884 3414 	strb.w	r3, [r4, #1044]	; 0x414
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 80096b2:	f8d4 3484 	ldr.w	r3, [r4, #1156]	; 0x484
 80096b6:	612b      	str	r3, [r5, #16]
    return status;
 80096b8:	e736      	b.n	8009528 <LoRaMacMcpsRequest+0x10>
            MacCtx.AckTimeoutRetries = MIN( mcpsRequest->Req.Confirmed.NbTrials, MAX_ACK_RETRIES );
 80096ba:	7beb      	ldrb	r3, [r5, #15]
 80096bc:	2b08      	cmp	r3, #8
 80096be:	bf28      	it	cs
 80096c0:	2308      	movcs	r3, #8
 80096c2:	f884 3411 	strb.w	r3, [r4, #1041]	; 0x411
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80096c6:	2304      	movs	r3, #4
            fPort = mcpsRequest->Req.Confirmed.fPort;
 80096c8:	f895 b004 	ldrb.w	fp, [r5, #4]
            fBuffer = mcpsRequest->Req.Confirmed.fBuffer;
 80096cc:	f8d5 a008 	ldr.w	sl, [r5, #8]
            fBufferSize = mcpsRequest->Req.Confirmed.fBufferSize;
 80096d0:	89af      	ldrh	r7, [r5, #12]
            datarate = mcpsRequest->Req.Confirmed.Datarate;
 80096d2:	f995 200e 	ldrsb.w	r2, [r5, #14]
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 80096d6:	f363 1847 	bfi	r8, r3, #5, #3
            readyToSend = true;
 80096da:	4689      	mov	r9, r1
            break;
 80096dc:	e751      	b.n	8009582 <LoRaMacMcpsRequest+0x6a>
            MacCtx.AckTimeoutRetries = 1;
 80096de:	f884 3411 	strb.w	r3, [r4, #1041]	; 0x411
            fBuffer = mcpsRequest->Req.Proprietary.fBuffer;
 80096e2:	f8d5 a004 	ldr.w	sl, [r5, #4]
            fBufferSize = mcpsRequest->Req.Proprietary.fBufferSize;
 80096e6:	892f      	ldrh	r7, [r5, #8]
            datarate = mcpsRequest->Req.Proprietary.Datarate;
 80096e8:	f995 200a 	ldrsb.w	r2, [r5, #10]
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 80096ec:	f068 081f 	orn	r8, r8, #31
            readyToSend = true;
 80096f0:	4699      	mov	r9, r3
    uint8_t fPort = 0;
 80096f2:	f04f 0b00 	mov.w	fp, #0
            break;
 80096f6:	e744      	b.n	8009582 <LoRaMacMcpsRequest+0x6a>
    switch( mcpsRequest->Type )
 80096f8:	464a      	mov	r2, r9
 80096fa:	46ca      	mov	sl, r9
 80096fc:	46cb      	mov	fp, r9
 80096fe:	e740      	b.n	8009582 <LoRaMacMcpsRequest+0x6a>
            MacCtx.NodeAckRequested = true;
 8009700:	f04f 0101 	mov.w	r1, #1
 8009704:	f884 1414 	strb.w	r1, [r4, #1044]	; 0x414
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8009708:	4f46      	ldr	r7, [pc, #280]	; (8009824 <LoRaMacMcpsRequest+0x30c>)
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 800970a:	f884 310d 	strb.w	r3, [r4, #269]	; 0x10d
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 800970e:	2104      	movs	r1, #4
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8009710:	f8d6 30cc 	ldr.w	r3, [r6, #204]	; 0xcc
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 8009714:	f884 1104 	strb.w	r1, [r4, #260]	; 0x104
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 8009718:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 800971c:	21ff      	movs	r1, #255	; 0xff
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 800971e:	f507 739b 	add.w	r3, r7, #310	; 0x136
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 8009722:	a805      	add	r0, sp, #20
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 8009724:	f8c4 7108 	str.w	r7, [r4, #264]	; 0x108
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 8009728:	f884 110c 	strb.w	r1, [r4, #268]	; 0x10c
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 800972c:	f884 b128 	strb.w	fp, [r4, #296]	; 0x128
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 8009730:	f884 9114 	strb.w	r9, [r4, #276]	; 0x114
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 8009734:	f884 2130 	strb.w	r2, [r4, #304]	; 0x130
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 8009738:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 800973c:	f000 fc2a 	bl	8009f94 <LoRaMacCryptoGetFCntUp>
 8009740:	2800      	cmp	r0, #0
 8009742:	d157      	bne.n	80097f4 <LoRaMacMcpsRequest+0x2dc>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 8009744:	9b05      	ldr	r3, [sp, #20]
            MacCtx.McpsConfirm.AckReceived = false;
 8009746:	f8a4 043c 	strh.w	r0, [r4, #1084]	; 0x43c
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 800974a:	a806      	add	r0, sp, #24
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 800974c:	f8a4 3116 	strh.w	r3, [r4, #278]	; 0x116
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 8009750:	f8c4 3444 	str.w	r3, [r4, #1092]	; 0x444
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 8009754:	f000 f9ba 	bl	8009acc <LoRaMacCommandsGetSizeSerializedCmds>
 8009758:	bb60      	cbnz	r0, 80097b4 <LoRaMacMcpsRequest+0x29c>
            if( macCmdsSize > 0 )
 800975a:	9b06      	ldr	r3, [sp, #24]
 800975c:	b1ab      	cbz	r3, 800978a <LoRaMacMcpsRequest+0x272>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 800975e:	f996 0039 	ldrsb.w	r0, [r6, #57]	; 0x39
 8009762:	f7fd fccb 	bl	80070fc <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 8009766:	f894 3237 	ldrb.w	r3, [r4, #567]	; 0x237
 800976a:	b32b      	cbz	r3, 80097b8 <LoRaMacMcpsRequest+0x2a0>
 800976c:	9b06      	ldr	r3, [sp, #24]
 800976e:	2b0f      	cmp	r3, #15
 8009770:	d819      	bhi.n	80097a6 <LoRaMacMcpsRequest+0x28e>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 8009772:	f507 728b 	add.w	r2, r7, #278	; 0x116
 8009776:	a906      	add	r1, sp, #24
 8009778:	200f      	movs	r0, #15
 800977a:	f000 f9b3 	bl	8009ae4 <LoRaMacCommandsSerializeCmds>
 800977e:	b9c8      	cbnz	r0, 80097b4 <LoRaMacMcpsRequest+0x29c>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 8009780:	9b06      	ldr	r3, [sp, #24]
 8009782:	f363 0903 	bfi	r9, r3, #0, #4
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 8009786:	f884 9114 	strb.w	r9, [r4, #276]	; 0x114
        status = ScheduleTx( allowDelayedTx ); /* ST_WORKAROUND: Update Send request with new input parameter to allow delayed tx */
 800978a:	9801      	ldr	r0, [sp, #4]
 800978c:	f7fd fe92 	bl	80074b4 <ScheduleTx>
    if( status != LORAMAC_STATUS_OK )
 8009790:	2800      	cmp	r0, #0
 8009792:	d189      	bne.n	80096a8 <LoRaMacMcpsRequest+0x190>
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 8009794:	9b04      	ldr	r3, [sp, #16]
        Nvm.MacGroup1.SrvAckRequested = false;
 8009796:	f886 003a 	strb.w	r0, [r6, #58]	; 0x3a
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 800979a:	62b3      	str	r3, [r6, #40]	; 0x28
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 800979c:	f000 f976 	bl	8009a8c <LoRaMacCommandsRemoveNoneStickyCmds>
 80097a0:	b380      	cbz	r0, 8009804 <LoRaMacMcpsRequest+0x2ec>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80097a2:	2013      	movs	r0, #19
 80097a4:	e782      	b.n	80096ac <LoRaMacMcpsRequest+0x194>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80097a6:	f207 4286 	addw	r2, r7, #1158	; 0x486
 80097aa:	a906      	add	r1, sp, #24
 80097ac:	f000 f99a 	bl	8009ae4 <LoRaMacCommandsSerializeCmds>
 80097b0:	2800      	cmp	r0, #0
 80097b2:	d0ea      	beq.n	800978a <LoRaMacMcpsRequest+0x272>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 80097b4:	2013      	movs	r0, #19
 80097b6:	e777      	b.n	80096a8 <LoRaMacMcpsRequest+0x190>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 80097b8:	f207 4786 	addw	r7, r7, #1158	; 0x486
 80097bc:	463a      	mov	r2, r7
 80097be:	a906      	add	r1, sp, #24
 80097c0:	f000 f990 	bl	8009ae4 <LoRaMacCommandsSerializeCmds>
 80097c4:	2800      	cmp	r0, #0
 80097c6:	d1f5      	bne.n	80097b4 <LoRaMacMcpsRequest+0x29c>
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80097c8:	9b06      	ldr	r3, [sp, #24]
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 80097ca:	f884 0128 	strb.w	r0, [r4, #296]	; 0x128
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 80097ce:	f8c4 712c 	str.w	r7, [r4, #300]	; 0x12c
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 80097d2:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 80097d6:	e7d8      	b.n	800978a <LoRaMacMcpsRequest+0x272>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 80097d8:	f1ba 0f00 	cmp.w	sl, #0
 80097dc:	d0d5      	beq.n	800978a <LoRaMacMcpsRequest+0x272>
 80097de:	2a00      	cmp	r2, #0
 80097e0:	d0d3      	beq.n	800978a <LoRaMacMcpsRequest+0x272>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 80097e2:	4811      	ldr	r0, [pc, #68]	; (8009828 <LoRaMacMcpsRequest+0x310>)
 80097e4:	4651      	mov	r1, sl
 80097e6:	f003 fca5 	bl	800d134 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 80097ea:	f894 3237 	ldrb.w	r3, [r4, #567]	; 0x237
 80097ee:	3301      	adds	r3, #1
 80097f0:	8023      	strh	r3, [r4, #0]
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 80097f2:	e7ca      	b.n	800978a <LoRaMacMcpsRequest+0x272>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 80097f4:	2012      	movs	r0, #18
 80097f6:	e757      	b.n	80096a8 <LoRaMacMcpsRequest+0x190>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 80097f8:	2007      	movs	r0, #7
 80097fa:	e757      	b.n	80096ac <LoRaMacMcpsRequest+0x194>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 80097fc:	4630      	mov	r0, r6
 80097fe:	e758      	b.n	80096b2 <LoRaMacMcpsRequest+0x19a>
        return LORAMAC_STATUS_BUSY;
 8009800:	2001      	movs	r0, #1
 8009802:	e691      	b.n	8009528 <LoRaMacMcpsRequest+0x10>
            MacCtx.McpsConfirm.McpsRequest = mcpsRequest->Type;
 8009804:	782b      	ldrb	r3, [r5, #0]
 8009806:	f884 3438 	strb.w	r3, [r4, #1080]	; 0x438
            MacCtx.MacFlags.Bits.McpsReq = 1;
 800980a:	f894 3481 	ldrb.w	r3, [r4, #1153]	; 0x481
 800980e:	f043 0301 	orr.w	r3, r3, #1
 8009812:	f884 3481 	strb.w	r3, [r4, #1153]	; 0x481
 8009816:	e74c      	b.n	80096b2 <LoRaMacMcpsRequest+0x19a>
 8009818:	200004b4 	.word	0x200004b4
 800981c:	200009bc 	.word	0x200009bc
 8009820:	200005ec 	.word	0x200005ec
 8009824:	200004b6 	.word	0x200004b6
 8009828:	200004b7 	.word	0x200004b7

0800982c <LoRaMacTestSetDutyCycleOn>:
/* ST_WORKAROUND_END */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 800982c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    VerifyParams_t verify;

    verify.DutyCycle = enable;

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 800982e:	4d07      	ldr	r5, [pc, #28]	; (800984c <LoRaMacTestSetDutyCycleOn+0x20>)
    verify.DutyCycle = enable;
 8009830:	f88d 0004 	strb.w	r0, [sp, #4]
{
 8009834:	4604      	mov	r4, r0
    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 8009836:	220f      	movs	r2, #15
 8009838:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
 800983c:	a901      	add	r1, sp, #4
 800983e:	f000 ff16 	bl	800a66e <RegionVerify>
 8009842:	b108      	cbz	r0, 8009848 <LoRaMacTestSetDutyCycleOn+0x1c>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 8009844:	f885 4100 	strb.w	r4, [r5, #256]	; 0x100
    }
}
 8009848:	b003      	add	sp, #12
 800984a:	bd30      	pop	{r4, r5, pc}
 800984c:	200009bc 	.word	0x200009bc

08009850 <LoRaMacAdrCalcNext>:
 * \param [OUT] adrAckCounter The calculated ADR acknowledgement counter.
 *
 * \retval Returns true, if an ADR request should be performed.
 */
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut, uint32_t* adrAckCounter )
{
 8009850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( adrNext->Version.Fields.Minor == 0 )
 8009854:	f890 9002 	ldrb.w	r9, [r0, #2]
{
 8009858:	b08b      	sub	sp, #44	; 0x2c
 800985a:	4604      	mov	r4, r0
 800985c:	468a      	mov	sl, r1
 800985e:	9201      	str	r2, [sp, #4]
    if( adrNext->Version.Fields.Minor == 0 )
 8009860:	f1b9 0f00 	cmp.w	r9, #0
 8009864:	d160      	bne.n	8009928 <LoRaMacAdrCalcNext+0xd8>
    if( adrNext->AdrEnabled == true )
 8009866:	7945      	ldrb	r5, [r0, #5]
    *adrAckCounter = adrNext->AdrAckCounter;
 8009868:	6881      	ldr	r1, [r0, #8]
    int8_t datarate = adrNext->Datarate;
 800986a:	f990 2010 	ldrsb.w	r2, [r0, #16]
    int8_t txPower = adrNext->TxPower;
 800986e:	f990 8011 	ldrsb.w	r8, [r0, #17]
    *adrAckCounter = adrNext->AdrAckCounter;
 8009872:	6019      	str	r1, [r3, #0]
    if( adrNext->AdrEnabled == true )
 8009874:	2d00      	cmp	r5, #0
 8009876:	d055      	beq.n	8009924 <LoRaMacAdrCalcNext+0xd4>
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8009878:	7c81      	ldrb	r1, [r0, #18]
 800987a:	f88d 1016 	strb.w	r1, [sp, #22]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800987e:	7cc0      	ldrb	r0, [r0, #19]
        getPhy.Attribute = PHY_MIN_TX_DR;
 8009880:	f04f 0b02 	mov.w	fp, #2
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8009884:	a905      	add	r1, sp, #20
 8009886:	e9cd 2302 	strd	r2, r3, [sp, #8]
        getPhy.Attribute = PHY_MIN_TX_DR;
 800988a:	f88d b014 	strb.w	fp, [sp, #20]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 800988e:	f000 fec8 	bl	800a622 <RegionGetPhyParam>
        datarate = MAX( datarate, minTxDatarate );
 8009892:	9a02      	ldr	r2, [sp, #8]
        minTxDatarate = phyParam.Value;
 8009894:	b247      	sxtb	r7, r0
        datarate = MAX( datarate, minTxDatarate );
 8009896:	42ba      	cmp	r2, r7
 8009898:	4616      	mov	r6, r2
 800989a:	bfb8      	it	lt
 800989c:	463e      	movlt	r6, r7
        if( datarate == minTxDatarate )
 800989e:	42ba      	cmp	r2, r7
 80098a0:	dc0c      	bgt.n	80098bc <LoRaMacAdrCalcNext+0x6c>
            *adrAckCounter = 0;
 80098a2:	9b03      	ldr	r3, [sp, #12]
 80098a4:	f8c3 9000 	str.w	r9, [r3]
                        adrAckReq = false;
 80098a8:	464d      	mov	r5, r9
    *txPowOut = txPower;
 80098aa:	9b01      	ldr	r3, [sp, #4]
    *drOut = datarate;
 80098ac:	f88a 6000 	strb.w	r6, [sl]
    *txPowOut = txPower;
 80098b0:	f883 8000 	strb.w	r8, [r3]
    {
        return CalcNextV10X( adrNext, drOut, txPowOut, adrAckCounter );
    }
    return false;
}
 80098b4:	4628      	mov	r0, r5
 80098b6:	b00b      	add	sp, #44	; 0x2c
 80098b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80098bc:	68a2      	ldr	r2, [r4, #8]
 80098be:	89a1      	ldrh	r1, [r4, #12]
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80098c0:	89e3      	ldrh	r3, [r4, #14]
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80098c2:	428a      	cmp	r2, r1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80098c4:	440b      	add	r3, r1
            if( adrNext->AdrAckCounter >=  adrNext->AdrAckLimit )
 80098c6:	bf34      	ite	cc
 80098c8:	2500      	movcc	r5, #0
 80098ca:	2501      	movcs	r5, #1
            if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 80098cc:	429a      	cmp	r2, r3
 80098ce:	d3ec      	bcc.n	80098aa <LoRaMacAdrCalcNext+0x5a>
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80098d0:	2308      	movs	r3, #8
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80098d2:	a905      	add	r1, sp, #20
 80098d4:	7ce0      	ldrb	r0, [r4, #19]
                getPhy.Attribute = PHY_MAX_TX_POWER;
 80098d6:	f88d 3014 	strb.w	r3, [sp, #20]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80098da:	f000 fea2 	bl	800a622 <RegionGetPhyParam>
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 80098de:	89e2      	ldrh	r2, [r4, #14]
 80098e0:	68a1      	ldr	r1, [r4, #8]
 80098e2:	fbb1 f3f2 	udiv	r3, r1, r2
 80098e6:	fb02 1313 	mls	r3, r2, r3, r1
 80098ea:	2b01      	cmp	r3, #1
                txPower = phyParam.Value;
 80098ec:	fa4f f880 	sxtb.w	r8, r0
                if( ( adrNext->AdrAckCounter % adrNext->AdrAckDelay ) == 1 )
 80098f0:	d1db      	bne.n	80098aa <LoRaMacAdrCalcNext+0x5a>
                    getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 80098f2:	2322      	movs	r3, #34	; 0x22
 80098f4:	f88d 3014 	strb.w	r3, [sp, #20]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 80098f8:	7ce0      	ldrb	r0, [r4, #19]
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 80098fa:	7ca3      	ldrb	r3, [r4, #18]
                    getPhy.Datarate = datarate;
 80098fc:	f88d 6015 	strb.w	r6, [sp, #21]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8009900:	a905      	add	r1, sp, #20
                    getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 8009902:	f88d 3016 	strb.w	r3, [sp, #22]
                    phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 8009906:	f000 fe8c 	bl	800a622 <RegionGetPhyParam>
                    datarate = phyParam.Value;
 800990a:	b246      	sxtb	r6, r0
                    if( datarate == minTxDatarate )
 800990c:	42b7      	cmp	r7, r6
 800990e:	d1cc      	bne.n	80098aa <LoRaMacAdrCalcNext+0x5a>
                        if( adrNext->UpdateChanMask == true )
 8009910:	7925      	ldrb	r5, [r4, #4]
 8009912:	2d00      	cmp	r5, #0
 8009914:	d0c9      	beq.n	80098aa <LoRaMacAdrCalcNext+0x5a>
                            RegionInitDefaults( adrNext->Region, &params );
 8009916:	7ce0      	ldrb	r0, [r4, #19]
                            params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 8009918:	f88d b024 	strb.w	fp, [sp, #36]	; 0x24
                            RegionInitDefaults( adrNext->Region, &params );
 800991c:	a907      	add	r1, sp, #28
 800991e:	f000 fe9b 	bl	800a658 <RegionInitDefaults>
 8009922:	e7c1      	b.n	80098a8 <LoRaMacAdrCalcNext+0x58>
    int8_t datarate = adrNext->Datarate;
 8009924:	4616      	mov	r6, r2
 8009926:	e7c0      	b.n	80098aa <LoRaMacAdrCalcNext+0x5a>
    return false;
 8009928:	2500      	movs	r5, #0
 800992a:	e7c3      	b.n	80098b4 <LoRaMacAdrCalcNext+0x64>

0800992c <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800992c:	4770      	bx	lr

0800992e <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800992e:	4770      	bx	lr

08009930 <LoRaMacClassBSetPingSlotState>:
 8009930:	4770      	bx	lr

08009932 <LoRaMacClassBSetMulticastSlotState>:
 8009932:	4770      	bx	lr

08009934 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009934:	2000      	movs	r0, #0
 8009936:	4770      	bx	lr

08009938 <LoRaMacClassBBeaconTimerEvent>:
    if( Ctx.LoRaMacClassBCallbacks.MacProcessNotify != NULL )
    {
        Ctx.LoRaMacClassBCallbacks.MacProcessNotify( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009938:	4770      	bx	lr

0800993a <LoRaMacClassBPingSlotTimerEvent>:
 800993a:	4770      	bx	lr

0800993c <LoRaMacClassBMulticastSlotTimerEvent>:
 800993c:	4770      	bx	lr

0800993e <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800993e:	2000      	movs	r0, #0
 8009940:	4770      	bx	lr

08009942 <LoRaMacClassBIsBeaconExpected>:
 8009942:	2000      	movs	r0, #0
 8009944:	4770      	bx	lr

08009946 <LoRaMacClassBIsPingExpected>:
 8009946:	2000      	movs	r0, #0
 8009948:	4770      	bx	lr

0800994a <LoRaMacClassBIsMulticastExpected>:
 800994a:	2000      	movs	r0, #0
 800994c:	4770      	bx	lr

0800994e <LoRaMacClassBIsBeaconModeActive>:
 800994e:	2000      	movs	r0, #0
 8009950:	4770      	bx	lr

08009952 <LoRaMacClassBSetPingSlotInfo>:
 8009952:	4770      	bx	lr

08009954 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009954:	4770      	bx	lr

08009956 <LoRaMacClassBResumeBeaconing>:
 8009956:	4770      	bx	lr

08009958 <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009958:	2002      	movs	r0, #2
 800995a:	4770      	bx	lr

0800995c <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800995c:	2002      	movs	r0, #2
 800995e:	4770      	bx	lr

08009960 <LoRaMacMibClassBSetRequestConfirm>:
 8009960:	2002      	movs	r0, #2
 8009962:	4770      	bx	lr

08009964 <LoRaMacClassBPingSlotInfoAns>:
 8009964:	4770      	bx	lr

08009966 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009966:	2000      	movs	r0, #0
 8009968:	4770      	bx	lr

0800996a <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800996a:	4770      	bx	lr

0800996c <LoRaMacClassBDeviceTimeAns>:
 800996c:	4770      	bx	lr

0800996e <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 800996e:	2000      	movs	r0, #0
 8009970:	4770      	bx	lr

08009972 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8009972:	2000      	movs	r0, #0
 8009974:	4770      	bx	lr

08009976 <LoRaMacClassBStopRxSlots>:
 8009976:	4770      	bx	lr

08009978 <LoRaMacClassBProcess>:
 8009978:	4770      	bx	lr
	...

0800997c <LoRaMacCommandsInit>:
            return false;
    }
}

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 800997c:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 800997e:	4c05      	ldr	r4, [pc, #20]	; (8009994 <LoRaMacCommandsInit+0x18>)
 8009980:	22fc      	movs	r2, #252	; 0xfc
 8009982:	4620      	mov	r0, r4
 8009984:	2100      	movs	r1, #0
 8009986:	f003 fbe9 	bl	800d15c <memset1>
    list->First = NULL;
 800998a:	2000      	movs	r0, #0
    list->Last = NULL;
 800998c:	e9c4 0000 	strd	r0, r0, [r4]

    LinkedListInit( &CommandsCtx.MacCommandList );

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009990:	bd10      	pop	{r4, pc}
 8009992:	bf00      	nop
 8009994:	20000fcc 	.word	0x20000fcc

08009998 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 8009998:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800999c:	4680      	mov	r8, r0
 800999e:	4616      	mov	r6, r2
    if( payload == NULL )
 80099a0:	2900      	cmp	r1, #0
 80099a2:	d03d      	beq.n	8009a20 <LoRaMacCommandsAddCmd+0x88>
 80099a4:	4c22      	ldr	r4, [pc, #136]	; (8009a30 <LoRaMacCommandsAddCmd+0x98>)
 80099a6:	2300      	movs	r3, #0
    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 80099a8:	1c65      	adds	r5, r4, #1
 80099aa:	4622      	mov	r2, r4
 80099ac:	0118      	lsls	r0, r3, #4
 80099ae:	3410      	adds	r4, #16
        if( mem[size] != 0x00 )
 80099b0:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 80099b4:	bbb7      	cbnz	r7, 8009a24 <LoRaMacCommandsAddCmd+0x8c>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 80099b6:	42a2      	cmp	r2, r4
 80099b8:	d1fa      	bne.n	80099b0 <LoRaMacCommandsAddCmd+0x18>
    if( list->First == NULL )
 80099ba:	4c1e      	ldr	r4, [pc, #120]	; (8009a34 <LoRaMacCommandsAddCmd+0x9c>)
 80099bc:	6822      	ldr	r2, [r4, #0]
 80099be:	b902      	cbnz	r2, 80099c2 <LoRaMacCommandsAddCmd+0x2a>
        list->First = element;
 80099c0:	6025      	str	r5, [r4, #0]
    if( list->Last )
 80099c2:	6862      	ldr	r2, [r4, #4]
 80099c4:	b102      	cbz	r2, 80099c8 <LoRaMacCommandsAddCmd+0x30>
        list->Last->Next = element;
 80099c6:	6015      	str	r5, [r2, #0]
    list->Last = element;
 80099c8:	6065      	str	r5, [r4, #4]
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
    newCmd->PayloadSize = payloadSize;
 80099ca:	1c5d      	adds	r5, r3, #1
    element->Next = NULL;
 80099cc:	1822      	adds	r2, r4, r0
    newCmd->PayloadSize = payloadSize;
 80099ce:	012b      	lsls	r3, r5, #4
    element->Next = NULL;
 80099d0:	f04f 0c00 	mov.w	ip, #0
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80099d4:	300d      	adds	r0, #13
    element->Next = NULL;
 80099d6:	f8c2 c008 	str.w	ip, [r2, #8]
    newCmd->CID = cid;
 80099da:	f882 800c 	strb.w	r8, [r2, #12]
    newCmd->PayloadSize = payloadSize;
 80099de:	50e6      	str	r6, [r4, r3]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 80099e0:	b2b2      	uxth	r2, r6
 80099e2:	4420      	add	r0, r4
 80099e4:	f003 fba6 	bl	800d134 <memcpy1>
    switch( cid )
 80099e8:	f1b8 0f05 	cmp.w	r8, #5
 80099ec:	d015      	beq.n	8009a1a <LoRaMacCommandsAddCmd+0x82>
 80099ee:	f1a8 0808 	sub.w	r8, r8, #8
 80099f2:	f1b8 0f02 	cmp.w	r8, #2
 80099f6:	bf8c      	ite	hi
 80099f8:	f04f 0800 	movhi.w	r8, #0
 80099fc:	f04f 0801 	movls.w	r8, #1
    newCmd->IsSticky = IsSticky( cid );
 8009a00:	eb04 1305 	add.w	r3, r4, r5, lsl #4
 8009a04:	f883 8004 	strb.w	r8, [r3, #4]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 8009a08:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8009a0c:	3301      	adds	r3, #1
 8009a0e:	4433      	add	r3, r6
 8009a10:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009a14:	4638      	mov	r0, r7
 8009a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return true;
 8009a1a:	f04f 0801 	mov.w	r8, #1
 8009a1e:	e7ef      	b.n	8009a00 <LoRaMacCommandsAddCmd+0x68>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8009a20:	2701      	movs	r7, #1
 8009a22:	e7f7      	b.n	8009a14 <LoRaMacCommandsAddCmd+0x7c>
        if( itr == NUM_OF_MAC_COMMANDS )
 8009a24:	3301      	adds	r3, #1
 8009a26:	2b0f      	cmp	r3, #15
 8009a28:	d1be      	bne.n	80099a8 <LoRaMacCommandsAddCmd+0x10>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 8009a2a:	2702      	movs	r7, #2
 8009a2c:	e7f2      	b.n	8009a14 <LoRaMacCommandsAddCmd+0x7c>
 8009a2e:	bf00      	nop
 8009a30:	20000fd3 	.word	0x20000fd3
 8009a34:	20000fcc 	.word	0x20000fcc

08009a38 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 8009a38:	b510      	push	{r4, lr}
    if( macCmd == NULL )
 8009a3a:	b310      	cbz	r0, 8009a82 <LoRaMacCommandsRemoveCmd+0x4a>
    curElement = list->First;
 8009a3c:	4b12      	ldr	r3, [pc, #72]	; (8009a88 <LoRaMacCommandsRemoveCmd+0x50>)
 8009a3e:	681a      	ldr	r2, [r3, #0]
    if( element != curElement )
 8009a40:	4290      	cmp	r0, r2
 8009a42:	d104      	bne.n	8009a4e <LoRaMacCommandsRemoveCmd+0x16>
        list->First = element->Next;
 8009a44:	6802      	ldr	r2, [r0, #0]
 8009a46:	601a      	str	r2, [r3, #0]
 8009a48:	2200      	movs	r2, #0
 8009a4a:	e004      	b.n	8009a56 <LoRaMacCommandsRemoveCmd+0x1e>
 8009a4c:	460a      	mov	r2, r1
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 8009a4e:	b112      	cbz	r2, 8009a56 <LoRaMacCommandsRemoveCmd+0x1e>
 8009a50:	6811      	ldr	r1, [r2, #0]
 8009a52:	4288      	cmp	r0, r1
 8009a54:	d1fa      	bne.n	8009a4c <LoRaMacCommandsRemoveCmd+0x14>
    if( list->Last == element )
 8009a56:	6859      	ldr	r1, [r3, #4]
 8009a58:	4288      	cmp	r0, r1
        list->Last = PrevElement;
 8009a5a:	bf08      	it	eq
 8009a5c:	605a      	streq	r2, [r3, #4]
    if( PrevElement != NULL )
 8009a5e:	b10a      	cbz	r2, 8009a64 <LoRaMacCommandsRemoveCmd+0x2c>
        PrevElement->Next = element->Next;
 8009a60:	6801      	ldr	r1, [r0, #0]
 8009a62:	6011      	str	r1, [r2, #0]
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8009a64:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8009a68:	6881      	ldr	r1, [r0, #8]
 8009a6a:	3a01      	subs	r2, #1
    element->Next = NULL;
 8009a6c:	2400      	movs	r4, #0
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8009a6e:	1a52      	subs	r2, r2, r1
    element->Next = NULL;
 8009a70:	6004      	str	r4, [r0, #0]
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8009a72:	4621      	mov	r1, r4
    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 8009a74:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 8009a78:	2210      	movs	r2, #16
 8009a7a:	f003 fb6f 	bl	800d15c <memset1>
    return true;
 8009a7e:	4620      	mov	r0, r4
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009a80:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 8009a82:	2001      	movs	r0, #1
 8009a84:	e7fc      	b.n	8009a80 <LoRaMacCommandsRemoveCmd+0x48>
 8009a86:	bf00      	nop
 8009a88:	20000fcc 	.word	0x20000fcc

08009a8c <LoRaMacCommandsRemoveNoneStickyCmds>:
    }
    return LORAMAC_COMMANDS_SUCCESS;
}

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 8009a8c:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8009a8e:	4b05      	ldr	r3, [pc, #20]	; (8009aa4 <LoRaMacCommandsRemoveNoneStickyCmds+0x18>)
 8009a90:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8009a92:	b900      	cbnz	r0, 8009a96 <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            curElement = curElement->Next;
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009a94:	bd10      	pop	{r4, pc}
        if( curElement->IsSticky == false )
 8009a96:	7b03      	ldrb	r3, [r0, #12]
 8009a98:	6804      	ldr	r4, [r0, #0]
 8009a9a:	b90b      	cbnz	r3, 8009aa0 <LoRaMacCommandsRemoveNoneStickyCmds+0x14>
            LoRaMacCommandsRemoveCmd( curElement );
 8009a9c:	f7ff ffcc 	bl	8009a38 <LoRaMacCommandsRemoveCmd>
{
 8009aa0:	4620      	mov	r0, r4
 8009aa2:	e7f6      	b.n	8009a92 <LoRaMacCommandsRemoveNoneStickyCmds+0x6>
 8009aa4:	20000fcc 	.word	0x20000fcc

08009aa8 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 8009aa8:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 8009aaa:	4b07      	ldr	r3, [pc, #28]	; (8009ac8 <LoRaMacCommandsRemoveStickyAnsCmds+0x20>)
 8009aac:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8009aae:	b900      	cbnz	r0, 8009ab2 <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009ab0:	bd10      	pop	{r4, pc}
        if( IsSticky( curElement->CID ) == true )
 8009ab2:	7903      	ldrb	r3, [r0, #4]
        nexElement = curElement->Next;
 8009ab4:	6804      	ldr	r4, [r0, #0]
    switch( cid )
 8009ab6:	2b05      	cmp	r3, #5
 8009ab8:	d002      	beq.n	8009ac0 <LoRaMacCommandsRemoveStickyAnsCmds+0x18>
 8009aba:	3b08      	subs	r3, #8
 8009abc:	2b02      	cmp	r3, #2
 8009abe:	d801      	bhi.n	8009ac4 <LoRaMacCommandsRemoveStickyAnsCmds+0x1c>
            LoRaMacCommandsRemoveCmd( curElement );
 8009ac0:	f7ff ffba 	bl	8009a38 <LoRaMacCommandsRemoveCmd>
{
 8009ac4:	4620      	mov	r0, r4
 8009ac6:	e7f2      	b.n	8009aae <LoRaMacCommandsRemoveStickyAnsCmds+0x6>
 8009ac8:	20000fcc 	.word	0x20000fcc

08009acc <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 8009acc:	b128      	cbz	r0, 8009ada <LoRaMacCommandsGetSizeSerializedCmds+0xe>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 8009ace:	4b04      	ldr	r3, [pc, #16]	; (8009ae0 <LoRaMacCommandsGetSizeSerializedCmds+0x14>)
 8009ad0:	f8d3 30f8 	ldr.w	r3, [r3, #248]	; 0xf8
 8009ad4:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 8009ad6:	2000      	movs	r0, #0
 8009ad8:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 8009ada:	2001      	movs	r0, #1
}
 8009adc:	4770      	bx	lr
 8009ade:	bf00      	nop
 8009ae0:	20000fcc 	.word	0x20000fcc

08009ae4 <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 8009ae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009ae8:	4607      	mov	r7, r0
 8009aea:	460e      	mov	r6, r1
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 8009aec:	4615      	mov	r5, r2
 8009aee:	b332      	cbz	r2, 8009b3e <LoRaMacCommandsSerializeCmds+0x5a>
 8009af0:	b329      	cbz	r1, 8009b3e <LoRaMacCommandsSerializeCmds+0x5a>
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 8009af2:	4b14      	ldr	r3, [pc, #80]	; (8009b44 <LoRaMacCommandsSerializeCmds+0x60>)
 8009af4:	681c      	ldr	r4, [r3, #0]
    uint8_t itr = 0;
 8009af6:	2300      	movs	r3, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 8009af8:	b92c      	cbnz	r4, 8009b06 <LoRaMacCommandsSerializeCmds+0x22>
        LoRaMacCommandsRemoveCmd( curElement );
        curElement = nextElement;
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 8009afa:	4630      	mov	r0, r6
 8009afc:	f7ff ffe6 	bl	8009acc <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 8009b00:	2000      	movs	r0, #0
}
 8009b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 8009b06:	68a2      	ldr	r2, [r4, #8]
 8009b08:	1af9      	subs	r1, r7, r3
 8009b0a:	3201      	adds	r2, #1
 8009b0c:	4291      	cmp	r1, r2
 8009b0e:	d30f      	bcc.n	8009b30 <LoRaMacCommandsSerializeCmds+0x4c>
            buffer[itr++] = curElement->CID;
 8009b10:	7922      	ldrb	r2, [r4, #4]
 8009b12:	54ea      	strb	r2, [r5, r3]
 8009b14:	1c58      	adds	r0, r3, #1
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8009b16:	8922      	ldrh	r2, [r4, #8]
            buffer[itr++] = curElement->CID;
 8009b18:	fa5f f880 	uxtb.w	r8, r0
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 8009b1c:	1d61      	adds	r1, r4, #5
 8009b1e:	fa55 f080 	uxtab	r0, r5, r0
 8009b22:	f003 fb07 	bl	800d134 <memcpy1>
            itr += curElement->PayloadSize;
 8009b26:	68a3      	ldr	r3, [r4, #8]
        curElement = curElement->Next;
 8009b28:	6824      	ldr	r4, [r4, #0]
            itr += curElement->PayloadSize;
 8009b2a:	4443      	add	r3, r8
 8009b2c:	b2db      	uxtb	r3, r3
        curElement = curElement->Next;
 8009b2e:	e7e3      	b.n	8009af8 <LoRaMacCommandsSerializeCmds+0x14>
        nextElement = curElement->Next;
 8009b30:	4620      	mov	r0, r4
 8009b32:	6824      	ldr	r4, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 8009b34:	f7ff ff80 	bl	8009a38 <LoRaMacCommandsRemoveCmd>
    while( curElement != NULL )
 8009b38:	2c00      	cmp	r4, #0
 8009b3a:	d1f9      	bne.n	8009b30 <LoRaMacCommandsSerializeCmds+0x4c>
 8009b3c:	e7dd      	b.n	8009afa <LoRaMacCommandsSerializeCmds+0x16>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8009b3e:	2001      	movs	r0, #1
 8009b40:	e7df      	b.n	8009b02 <LoRaMacCommandsSerializeCmds+0x1e>
 8009b42:	bf00      	nop
 8009b44:	20000fcc 	.word	0x20000fcc

08009b48 <LoRaMacCommandsStickyCmdsPending>:

LoRaMacCommandStatus_t LoRaMacCommandsStickyCmdsPending( bool* cmdsPending )
{
    if( cmdsPending == NULL )
 8009b48:	4603      	mov	r3, r0
 8009b4a:	b168      	cbz	r0, 8009b68 <LoRaMacCommandsStickyCmdsPending+0x20>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* curElement;
    curElement = CommandsCtx.MacCommandList.First;
 8009b4c:	4a07      	ldr	r2, [pc, #28]	; (8009b6c <LoRaMacCommandsStickyCmdsPending+0x24>)
 8009b4e:	6810      	ldr	r0, [r2, #0]

    *cmdsPending = false;
 8009b50:	2200      	movs	r2, #0
 8009b52:	701a      	strb	r2, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 8009b54:	b900      	cbnz	r0, 8009b58 <LoRaMacCommandsStickyCmdsPending+0x10>
 8009b56:	4770      	bx	lr
    {
        if( curElement->IsSticky == true )
 8009b58:	7b02      	ldrb	r2, [r0, #12]
 8009b5a:	b11a      	cbz	r2, 8009b64 <LoRaMacCommandsStickyCmdsPending+0x1c>
        {
            // Found one sticky MAC command
            *cmdsPending = true;
 8009b5c:	2201      	movs	r2, #1
 8009b5e:	701a      	strb	r2, [r3, #0]
            return LORAMAC_COMMANDS_SUCCESS;
 8009b60:	2000      	movs	r0, #0
 8009b62:	4770      	bx	lr
        }
        curElement = curElement->Next;
 8009b64:	6800      	ldr	r0, [r0, #0]
 8009b66:	e7f5      	b.n	8009b54 <LoRaMacCommandsStickyCmdsPending+0xc>
        return LORAMAC_COMMANDS_ERROR_NPE;
 8009b68:	2001      	movs	r0, #1
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 8009b6a:	4770      	bx	lr
 8009b6c:	20000fcc 	.word	0x20000fcc

08009b70 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 8009b70:	3802      	subs	r0, #2
 8009b72:	b2c0      	uxtb	r0, r0
 8009b74:	2811      	cmp	r0, #17
 8009b76:	bf9a      	itte	ls
 8009b78:	4b01      	ldrls	r3, [pc, #4]	; (8009b80 <LoRaMacCommandsGetCmdSize+0x10>)
 8009b7a:	5c18      	ldrbls	r0, [r3, r0]
{
 8009b7c:	2000      	movhi	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 8009b7e:	4770      	bx	lr
 8009b80:	08010a21 	.word	0x08010a21

08009b84 <GetElement.isra.0>:
        return true;
    }
    return false;
}

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8009b84:	b530      	push	{r4, r5, lr}
{
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8009b86:	4b0c      	ldr	r3, [pc, #48]	; (8009bb8 <GetElement.isra.0+0x34>)
 8009b88:	f893 2020 	ldrb.w	r2, [r3, #32]
static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
 8009b8c:	4604      	mov	r4, r0
 8009b8e:	4608      	mov	r0, r1
    if( count == 0 )
 8009b90:	b17a      	cbz	r2, 8009bb2 <GetElement.isra.0+0x2e>
 8009b92:	2100      	movs	r1, #0
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009b94:	331c      	adds	r3, #28
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8009b96:	b2cd      	uxtb	r5, r1
 8009b98:	42aa      	cmp	r2, r5
 8009b9a:	d801      	bhi.n	8009ba0 <GetElement.isra.0+0x1c>
        return NULL;
 8009b9c:	2000      	movs	r0, #0
        }
        element = IncreaseBufferPointer( element );
    }

    return NULL;
}
 8009b9e:	bd30      	pop	{r4, r5, pc}
        if( element->Request == request )
 8009ba0:	7805      	ldrb	r5, [r0, #0]
 8009ba2:	42a5      	cmp	r5, r4
 8009ba4:	d0fb      	beq.n	8009b9e <GetElement.isra.0+0x1a>
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009ba6:	4298      	cmp	r0, r3
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009ba8:	bf0c      	ite	eq
 8009baa:	4804      	ldreq	r0, [pc, #16]	; (8009bbc <GetElement.isra.0+0x38>)
        bufferPointer++;
 8009bac:	3004      	addne	r0, #4
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 8009bae:	3101      	adds	r1, #1
 8009bb0:	e7f1      	b.n	8009b96 <GetElement.isra.0+0x12>
        return NULL;
 8009bb2:	4610      	mov	r0, r2
 8009bb4:	e7f3      	b.n	8009b9e <GetElement.isra.0+0x1a>
 8009bb6:	bf00      	nop
 8009bb8:	200010c8 	.word	0x200010c8
 8009bbc:	200010d4 	.word	0x200010d4

08009bc0 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 8009bc0:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 8009bc2:	4c08      	ldr	r4, [pc, #32]	; (8009be4 <LoRaMacConfirmQueueInit+0x24>)

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8009bc4:	2300      	movs	r3, #0
    ConfirmQueueCtx.Primitives = primitives;
 8009bc6:	6020      	str	r0, [r4, #0]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8009bc8:	2214      	movs	r2, #20
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009bca:	f104 000c 	add.w	r0, r4, #12
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8009bce:	21ff      	movs	r1, #255	; 0xff
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 8009bd0:	f884 3020 	strb.w	r3, [r4, #32]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009bd4:	e9c4 0001 	strd	r0, r0, [r4, #4]
    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 8009bd8:	f003 fac0 	bl	800d15c <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 8009bdc:	2301      	movs	r3, #1
 8009bde:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8009be2:	bd10      	pop	{r4, pc}
 8009be4:	200010c8 	.word	0x200010c8

08009be8 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8009be8:	4b0f      	ldr	r3, [pc, #60]	; (8009c28 <LoRaMacConfirmQueueAdd+0x40>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8009bea:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009bee:	2a04      	cmp	r2, #4
 8009bf0:	d817      	bhi.n	8009c22 <LoRaMacConfirmQueueAdd+0x3a>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 8009bf2:	689a      	ldr	r2, [r3, #8]
 8009bf4:	7801      	ldrb	r1, [r0, #0]
 8009bf6:	7011      	strb	r1, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 8009bf8:	7841      	ldrb	r1, [r0, #1]
 8009bfa:	7051      	strb	r1, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 8009bfc:	78c1      	ldrb	r1, [r0, #3]
 8009bfe:	70d1      	strb	r1, [r2, #3]
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
 8009c00:	2100      	movs	r1, #0
 8009c02:	7091      	strb	r1, [r2, #2]
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 8009c04:	f893 1020 	ldrb.w	r1, [r3, #32]
 8009c08:	3101      	adds	r1, #1
 8009c0a:	f883 1020 	strb.w	r1, [r3, #32]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009c0e:	f103 011c 	add.w	r1, r3, #28
 8009c12:	428a      	cmp	r2, r1
        bufferPointer++;
 8009c14:	bf14      	ite	ne
 8009c16:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009c18:	f103 020c 	addeq.w	r2, r3, #12
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 8009c1c:	609a      	str	r2, [r3, #8]
 8009c1e:	2001      	movs	r0, #1
 8009c20:	4770      	bx	lr
        return false;
 8009c22:	2000      	movs	r0, #0

    return true;
}
 8009c24:	4770      	bx	lr
 8009c26:	bf00      	nop
 8009c28:	200010c8 	.word	0x200010c8

08009c2c <LoRaMacConfirmQueueRemoveFirst>:
    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8009c2c:	4b09      	ldr	r3, [pc, #36]	; (8009c54 <LoRaMacConfirmQueueRemoveFirst+0x28>)
 8009c2e:	f893 0020 	ldrb.w	r0, [r3, #32]
    if( count == 0 )
 8009c32:	b168      	cbz	r0, 8009c50 <LoRaMacConfirmQueueRemoveFirst+0x24>
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8009c34:	685a      	ldr	r2, [r3, #4]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009c36:	f103 011c 	add.w	r1, r3, #28
 8009c3a:	428a      	cmp	r2, r1
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8009c3c:	f100 30ff 	add.w	r0, r0, #4294967295
        bufferPointer++;
 8009c40:	bf14      	ite	ne
 8009c42:	3204      	addne	r2, #4
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009c44:	f103 020c 	addeq.w	r2, r3, #12
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 8009c48:	f883 0020 	strb.w	r0, [r3, #32]
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 8009c4c:	605a      	str	r2, [r3, #4]

    return true;
 8009c4e:	2001      	movs	r0, #1
}
 8009c50:	4770      	bx	lr
 8009c52:	bf00      	nop
 8009c54:	200010c8 	.word	0x200010c8

08009c58 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 8009c58:	b510      	push	{r4, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8009c5a:	4b07      	ldr	r3, [pc, #28]	; (8009c78 <LoRaMacConfirmQueueSetStatus+0x20>)
    if( count == 0 )
 8009c5c:	f893 2020 	ldrb.w	r2, [r3, #32]
{
 8009c60:	4604      	mov	r4, r0
 8009c62:	4608      	mov	r0, r1
    if( count == 0 )
 8009c64:	b132      	cbz	r2, 8009c74 <LoRaMacConfirmQueueSetStatus+0x1c>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8009c66:	6859      	ldr	r1, [r3, #4]
 8009c68:	f7ff ff8c 	bl	8009b84 <GetElement.isra.0>
        if( element != NULL )
 8009c6c:	b110      	cbz	r0, 8009c74 <LoRaMacConfirmQueueSetStatus+0x1c>
        {
            element->Status = status;
            element->ReadyToHandle = true;
 8009c6e:	2301      	movs	r3, #1
            element->Status = status;
 8009c70:	7044      	strb	r4, [r0, #1]
            element->ReadyToHandle = true;
 8009c72:	7083      	strb	r3, [r0, #2]
        }
    }
}
 8009c74:	bd10      	pop	{r4, pc}
 8009c76:	bf00      	nop
 8009c78:	200010c8 	.word	0x200010c8

08009c7c <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 8009c7c:	b508      	push	{r3, lr}
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 8009c7e:	4b06      	ldr	r3, [pc, #24]	; (8009c98 <LoRaMacConfirmQueueGetStatus+0x1c>)
    if( count == 0 )
 8009c80:	f893 2020 	ldrb.w	r2, [r3, #32]
 8009c84:	b12a      	cbz	r2, 8009c92 <LoRaMacConfirmQueueGetStatus+0x16>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 8009c86:	6859      	ldr	r1, [r3, #4]
 8009c88:	f7ff ff7c 	bl	8009b84 <GetElement.isra.0>
        if( element != NULL )
 8009c8c:	b108      	cbz	r0, 8009c92 <LoRaMacConfirmQueueGetStatus+0x16>
        {
            return element->Status;
 8009c8e:	7840      	ldrb	r0, [r0, #1]
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
}
 8009c90:	bd08      	pop	{r3, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 8009c92:	2001      	movs	r0, #1
 8009c94:	e7fc      	b.n	8009c90 <LoRaMacConfirmQueueGetStatus+0x14>
 8009c96:	bf00      	nop
 8009c98:	200010c8 	.word	0x200010c8

08009c9c <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 8009c9c:	b530      	push	{r4, r5, lr}
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8009c9e:	4a0a      	ldr	r2, [pc, #40]	; (8009cc8 <LoRaMacConfirmQueueSetStatusCmn+0x2c>)
    if( count == 0 )
 8009ca0:	f892 1020 	ldrb.w	r1, [r2, #32]
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 8009ca4:	6853      	ldr	r3, [r2, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 8009ca6:	f882 0021 	strb.w	r0, [r2, #33]	; 0x21
    if( count == 0 )
 8009caa:	b161      	cbz	r1, 8009cc6 <LoRaMacConfirmQueueSetStatusCmn+0x2a>
            if( element->RestrictCommonReadyToHandle == false )
            {
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
 8009cac:	6891      	ldr	r1, [r2, #8]
                element->ReadyToHandle = true;
 8009cae:	2401      	movs	r4, #1
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009cb0:	321c      	adds	r2, #28
            if( element->RestrictCommonReadyToHandle == false )
 8009cb2:	78dd      	ldrb	r5, [r3, #3]
            element->Status = status;
 8009cb4:	7058      	strb	r0, [r3, #1]
            if( element->RestrictCommonReadyToHandle == false )
 8009cb6:	b905      	cbnz	r5, 8009cba <LoRaMacConfirmQueueSetStatusCmn+0x1e>
                element->ReadyToHandle = true;
 8009cb8:	709c      	strb	r4, [r3, #2]
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 8009cba:	4293      	cmp	r3, r2
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 8009cbc:	bf0c      	ite	eq
 8009cbe:	4b03      	ldreq	r3, [pc, #12]	; (8009ccc <LoRaMacConfirmQueueSetStatusCmn+0x30>)
        bufferPointer++;
 8009cc0:	3304      	addne	r3, #4
        }while( element != ConfirmQueueCtx.BufferEnd );
 8009cc2:	4299      	cmp	r1, r3
 8009cc4:	d1f5      	bne.n	8009cb2 <LoRaMacConfirmQueueSetStatusCmn+0x16>
    }
}
 8009cc6:	bd30      	pop	{r4, r5, pc}
 8009cc8:	200010c8 	.word	0x200010c8
 8009ccc:	200010d4 	.word	0x200010d4

08009cd0 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 8009cd0:	b508      	push	{r3, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 8009cd2:	4b04      	ldr	r3, [pc, #16]	; (8009ce4 <LoRaMacConfirmQueueIsCmdActive+0x14>)
 8009cd4:	6859      	ldr	r1, [r3, #4]
 8009cd6:	f7ff ff55 	bl	8009b84 <GetElement.isra.0>
    {
        return true;
    }
    return false;
}
 8009cda:	3800      	subs	r0, #0
 8009cdc:	bf18      	it	ne
 8009cde:	2001      	movne	r0, #1
 8009ce0:	bd08      	pop	{r3, pc}
 8009ce2:	bf00      	nop
 8009ce4:	200010c8 	.word	0x200010c8

08009ce8 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 8009ce8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 8009cec:	4d12      	ldr	r5, [pc, #72]	; (8009d38 <LoRaMacConfirmQueueHandleCb+0x50>)
 8009cee:	f895 8020 	ldrb.w	r8, [r5, #32]
{
 8009cf2:	4604      	mov	r4, r0
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    for( uint8_t i = 0; i < nbElements; i++ )
 8009cf4:	2600      	movs	r6, #0
 8009cf6:	b2f3      	uxtb	r3, r6
 8009cf8:	4598      	cmp	r8, r3
 8009cfa:	d802      	bhi.n	8009d02 <LoRaMacConfirmQueueHandleCb+0x1a>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
        }
    }
}
 8009cfc:	b002      	add	sp, #8
 8009cfe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 8009d02:	686b      	ldr	r3, [r5, #4]
 8009d04:	7819      	ldrb	r1, [r3, #0]
 8009d06:	7021      	strb	r1, [r4, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 8009d08:	785a      	ldrb	r2, [r3, #1]
 8009d0a:	7062      	strb	r2, [r4, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 8009d0c:	789f      	ldrb	r7, [r3, #2]
        if( readyToHandle == true )
 8009d0e:	b15f      	cbz	r7, 8009d28 <LoRaMacConfirmQueueHandleCb+0x40>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 8009d10:	682b      	ldr	r3, [r5, #0]
 8009d12:	4620      	mov	r0, r4
 8009d14:	689b      	ldr	r3, [r3, #8]
 8009d16:	4798      	blx	r3
        LoRaMacConfirmQueueRemoveFirst( );
 8009d18:	f7ff ff88 	bl	8009c2c <LoRaMacConfirmQueueRemoveFirst>
        if( readyToHandle == false )
 8009d1c:	b917      	cbnz	r7, 8009d24 <LoRaMacConfirmQueueHandleCb+0x3c>
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 8009d1e:	a801      	add	r0, sp, #4
 8009d20:	f7ff ff62 	bl	8009be8 <LoRaMacConfirmQueueAdd>
    for( uint8_t i = 0; i < nbElements; i++ )
 8009d24:	3601      	adds	r6, #1
 8009d26:	e7e6      	b.n	8009cf6 <LoRaMacConfirmQueueHandleCb+0xe>
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8009d28:	78db      	ldrb	r3, [r3, #3]
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 8009d2a:	f88d 1004 	strb.w	r1, [sp, #4]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 8009d2e:	f88d 2005 	strb.w	r2, [sp, #5]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 8009d32:	f88d 3007 	strb.w	r3, [sp, #7]
 8009d36:	e7ef      	b.n	8009d18 <LoRaMacConfirmQueueHandleCb+0x30>
 8009d38:	200010c8 	.word	0x200010c8

08009d3c <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
}
 8009d3c:	4b01      	ldr	r3, [pc, #4]	; (8009d44 <LoRaMacConfirmQueueGetCnt+0x8>)
 8009d3e:	f893 0020 	ldrb.w	r0, [r3, #32]
 8009d42:	4770      	bx	lr
 8009d44:	200010c8 	.word	0x200010c8

08009d48 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 8009d48:	4b03      	ldr	r3, [pc, #12]	; (8009d58 <LoRaMacConfirmQueueIsFull+0x10>)
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 8009d4a:	f893 0020 	ldrb.w	r0, [r3, #32]
    }
    else
    {
        return false;
    }
}
 8009d4e:	2804      	cmp	r0, #4
 8009d50:	bf94      	ite	ls
 8009d52:	2000      	movls	r0, #0
 8009d54:	2001      	movhi	r0, #1
 8009d56:	4770      	bx	lr
 8009d58:	200010c8 	.word	0x200010c8

08009d5c <DeriveSessionKey10x>:
 * \param[IN]  netID          - Network Identifier
 * \param[IN]  deviceNonce    - Device nonce
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t DeriveSessionKey10x( KeyIdentifier_t keyID, uint32_t joinNonce, uint32_t netID, uint16_t devNonce )
{
 8009d5c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t compBase[16] = { 0 };
 8009d5e:	2400      	movs	r4, #0
 8009d60:	e9cd 4402 	strd	r4, r4, [sp, #8]

    /* ST_WORKAROUND_BEGIN: integrate 1.1.x keys only if required */
    switch( keyID )
 8009d64:	1e44      	subs	r4, r0, #1
 8009d66:	f88d 4000 	strb.w	r4, [sp]
        default:
            return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
   /* ST_WORKAROUND_END */

    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 8009d6a:	f88d 1001 	strb.w	r1, [sp, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8009d6e:	0a0c      	lsrs	r4, r1, #8
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );

    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 8009d70:	f8ad 2004 	strh.w	r2, [sp, #4]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8009d74:	0c09      	lsrs	r1, r1, #16
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8009d76:	0c12      	lsrs	r2, r2, #16
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 8009d78:	f88d 1003 	strb.w	r1, [sp, #3]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 8009d7c:	f88d 2006 	strb.w	r2, [sp, #6]

    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 8009d80:	f88d 3007 	strb.w	r3, [sp, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );

    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8009d84:	4602      	mov	r2, r0
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8009d86:	0a1b      	lsrs	r3, r3, #8
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8009d88:	2101      	movs	r1, #1
 8009d8a:	4668      	mov	r0, sp
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 8009d8c:	f88d 4002 	strb.w	r4, [sp, #2]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 8009d90:	f88d 3008 	strb.w	r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 8009d94:	f003 f915 	bl	800cfc2 <SecureElementDeriveAndStoreKey>
 8009d98:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8009d9a:	bf18      	it	ne
 8009d9c:	200f      	movne	r0, #15
 8009d9e:	b004      	add	sp, #16
 8009da0:	bd10      	pop	{r4, pc}

08009da2 <PayloadEncrypt>:
{
 8009da2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009da6:	b088      	sub	sp, #32
 8009da8:	4617      	mov	r7, r2
 8009daa:	460d      	mov	r5, r1
 8009dac:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    if( buffer == 0 )
 8009dae:	4606      	mov	r6, r0
 8009db0:	2800      	cmp	r0, #0
 8009db2:	d04d      	beq.n	8009e50 <PayloadEncrypt+0xae>
    uint8_t sBlock[16] = { 0 };
 8009db4:	2400      	movs	r4, #0
    aBlock[0] = 0x01;
 8009db6:	2101      	movs	r1, #1
    uint8_t aBlock[16] = { 0 };
 8009db8:	e9cd 4404 	strd	r4, r4, [sp, #16]
    aBlock[0] = 0x01;
 8009dbc:	f88d 1010 	strb.w	r1, [sp, #16]
    aBlock[5] = dir;
 8009dc0:	f89d 1038 	ldrb.w	r1, [sp, #56]	; 0x38
 8009dc4:	f88d 1015 	strb.w	r1, [sp, #21]
    aBlock[6] = address & 0xFF;
 8009dc8:	f8ad 3016 	strh.w	r3, [sp, #22]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8009dcc:	0c19      	lsrs	r1, r3, #16
    uint8_t sBlock[16] = { 0 };
 8009dce:	e9cd 4400 	strd	r4, r4, [sp]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8009dd2:	0e1b      	lsrs	r3, r3, #24
    uint8_t sBlock[16] = { 0 };
 8009dd4:	e9cd 4402 	strd	r4, r4, [sp, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 8009dd8:	f88d 3019 	strb.w	r3, [sp, #25]
    aBlock[10] = frameCounter & 0xFF;
 8009ddc:	f8ad 201a 	strh.w	r2, [sp, #26]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8009de0:	0c13      	lsrs	r3, r2, #16
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8009de2:	0e12      	lsrs	r2, r2, #24
    uint8_t aBlock[16] = { 0 };
 8009de4:	9407      	str	r4, [sp, #28]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 8009de6:	f88d 1018 	strb.w	r1, [sp, #24]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 8009dea:	f88d 301c 	strb.w	r3, [sp, #28]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 8009dee:	f88d 201d 	strb.w	r2, [sp, #29]
    while( size > 0 )
 8009df2:	b2e3      	uxtb	r3, r4
 8009df4:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8009df8:	2d00      	cmp	r5, #0
 8009dfa:	fa5f f888 	uxtb.w	r8, r8
 8009dfe:	dc03      	bgt.n	8009e08 <PayloadEncrypt+0x66>
    return LORAMAC_CRYPTO_SUCCESS;
 8009e00:	2000      	movs	r0, #0
}
 8009e02:	b008      	add	sp, #32
 8009e04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        aBlock[15] = ctr & 0xFF;
 8009e08:	3301      	adds	r3, #1
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8009e0a:	2110      	movs	r1, #16
        aBlock[15] = ctr & 0xFF;
 8009e0c:	f88d 301f 	strb.w	r3, [sp, #31]
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 8009e10:	463a      	mov	r2, r7
 8009e12:	466b      	mov	r3, sp
 8009e14:	eb0d 0001 	add.w	r0, sp, r1
 8009e18:	f003 f868 	bl	800ceec <SecureElementAesEncrypt>
 8009e1c:	4603      	mov	r3, r0
 8009e1e:	b9c8      	cbnz	r0, 8009e54 <PayloadEncrypt+0xb2>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8009e20:	2d10      	cmp	r5, #16
 8009e22:	46ac      	mov	ip, r5
 8009e24:	bfa8      	it	ge
 8009e26:	f04f 0c10 	movge.w	ip, #16
 8009e2a:	b2da      	uxtb	r2, r3
 8009e2c:	4562      	cmp	r2, ip
 8009e2e:	f103 0301 	add.w	r3, r3, #1
 8009e32:	db03      	blt.n	8009e3c <PayloadEncrypt+0x9a>
        size -= 16;
 8009e34:	3d10      	subs	r5, #16
 8009e36:	b22d      	sxth	r5, r5
        bufferIndex += 16;
 8009e38:	3401      	adds	r4, #1
 8009e3a:	e7da      	b.n	8009df2 <PayloadEncrypt+0x50>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 8009e3c:	a908      	add	r1, sp, #32
 8009e3e:	eb08 0002 	add.w	r0, r8, r2
 8009e42:	440a      	add	r2, r1
 8009e44:	5c31      	ldrb	r1, [r6, r0]
 8009e46:	f812 2c20 	ldrb.w	r2, [r2, #-32]
 8009e4a:	404a      	eors	r2, r1
 8009e4c:	5432      	strb	r2, [r6, r0]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 8009e4e:	e7ec      	b.n	8009e2a <PayloadEncrypt+0x88>
        return LORAMAC_CRYPTO_ERROR_NPE;
 8009e50:	200a      	movs	r0, #10
 8009e52:	e7d6      	b.n	8009e02 <PayloadEncrypt+0x60>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8009e54:	200f      	movs	r0, #15
 8009e56:	e7d4      	b.n	8009e02 <PayloadEncrypt+0x60>

08009e58 <GetLastFcntDown>:
{
    if( lastDown == NULL )
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 8009e58:	3801      	subs	r0, #1
 8009e5a:	2803      	cmp	r0, #3
 8009e5c:	d81c      	bhi.n	8009e98 <GetLastFcntDown+0x40>
 8009e5e:	e8df f000 	tbb	[pc, r0]
 8009e62:	0a02      	.short	0x0a02
 8009e64:	1610      	.short	0x1610
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 8009e66:	4b0d      	ldr	r3, [pc, #52]	; (8009e9c <GetLastFcntDown+0x44>)
 8009e68:	681b      	ldr	r3, [r3, #0]
 8009e6a:	691a      	ldr	r2, [r3, #16]
 8009e6c:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8009e6e:	691a      	ldr	r2, [r3, #16]
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8009e70:	621a      	str	r2, [r3, #32]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 8009e72:	2000      	movs	r0, #0
            break;
 8009e74:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 8009e76:	4b09      	ldr	r3, [pc, #36]	; (8009e9c <GetLastFcntDown+0x44>)
 8009e78:	681b      	ldr	r3, [r3, #0]
 8009e7a:	695a      	ldr	r2, [r3, #20]
 8009e7c:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.AFCntDown;
 8009e7e:	695a      	ldr	r2, [r3, #20]
 8009e80:	e7f6      	b.n	8009e70 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 8009e82:	4b06      	ldr	r3, [pc, #24]	; (8009e9c <GetLastFcntDown+0x44>)
 8009e84:	681b      	ldr	r3, [r3, #0]
 8009e86:	699a      	ldr	r2, [r3, #24]
 8009e88:	600a      	str	r2, [r1, #0]
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 8009e8a:	699a      	ldr	r2, [r3, #24]
 8009e8c:	e7f0      	b.n	8009e70 <GetLastFcntDown+0x18>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 8009e8e:	4b03      	ldr	r3, [pc, #12]	; (8009e9c <GetLastFcntDown+0x44>)
 8009e90:	681b      	ldr	r3, [r3, #0]
 8009e92:	69db      	ldr	r3, [r3, #28]
 8009e94:	600b      	str	r3, [r1, #0]
            break;
 8009e96:	e7ec      	b.n	8009e72 <GetLastFcntDown+0x1a>
            CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.NFCntDown;
 8009e98:	2005      	movs	r0, #5
}
 8009e9a:	4770      	bx	lr
 8009e9c:	200010ec 	.word	0x200010ec

08009ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>:
    }

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveMcKEKey( KeyIdentifier_t keyID )
 8009ea0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    // Prevent other keys than McRootKey
    if( keyID != MC_ROOT_KEY )
    {
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
    }
    uint8_t compBase[16] = { 0 };
 8009ea2:	2300      	movs	r3, #0

    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8009ea4:	227f      	movs	r2, #127	; 0x7f
 8009ea6:	2104      	movs	r1, #4
 8009ea8:	4668      	mov	r0, sp
    uint8_t compBase[16] = { 0 };
 8009eaa:	e9cd 3300 	strd	r3, r3, [sp]
 8009eae:	e9cd 3302 	strd	r3, r3, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_KE_KEY ) != SECURE_ELEMENT_SUCCESS )
 8009eb2:	f003 f886 	bl	800cfc2 <SecureElementDeriveAndStoreKey>
 8009eb6:	2800      	cmp	r0, #0
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 8009eb8:	bf18      	it	ne
 8009eba:	200f      	movne	r0, #15
 8009ebc:	b005      	add	sp, #20
 8009ebe:	f85d fb04 	ldr.w	pc, [sp], #4

08009ec2 <VerifyCmacB0.isra.0.constprop.0>:
static LoRaMacCryptoStatus_t VerifyCmacB0( uint8_t* msg, uint16_t len, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint32_t expectedCmac )
 8009ec2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009ec6:	b0c4      	sub	sp, #272	; 0x110
 8009ec8:	460c      	mov	r4, r1
 8009eca:	9e4a      	ldr	r6, [sp, #296]	; 0x128
 8009ecc:	4617      	mov	r7, r2
 8009ece:	461d      	mov	r5, r3
    if( msg == 0 )
 8009ed0:	4680      	mov	r8, r0
 8009ed2:	b3b8      	cbz	r0, 8009f44 <VerifyCmacB0.isra.0.constprop.0+0x82>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 8009ed4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8009ed8:	d836      	bhi.n	8009f48 <VerifyCmacB0.isra.0.constprop.0+0x86>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 8009eda:	f44f 7288 	mov.w	r2, #272	; 0x110
 8009ede:	2100      	movs	r1, #0
 8009ee0:	4668      	mov	r0, sp
 8009ee2:	f003 f93b 	bl	800d15c <memset1>
    b0[0] = 0x49;
 8009ee6:	2349      	movs	r3, #73	; 0x49
 8009ee8:	9300      	str	r3, [sp, #0]
    b0[4] = 0x00;
 8009eea:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009eee:	f8ad 3004 	strh.w	r3, [sp, #4]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 8009ef2:	0c2b      	lsrs	r3, r5, #16
 8009ef4:	f88d 3008 	strb.w	r3, [sp, #8]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8009ef8:	0c33      	lsrs	r3, r6, #16
    b0[6] = devAddr & 0xFF;
 8009efa:	f8ad 5006 	strh.w	r5, [sp, #6]
    b0[10] = fCnt & 0xFF;
 8009efe:	f8ad 600a 	strh.w	r6, [sp, #10]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 8009f02:	f88d 300c 	strb.w	r3, [sp, #12]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8009f06:	4622      	mov	r2, r4
    b0[14] = 0x00;
 8009f08:	2300      	movs	r3, #0
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8009f0a:	4641      	mov	r1, r8
 8009f0c:	a804      	add	r0, sp, #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8009f0e:	0e2d      	lsrs	r5, r5, #24
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8009f10:	0e36      	lsrs	r6, r6, #24
    b0[14] = 0x00;
 8009f12:	f88d 300e 	strb.w	r3, [sp, #14]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 8009f16:	f88d 5009 	strb.w	r5, [sp, #9]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 8009f1a:	f88d 600d 	strb.w	r6, [sp, #13]
    b0[15] = msgLen & 0xFF;
 8009f1e:	f88d 400f 	strb.w	r4, [sp, #15]
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 8009f22:	f003 f907 	bl	800d134 <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 8009f26:	f104 0110 	add.w	r1, r4, #16
 8009f2a:	9a4b      	ldr	r2, [sp, #300]	; 0x12c
 8009f2c:	463b      	mov	r3, r7
 8009f2e:	b289      	uxth	r1, r1
 8009f30:	4668      	mov	r0, sp
 8009f32:	f002 ffc5 	bl	800cec0 <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 8009f36:	b110      	cbz	r0, 8009f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 8009f38:	2801      	cmp	r0, #1
 8009f3a:	bf18      	it	ne
 8009f3c:	200f      	movne	r0, #15
}
 8009f3e:	b044      	add	sp, #272	; 0x110
 8009f40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 8009f44:	200a      	movs	r0, #10
 8009f46:	e7fa      	b.n	8009f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 8009f48:	200e      	movs	r0, #14
 8009f4a:	e7f8      	b.n	8009f3e <VerifyCmacB0.isra.0.constprop.0+0x7c>

08009f4c <LoRaMacCryptoInit>:
{
 8009f4c:	b510      	push	{r4, lr}
    if( nvm == NULL )
 8009f4e:	b190      	cbz	r0, 8009f76 <LoRaMacCryptoInit+0x2a>
    CryptoNvm = nvm;
 8009f50:	4c0a      	ldr	r4, [pc, #40]	; (8009f7c <LoRaMacCryptoInit+0x30>)
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8009f52:	2228      	movs	r2, #40	; 0x28
 8009f54:	2100      	movs	r1, #0
    CryptoNvm = nvm;
 8009f56:	6020      	str	r0, [r4, #0]
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 8009f58:	f003 f900 	bl	800d15c <memset1>
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 8009f5c:	6823      	ldr	r3, [r4, #0]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 8009f5e:	4a08      	ldr	r2, [pc, #32]	; (8009f80 <LoRaMacCryptoInit+0x34>)
 8009f60:	601a      	str	r2, [r3, #0]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITAL_VALUE;
 8009f62:	2000      	movs	r0, #0
 8009f64:	f04f 32ff 	mov.w	r2, #4294967295
 8009f68:	e9c3 0203 	strd	r0, r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 8009f6c:	e9c3 2205 	strd	r2, r2, [r3, #20]
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITAL_VALUE;
 8009f70:	e9c3 2207 	strd	r2, r2, [r3, #28]
}
 8009f74:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 8009f76:	2009      	movs	r0, #9
 8009f78:	e7fc      	b.n	8009f74 <LoRaMacCryptoInit+0x28>
 8009f7a:	bf00      	nop
 8009f7c:	200010ec 	.word	0x200010ec
 8009f80:	01010100 	.word	0x01010100

08009f84 <LoRaMacCryptoSetLrWanVersion>:
    CryptoNvm->LrWanVersion = version;
 8009f84:	4b02      	ldr	r3, [pc, #8]	; (8009f90 <LoRaMacCryptoSetLrWanVersion+0xc>)
 8009f86:	681b      	ldr	r3, [r3, #0]
 8009f88:	6018      	str	r0, [r3, #0]
}
 8009f8a:	2000      	movs	r0, #0
 8009f8c:	4770      	bx	lr
 8009f8e:	bf00      	nop
 8009f90:	200010ec 	.word	0x200010ec

08009f94 <LoRaMacCryptoGetFCntUp>:
    if( currentUp == NULL )
 8009f94:	b130      	cbz	r0, 8009fa4 <LoRaMacCryptoGetFCntUp+0x10>
    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 8009f96:	4b04      	ldr	r3, [pc, #16]	; (8009fa8 <LoRaMacCryptoGetFCntUp+0x14>)
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	68db      	ldr	r3, [r3, #12]
 8009f9c:	3301      	adds	r3, #1
 8009f9e:	6003      	str	r3, [r0, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 8009fa0:	2000      	movs	r0, #0
 8009fa2:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 8009fa4:	200a      	movs	r0, #10
}
 8009fa6:	4770      	bx	lr
 8009fa8:	200010ec 	.word	0x200010ec

08009fac <LoRaMacCryptoGetFCntDown>:
{
 8009fac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8009fae:	4617      	mov	r7, r2
    uint32_t lastDown = 0;
 8009fb0:	2200      	movs	r2, #0
{
 8009fb2:	460e      	mov	r6, r1
    uint32_t lastDown = 0;
 8009fb4:	9201      	str	r2, [sp, #4]
    if( currentDown == NULL )
 8009fb6:	461c      	mov	r4, r3
 8009fb8:	b353      	cbz	r3, 800a010 <LoRaMacCryptoGetFCntDown+0x64>
    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 8009fba:	a901      	add	r1, sp, #4
 8009fbc:	f7ff ff4c 	bl	8009e58 <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 8009fc0:	b9e8      	cbnz	r0, 8009ffe <LoRaMacCryptoGetFCntDown+0x52>
    if( lastDown == FCNT_DOWN_INITAL_VALUE )
 8009fc2:	9d01      	ldr	r5, [sp, #4]
 8009fc4:	1c6b      	adds	r3, r5, #1
 8009fc6:	d110      	bne.n	8009fea <LoRaMacCryptoGetFCntDown+0x3e>
        *currentDown = frameFcnt;
 8009fc8:	6027      	str	r7, [r4, #0]
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 8009fca:	4b12      	ldr	r3, [pc, #72]	; (800a014 <LoRaMacCryptoGetFCntDown+0x68>)
 8009fcc:	681b      	ldr	r3, [r3, #0]
 8009fce:	789b      	ldrb	r3, [r3, #2]
 8009fd0:	b9ab      	cbnz	r3, 8009ffe <LoRaMacCryptoGetFCntDown+0x52>
        if( ( ( int64_t )*currentDown - ( int64_t )lastDown ) >= maxFCntGap )
 8009fd2:	6822      	ldr	r2, [r4, #0]
 8009fd4:	b2b6      	uxth	r6, r6
 8009fd6:	1b52      	subs	r2, r2, r5
 8009fd8:	eb62 0302 	sbc.w	r3, r2, r2
 8009fdc:	2700      	movs	r7, #0
 8009fde:	42b2      	cmp	r2, r6
 8009fe0:	41bb      	sbcs	r3, r7
            return LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT;
 8009fe2:	bfb4      	ite	lt
 8009fe4:	2000      	movlt	r0, #0
 8009fe6:	2008      	movge	r0, #8
 8009fe8:	e009      	b.n	8009ffe <LoRaMacCryptoGetFCntDown+0x52>
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 8009fea:	b2a9      	uxth	r1, r5
 8009fec:	1a79      	subs	r1, r7, r1
        if( fCntDiff > 0 )
 8009fee:	2900      	cmp	r1, #0
 8009ff0:	dd02      	ble.n	8009ff8 <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = lastDown + fCntDiff;
 8009ff2:	4429      	add	r1, r5
 8009ff4:	6021      	str	r1, [r4, #0]
 8009ff6:	e7e8      	b.n	8009fca <LoRaMacCryptoGetFCntDown+0x1e>
        else if( fCntDiff == 0 )
 8009ff8:	d103      	bne.n	800a002 <LoRaMacCryptoGetFCntDown+0x56>
            *currentDown = lastDown;
 8009ffa:	6025      	str	r5, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 8009ffc:	2007      	movs	r0, #7
}
 8009ffe:	b003      	add	sp, #12
 800a000:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 800a002:	0c2b      	lsrs	r3, r5, #16
 800a004:	041b      	lsls	r3, r3, #16
 800a006:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800a00a:	443b      	add	r3, r7
 800a00c:	6023      	str	r3, [r4, #0]
 800a00e:	e7dc      	b.n	8009fca <LoRaMacCryptoGetFCntDown+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a010:	200a      	movs	r0, #10
 800a012:	e7f4      	b.n	8009ffe <LoRaMacCryptoGetFCntDown+0x52>
 800a014:	200010ec 	.word	0x200010ec

0800a018 <LoRaMacCryptoSetMulticastReference>:
    if( multicastList == NULL )
 800a018:	b128      	cbz	r0, 800a026 <LoRaMacCryptoSetMulticastReference+0xe>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 800a01a:	4b04      	ldr	r3, [pc, #16]	; (800a02c <LoRaMacCryptoSetMulticastReference+0x14>)
 800a01c:	681b      	ldr	r3, [r3, #0]
 800a01e:	331c      	adds	r3, #28
 800a020:	6203      	str	r3, [r0, #32]
    return LORAMAC_CRYPTO_SUCCESS;
 800a022:	2000      	movs	r0, #0
 800a024:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a026:	200a      	movs	r0, #10
}
 800a028:	4770      	bx	lr
 800a02a:	bf00      	nop
 800a02c:	200010ec 	.word	0x200010ec

0800a030 <LoRaMacCryptoPrepareJoinRequest>:
{
 800a030:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( macMsg == 0 )
 800a032:	4604      	mov	r4, r0
 800a034:	b1f0      	cbz	r0, 800a074 <LoRaMacCryptoPrepareJoinRequest+0x44>
    uint32_t devNonce = 0;
 800a036:	2300      	movs	r3, #0
    SecureElementRandomNumber( &devNonce );
 800a038:	a803      	add	r0, sp, #12
    uint32_t devNonce = 0;
 800a03a:	9303      	str	r3, [sp, #12]
    SecureElementRandomNumber( &devNonce );
 800a03c:	f003 f820 	bl	800d080 <SecureElementRandomNumber>
    CryptoNvm->DevNonce = devNonce;
 800a040:	4a0e      	ldr	r2, [pc, #56]	; (800a07c <LoRaMacCryptoPrepareJoinRequest+0x4c>)
 800a042:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 800a046:	6812      	ldr	r2, [r2, #0]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 800a048:	4620      	mov	r0, r4
    CryptoNvm->DevNonce = devNonce;
 800a04a:	8093      	strh	r3, [r2, #4]
    macMsg->DevNonce = CryptoNvm->DevNonce;
 800a04c:	82e3      	strh	r3, [r4, #22]
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 800a04e:	f000 fa3a 	bl	800a4c6 <LoRaMacSerializerJoinRequest>
 800a052:	b960      	cbnz	r0, 800a06e <LoRaMacCryptoPrepareJoinRequest+0x3e>
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 800a054:	f104 0318 	add.w	r3, r4, #24
 800a058:	9300      	str	r3, [sp, #0]
 800a05a:	6821      	ldr	r1, [r4, #0]
 800a05c:	2301      	movs	r3, #1
 800a05e:	2213      	movs	r2, #19
 800a060:	f002 ff28 	bl	800ceb4 <SecureElementComputeAesCmac>
 800a064:	b940      	cbnz	r0, 800a078 <LoRaMacCryptoPrepareJoinRequest+0x48>
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 800a066:	4620      	mov	r0, r4
 800a068:	f000 fa2d 	bl	800a4c6 <LoRaMacSerializerJoinRequest>
 800a06c:	b100      	cbz	r0, 800a070 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 800a06e:	2011      	movs	r0, #17
}
 800a070:	b004      	add	sp, #16
 800a072:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a074:	200a      	movs	r0, #10
 800a076:	e7fb      	b.n	800a070 <LoRaMacCryptoPrepareJoinRequest+0x40>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 800a078:	200f      	movs	r0, #15
 800a07a:	e7f9      	b.n	800a070 <LoRaMacCryptoPrepareJoinRequest+0x40>
 800a07c:	200010ec 	.word	0x200010ec

0800a080 <LoRaMacCryptoSecureMessage>:
{
 800a080:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a082:	4605      	mov	r5, r0
 800a084:	b087      	sub	sp, #28
    if( macMsg == NULL )
 800a086:	461c      	mov	r4, r3
 800a088:	b323      	cbz	r3, 800a0d4 <LoRaMacCryptoSecureMessage+0x54>
    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 800a08a:	4e2f      	ldr	r6, [pc, #188]	; (800a148 <LoRaMacCryptoSecureMessage+0xc8>)
 800a08c:	6833      	ldr	r3, [r6, #0]
 800a08e:	68db      	ldr	r3, [r3, #12]
 800a090:	4283      	cmp	r3, r0
 800a092:	d856      	bhi.n	800a142 <LoRaMacCryptoSecureMessage+0xc2>
    if( macMsg->FPort == 0 )
 800a094:	f894 2020 	ldrb.w	r2, [r4, #32]
        payloadDecryptionKeyID = NWK_S_KEY;
 800a098:	2a00      	cmp	r2, #0
 800a09a:	bf14      	ite	ne
 800a09c:	2203      	movne	r2, #3
 800a09e:	2202      	moveq	r2, #2
    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 800a0a0:	4283      	cmp	r3, r0
 800a0a2:	d305      	bcc.n	800a0b0 <LoRaMacCryptoSecureMessage+0x30>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 800a0a4:	4620      	mov	r0, r4
 800a0a6:	f000 fa42 	bl	800a52e <LoRaMacSerializerData>
 800a0aa:	b170      	cbz	r0, 800a0ca <LoRaMacCryptoSecureMessage+0x4a>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 800a0ac:	2011      	movs	r0, #17
 800a0ae:	e00a      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 800a0b0:	2300      	movs	r3, #0
 800a0b2:	9001      	str	r0, [sp, #4]
 800a0b4:	9300      	str	r3, [sp, #0]
 800a0b6:	68a3      	ldr	r3, [r4, #8]
 800a0b8:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 800a0bc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800a0be:	f7ff fe70 	bl	8009da2 <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a0c2:	2800      	cmp	r0, #0
 800a0c4:	d0ee      	beq.n	800a0a4 <LoRaMacCryptoSecureMessage+0x24>
}
 800a0c6:	b007      	add	sp, #28
 800a0c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 800a0ca:	7923      	ldrb	r3, [r4, #4]
 800a0cc:	6821      	ldr	r1, [r4, #0]
 800a0ce:	3b04      	subs	r3, #4
 800a0d0:	b29a      	uxth	r2, r3
    if( ( msg == 0 ) || ( cmac == 0 ) )
 800a0d2:	b909      	cbnz	r1, 800a0d8 <LoRaMacCryptoSecureMessage+0x58>
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a0d4:	200a      	movs	r0, #10
 800a0d6:	e7f6      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 800a0d8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800a0dc:	d82f      	bhi.n	800a13e <LoRaMacCryptoSecureMessage+0xbe>
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 800a0de:	68a7      	ldr	r7, [r4, #8]
    b0[5] = dir;
 800a0e0:	f8b4 c008 	ldrh.w	ip, [r4, #8]
    b0[6] = devAddr & 0xFF;
 800a0e4:	f8ad c00e 	strh.w	ip, [sp, #14]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 800a0e8:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 800a0ec:	0e3f      	lsrs	r7, r7, #24
 800a0ee:	f88d 7011 	strb.w	r7, [sp, #17]
    b0[15] = msgLen & 0xFF;
 800a0f2:	f88d 3017 	strb.w	r3, [sp, #23]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 800a0f6:	0c2f      	lsrs	r7, r5, #16
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 800a0f8:	f104 032c 	add.w	r3, r4, #44	; 0x2c
    b0[0] = 0x49;
 800a0fc:	f04f 0e49 	mov.w	lr, #73	; 0x49
    b0[4] = 0x00;
 800a100:	f8ad 000c 	strh.w	r0, [sp, #12]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 800a104:	f88d 7014 	strb.w	r7, [sp, #20]
    b0[14] = 0x00;
 800a108:	f88d 0016 	strb.w	r0, [sp, #22]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 800a10c:	0e2f      	lsrs	r7, r5, #24
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 800a10e:	9300      	str	r3, [sp, #0]
 800a110:	a802      	add	r0, sp, #8
 800a112:	2302      	movs	r3, #2
    b0[0] = 0x49;
 800a114:	f8cd e008 	str.w	lr, [sp, #8]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 800a118:	f88d c010 	strb.w	ip, [sp, #16]
    b0[10] = fCnt & 0xFF;
 800a11c:	f8ad 5012 	strh.w	r5, [sp, #18]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 800a120:	f88d 7015 	strb.w	r7, [sp, #21]
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 800a124:	f002 fec6 	bl	800ceb4 <SecureElementComputeAesCmac>
 800a128:	b108      	cbz	r0, 800a12e <LoRaMacCryptoSecureMessage+0xae>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 800a12a:	200f      	movs	r0, #15
 800a12c:	e7cb      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 800a12e:	4620      	mov	r0, r4
 800a130:	f000 f9fd 	bl	800a52e <LoRaMacSerializerData>
 800a134:	2800      	cmp	r0, #0
 800a136:	d1b9      	bne.n	800a0ac <LoRaMacCryptoSecureMessage+0x2c>
    CryptoNvm->FCntList.FCntUp = fCntUp;
 800a138:	6833      	ldr	r3, [r6, #0]
 800a13a:	60dd      	str	r5, [r3, #12]
    return LORAMAC_CRYPTO_SUCCESS;
 800a13c:	e7c3      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 800a13e:	200e      	movs	r0, #14
 800a140:	e7c1      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 800a142:	2006      	movs	r0, #6
 800a144:	e7bf      	b.n	800a0c6 <LoRaMacCryptoSecureMessage+0x46>
 800a146:	bf00      	nop
 800a148:	200010ec 	.word	0x200010ec

0800a14c <LoRaMacCryptoUnsecureMessage>:
{
 800a14c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800a150:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 800a152:	4680      	mov	r8, r0
 800a154:	460f      	mov	r7, r1
 800a156:	4616      	mov	r6, r2
 800a158:	461c      	mov	r4, r3
    if( macMsg == 0 )
 800a15a:	2d00      	cmp	r5, #0
 800a15c:	d059      	beq.n	800a212 <LoRaMacCryptoUnsecureMessage+0xc6>
    uint32_t lastDown = 0;
 800a15e:	2300      	movs	r3, #0
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 800a160:	a903      	add	r1, sp, #12
 800a162:	4610      	mov	r0, r2
    uint32_t lastDown = 0;
 800a164:	9303      	str	r3, [sp, #12]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 800a166:	f7ff fe77 	bl	8009e58 <GetLastFcntDown>
 800a16a:	b118      	cbz	r0, 800a174 <LoRaMacCryptoUnsecureMessage+0x28>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 800a16c:	2006      	movs	r0, #6
}
 800a16e:	b004      	add	sp, #16
 800a170:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( ( currentDown > lastDown ) ||
 800a174:	9b03      	ldr	r3, [sp, #12]
 800a176:	429c      	cmp	r4, r3
 800a178:	d801      	bhi.n	800a17e <LoRaMacCryptoUnsecureMessage+0x32>
 800a17a:	3301      	adds	r3, #1
 800a17c:	d1f6      	bne.n	800a16c <LoRaMacCryptoUnsecureMessage+0x20>
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 800a17e:	4628      	mov	r0, r5
 800a180:	f000 f946 	bl	800a410 <LoRaMacParserData>
 800a184:	2800      	cmp	r0, #0
 800a186:	d146      	bne.n	800a216 <LoRaMacCryptoUnsecureMessage+0xca>
        if( KeyAddrList[i].AddrID == addrID )
 800a188:	4b26      	ldr	r3, [pc, #152]	; (800a224 <LoRaMacCryptoUnsecureMessage+0xd8>)
 800a18a:	781a      	ldrb	r2, [r3, #0]
 800a18c:	4542      	cmp	r2, r8
 800a18e:	d003      	beq.n	800a198 <LoRaMacCryptoUnsecureMessage+0x4c>
 800a190:	791a      	ldrb	r2, [r3, #4]
 800a192:	4542      	cmp	r2, r8
 800a194:	d141      	bne.n	800a21a <LoRaMacCryptoUnsecureMessage+0xce>
 800a196:	2001      	movs	r0, #1
    if( address != macMsg->FHDR.DevAddr )
 800a198:	68aa      	ldr	r2, [r5, #8]
 800a19a:	42ba      	cmp	r2, r7
 800a19c:	d13f      	bne.n	800a21e <LoRaMacCryptoUnsecureMessage+0xd2>
    payloadDecryptionKeyID = curItem->AppSkey;
 800a19e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 800a1a2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    payloadDecryptionKeyID = curItem->AppSkey;
 800a1a4:	f890 8001 	ldrb.w	r8, [r0, #1]
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 800a1a8:	7929      	ldrb	r1, [r5, #4]
 800a1aa:	e9cd 4300 	strd	r4, r3, [sp]
 800a1ae:	3904      	subs	r1, #4
 800a1b0:	7882      	ldrb	r2, [r0, #2]
 800a1b2:	6828      	ldr	r0, [r5, #0]
 800a1b4:	463b      	mov	r3, r7
 800a1b6:	b289      	uxth	r1, r1
 800a1b8:	f7ff fe83 	bl	8009ec2 <VerifyCmacB0.isra.0.constprop.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a1bc:	2800      	cmp	r0, #0
 800a1be:	d1d6      	bne.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
    if( macMsg->FPort == 0 )
 800a1c0:	f895 3020 	ldrb.w	r3, [r5, #32]
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 800a1c4:	9401      	str	r4, [sp, #4]
        payloadDecryptionKeyID = NWK_S_KEY;
 800a1c6:	2b00      	cmp	r3, #0
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 800a1c8:	f04f 0301 	mov.w	r3, #1
 800a1cc:	9300      	str	r3, [sp, #0]
 800a1ce:	bf14      	ite	ne
 800a1d0:	4642      	movne	r2, r8
 800a1d2:	2202      	moveq	r2, #2
 800a1d4:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
 800a1d8:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800a1da:	463b      	mov	r3, r7
 800a1dc:	f7ff fde1 	bl	8009da2 <PayloadEncrypt>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a1e0:	2800      	cmp	r0, #0
 800a1e2:	d1c4      	bne.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
    switch( fCntID )
 800a1e4:	3e01      	subs	r6, #1
 800a1e6:	2e03      	cmp	r6, #3
 800a1e8:	d8c1      	bhi.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
 800a1ea:	e8df f006 	tbb	[pc, r6]
 800a1ee:	0602      	.short	0x0602
 800a1f0:	0e0a      	.short	0x0e0a
            CryptoNvm->FCntList.NFCntDown = currentDown;
 800a1f2:	4b0d      	ldr	r3, [pc, #52]	; (800a228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 800a1f4:	681b      	ldr	r3, [r3, #0]
 800a1f6:	611c      	str	r4, [r3, #16]
            break;
 800a1f8:	e7b9      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.AFCntDown = currentDown;
 800a1fa:	4b0b      	ldr	r3, [pc, #44]	; (800a228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 800a1fc:	681b      	ldr	r3, [r3, #0]
 800a1fe:	615c      	str	r4, [r3, #20]
            break;
 800a200:	e7b5      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.FCntDown = currentDown;
 800a202:	4b09      	ldr	r3, [pc, #36]	; (800a228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 800a204:	681b      	ldr	r3, [r3, #0]
 800a206:	619c      	str	r4, [r3, #24]
            break;
 800a208:	e7b1      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 800a20a:	4b07      	ldr	r3, [pc, #28]	; (800a228 <LoRaMacCryptoUnsecureMessage+0xdc>)
 800a20c:	681b      	ldr	r3, [r3, #0]
 800a20e:	61dc      	str	r4, [r3, #28]
            break;
 800a210:	e7ad      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a212:	200a      	movs	r0, #10
 800a214:	e7ab      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 800a216:	2010      	movs	r0, #16
 800a218:	e7a9      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 800a21a:	200c      	movs	r0, #12
 800a21c:	e7a7      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 800a21e:	2002      	movs	r0, #2
 800a220:	e7a5      	b.n	800a16e <LoRaMacCryptoUnsecureMessage+0x22>
 800a222:	bf00      	nop
 800a224:	200000c4 	.word	0x200000c4
 800a228:	200010ec 	.word	0x200010ec

0800a22c <LoRaMacCryptoDeriveMcRootKey>:
{
 800a22c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( keyID != APP_KEY )
 800a22e:	b9b1      	cbnz	r1, 800a25e <LoRaMacCryptoDeriveMcRootKey+0x32>
    if( versionMinor == 1 )
 800a230:	2801      	cmp	r0, #1
    uint8_t compBase[16] = { 0 };
 800a232:	e9cd 1100 	strd	r1, r1, [sp]
        compBase[0] = 0x20;
 800a236:	bf08      	it	eq
 800a238:	2320      	moveq	r3, #32
    uint8_t compBase[16] = { 0 };
 800a23a:	e9cd 1102 	strd	r1, r1, [sp, #8]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 800a23e:	f04f 0204 	mov.w	r2, #4
 800a242:	f04f 0100 	mov.w	r1, #0
 800a246:	4668      	mov	r0, sp
        compBase[0] = 0x20;
 800a248:	bf08      	it	eq
 800a24a:	f88d 3000 	strbeq.w	r3, [sp]
    if( SecureElementDeriveAndStoreKey( compBase, keyID, MC_ROOT_KEY ) != SECURE_ELEMENT_SUCCESS )
 800a24e:	f002 feb8 	bl	800cfc2 <SecureElementDeriveAndStoreKey>
 800a252:	2800      	cmp	r0, #0
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 800a254:	bf18      	it	ne
 800a256:	200f      	movne	r0, #15
}
 800a258:	b005      	add	sp, #20
 800a25a:	f85d fb04 	ldr.w	pc, [sp], #4
        return LORAMAC_CRYPTO_ERROR_INVALID_KEY_ID;
 800a25e:	200b      	movs	r0, #11
 800a260:	e7fa      	b.n	800a258 <LoRaMacCryptoDeriveMcRootKey+0x2c>
	...

0800a264 <LoRaMacCryptoSetKey>:
{
 800a264:	b538      	push	{r3, r4, r5, lr}
 800a266:	4605      	mov	r5, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 800a268:	f002 fea6 	bl	800cfb8 <SecureElementSetKey>
 800a26c:	4604      	mov	r4, r0
 800a26e:	b950      	cbnz	r0, 800a286 <LoRaMacCryptoSetKey+0x22>
    if( keyID == APP_KEY )
 800a270:	b955      	cbnz	r5, 800a288 <LoRaMacCryptoSetKey+0x24>
        if( LoRaMacCryptoDeriveMcRootKey( CryptoNvm->LrWanVersion.Fields.Minor, keyID ) != LORAMAC_CRYPTO_SUCCESS )
 800a272:	4b06      	ldr	r3, [pc, #24]	; (800a28c <LoRaMacCryptoSetKey+0x28>)
 800a274:	681b      	ldr	r3, [r3, #0]
 800a276:	4601      	mov	r1, r0
 800a278:	7898      	ldrb	r0, [r3, #2]
 800a27a:	f7ff ffd7 	bl	800a22c <LoRaMacCryptoDeriveMcRootKey>
 800a27e:	b910      	cbnz	r0, 800a286 <LoRaMacCryptoSetKey+0x22>
    if( keyID != MC_ROOT_KEY )
 800a280:	f7ff fe0e 	bl	8009ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>
        if( LoRaMacCryptoDeriveMcKEKey( MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 800a284:	b100      	cbz	r0, 800a288 <LoRaMacCryptoSetKey+0x24>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 800a286:	240f      	movs	r4, #15
}
 800a288:	4620      	mov	r0, r4
 800a28a:	bd38      	pop	{r3, r4, r5, pc}
 800a28c:	200010ec 	.word	0x200010ec

0800a290 <LoRaMacCryptoHandleJoinAccept>:
{
 800a290:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800a294:	4680      	mov	r8, r0
 800a296:	b08f      	sub	sp, #60	; 0x3c
 800a298:	460d      	mov	r5, r1
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 800a29a:	4614      	mov	r4, r2
 800a29c:	2a00      	cmp	r2, #0
 800a29e:	d05f      	beq.n	800a360 <LoRaMacCryptoHandleJoinAccept+0xd0>
 800a2a0:	2900      	cmp	r1, #0
 800a2a2:	d05d      	beq.n	800a360 <LoRaMacCryptoHandleJoinAccept+0xd0>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 800a2a4:	2600      	movs	r6, #0
 800a2a6:	4631      	mov	r1, r6
 800a2a8:	221d      	movs	r2, #29
 800a2aa:	a806      	add	r0, sp, #24
 800a2ac:	9605      	str	r6, [sp, #20]
 800a2ae:	f005 fb91 	bl	800f9d4 <memset>
    uint8_t versionMinor         = 0;
 800a2b2:	f88d 6013 	strb.w	r6, [sp, #19]
    uint16_t nonce               = CryptoNvm->DevNonce;
 800a2b6:	4e2e      	ldr	r6, [pc, #184]	; (800a370 <LoRaMacCryptoHandleJoinAccept+0xe0>)
 800a2b8:	6833      	ldr	r3, [r6, #0]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 800a2ba:	f10d 0914 	add.w	r9, sp, #20
    uint16_t nonce               = CryptoNvm->DevNonce;
 800a2be:	889f      	ldrh	r7, [r3, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 800a2c0:	f8cd 9004 	str.w	r9, [sp, #4]
 800a2c4:	f10d 0313 	add.w	r3, sp, #19
 800a2c8:	9302      	str	r3, [sp, #8]
 800a2ca:	7923      	ldrb	r3, [r4, #4]
 800a2cc:	9300      	str	r3, [sp, #0]
 800a2ce:	6823      	ldr	r3, [r4, #0]
 800a2d0:	463a      	mov	r2, r7
 800a2d2:	4629      	mov	r1, r5
 800a2d4:	4640      	mov	r0, r8
 800a2d6:	f002 fe90 	bl	800cffa <SecureElementProcessJoinAccept>
 800a2da:	2800      	cmp	r0, #0
 800a2dc:	d142      	bne.n	800a364 <LoRaMacCryptoHandleJoinAccept+0xd4>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 800a2de:	4649      	mov	r1, r9
 800a2e0:	7922      	ldrb	r2, [r4, #4]
 800a2e2:	6820      	ldr	r0, [r4, #0]
 800a2e4:	f002 ff26 	bl	800d134 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 800a2e8:	4620      	mov	r0, r4
 800a2ea:	f000 f843 	bl	800a374 <LoRaMacParserJoinAccept>
 800a2ee:	4601      	mov	r1, r0
 800a2f0:	2800      	cmp	r0, #0
 800a2f2:	d139      	bne.n	800a368 <LoRaMacCryptoHandleJoinAccept+0xd8>
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 800a2f4:	7a25      	ldrb	r5, [r4, #8]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 800a2f6:	79e2      	ldrb	r2, [r4, #7]
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 800a2f8:	79a3      	ldrb	r3, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 800a2fa:	042d      	lsls	r5, r5, #16
 800a2fc:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 800a300:	431d      	orrs	r5, r3
    if( currentJoinNonce != CryptoNvm->JoinNonce )
 800a302:	6833      	ldr	r3, [r6, #0]
 800a304:	689a      	ldr	r2, [r3, #8]
 800a306:	42aa      	cmp	r2, r5
 800a308:	d030      	beq.n	800a36c <LoRaMacCryptoHandleJoinAccept+0xdc>
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 800a30a:	f89d 0013 	ldrb.w	r0, [sp, #19]
        CryptoNvm->JoinNonce = currentJoinNonce;
 800a30e:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveMcRootKey( versionMinor, APP_KEY );
 800a310:	f7ff ff8c 	bl	800a22c <LoRaMacCryptoDeriveMcRootKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a314:	bb08      	cbnz	r0, 800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
    if( keyID != MC_ROOT_KEY )
 800a316:	f7ff fdc3 	bl	8009ea0 <LoRaMacCryptoDeriveMcKEKey.part.0>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a31a:	b9f0      	cbnz	r0, 800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
        netID = ( uint32_t )macMsg->NetID[0];
 800a31c:	7a62      	ldrb	r2, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 800a31e:	7aa3      	ldrb	r3, [r4, #10]
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 800a320:	7ae4      	ldrb	r4, [r4, #11]
 800a322:	0424      	lsls	r4, r4, #16
 800a324:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 800a328:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 800a32a:	463b      	mov	r3, r7
 800a32c:	4622      	mov	r2, r4
 800a32e:	4629      	mov	r1, r5
 800a330:	2003      	movs	r0, #3
 800a332:	f7ff fd13 	bl	8009d5c <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a336:	b980      	cbnz	r0, 800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 800a338:	463b      	mov	r3, r7
 800a33a:	4622      	mov	r2, r4
 800a33c:	4629      	mov	r1, r5
 800a33e:	2002      	movs	r0, #2
 800a340:	f7ff fd0c 	bl	8009d5c <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 800a344:	b948      	cbnz	r0, 800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 800a346:	6833      	ldr	r3, [r6, #0]
 800a348:	f89d 2013 	ldrb.w	r2, [sp, #19]
 800a34c:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 800a34e:	f04f 32ff 	mov.w	r2, #4294967295
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITAL_VALUE;
 800a352:	e9c3 2204 	strd	r2, r2, [r3, #16]
    CryptoNvm->FCntList.FCntUp = 0;
 800a356:	60d8      	str	r0, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITAL_VALUE;
 800a358:	619a      	str	r2, [r3, #24]
}
 800a35a:	b00f      	add	sp, #60	; 0x3c
 800a35c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 800a360:	200a      	movs	r0, #10
 800a362:	e7fa      	b.n	800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 800a364:	200f      	movs	r0, #15
 800a366:	e7f8      	b.n	800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_ERROR_PARSER;
 800a368:	2010      	movs	r0, #16
 800a36a:	e7f6      	b.n	800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 800a36c:	2003      	movs	r0, #3
 800a36e:	e7f4      	b.n	800a35a <LoRaMacCryptoHandleJoinAccept+0xca>
 800a370:	200010ec 	.word	0x200010ec

0800a374 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 800a374:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 800a376:	4604      	mov	r4, r0
 800a378:	2800      	cmp	r0, #0
 800a37a:	d045      	beq.n	800a408 <LoRaMacParserJoinAccept+0x94>
 800a37c:	6801      	ldr	r1, [r0, #0]
 800a37e:	2900      	cmp	r1, #0
 800a380:	d042      	beq.n	800a408 <LoRaMacParserJoinAccept+0x94>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 800a382:	f811 3b01 	ldrb.w	r3, [r1], #1
 800a386:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 800a388:	2203      	movs	r2, #3
 800a38a:	3006      	adds	r0, #6
 800a38c:	f002 fed2 	bl	800d134 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 800a390:	4620      	mov	r0, r4
 800a392:	2203      	movs	r2, #3
 800a394:	f850 1b09 	ldr.w	r1, [r0], #9
 800a398:	3104      	adds	r1, #4
 800a39a:	f002 fecb 	bl	800d134 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 800a39e:	6821      	ldr	r1, [r4, #0]
 800a3a0:	79cb      	ldrb	r3, [r1, #7]
 800a3a2:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 800a3a4:	7a0a      	ldrb	r2, [r1, #8]
 800a3a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800a3aa:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 800a3ac:	7a4a      	ldrb	r2, [r1, #9]
 800a3ae:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800a3b2:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 800a3b4:	7a8a      	ldrb	r2, [r1, #10]
 800a3b6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a3ba:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 800a3bc:	7acb      	ldrb	r3, [r1, #11]
 800a3be:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 800a3c0:	7b0b      	ldrb	r3, [r1, #12]
 800a3c2:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 800a3c4:	7923      	ldrb	r3, [r4, #4]
 800a3c6:	2b21      	cmp	r3, #33	; 0x21
 800a3c8:	d11a      	bne.n	800a400 <LoRaMacParserJoinAccept+0x8c>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 800a3ca:	2210      	movs	r2, #16
 800a3cc:	310d      	adds	r1, #13
 800a3ce:	f104 0012 	add.w	r0, r4, #18
 800a3d2:	f002 feaf 	bl	800d134 <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 800a3d6:	221d      	movs	r2, #29
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 800a3d8:	6821      	ldr	r1, [r4, #0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 800a3da:	1c50      	adds	r0, r2, #1
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 800a3dc:	5c8b      	ldrb	r3, [r1, r2]
 800a3de:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 800a3e0:	5c08      	ldrb	r0, [r1, r0]
 800a3e2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 800a3e6:	1c90      	adds	r0, r2, #2
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 800a3e8:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 800a3ea:	5c08      	ldrb	r0, [r1, r0]
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 800a3ec:	3203      	adds	r2, #3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 800a3ee:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 800a3f2:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 800a3f4:	5c8a      	ldrb	r2, [r1, r2]
 800a3f6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a3fa:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 800a3fc:	2000      	movs	r0, #0
}
 800a3fe:	bd10      	pop	{r4, pc}
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 800a400:	2b11      	cmp	r3, #17
 800a402:	dc03      	bgt.n	800a40c <LoRaMacParserJoinAccept+0x98>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 800a404:	220d      	movs	r2, #13
 800a406:	e7e7      	b.n	800a3d8 <LoRaMacParserJoinAccept+0x64>
        return LORAMAC_PARSER_ERROR_NPE;
 800a408:	2002      	movs	r0, #2
 800a40a:	e7f8      	b.n	800a3fe <LoRaMacParserJoinAccept+0x8a>
        return LORAMAC_PARSER_FAIL;
 800a40c:	2001      	movs	r0, #1
 800a40e:	e7f6      	b.n	800a3fe <LoRaMacParserJoinAccept+0x8a>

0800a410 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 800a410:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 800a412:	4604      	mov	r4, r0
 800a414:	2800      	cmp	r0, #0
 800a416:	d054      	beq.n	800a4c2 <LoRaMacParserData+0xb2>
 800a418:	6801      	ldr	r1, [r0, #0]
 800a41a:	2900      	cmp	r1, #0
 800a41c:	d051      	beq.n	800a4c2 <LoRaMacParserData+0xb2>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 800a41e:	780b      	ldrb	r3, [r1, #0]
 800a420:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 800a422:	784b      	ldrb	r3, [r1, #1]
 800a424:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 800a426:	788a      	ldrb	r2, [r1, #2]
 800a428:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800a42c:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 800a42e:	78ca      	ldrb	r2, [r1, #3]
 800a430:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800a434:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 800a436:	790a      	ldrb	r2, [r1, #4]
 800a438:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a43c:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 800a43e:	794b      	ldrb	r3, [r1, #5]
 800a440:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 800a442:	798b      	ldrb	r3, [r1, #6]
 800a444:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 800a446:	79ca      	ldrb	r2, [r1, #7]
 800a448:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

    if( macMsg->FHDR.FCtrl.Bits.FOptsLen <= 15 )
    {
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 800a44c:	7b02      	ldrb	r2, [r0, #12]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 800a44e:	81c3      	strh	r3, [r0, #14]
        memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 800a450:	f002 020f 	and.w	r2, r2, #15
 800a454:	3108      	adds	r1, #8
 800a456:	3010      	adds	r0, #16
 800a458:	f002 fe6c 	bl	800d134 <memcpy1>
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a45c:	7b23      	ldrb	r3, [r4, #12]
    {
        return LORAMAC_PARSER_FAIL;
    }

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 800a45e:	2200      	movs	r2, #0
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a460:	f003 030f 	and.w	r3, r3, #15
    macMsg->FPort = 0;
 800a464:	f884 2020 	strb.w	r2, [r4, #32]
    macMsg->FRMPayloadSize = 0;
 800a468:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 800a46c:	7922      	ldrb	r2, [r4, #4]
        bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a46e:	f103 0008 	add.w	r0, r3, #8
    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 800a472:	1a11      	subs	r1, r2, r0
 800a474:	2904      	cmp	r1, #4
 800a476:	dd0d      	ble.n	800a494 <LoRaMacParserData+0x84>
    {
        macMsg->FPort = macMsg->Buffer[bufItr++];
 800a478:	6821      	ldr	r1, [r4, #0]
 800a47a:	3309      	adds	r3, #9

        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 800a47c:	3a04      	subs	r2, #4
 800a47e:	1ad2      	subs	r2, r2, r3
        macMsg->FPort = macMsg->Buffer[bufItr++];
 800a480:	5c08      	ldrb	r0, [r1, r0]
 800a482:	f884 0020 	strb.w	r0, [r4, #32]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 800a486:	b2d2      	uxtb	r2, r2
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 800a488:	6a60      	ldr	r0, [r4, #36]	; 0x24
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 800a48a:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 800a48e:	4419      	add	r1, r3
 800a490:	f002 fe50 	bl	800d134 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 800a494:	7923      	ldrb	r3, [r4, #4]
 800a496:	6822      	ldr	r2, [r4, #0]
 800a498:	441a      	add	r2, r3
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );

    return LORAMAC_PARSER_SUCCESS;
 800a49a:	2000      	movs	r0, #0
    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 800a49c:	f812 3c04 	ldrb.w	r3, [r2, #-4]
 800a4a0:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 800a4a2:	f812 1c03 	ldrb.w	r1, [r2, #-3]
 800a4a6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800a4aa:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 800a4ac:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 800a4b0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800a4b4:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 800a4b6:	f812 2c01 	ldrb.w	r2, [r2, #-1]
 800a4ba:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800a4be:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 800a4c0:	bd10      	pop	{r4, pc}
        return LORAMAC_PARSER_ERROR_NPE;
 800a4c2:	2002      	movs	r0, #2
 800a4c4:	e7fc      	b.n	800a4c0 <LoRaMacParserData+0xb0>

0800a4c6 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 800a4c6:	b510      	push	{r4, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 800a4c8:	4604      	mov	r4, r0
 800a4ca:	b360      	cbz	r0, 800a526 <LoRaMacSerializerJoinRequest+0x60>
 800a4cc:	6803      	ldr	r3, [r0, #0]
 800a4ce:	b353      	cbz	r3, 800a526 <LoRaMacSerializerJoinRequest+0x60>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 800a4d0:	7902      	ldrb	r2, [r0, #4]
 800a4d2:	2a16      	cmp	r2, #22
 800a4d4:	d929      	bls.n	800a52a <LoRaMacSerializerJoinRequest+0x64>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 800a4d6:	7942      	ldrb	r2, [r0, #5]
 800a4d8:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 800a4da:	4601      	mov	r1, r0
 800a4dc:	2208      	movs	r2, #8
 800a4de:	f851 0b06 	ldr.w	r0, [r1], #6
 800a4e2:	3001      	adds	r0, #1
 800a4e4:	f002 fe30 	bl	800d148 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 800a4e8:	4621      	mov	r1, r4
 800a4ea:	2208      	movs	r2, #8
 800a4ec:	f851 0b0e 	ldr.w	r0, [r1], #14
 800a4f0:	3009      	adds	r0, #9
 800a4f2:	f002 fe29 	bl	800d148 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 800a4f6:	6823      	ldr	r3, [r4, #0]
 800a4f8:	8ae2      	ldrh	r2, [r4, #22]
 800a4fa:	745a      	strb	r2, [r3, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 800a4fc:	8ae3      	ldrh	r3, [r4, #22]
 800a4fe:	6822      	ldr	r2, [r4, #0]
 800a500:	0a1b      	lsrs	r3, r3, #8
 800a502:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 800a504:	6823      	ldr	r3, [r4, #0]
 800a506:	69a2      	ldr	r2, [r4, #24]
 800a508:	74da      	strb	r2, [r3, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 800a50a:	69a3      	ldr	r3, [r4, #24]
 800a50c:	6822      	ldr	r2, [r4, #0]
 800a50e:	0a1b      	lsrs	r3, r3, #8
 800a510:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 800a512:	6823      	ldr	r3, [r4, #0]
 800a514:	8b62      	ldrh	r2, [r4, #26]
 800a516:	755a      	strb	r2, [r3, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 800a518:	6823      	ldr	r3, [r4, #0]
 800a51a:	7ee2      	ldrb	r2, [r4, #27]
 800a51c:	759a      	strb	r2, [r3, #22]

    macMsg->BufSize = bufItr;
 800a51e:	2317      	movs	r3, #23
 800a520:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 800a522:	2000      	movs	r0, #0
}
 800a524:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 800a526:	2001      	movs	r0, #1
 800a528:	e7fc      	b.n	800a524 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 800a52a:	2002      	movs	r0, #2
 800a52c:	e7fa      	b.n	800a524 <LoRaMacSerializerJoinRequest+0x5e>

0800a52e <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 800a52e:	b538      	push	{r3, r4, r5, lr}
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 800a530:	4604      	mov	r4, r0
 800a532:	2800      	cmp	r0, #0
 800a534:	d063      	beq.n	800a5fe <LoRaMacSerializerData+0xd0>
 800a536:	6801      	ldr	r1, [r0, #0]
 800a538:	2900      	cmp	r1, #0
 800a53a:	d060      	beq.n	800a5fe <LoRaMacSerializerData+0xd0>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a53c:	7b03      	ldrb	r3, [r0, #12]

    if( macMsg->FRMPayloadSize > 0 )
 800a53e:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a542:	f003 030f 	and.w	r3, r3, #15
    if( macMsg->FRMPayloadSize > 0 )
 800a546:	2a00      	cmp	r2, #0
 800a548:	d157      	bne.n	800a5fa <LoRaMacSerializerData+0xcc>
    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a54a:	3308      	adds	r3, #8
    }

    computedBufSize += macMsg->FRMPayloadSize;
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;

    if( macMsg->BufSize < computedBufSize )
 800a54c:	7920      	ldrb	r0, [r4, #4]
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 800a54e:	3204      	adds	r2, #4
    if( macMsg->BufSize < computedBufSize )
 800a550:	4413      	add	r3, r2
 800a552:	4298      	cmp	r0, r3
 800a554:	d355      	bcc.n	800a602 <LoRaMacSerializerData+0xd4>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 800a556:	7963      	ldrb	r3, [r4, #5]
 800a558:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 800a55a:	6823      	ldr	r3, [r4, #0]
 800a55c:	68a2      	ldr	r2, [r4, #8]
 800a55e:	705a      	strb	r2, [r3, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 800a560:	68a3      	ldr	r3, [r4, #8]
 800a562:	6822      	ldr	r2, [r4, #0]
 800a564:	0a1b      	lsrs	r3, r3, #8
 800a566:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 800a568:	6823      	ldr	r3, [r4, #0]
 800a56a:	8962      	ldrh	r2, [r4, #10]
 800a56c:	70da      	strb	r2, [r3, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 800a56e:	6823      	ldr	r3, [r4, #0]
 800a570:	7ae2      	ldrb	r2, [r4, #11]
 800a572:	711a      	strb	r2, [r3, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 800a574:	6823      	ldr	r3, [r4, #0]
 800a576:	7b22      	ldrb	r2, [r4, #12]
 800a578:	715a      	strb	r2, [r3, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 800a57a:	6823      	ldr	r3, [r4, #0]
 800a57c:	89e2      	ldrh	r2, [r4, #14]
 800a57e:	719a      	strb	r2, [r3, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 800a580:	89e3      	ldrh	r3, [r4, #14]
 800a582:	6822      	ldr	r2, [r4, #0]
 800a584:	0a1b      	lsrs	r3, r3, #8

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 800a586:	4621      	mov	r1, r4
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 800a588:	71d3      	strb	r3, [r2, #7]
    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 800a58a:	7b22      	ldrb	r2, [r4, #12]
 800a58c:	f851 0b10 	ldr.w	r0, [r1], #16
 800a590:	f002 020f 	and.w	r2, r2, #15
 800a594:	3008      	adds	r0, #8
 800a596:	f002 fdcd 	bl	800d134 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a59a:	7b23      	ldrb	r3, [r4, #12]

    if( macMsg->FRMPayloadSize > 0 )
 800a59c:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 800a5a0:	f003 030f 	and.w	r3, r3, #15
 800a5a4:	f103 0508 	add.w	r5, r3, #8
    if( macMsg->FRMPayloadSize > 0 )
 800a5a8:	b12a      	cbz	r2, 800a5b6 <LoRaMacSerializerData+0x88>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 800a5aa:	6822      	ldr	r2, [r4, #0]
 800a5ac:	f894 1020 	ldrb.w	r1, [r4, #32]
 800a5b0:	5551      	strb	r1, [r2, r5]
 800a5b2:	f103 0509 	add.w	r5, r3, #9
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 800a5b6:	6820      	ldr	r0, [r4, #0]
 800a5b8:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 800a5bc:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800a5be:	4428      	add	r0, r5
 800a5c0:	f002 fdb8 	bl	800d134 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 800a5c4:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 800a5c8:	6822      	ldr	r2, [r4, #0]
 800a5ca:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
    bufItr = bufItr + macMsg->FRMPayloadSize;
 800a5cc:	442b      	add	r3, r5
    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 800a5ce:	54d1      	strb	r1, [r2, r3]
 800a5d0:	1c5a      	adds	r2, r3, #1
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 800a5d2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800a5d4:	6820      	ldr	r0, [r4, #0]
 800a5d6:	b292      	uxth	r2, r2
 800a5d8:	0a09      	lsrs	r1, r1, #8
 800a5da:	5481      	strb	r1, [r0, r2]
 800a5dc:	1c9a      	adds	r2, r3, #2
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 800a5de:	6821      	ldr	r1, [r4, #0]
 800a5e0:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 800a5e2:	b292      	uxth	r2, r2
 800a5e4:	5488      	strb	r0, [r1, r2]
 800a5e6:	1cda      	adds	r2, r3, #3
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 800a5e8:	6821      	ldr	r1, [r4, #0]
 800a5ea:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
 800a5ee:	b292      	uxth	r2, r2
 800a5f0:	3304      	adds	r3, #4
 800a5f2:	5488      	strb	r0, [r1, r2]

    macMsg->BufSize = bufItr;
 800a5f4:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 800a5f6:	2000      	movs	r0, #0
}
 800a5f8:	bd38      	pop	{r3, r4, r5, pc}
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 800a5fa:	3309      	adds	r3, #9
 800a5fc:	e7a6      	b.n	800a54c <LoRaMacSerializerData+0x1e>
        return LORAMAC_SERIALIZER_ERROR_NPE;
 800a5fe:	2001      	movs	r0, #1
 800a600:	e7fa      	b.n	800a5f8 <LoRaMacSerializerData+0xca>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 800a602:	2002      	movs	r0, #2
 800a604:	e7f8      	b.n	800a5f8 <LoRaMacSerializerData+0xca>

0800a606 <NvmDataMgmtEvent>:
void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags = notifyFlags;
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 800a606:	4770      	bx	lr

0800a608 <NvmDataMgmtStore>:
    LoRaMacStart( );
    return dataSize;
#else
    return 0;
#endif
}
 800a608:	2000      	movs	r0, #0
 800a60a:	4770      	bx	lr

0800a60c <NvmDataMgmtRestore>:
 800a60c:	2000      	movs	r0, #0
 800a60e:	4770      	bx	lr

0800a610 <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 800a610:	2805      	cmp	r0, #5
 800a612:	d004      	beq.n	800a61e <RegionIsActive+0xe>
 800a614:	f1a0 0308 	sub.w	r3, r0, #8
 800a618:	4258      	negs	r0, r3
 800a61a:	4158      	adcs	r0, r3
 800a61c:	4770      	bx	lr
        AS923_IS_ACTIVE( );
        AU915_IS_ACTIVE( );
        CN470_IS_ACTIVE( );
        CN779_IS_ACTIVE( );
        EU433_IS_ACTIVE( );
        EU868_IS_ACTIVE( );
 800a61e:	2001      	movs	r0, #1
        default:
        {
            return false;
        }
    }
}
 800a620:	4770      	bx	lr

0800a622 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 800a622:	4603      	mov	r3, r0
    PhyParam_t phyParam = { 0 };
    switch( region )
 800a624:	2b05      	cmp	r3, #5
{
 800a626:	b082      	sub	sp, #8
 800a628:	4608      	mov	r0, r1
    switch( region )
 800a62a:	d004      	beq.n	800a636 <RegionGetPhyParam+0x14>
 800a62c:	2b08      	cmp	r3, #8
 800a62e:	d005      	beq.n	800a63c <RegionGetPhyParam+0x1a>
        default:
        {
            return phyParam;
        }
    }
}
 800a630:	2000      	movs	r0, #0
 800a632:	b002      	add	sp, #8
 800a634:	4770      	bx	lr
 800a636:	b002      	add	sp, #8
        EU868_GET_PHY_PARAM( );
 800a638:	f000 bcf6 	b.w	800b028 <RegionEU868GetPhyParam>
}
 800a63c:	b002      	add	sp, #8
        US915_GET_PHY_PARAM( );
 800a63e:	f001 ba41 	b.w	800bac4 <RegionUS915GetPhyParam>

0800a642 <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 800a642:	4603      	mov	r3, r0
    switch( region )
 800a644:	2b05      	cmp	r3, #5
{
 800a646:	4608      	mov	r0, r1
    switch( region )
 800a648:	d002      	beq.n	800a650 <RegionSetBandTxDone+0xe>
 800a64a:	2b08      	cmp	r3, #8
 800a64c:	d002      	beq.n	800a654 <RegionSetBandTxDone+0x12>
 800a64e:	4770      	bx	lr
        AS923_SET_BAND_TX_DONE( );
        AU915_SET_BAND_TX_DONE( );
        CN470_SET_BAND_TX_DONE( );
        CN779_SET_BAND_TX_DONE( );
        EU433_SET_BAND_TX_DONE( );
        EU868_SET_BAND_TX_DONE( );
 800a650:	f000 bd88 	b.w	800b164 <RegionEU868SetBandTxDone>
        KR920_SET_BAND_TX_DONE( );
        IN865_SET_BAND_TX_DONE( );
        US915_SET_BAND_TX_DONE( );
 800a654:	f001 bade 	b.w	800bc14 <RegionUS915SetBandTxDone>

0800a658 <RegionInitDefaults>:
        }
    }
}

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 800a658:	4603      	mov	r3, r0
    switch( region )
 800a65a:	2b05      	cmp	r3, #5
{
 800a65c:	4608      	mov	r0, r1
    switch( region )
 800a65e:	d002      	beq.n	800a666 <RegionInitDefaults+0xe>
 800a660:	2b08      	cmp	r3, #8
 800a662:	d002      	beq.n	800a66a <RegionInitDefaults+0x12>
 800a664:	4770      	bx	lr
        AS923_INIT_DEFAULTS( );
        AU915_INIT_DEFAULTS( );
        CN470_INIT_DEFAULTS( );
        CN779_INIT_DEFAULTS( );
        EU433_INIT_DEFAULTS( );
        EU868_INIT_DEFAULTS( );
 800a666:	f000 bd99 	b.w	800b19c <RegionEU868InitDefaults>
        KR920_INIT_DEFAULTS( );
        IN865_INIT_DEFAULTS( );
        US915_INIT_DEFAULTS( );
 800a66a:	f001 baef 	b.w	800bc4c <RegionUS915InitDefaults>

0800a66e <RegionVerify>:
        }
    }
}

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 800a66e:	4603      	mov	r3, r0
    switch( region )
 800a670:	2b05      	cmp	r3, #5
{
 800a672:	4608      	mov	r0, r1
 800a674:	4611      	mov	r1, r2
    switch( region )
 800a676:	d003      	beq.n	800a680 <RegionVerify+0x12>
 800a678:	2b08      	cmp	r3, #8
 800a67a:	d003      	beq.n	800a684 <RegionVerify+0x16>
        default:
        {
            return false;
        }
    }
}
 800a67c:	2000      	movs	r0, #0
 800a67e:	4770      	bx	lr
        EU868_VERIFY( );
 800a680:	f000 bdf2 	b.w	800b268 <RegionEU868Verify>
        US915_VERIFY( );
 800a684:	f001 bb6a 	b.w	800bd5c <RegionUS915Verify>

0800a688 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 800a688:	4603      	mov	r3, r0
    switch( region )
 800a68a:	2b05      	cmp	r3, #5
{
 800a68c:	4608      	mov	r0, r1
    switch( region )
 800a68e:	d002      	beq.n	800a696 <RegionApplyCFList+0xe>
 800a690:	2b08      	cmp	r3, #8
 800a692:	d002      	beq.n	800a69a <RegionApplyCFList+0x12>
 800a694:	4770      	bx	lr
        AS923_APPLY_CF_LIST( );
        AU915_APPLY_CF_LIST( );
        CN470_APPLY_CF_LIST( );
        CN779_APPLY_CF_LIST( );
        EU433_APPLY_CF_LIST( );
        EU868_APPLY_CF_LIST( );
 800a696:	f001 b949 	b.w	800b92c <RegionEU868ApplyCFList>
        KR920_APPLY_CF_LIST( );
        IN865_APPLY_CF_LIST( );
        US915_APPLY_CF_LIST( );
 800a69a:	f001 bb81 	b.w	800bda0 <RegionUS915ApplyCFList>

0800a69e <RegionChanMaskSet>:
        }
    }
}

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 800a69e:	4603      	mov	r3, r0
    switch( region )
 800a6a0:	2b05      	cmp	r3, #5
{
 800a6a2:	4608      	mov	r0, r1
    switch( region )
 800a6a4:	d003      	beq.n	800a6ae <RegionChanMaskSet+0x10>
 800a6a6:	2b08      	cmp	r3, #8
 800a6a8:	d003      	beq.n	800a6b2 <RegionChanMaskSet+0x14>
        default:
        {
            return false;
        }
    }
}
 800a6aa:	2000      	movs	r0, #0
 800a6ac:	4770      	bx	lr
        EU868_CHAN_MASK_SET( );
 800a6ae:	f000 be03 	b.w	800b2b8 <RegionEU868ChanMaskSet>
        US915_CHAN_MASK_SET( );
 800a6b2:	f001 bba3 	b.w	800bdfc <RegionUS915ChanMaskSet>

0800a6b6 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 800a6b6:	b410      	push	{r4}
 800a6b8:	4604      	mov	r4, r0
    switch( region )
 800a6ba:	2c05      	cmp	r4, #5
{
 800a6bc:	4608      	mov	r0, r1
 800a6be:	4611      	mov	r1, r2
 800a6c0:	461a      	mov	r2, r3
 800a6c2:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 800a6c4:	d003      	beq.n	800a6ce <RegionComputeRxWindowParameters+0x18>
 800a6c6:	2c08      	cmp	r4, #8
 800a6c8:	d004      	beq.n	800a6d4 <RegionComputeRxWindowParameters+0x1e>
        default:
        {
            break;
        }
    }
}
 800a6ca:	bc10      	pop	{r4}
 800a6cc:	4770      	bx	lr
 800a6ce:	bc10      	pop	{r4}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 800a6d0:	f000 be10 	b.w	800b2f4 <RegionEU868ComputeRxWindowParameters>
}
 800a6d4:	bc10      	pop	{r4}
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 800a6d6:	f001 bbcd 	b.w	800be74 <RegionUS915ComputeRxWindowParameters>

0800a6da <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 800a6da:	4603      	mov	r3, r0
    switch( region )
 800a6dc:	2b05      	cmp	r3, #5
{
 800a6de:	4608      	mov	r0, r1
 800a6e0:	4611      	mov	r1, r2
    switch( region )
 800a6e2:	d003      	beq.n	800a6ec <RegionRxConfig+0x12>
 800a6e4:	2b08      	cmp	r3, #8
 800a6e6:	d003      	beq.n	800a6f0 <RegionRxConfig+0x16>
        default:
        {
            return false;
        }
    }
}
 800a6e8:	2000      	movs	r0, #0
 800a6ea:	4770      	bx	lr
        EU868_RX_CONFIG( );
 800a6ec:	f000 be34 	b.w	800b358 <RegionEU868RxConfig>
        US915_RX_CONFIG( );
 800a6f0:	f001 bbec 	b.w	800becc <RegionUS915RxConfig>

0800a6f4 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 800a6f4:	b410      	push	{r4}
 800a6f6:	4604      	mov	r4, r0
    switch( region )
 800a6f8:	2c05      	cmp	r4, #5
{
 800a6fa:	4608      	mov	r0, r1
 800a6fc:	4611      	mov	r1, r2
 800a6fe:	461a      	mov	r2, r3
    switch( region )
 800a700:	d004      	beq.n	800a70c <RegionTxConfig+0x18>
 800a702:	2c08      	cmp	r4, #8
 800a704:	d005      	beq.n	800a712 <RegionTxConfig+0x1e>
        default:
        {
            return false;
        }
    }
}
 800a706:	2000      	movs	r0, #0
 800a708:	bc10      	pop	{r4}
 800a70a:	4770      	bx	lr
 800a70c:	bc10      	pop	{r4}
        EU868_TX_CONFIG( );
 800a70e:	f000 be9b 	b.w	800b448 <RegionEU868TxConfig>
}
 800a712:	bc10      	pop	{r4}
        US915_TX_CONFIG( );
 800a714:	f001 bc30 	b.w	800bf78 <RegionUS915TxConfig>

0800a718 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 800a718:	b430      	push	{r4, r5}
 800a71a:	4604      	mov	r4, r0
    switch( region )
 800a71c:	2c05      	cmp	r4, #5
{
 800a71e:	4608      	mov	r0, r1
 800a720:	4611      	mov	r1, r2
 800a722:	461a      	mov	r2, r3
 800a724:	e9dd 3502 	ldrd	r3, r5, [sp, #8]
    switch( region )
 800a728:	d004      	beq.n	800a734 <RegionLinkAdrReq+0x1c>
 800a72a:	2c08      	cmp	r4, #8
 800a72c:	d006      	beq.n	800a73c <RegionLinkAdrReq+0x24>
        default:
        {
            return 0;
        }
    }
}
 800a72e:	2000      	movs	r0, #0
 800a730:	bc30      	pop	{r4, r5}
 800a732:	4770      	bx	lr
        EU868_LINK_ADR_REQ( );
 800a734:	9502      	str	r5, [sp, #8]
}
 800a736:	bc30      	pop	{r4, r5}
        EU868_LINK_ADR_REQ( );
 800a738:	f000 bf0e 	b.w	800b558 <RegionEU868LinkAdrReq>
        US915_LINK_ADR_REQ( );
 800a73c:	9502      	str	r5, [sp, #8]
}
 800a73e:	bc30      	pop	{r4, r5}
        US915_LINK_ADR_REQ( );
 800a740:	f001 bca6 	b.w	800c090 <RegionUS915LinkAdrReq>

0800a744 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 800a744:	4603      	mov	r3, r0
    switch( region )
 800a746:	2b05      	cmp	r3, #5
{
 800a748:	4608      	mov	r0, r1
    switch( region )
 800a74a:	d003      	beq.n	800a754 <RegionRxParamSetupReq+0x10>
 800a74c:	2b08      	cmp	r3, #8
 800a74e:	d003      	beq.n	800a758 <RegionRxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 800a750:	2000      	movs	r0, #0
 800a752:	4770      	bx	lr
        EU868_RX_PARAM_SETUP_REQ( );
 800a754:	f000 bfae 	b.w	800b6b4 <RegionEU868RxParamSetupReq>
        US915_RX_PARAM_SETUP_REQ( );
 800a758:	f001 bdb2 	b.w	800c2c0 <RegionUS915RxParamSetupReq>

0800a75c <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 800a75c:	4603      	mov	r3, r0
    switch( region )
 800a75e:	2b05      	cmp	r3, #5
{
 800a760:	4608      	mov	r0, r1
    switch( region )
 800a762:	d003      	beq.n	800a76c <RegionNewChannelReq+0x10>
 800a764:	2b08      	cmp	r3, #8
 800a766:	d003      	beq.n	800a770 <RegionNewChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 800a768:	2000      	movs	r0, #0
 800a76a:	4770      	bx	lr
        EU868_NEW_CHANNEL_REQ( );
 800a76c:	f001 b91c 	b.w	800b9a8 <RegionEU868NewChannelReq>
        US915_NEW_CHANNEL_REQ( );
 800a770:	f001 bdd2 	b.w	800c318 <RegionUS915NewChannelReq>

0800a774 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 800a774:	4603      	mov	r3, r0
    switch( region )
 800a776:	2b05      	cmp	r3, #5
{
 800a778:	4608      	mov	r0, r1
    switch( region )
 800a77a:	d003      	beq.n	800a784 <RegionTxParamSetupReq+0x10>
 800a77c:	2b08      	cmp	r3, #8
 800a77e:	d003      	beq.n	800a788 <RegionTxParamSetupReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 800a780:	2000      	movs	r0, #0
 800a782:	4770      	bx	lr
        EU868_TX_PARAM_SETUP_REQ( );
 800a784:	f000 bfb9 	b.w	800b6fa <RegionEU868TxParamSetupReq>
        US915_TX_PARAM_SETUP_REQ( );
 800a788:	f001 bdc9 	b.w	800c31e <RegionUS915TxParamSetupReq>

0800a78c <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 800a78c:	4603      	mov	r3, r0
    switch( region )
 800a78e:	2b05      	cmp	r3, #5
{
 800a790:	4608      	mov	r0, r1
    switch( region )
 800a792:	d003      	beq.n	800a79c <RegionDlChannelReq+0x10>
 800a794:	2b08      	cmp	r3, #8
 800a796:	d003      	beq.n	800a7a0 <RegionDlChannelReq+0x14>
        default:
        {
            return 0;
        }
    }
}
 800a798:	2000      	movs	r0, #0
 800a79a:	4770      	bx	lr
        EU868_DL_CHANNEL_REQ( );
 800a79c:	f000 bfb0 	b.w	800b700 <RegionEU868DlChannelReq>
        US915_DL_CHANNEL_REQ( );
 800a7a0:	f001 bdc0 	b.w	800c324 <RegionUS915DlChannelReq>

0800a7a4 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 800a7a4:	4603      	mov	r3, r0
    switch( region )
 800a7a6:	2b05      	cmp	r3, #5
{
 800a7a8:	4608      	mov	r0, r1
 800a7aa:	4611      	mov	r1, r2
    switch( region )
 800a7ac:	d003      	beq.n	800a7b6 <RegionAlternateDr+0x12>
 800a7ae:	2b08      	cmp	r3, #8
 800a7b0:	d003      	beq.n	800a7ba <RegionAlternateDr+0x16>
        default:
        {
            return 0;
        }
    }
}
 800a7b2:	2000      	movs	r0, #0
 800a7b4:	4770      	bx	lr
        EU868_ALTERNATE_DR( );
 800a7b6:	f000 bfc7 	b.w	800b748 <RegionEU868AlternateDr>
        US915_ALTERNATE_DR( );
 800a7ba:	f001 bdb7 	b.w	800c32c <RegionUS915AlternateDr>

0800a7be <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 800a7be:	b410      	push	{r4}
 800a7c0:	4604      	mov	r4, r0
    switch( region )
 800a7c2:	2c05      	cmp	r4, #5
{
 800a7c4:	4608      	mov	r0, r1
 800a7c6:	4611      	mov	r1, r2
 800a7c8:	461a      	mov	r2, r3
 800a7ca:	9b01      	ldr	r3, [sp, #4]
    switch( region )
 800a7cc:	d004      	beq.n	800a7d8 <RegionNextChannel+0x1a>
 800a7ce:	2c08      	cmp	r4, #8
 800a7d0:	d005      	beq.n	800a7de <RegionNextChannel+0x20>
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 800a7d2:	2009      	movs	r0, #9
 800a7d4:	bc10      	pop	{r4}
 800a7d6:	4770      	bx	lr
 800a7d8:	bc10      	pop	{r4}
        EU868_NEXT_CHANNEL( );
 800a7da:	f000 bfb7 	b.w	800b74c <RegionEU868NextChannel>
}
 800a7de:	bc10      	pop	{r4}
        US915_NEXT_CHANNEL( );
 800a7e0:	f001 bdbc 	b.w	800c35c <RegionUS915NextChannel>

0800a7e4 <RegionSetContinuousWave>:
        }
    }
}

void RegionSetContinuousWave( LoRaMacRegion_t region, ContinuousWaveParams_t* continuousWave )
{
 800a7e4:	4603      	mov	r3, r0
    switch( region )
 800a7e6:	2b05      	cmp	r3, #5
{
 800a7e8:	4608      	mov	r0, r1
    switch( region )
 800a7ea:	d002      	beq.n	800a7f2 <RegionSetContinuousWave+0xe>
 800a7ec:	2b08      	cmp	r3, #8
 800a7ee:	d002      	beq.n	800a7f6 <RegionSetContinuousWave+0x12>
 800a7f0:	4770      	bx	lr
        AS923_SET_CONTINUOUS_WAVE( );
        AU915_SET_CONTINUOUS_WAVE( );
        CN470_SET_CONTINUOUS_WAVE( );
        CN779_SET_CONTINUOUS_WAVE( );
        EU433_SET_CONTINUOUS_WAVE( );
        EU868_SET_CONTINUOUS_WAVE( );
 800a7f2:	f001 b8f9 	b.w	800b9e8 <RegionEU868SetContinuousWave>
        KR920_SET_CONTINUOUS_WAVE( );
        IN865_SET_CONTINUOUS_WAVE( );
        US915_SET_CONTINUOUS_WAVE( );
 800a7f6:	f001 be53 	b.w	800c4a0 <RegionUS915SetContinuousWave>

0800a7fa <RegionApplyDrOffset>:
        }
    }
}

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 800a7fa:	b410      	push	{r4}
 800a7fc:	4604      	mov	r4, r0
    switch( region )
 800a7fe:	2c05      	cmp	r4, #5
{
 800a800:	4608      	mov	r0, r1
 800a802:	4611      	mov	r1, r2
 800a804:	461a      	mov	r2, r3
    switch( region )
 800a806:	d004      	beq.n	800a812 <RegionApplyDrOffset+0x18>
 800a808:	2c08      	cmp	r4, #8
 800a80a:	d005      	beq.n	800a818 <RegionApplyDrOffset+0x1e>
        default:
        {
            return dr;
        }
    }
}
 800a80c:	b2c8      	uxtb	r0, r1
 800a80e:	bc10      	pop	{r4}
 800a810:	4770      	bx	lr
 800a812:	bc10      	pop	{r4}
        EU868_APPLY_DR_OFFSET( );
 800a814:	f001 b912 	b.w	800ba3c <RegionEU868ApplyDrOffset>
}
 800a818:	bc10      	pop	{r4}
        US915_APPLY_DR_OFFSET( );
 800a81a:	f001 be8b 	b.w	800c534 <RegionUS915ApplyDrOffset>
	...

0800a820 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 800a820:	4800      	ldr	r0, [pc, #0]	; (800a824 <RegionGetVersion+0x4>)
 800a822:	4770      	bx	lr
 800a824:	01000300 	.word	0x01000300

0800a828 <RegionBaseUSComputeNext125kHzJoinChannel>:
    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 800a828:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 800a82c:	2300      	movs	r3, #0
 800a82e:	e9cd 3300 	strd	r3, r3, [sp]
{
 800a832:	460e      	mov	r6, r1
 800a834:	4690      	mov	r8, r2
    uint8_t availableChannels = 0;
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 800a836:	4607      	mov	r7, r0
 800a838:	b918      	cbnz	r0, 800a842 <RegionBaseUSComputeNext125kHzJoinChannel+0x1a>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800a83a:	2003      	movs	r0, #3
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
}
 800a83c:	b002      	add	sp, #8
 800a83e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 800a842:	2900      	cmp	r1, #0
 800a844:	d0f9      	beq.n	800a83a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
 800a846:	2a00      	cmp	r2, #0
 800a848:	d0f7      	beq.n	800a83a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
    startIndex = *groupsCurrentIndex;
 800a84a:	780c      	ldrb	r4, [r1, #0]
        if( ( startIndex % 2 ) == 0 )
 800a84c:	0863      	lsrs	r3, r4, #1
 800a84e:	07e0      	lsls	r0, r4, #31
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 800a850:	f837 1013 	ldrh.w	r1, [r7, r3, lsl #1]
{
 800a854:	f04f 0300 	mov.w	r3, #0
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 800a858:	bf54      	ite	pl
 800a85a:	b2c9      	uxtbpl	r1, r1
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 800a85c:	0a09      	lsrmi	r1, r1, #8
    *availableChannels = 0;
 800a85e:	461d      	mov	r5, r3
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 800a860:	fa41 f203 	asr.w	r2, r1, r3
 800a864:	07d2      	lsls	r2, r2, #31
 800a866:	b2d8      	uxtb	r0, r3
 800a868:	d505      	bpl.n	800a876 <RegionBaseUSComputeNext125kHzJoinChannel+0x4e>
            findAvailableChannelsIndex[*availableChannels] = i;
 800a86a:	aa02      	add	r2, sp, #8
 800a86c:	442a      	add	r2, r5
            ( *availableChannels )++;
 800a86e:	3501      	adds	r5, #1
            findAvailableChannelsIndex[*availableChannels] = i;
 800a870:	f802 0c08 	strb.w	r0, [r2, #-8]
            ( *availableChannels )++;
 800a874:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < 8; i++ )
 800a876:	3301      	adds	r3, #1
 800a878:	2b08      	cmp	r3, #8
 800a87a:	d1f1      	bne.n	800a860 <RegionBaseUSComputeNext125kHzJoinChannel+0x38>
        if ( availableChannels > 0 )
 800a87c:	b15d      	cbz	r5, 800a896 <RegionBaseUSComputeNext125kHzJoinChannel+0x6e>
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 800a87e:	1e69      	subs	r1, r5, #1
 800a880:	2000      	movs	r0, #0
 800a882:	f002 fc3b 	bl	800d0fc <randr>
 800a886:	ab02      	add	r3, sp, #8
 800a888:	4418      	add	r0, r3
 800a88a:	f810 3c08 	ldrb.w	r3, [r0, #-8]
 800a88e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800a892:	f888 3000 	strb.w	r3, [r8]
        startIndex++;
 800a896:	3401      	adds	r4, #1
 800a898:	b2e4      	uxtb	r4, r4
            startIndex = 0;
 800a89a:	2c08      	cmp	r4, #8
 800a89c:	bf28      	it	cs
 800a89e:	2400      	movcs	r4, #0
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 800a8a0:	b91d      	cbnz	r5, 800a8aa <RegionBaseUSComputeNext125kHzJoinChannel+0x82>
 800a8a2:	7833      	ldrb	r3, [r6, #0]
 800a8a4:	42a3      	cmp	r3, r4
 800a8a6:	d1d1      	bne.n	800a84c <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
 800a8a8:	e7c7      	b.n	800a83a <RegionBaseUSComputeNext125kHzJoinChannel+0x12>
        *groupsCurrentIndex = startIndex;
 800a8aa:	7034      	strb	r4, [r6, #0]
        return LORAMAC_STATUS_OK;
 800a8ac:	2000      	movs	r0, #0
 800a8ae:	e7c5      	b.n	800a83c <RegionBaseUSComputeNext125kHzJoinChannel+0x14>

0800a8b0 <RegionBaseUSCalcDownlinkFrequency>:
uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
}
 800a8b0:	fb02 1000 	mla	r0, r2, r0, r1
 800a8b4:	4770      	bx	lr

0800a8b6 <RegionCommonChanVerifyDr>:
    }
    return nbActiveBits;
}

bool RegionCommonChanVerifyDr( uint8_t nbChannels, uint16_t* channelsMask, int8_t dr, int8_t minDr, int8_t maxDr, ChannelParams_t* channels )
{
 800a8b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 800a8ba:	429a      	cmp	r2, r3
{
 800a8bc:	9f07      	ldr	r7, [sp, #28]
    if( ( value >= min ) && ( value <= max ) )
 800a8be:	db03      	blt.n	800a8c8 <RegionCommonChanVerifyDr+0x12>
 800a8c0:	f99d 3018 	ldrsb.w	r3, [sp, #24]
 800a8c4:	429a      	cmp	r2, r3
 800a8c6:	dd24      	ble.n	800a912 <RegionCommonChanVerifyDr+0x5c>
        return false;
 800a8c8:	2000      	movs	r0, #0
}
 800a8ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 800a8ce:	f831 8014 	ldrh.w	r8, [r1, r4, lsl #1]
 800a8d2:	fb1e 7303 	smlabb	r3, lr, r3, r7
 800a8d6:	2500      	movs	r5, #0
 800a8d8:	fa48 f605 	asr.w	r6, r8, r5
 800a8dc:	07f6      	lsls	r6, r6, #31
 800a8de:	d50e      	bpl.n	800a8fe <RegionCommonChanVerifyDr+0x48>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 800a8e0:	fb0e 3605 	mla	r6, lr, r5, r3
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 800a8e4:	f896 c008 	ldrb.w	ip, [r6, #8]
 800a8e8:	f34c 1603 	sbfx	r6, ip, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 800a8ec:	f00c 0c0f 	and.w	ip, ip, #15
 800a8f0:	4562      	cmp	r2, ip
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 800a8f2:	b276      	sxtb	r6, r6
    if( ( value >= min ) && ( value <= max ) )
 800a8f4:	db03      	blt.n	800a8fe <RegionCommonChanVerifyDr+0x48>
 800a8f6:	f006 060f 	and.w	r6, r6, #15
 800a8fa:	42b2      	cmp	r2, r6
 800a8fc:	dd0d      	ble.n	800a91a <RegionCommonChanVerifyDr+0x64>
        for( uint8_t j = 0; j < 16; j++ )
 800a8fe:	3501      	adds	r5, #1
 800a900:	2d10      	cmp	r5, #16
 800a902:	d1e9      	bne.n	800a8d8 <RegionCommonChanVerifyDr+0x22>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 800a904:	3401      	adds	r4, #1
 800a906:	b2e4      	uxtb	r4, r4
 800a908:	0123      	lsls	r3, r4, #4
 800a90a:	b2db      	uxtb	r3, r3
 800a90c:	4298      	cmp	r0, r3
 800a90e:	d8de      	bhi.n	800a8ce <RegionCommonChanVerifyDr+0x18>
 800a910:	e7da      	b.n	800a8c8 <RegionCommonChanVerifyDr+0x12>
 800a912:	2400      	movs	r4, #0
 800a914:	f04f 0e0c 	mov.w	lr, #12
 800a918:	e7f6      	b.n	800a908 <RegionCommonChanVerifyDr+0x52>
                    return true;
 800a91a:	2001      	movs	r0, #1
 800a91c:	e7d5      	b.n	800a8ca <RegionCommonChanVerifyDr+0x14>

0800a91e <RegionCommonValueInRange>:
    if( ( value >= min ) && ( value <= max ) )
 800a91e:	4288      	cmp	r0, r1
 800a920:	db04      	blt.n	800a92c <RegionCommonValueInRange+0xe>
    {
        return 1;
 800a922:	4290      	cmp	r0, r2
 800a924:	bfcc      	ite	gt
 800a926:	2000      	movgt	r0, #0
 800a928:	2001      	movle	r0, #1
 800a92a:	4770      	bx	lr
    }
    return 0;
 800a92c:	2000      	movs	r0, #0
}
 800a92e:	4770      	bx	lr

0800a930 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 800a930:	b510      	push	{r4, lr}
    uint8_t index = id / 16;

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 800a932:	0914      	lsrs	r4, r2, #4
 800a934:	ebb4 1f11 	cmp.w	r4, r1, lsr #4
{
 800a938:	4603      	mov	r3, r0
    uint8_t index = id / 16;
 800a93a:	ea4f 1011 	mov.w	r0, r1, lsr #4
    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 800a93e:	d30e      	bcc.n	800a95e <RegionCommonChanDisable+0x2e>
 800a940:	4291      	cmp	r1, r2
 800a942:	d20c      	bcs.n	800a95e <RegionCommonChanDisable+0x2e>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 800a944:	b202      	sxth	r2, r0
 800a946:	f001 010f 	and.w	r1, r1, #15
 800a94a:	f833 4012 	ldrh.w	r4, [r3, r2, lsl #1]
 800a94e:	2001      	movs	r0, #1
 800a950:	fa00 f101 	lsl.w	r1, r0, r1
 800a954:	ea24 0101 	bic.w	r1, r4, r1
 800a958:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]

    return true;
}
 800a95c:	bd10      	pop	{r4, pc}
        return false;
 800a95e:	2000      	movs	r0, #0
 800a960:	e7fc      	b.n	800a95c <RegionCommonChanDisable+0x2c>

0800a962 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 800a962:	b5f0      	push	{r4, r5, r6, r7, lr}
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 800a964:	b128      	cbz	r0, 800a972 <RegionCommonCountChannels+0x10>
 800a966:	eb00 0541 	add.w	r5, r0, r1, lsl #1
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 800a96a:	2601      	movs	r6, #1
    uint8_t nbChannels = 0;
 800a96c:	2000      	movs	r0, #0
    {
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
 800a96e:	4291      	cmp	r1, r2
 800a970:	d300      	bcc.n	800a974 <RegionCommonCountChannels+0x12>
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
    }

    return nbChannels;
}
 800a972:	bdf0      	pop	{r4, r5, r6, r7, pc}
        nbChannels += CountChannels( channelsMask[i], 16 );
 800a974:	2400      	movs	r4, #0
 800a976:	f835 7b02 	ldrh.w	r7, [r5], #2
    uint8_t nbActiveBits = 0;
 800a97a:	4623      	mov	r3, r4
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 800a97c:	fa06 fc04 	lsl.w	ip, r6, r4
 800a980:	ea3c 0c07 	bics.w	ip, ip, r7
            nbActiveBits++;
 800a984:	bf08      	it	eq
 800a986:	3301      	addeq	r3, #1
 800a988:	f104 0401 	add.w	r4, r4, #1
 800a98c:	bf08      	it	eq
 800a98e:	b2db      	uxtbeq	r3, r3
    for( uint8_t j = 0; j < nbBits; j++ )
 800a990:	2c10      	cmp	r4, #16
 800a992:	d1f3      	bne.n	800a97c <RegionCommonCountChannels+0x1a>
        nbChannels += CountChannels( channelsMask[i], 16 );
 800a994:	4418      	add	r0, r3
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 800a996:	3101      	adds	r1, #1
        nbChannels += CountChannels( channelsMask[i], 16 );
 800a998:	b2c0      	uxtb	r0, r0
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 800a99a:	b2c9      	uxtb	r1, r1
 800a99c:	e7e7      	b.n	800a96e <RegionCommonCountChannels+0xc>

0800a99e <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 800a99e:	b510      	push	{r4, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 800a9a0:	b100      	cbz	r0, 800a9a4 <RegionCommonChanMaskCopy+0x6>
 800a9a2:	b949      	cbnz	r1, 800a9b8 <RegionCommonChanMaskCopy+0x1a>
        for( uint8_t i = 0; i < len; i++ )
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
        }
    }
}
 800a9a4:	bd10      	pop	{r4, pc}
            channelsMaskDest[i] = channelsMaskSrc[i];
 800a9a6:	f831 4013 	ldrh.w	r4, [r1, r3, lsl #1]
 800a9aa:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
        for( uint8_t i = 0; i < len; i++ )
 800a9ae:	3301      	adds	r3, #1
 800a9b0:	b2dc      	uxtb	r4, r3
 800a9b2:	42a2      	cmp	r2, r4
 800a9b4:	d8f7      	bhi.n	800a9a6 <RegionCommonChanMaskCopy+0x8>
 800a9b6:	e7f5      	b.n	800a9a4 <RegionCommonChanMaskCopy+0x6>
 800a9b8:	2300      	movs	r3, #0
 800a9ba:	e7f9      	b.n	800a9b0 <RegionCommonChanMaskCopy+0x12>

0800a9bc <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 800a9bc:	b082      	sub	sp, #8
 800a9be:	b530      	push	{r4, r5, lr}
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 800a9c0:	8804      	ldrh	r4, [r0, #0]
{
 800a9c2:	9304      	str	r3, [sp, #16]
    if( joined == false )
 800a9c4:	b972      	cbnz	r2, 800a9e4 <RegionCommonSetBandTxDone+0x28>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 800a9c6:	f5b3 6f61 	cmp.w	r3, #3600	; 0xe10
 800a9ca:	d319      	bcc.n	800aa00 <RegionCommonSetBandTxDone+0x44>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 800a9cc:	f649 25af 	movw	r5, #39599	; 0x9aaf
 800a9d0:	f242 7210 	movw	r2, #10000	; 0x2710
 800a9d4:	42ab      	cmp	r3, r5
 800a9d6:	bf8c      	ite	hi
 800a9d8:	4613      	movhi	r3, r2
 800a9da:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 800a9de:	429c      	cmp	r4, r3
 800a9e0:	bf38      	it	cc
 800a9e2:	461c      	movcc	r4, r3

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 800a9e4:	2c01      	cmp	r4, #1
 800a9e6:	bf38      	it	cc
 800a9e8:	2401      	movcc	r4, #1
 800a9ea:	4361      	muls	r1, r4
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 800a9ec:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 800a9f0:	68c3      	ldr	r3, [r0, #12]
 800a9f2:	428b      	cmp	r3, r1
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 800a9f4:	bf8c      	ite	hi
 800a9f6:	1a59      	subhi	r1, r3, r1
        band->TimeCredits = 0;
 800a9f8:	2100      	movls	r1, #0
 800a9fa:	60c1      	str	r1, [r0, #12]
}
 800a9fc:	b002      	add	sp, #8
 800a9fe:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 800aa00:	2364      	movs	r3, #100	; 0x64
 800aa02:	e7ec      	b.n	800a9de <RegionCommonSetBandTxDone+0x22>

0800aa04 <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 800aa04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aa08:	b091      	sub	sp, #68	; 0x44
 800aa0a:	4615      	mov	r5, r2
 800aa0c:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
 800aa10:	9305      	str	r3, [sp, #20]
 800aa12:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
 800aa16:	9309      	str	r3, [sp, #36]	; 0x24
 800aa18:	460c      	mov	r4, r1
 800aa1a:	4606      	mov	r6, r0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 800aa1c:	f004 fd6c 	bl	800f4f8 <UTIL_TIMER_GetCurrentTime>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 800aa20:	4b68      	ldr	r3, [pc, #416]	; (800abc4 <RegionCommonUpdateBandTimeOff+0x1c0>)
 800aa22:	f8df b1b8 	ldr.w	fp, [pc, #440]	; 800abdc <RegionCommonUpdateBandTimeOff+0x1d8>
    TimerTime_t currentTime = TimerGetCurrentTime( );
 800aa26:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 800aa28:	f5a8 32f6 	sub.w	r2, r8, #125952	; 0x1ec00
 800aa2c:	3a30      	subs	r2, #48	; 0x30
 800aa2e:	fbb2 f2f3 	udiv	r2, r2, r3
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 800aa32:	4353      	muls	r3, r2
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 800aa34:	f503 32f6 	add.w	r2, r3, #125952	; 0x1ec00
 800aa38:	3230      	adds	r2, #48	; 0x30
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 800aa3a:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
 800aa3e:	f503 73c0 	add.w	r3, r3, #384	; 0x180
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 800aa42:	9204      	str	r2, [sp, #16]
 800aa44:	2218      	movs	r2, #24
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 800aa46:	9303      	str	r3, [sp, #12]
 800aa48:	fb12 4305 	smlabb	r3, r2, r5, r4
 800aa4c:	9307      	str	r3, [sp, #28]
    uint8_t validBands = 0;
 800aa4e:	2500      	movs	r5, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 800aa50:	f04f 3aff 	mov.w	sl, #4294967295
    for( uint8_t i = 0; i < nbBands; i++ )
 800aa54:	9b07      	ldr	r3, [sp, #28]
 800aa56:	42a3      	cmp	r3, r4
 800aa58:	d107      	bne.n	800aa6a <RegionCommonUpdateBandTimeOff+0x66>

    if( validBands == 0 )
    {
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
 800aa5a:	2d00      	cmp	r5, #0
    }
    return minTimeToWait;
}
 800aa5c:	bf14      	ite	ne
 800aa5e:	4650      	movne	r0, sl
 800aa60:	f04f 30ff 	moveq.w	r0, #4294967295
 800aa64:	b011      	add	sp, #68	; 0x44
 800aa66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 800aa6a:	f9bd 3070 	ldrsh.w	r3, [sp, #112]	; 0x70
 800aa6e:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 800aa72:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800aa74:	f8cd 806c 	str.w	r8, [sp, #108]	; 0x6c
 800aa78:	4640      	mov	r0, r8
 800aa7a:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 800aa7e:	f004 fccd 	bl	800f41c <SysTimeToMs>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 800aa82:	f8b4 9000 	ldrh.w	r9, [r4]
    if( joined == false )
 800aa86:	b96e      	cbnz	r6, 800aaa4 <RegionCommonUpdateBandTimeOff+0xa0>
        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 800aa88:	f5b8 6f61 	cmp.w	r8, #3600	; 0xe10
 800aa8c:	d35b      	bcc.n	800ab46 <RegionCommonUpdateBandTimeOff+0x142>
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 800aa8e:	f649 22af 	movw	r2, #39599	; 0x9aaf
 800aa92:	f242 7310 	movw	r3, #10000	; 0x2710
 800aa96:	4590      	cmp	r8, r2
 800aa98:	bf98      	it	ls
 800aa9a:	f44f 737a 	movls.w	r3, #1000	; 0x3e8
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 800aa9e:	4599      	cmp	r9, r3
 800aaa0:	bf38      	it	cc
 800aaa2:	4699      	movcc	r9, r3
    if( dutyCycle == 0 )
 800aaa4:	464b      	mov	r3, r9
 800aaa6:	2b01      	cmp	r3, #1
 800aaa8:	bf38      	it	cc
 800aaaa:	2301      	movcc	r3, #1
 800aaac:	9308      	str	r3, [sp, #32]
    if( joined == false )
 800aaae:	2e00      	cmp	r6, #0
 800aab0:	d152      	bne.n	800ab58 <RegionCommonUpdateBandTimeOff+0x154>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 800aab2:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 800aab6:	d148      	bne.n	800ab4a <RegionCommonUpdateBandTimeOff+0x146>
            band->LastMaxCreditAssignTime = elapsedTime;
 800aab8:	60a0      	str	r0, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 800aaba:	465f      	mov	r7, fp
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 800aabc:	68a1      	ldr	r1, [r4, #8]
 800aabe:	a80e      	add	r0, sp, #56	; 0x38
 800aac0:	f004 fccc 	bl	800f45c <SysTimeFromMs>
 800aac4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800aac6:	9300      	str	r3, [sp, #0]
 800aac8:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
 800aacc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800aace:	a80c      	add	r0, sp, #48	; 0x30
 800aad0:	f004 fc24 	bl	800f31c <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 800aad4:	9b05      	ldr	r3, [sp, #20]
 800aad6:	b90b      	cbnz	r3, 800aadc <RegionCommonUpdateBandTimeOff+0xd8>
 800aad8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800aada:	b133      	cbz	r3, 800aaea <RegionCommonUpdateBandTimeOff+0xe6>
 800aadc:	6923      	ldr	r3, [r4, #16]
 800aade:	42bb      	cmp	r3, r7
 800aae0:	d103      	bne.n	800aaea <RegionCommonUpdateBandTimeOff+0xe6>
            ( band->MaxTimeCredits != maxCredits ) ||
 800aae2:	4b39      	ldr	r3, [pc, #228]	; (800abc8 <RegionCommonUpdateBandTimeOff+0x1c4>)
 800aae4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800aae6:	429a      	cmp	r2, r3
 800aae8:	d90d      	bls.n	800ab06 <RegionCommonUpdateBandTimeOff+0x102>
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 800aaea:	4b38      	ldr	r3, [pc, #224]	; (800abcc <RegionCommonUpdateBandTimeOff+0x1c8>)
            band->TimeCredits = maxCredits;
 800aaec:	60e7      	str	r7, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 800aaee:	4598      	cmp	r8, r3
 800aaf0:	d909      	bls.n	800ab06 <RegionCommonUpdateBandTimeOff+0x102>
                timeDiff.SubSeconds = 0;
 800aaf2:	2300      	movs	r3, #0
 800aaf4:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 800aaf8:	9b04      	ldr	r3, [sp, #16]
 800aafa:	990d      	ldr	r1, [sp, #52]	; 0x34
 800aafc:	930c      	str	r3, [sp, #48]	; 0x30
 800aafe:	4618      	mov	r0, r3
 800ab00:	f004 fc8c 	bl	800f41c <SysTimeToMs>
 800ab04:	60a0      	str	r0, [r4, #8]
    if( band->LastBandUpdateTime == 0 )
 800ab06:	6860      	ldr	r0, [r4, #4]
 800ab08:	b900      	cbnz	r0, 800ab0c <RegionCommonUpdateBandTimeOff+0x108>
        band->TimeCredits = maxCredits;
 800ab0a:	60e7      	str	r7, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 800ab0c:	6127      	str	r7, [r4, #16]
    if( joined == true )
 800ab0e:	b126      	cbz	r6, 800ab1a <RegionCommonUpdateBandTimeOff+0x116>
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 800ab10:	f004 fcfc 	bl	800f50c <UTIL_TIMER_GetElapsedTime>
 800ab14:	68e3      	ldr	r3, [r4, #12]
 800ab16:	4403      	add	r3, r0
 800ab18:	60e3      	str	r3, [r4, #12]
    if( band->TimeCredits > band->MaxTimeCredits )
 800ab1a:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 800ab1e:	4293      	cmp	r3, r2
    band->LastBandUpdateTime = currentTime;
 800ab20:	9b06      	ldr	r3, [sp, #24]
        creditCosts = expectedTimeOnAir * dutyCycle;
 800ab22:	991d      	ldr	r1, [sp, #116]	; 0x74
    band->LastBandUpdateTime = currentTime;
 800ab24:	6063      	str	r3, [r4, #4]
        creditCosts = expectedTimeOnAir * dutyCycle;
 800ab26:	9b08      	ldr	r3, [sp, #32]
        band->TimeCredits = band->MaxTimeCredits;
 800ab28:	bf88      	it	hi
 800ab2a:	60e2      	strhi	r2, [r4, #12]
        creditCosts = expectedTimeOnAir * dutyCycle;
 800ab2c:	434b      	muls	r3, r1
        if( ( bands[i].TimeCredits > creditCosts ) ||
 800ab2e:	68e1      	ldr	r1, [r4, #12]
 800ab30:	4299      	cmp	r1, r3
 800ab32:	d802      	bhi.n	800ab3a <RegionCommonUpdateBandTimeOff+0x136>
 800ab34:	9805      	ldr	r0, [sp, #20]
 800ab36:	b9a8      	cbnz	r0, 800ab64 <RegionCommonUpdateBandTimeOff+0x160>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 800ab38:	b1a6      	cbz	r6, 800ab64 <RegionCommonUpdateBandTimeOff+0x160>
            bands[i].ReadyForTransmission = true;
 800ab3a:	2301      	movs	r3, #1
            validBands++;
 800ab3c:	441d      	add	r5, r3
            bands[i].ReadyForTransmission = true;
 800ab3e:	7523      	strb	r3, [r4, #20]
            validBands++;
 800ab40:	b2ed      	uxtb	r5, r5
    for( uint8_t i = 0; i < nbBands; i++ )
 800ab42:	3418      	adds	r4, #24
 800ab44:	e786      	b.n	800aa54 <RegionCommonUpdateBandTimeOff+0x50>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 800ab46:	2364      	movs	r3, #100	; 0x64
 800ab48:	e7a9      	b.n	800aa9e <RegionCommonUpdateBandTimeOff+0x9a>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 800ab4a:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 800ab4e:	bf0a      	itet	eq
 800ab50:	4f1f      	ldreq	r7, [pc, #124]	; (800abd0 <RegionCommonUpdateBandTimeOff+0x1cc>)
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 800ab52:	4f20      	ldrne	r7, [pc, #128]	; (800abd4 <RegionCommonUpdateBandTimeOff+0x1d0>)
            band->LastMaxCreditAssignTime = elapsedTime;
 800ab54:	60a0      	streq	r0, [r4, #8]
 800ab56:	e7b1      	b.n	800aabc <RegionCommonUpdateBandTimeOff+0xb8>
        if( dutyCycleEnabled == false )
 800ab58:	9b05      	ldr	r3, [sp, #20]
 800ab5a:	b90b      	cbnz	r3, 800ab60 <RegionCommonUpdateBandTimeOff+0x15c>
            band->TimeCredits = maxCredits;
 800ab5c:	f8c4 b00c 	str.w	fp, [r4, #12]
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 800ab60:	465f      	mov	r7, fp
 800ab62:	e7d0      	b.n	800ab06 <RegionCommonUpdateBandTimeOff+0x102>
            bands[i].ReadyForTransmission = false;
 800ab64:	2000      	movs	r0, #0
            if( bands[i].MaxTimeCredits > creditCosts )
 800ab66:	4293      	cmp	r3, r2
            bands[i].ReadyForTransmission = false;
 800ab68:	7520      	strb	r0, [r4, #20]
            if( bands[i].MaxTimeCredits > creditCosts )
 800ab6a:	d206      	bcs.n	800ab7a <RegionCommonUpdateBandTimeOff+0x176>
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 800ab6c:	1a5b      	subs	r3, r3, r1
 800ab6e:	459a      	cmp	sl, r3
                validBands++;
 800ab70:	f105 0501 	add.w	r5, r5, #1
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 800ab74:	bf28      	it	cs
 800ab76:	469a      	movcs	sl, r3
                validBands++;
 800ab78:	b2ed      	uxtb	r5, r5
            if( joined == false )
 800ab7a:	2e00      	cmp	r6, #0
 800ab7c:	d1e1      	bne.n	800ab42 <RegionCommonUpdateBandTimeOff+0x13e>
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 800ab7e:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
 800ab82:	4a15      	ldr	r2, [pc, #84]	; (800abd8 <RegionCommonUpdateBandTimeOff+0x1d4>)
                SysTime_t backoffTimeRange = {
 800ab84:	f8ad 6034 	strh.w	r6, [sp, #52]	; 0x34
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 800ab88:	d019      	beq.n	800abbe <RegionCommonUpdateBandTimeOff+0x1ba>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 800ab8a:	f649 23b0 	movw	r3, #39600	; 0x9ab0
 800ab8e:	f5b9 7f7a 	cmp.w	r9, #1000	; 0x3e8
 800ab92:	bf18      	it	ne
 800ab94:	4613      	movne	r3, r2
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 800ab96:	4590      	cmp	r8, r2
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 800ab98:	bf84      	itt	hi
 800ab9a:	9a03      	ldrhi	r2, [sp, #12]
 800ab9c:	189b      	addhi	r3, r3, r2
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 800ab9e:	930c      	str	r3, [sp, #48]	; 0x30
 800aba0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800aba2:	9300      	str	r3, [sp, #0]
 800aba4:	af0c      	add	r7, sp, #48	; 0x30
 800aba6:	e897 0006 	ldmia.w	r7, {r1, r2}
 800abaa:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800abac:	4638      	mov	r0, r7
 800abae:	f004 fbb5 	bl	800f31c <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 800abb2:	e897 0003 	ldmia.w	r7, {r0, r1}
 800abb6:	f004 fc31 	bl	800f41c <SysTimeToMs>
 800abba:	4682      	mov	sl, r0
 800abbc:	e7c1      	b.n	800ab42 <RegionCommonUpdateBandTimeOff+0x13e>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 800abbe:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 800abc2:	e7e8      	b.n	800ab96 <RegionCommonUpdateBandTimeOff+0x192>
 800abc4:	00015180 	.word	0x00015180
 800abc8:	0001517f 	.word	0x0001517f
 800abcc:	0001ec2f 	.word	0x0001ec2f
 800abd0:	0112a880 	.word	0x0112a880
 800abd4:	02932e00 	.word	0x02932e00
 800abd8:	0001ec30 	.word	0x0001ec30
 800abdc:	001b7740 	.word	0x001b7740

0800abe0 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 800abe0:	7803      	ldrb	r3, [r0, #0]
 800abe2:	2b03      	cmp	r3, #3
 800abe4:	d114      	bne.n	800ac10 <RegionCommonParseLinkAdrReq+0x30>
    {
        // Parse datarate and tx power
        linkAdrParams->Datarate = payload[1];
 800abe6:	7843      	ldrb	r3, [r0, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 800abe8:	f003 020f 	and.w	r2, r3, #15
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 800abec:	091b      	lsrs	r3, r3, #4
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 800abee:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 800abf0:	704b      	strb	r3, [r1, #1]
        // Parse ChMask
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 800abf2:	7883      	ldrb	r3, [r0, #2]
 800abf4:	808b      	strh	r3, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 800abf6:	78c2      	ldrb	r2, [r0, #3]
 800abf8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800abfc:	808b      	strh	r3, [r1, #4]
        // Parse ChMaskCtrl and nbRep
        linkAdrParams->NbRep = payload[4];
 800abfe:	7903      	ldrb	r3, [r0, #4]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 800ac00:	f3c3 1202 	ubfx	r2, r3, #4, #3
        linkAdrParams->NbRep &= 0x0F;
 800ac04:	f003 030f 	and.w	r3, r3, #15
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 800ac08:	70ca      	strb	r2, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 800ac0a:	700b      	strb	r3, [r1, #0]

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
 800ac0c:	2005      	movs	r0, #5
 800ac0e:	4770      	bx	lr
    uint8_t retIndex = 0;
 800ac10:	2000      	movs	r0, #0
    }
    return retIndex;
}
 800ac12:	4770      	bx	lr

0800ac14 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 800ac14:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800ac18:	4698      	mov	r8, r3
    int8_t datarate = verifyParams->Datarate;
    int8_t txPower = verifyParams->TxPower;
    int8_t nbRepetitions = verifyParams->NbRep;

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 800ac1a:	7943      	ldrb	r3, [r0, #5]
    uint8_t status = verifyParams->Status;
 800ac1c:	7905      	ldrb	r5, [r0, #4]
    int8_t txPower = verifyParams->TxPower;
 800ac1e:	f990 7007 	ldrsb.w	r7, [r0, #7]
    int8_t nbRepetitions = verifyParams->NbRep;
 800ac22:	7a06      	ldrb	r6, [r0, #8]
{
 800ac24:	4691      	mov	r9, r2
 800ac26:	4604      	mov	r4, r0
    int8_t datarate = verifyParams->Datarate;
 800ac28:	f990 2006 	ldrsb.w	r2, [r0, #6]
{
 800ac2c:	468a      	mov	sl, r1
    if( verifyParams->AdrEnabled == false )
 800ac2e:	b31b      	cbz	r3, 800ac78 <RegionCommonLinkAdrReqVerifyParams+0x64>
    int8_t nbRepetitions = verifyParams->NbRep;
 800ac30:	b276      	sxtb	r6, r6
        nbRepetitions = verifyParams->CurrentNbRep;
        datarate =  verifyParams->CurrentDatarate;
        txPower =  verifyParams->CurrentTxPower;
    }

    if( status != 0 )
 800ac32:	b1bd      	cbz	r5, 800ac64 <RegionCommonLinkAdrReqVerifyParams+0x50>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 800ac34:	69a3      	ldr	r3, [r4, #24]
 800ac36:	9301      	str	r3, [sp, #4]
 800ac38:	f994 3015 	ldrsb.w	r3, [r4, #21]
 800ac3c:	9300      	str	r3, [sp, #0]
 800ac3e:	6921      	ldr	r1, [r4, #16]
 800ac40:	f994 3014 	ldrsb.w	r3, [r4, #20]
 800ac44:	7b20      	ldrb	r0, [r4, #12]
 800ac46:	f7ff fe36 	bl	800a8b6 <RegionCommonChanVerifyDr>
 800ac4a:	b908      	cbnz	r0, 800ac50 <RegionCommonLinkAdrReqVerifyParams+0x3c>
                                      verifyParams->MinDatarate, verifyParams->MaxDatarate, verifyParams->Channels  ) == false )
        {
            status &= 0xFD; // Datarate KO
 800ac4c:	f005 05fd 	and.w	r5, r5, #253	; 0xfd
        }

        // Verify tx power
        if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 800ac50:	f994 301d 	ldrsb.w	r3, [r4, #29]
 800ac54:	f994 101c 	ldrsb.w	r1, [r4, #28]
    if( ( value >= min ) && ( value <= max ) )
 800ac58:	42bb      	cmp	r3, r7
 800ac5a:	dc14      	bgt.n	800ac86 <RegionCommonLinkAdrReqVerifyParams+0x72>
 800ac5c:	42b9      	cmp	r1, r7
 800ac5e:	da13      	bge.n	800ac88 <RegionCommonLinkAdrReqVerifyParams+0x74>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 800ac60:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
    *dr = datarate;
    *txPow = txPower;
    *nbRep = nbRepetitions;

    return status;
}
 800ac64:	4628      	mov	r0, r5
    *dr = datarate;
 800ac66:	f88a 2000 	strb.w	r2, [sl]
    *txPow = txPower;
 800ac6a:	f889 7000 	strb.w	r7, [r9]
    *nbRep = nbRepetitions;
 800ac6e:	f888 6000 	strb.w	r6, [r8]
}
 800ac72:	b002      	add	sp, #8
 800ac74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nbRepetitions = verifyParams->CurrentNbRep;
 800ac78:	f990 600b 	ldrsb.w	r6, [r0, #11]
        datarate =  verifyParams->CurrentDatarate;
 800ac7c:	f990 2009 	ldrsb.w	r2, [r0, #9]
        txPower =  verifyParams->CurrentTxPower;
 800ac80:	f990 700a 	ldrsb.w	r7, [r0, #10]
 800ac84:	e7d5      	b.n	800ac32 <RegionCommonLinkAdrReqVerifyParams+0x1e>
 800ac86:	461f      	mov	r7, r3
    if( status == 0x07 )
 800ac88:	2d07      	cmp	r5, #7
 800ac8a:	d1eb      	bne.n	800ac64 <RegionCommonLinkAdrReqVerifyParams+0x50>
            nbRepetitions = 1;
 800ac8c:	2e00      	cmp	r6, #0
 800ac8e:	bf08      	it	eq
 800ac90:	2601      	moveq	r6, #1
 800ac92:	e7e7      	b.n	800ac64 <RegionCommonLinkAdrReqVerifyParams+0x50>

0800ac94 <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 800ac94:	4b02      	ldr	r3, [pc, #8]	; (800aca0 <RegionCommonComputeSymbolTimeLoRa+0xc>)
 800ac96:	fa03 f000 	lsl.w	r0, r3, r0
}
 800ac9a:	fbb0 f0f1 	udiv	r0, r0, r1
 800ac9e:	4770      	bx	lr
 800aca0:	000f4240 	.word	0x000f4240

0800aca4 <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
}
 800aca4:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 800aca8:	fbb3 f0f0 	udiv	r0, r3, r0
 800acac:	4770      	bx	lr

0800acae <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 800acae:	b530      	push	{r4, r5, lr}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 800acb0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800acb4:	1f0c      	subs	r4, r1, #4
 800acb6:	436a      	muls	r2, r5
 800acb8:	fb00 2204 	mla	r2, r0, r4, r2
 800acbc:	0052      	lsls	r2, r2, #1
 800acbe:	bf1e      	ittt	ne
 800acc0:	f100 34ff 	addne.w	r4, r0, #4294967295
 800acc4:	1912      	addne	r2, r2, r4
 800acc6:	fbb2 f2f0 	udivne	r2, r2, r0
 800acca:	428a      	cmp	r2, r1
 800accc:	bf38      	it	cc
 800acce:	460a      	movcc	r2, r1
 800acd0:	9903      	ldr	r1, [sp, #12]
 800acd2:	600a      	str	r2, [r1, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 800acd4:	0081      	lsls	r1, r0, #2
 800acd6:	4350      	muls	r0, r2
 800acd8:	bf1c      	itt	ne
 800acda:	3001      	addne	r0, #1
 800acdc:	0840      	lsrne	r0, r0, #1
 800acde:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800ace2:	1a08      	subs	r0, r1, r0
 800ace4:	fb02 0313 	mls	r3, r2, r3, r0
 800ace8:	2b00      	cmp	r3, #0
 800acea:	bfca      	itet	gt
 800acec:	f203 33e7 	addwgt	r3, r3, #999	; 0x3e7
 800acf0:	fb93 f3f2 	sdivle	r3, r3, r2
 800acf4:	fbb3 f3f2 	udivgt	r3, r3, r2
 800acf8:	9a04      	ldr	r2, [sp, #16]
 800acfa:	6013      	str	r3, [r2, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 800acfc:	bd30      	pop	{r4, r5, pc}

0800acfe <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 800acfe:	b538      	push	{r3, r4, r5, lr}
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 800ad00:	0040      	lsls	r0, r0, #1
{
 800ad02:	4614      	mov	r4, r2
 800ad04:	460d      	mov	r5, r1
    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 800ad06:	f7f5 fdb5 	bl	8000874 <__aeabi_ui2f>
 800ad0a:	4601      	mov	r1, r0
 800ad0c:	4628      	mov	r0, r5
 800ad0e:	f7f5 fcff 	bl	8000710 <__aeabi_fsub>
 800ad12:	4621      	mov	r1, r4
 800ad14:	f7f5 fcfc 	bl	8000710 <__aeabi_fsub>
 800ad18:	f7f5 fbee 	bl	80004f8 <__aeabi_f2d>
 800ad1c:	f005 fa90 	bl	8010240 <floor>
 800ad20:	f7f5 fcca 	bl	80006b8 <__aeabi_d2iz>

    return phyTxPower;
}
 800ad24:	b240      	sxtb	r0, r0
 800ad26:	bd38      	pop	{r3, r4, r5, pc}

0800ad28 <RegionCommonCountNbOfEnabledChannels>:
    /* ST_WORKAROUND_END */
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 800ad28:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ad2c:	e9cd 2300 	strd	r2, r3, [sp]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 800ad30:	2300      	movs	r3, #0
    uint8_t nbRestrictedChannelsCount = 0;
 800ad32:	461d      	mov	r5, r3
    uint8_t nbChannelCount = 0;
 800ad34:	461e      	mov	r6, r3
    {
        for( uint8_t j = 0; j < 16; j++ )
        {
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
            {
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 800ad36:	f04f 090c 	mov.w	r9, #12
 800ad3a:	011a      	lsls	r2, r3, #4
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 800ad3c:	8a04      	ldrh	r4, [r0, #16]
 800ad3e:	fa5f f882 	uxtb.w	r8, r2
 800ad42:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800ad46:	4294      	cmp	r4, r2
 800ad48:	d806      	bhi.n	800ad58 <RegionCommonCountNbOfEnabledChannels+0x30>
                }
                enabledChannels[nbChannelCount++] = i + j;
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 800ad4a:	9b00      	ldr	r3, [sp, #0]
 800ad4c:	701e      	strb	r6, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 800ad4e:	9b01      	ldr	r3, [sp, #4]
 800ad50:	701d      	strb	r5, [r3, #0]
}
 800ad52:	b003      	add	sp, #12
 800ad54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 800ad58:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800ad5c:	2200      	movs	r2, #0
 800ad5e:	6844      	ldr	r4, [r0, #4]
 800ad60:	f834 400c 	ldrh.w	r4, [r4, ip]
 800ad64:	4114      	asrs	r4, r2
 800ad66:	07e7      	lsls	r7, r4, #31
 800ad68:	d52a      	bpl.n	800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 800ad6a:	eb02 0e08 	add.w	lr, r2, r8
 800ad6e:	6887      	ldr	r7, [r0, #8]
 800ad70:	fb09 f40e 	mul.w	r4, r9, lr
 800ad74:	eb07 0a04 	add.w	sl, r7, r4
 800ad78:	593c      	ldr	r4, [r7, r4]
 800ad7a:	b30c      	cbz	r4, 800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 800ad7c:	7804      	ldrb	r4, [r0, #0]
 800ad7e:	b934      	cbnz	r4, 800ad8e <RegionCommonCountNbOfEnabledChannels+0x66>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 800ad80:	6944      	ldr	r4, [r0, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 800ad82:	b124      	cbz	r4, 800ad8e <RegionCommonCountNbOfEnabledChannels+0x66>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 800ad84:	f834 400c 	ldrh.w	r4, [r4, ip]
 800ad88:	4114      	asrs	r4, r2
 800ad8a:	07e4      	lsls	r4, r4, #31
 800ad8c:	d518      	bpl.n	800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 800ad8e:	f89a 4008 	ldrb.w	r4, [sl, #8]
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 800ad92:	f990 b001 	ldrsb.w	fp, [r0, #1]
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 800ad96:	f344 0703 	sbfx	r7, r4, #0, #4
    if( ( value >= min ) && ( value <= max ) )
 800ad9a:	b27f      	sxtb	r7, r7
 800ad9c:	455f      	cmp	r7, fp
 800ad9e:	dc0f      	bgt.n	800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 800ada0:	f344 1403 	sbfx	r4, r4, #4, #4
    if( ( value >= min ) && ( value <= max ) )
 800ada4:	b264      	sxtb	r4, r4
 800ada6:	455c      	cmp	r4, fp
 800ada8:	db0a      	blt.n	800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 800adaa:	f89a 4009 	ldrb.w	r4, [sl, #9]
 800adae:	eb04 0744 	add.w	r7, r4, r4, lsl #1
 800adb2:	68c4      	ldr	r4, [r0, #12]
 800adb4:	eb04 04c7 	add.w	r4, r4, r7, lsl #3
 800adb8:	7d24      	ldrb	r4, [r4, #20]
 800adba:	b93c      	cbnz	r4, 800adcc <RegionCommonCountNbOfEnabledChannels+0xa4>
                    nbRestrictedChannelsCount++;
 800adbc:	3501      	adds	r5, #1
 800adbe:	b2ed      	uxtb	r5, r5
        for( uint8_t j = 0; j < 16; j++ )
 800adc0:	3201      	adds	r2, #1
 800adc2:	2a10      	cmp	r2, #16
 800adc4:	d1cb      	bne.n	800ad5e <RegionCommonCountNbOfEnabledChannels+0x36>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 800adc6:	3301      	adds	r3, #1
 800adc8:	b2db      	uxtb	r3, r3
 800adca:	e7b6      	b.n	800ad3a <RegionCommonCountNbOfEnabledChannels+0x12>
                enabledChannels[nbChannelCount++] = i + j;
 800adcc:	1c74      	adds	r4, r6, #1
 800adce:	f801 e006 	strb.w	lr, [r1, r6]
 800add2:	b2e6      	uxtb	r6, r4
 800add4:	e7f4      	b.n	800adc0 <RegionCommonCountNbOfEnabledChannels+0x98>

0800add6 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 800add6:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800adda:	4604      	mov	r4, r0
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 800addc:	6840      	ldr	r0, [r0, #4]
{
 800adde:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
 800ade2:	461e      	mov	r6, r3
 800ade4:	468a      	mov	sl, r1
 800ade6:	4691      	mov	r9, r2
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 800ade8:	f004 fb90 	bl	800f50c <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 800adec:	6823      	ldr	r3, [r4, #0]
 800adee:	1a1b      	subs	r3, r3, r0
 800adf0:	f8c8 3000 	str.w	r3, [r8]
    *nbRestrictedChannels = 1;
    *nbEnabledChannels = 0;
 800adf4:	2500      	movs	r5, #0
    *nbRestrictedChannels = 1;
 800adf6:	2301      	movs	r3, #1
 800adf8:	703b      	strb	r3, [r7, #0]
    *nbEnabledChannels = 0;
 800adfa:	7035      	strb	r5, [r6, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 800adfc:	6863      	ldr	r3, [r4, #4]
 800adfe:	b113      	cbz	r3, 800ae06 <RegionCommonIdentifyChannels+0x30>
 800ae00:	6823      	ldr	r3, [r4, #0]
 800ae02:	4283      	cmp	r3, r0
 800ae04:	d825      	bhi.n	800ae52 <RegionCommonIdentifyChannels+0x7c>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 800ae06:	f8ca 5000 	str.w	r5, [sl]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 800ae0a:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 800ae0e:	69a3      	ldr	r3, [r4, #24]
 800ae10:	f89c e000 	ldrb.w	lr, [ip]
 800ae14:	9303      	str	r3, [sp, #12]
 800ae16:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
 800ae1a:	ab01      	add	r3, sp, #4
 800ae1c:	e883 0003 	stmia.w	r3, {r0, r1}
 800ae20:	7d23      	ldrb	r3, [r4, #20]
 800ae22:	9300      	str	r3, [sp, #0]
 800ae24:	f8dc 100c 	ldr.w	r1, [ip, #12]
 800ae28:	7a23      	ldrb	r3, [r4, #8]
 800ae2a:	7a62      	ldrb	r2, [r4, #9]
 800ae2c:	4670      	mov	r0, lr
 800ae2e:	f7ff fde9 	bl	800aa04 <RegionCommonUpdateBandTimeOff>
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 800ae32:	463b      	mov	r3, r7
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 800ae34:	f8c8 0000 	str.w	r0, [r8]
        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 800ae38:	4632      	mov	r2, r6
 800ae3a:	69e0      	ldr	r0, [r4, #28]
 800ae3c:	4649      	mov	r1, r9
 800ae3e:	f7ff ff73 	bl	800ad28 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 800ae42:	7833      	ldrb	r3, [r6, #0]
 800ae44:	b12b      	cbz	r3, 800ae52 <RegionCommonIdentifyChannels+0x7c>
    {
        *nextTxDelay = 0;
 800ae46:	f8c8 5000 	str.w	r5, [r8]
        return LORAMAC_STATUS_OK;
 800ae4a:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 800ae4c:	b004      	add	sp, #16
 800ae4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if( *nbRestrictedChannels > 0 )
 800ae52:	783b      	ldrb	r3, [r7, #0]
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 800ae54:	2b00      	cmp	r3, #0
 800ae56:	bf14      	ite	ne
 800ae58:	200b      	movne	r0, #11
 800ae5a:	200c      	moveq	r0, #12
 800ae5c:	e7f6      	b.n	800ae4c <RegionCommonIdentifyChannels+0x76>

0800ae5e <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 800ae5e:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int8_t drLocal = params->CurrentDr;
 800ae60:	f990 2000 	ldrsb.w	r2, [r0]

    if( params->CurrentDr == params->MinDr )
 800ae64:	f990 5002 	ldrsb.w	r5, [r0, #2]
 800ae68:	4295      	cmp	r5, r2
{
 800ae6a:	4604      	mov	r4, r0
    if( params->CurrentDr == params->MinDr )
 800ae6c:	d00f      	beq.n	800ae8e <RegionCommonGetNextLowerTxDr+0x30>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 800ae6e:	3a01      	subs	r2, #1
 800ae70:	b252      	sxtb	r2, r2
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 800ae72:	42aa      	cmp	r2, r5
 800ae74:	d00b      	beq.n	800ae8e <RegionCommonGetNextLowerTxDr+0x30>
 800ae76:	68a3      	ldr	r3, [r4, #8]
 800ae78:	9301      	str	r3, [sp, #4]
 800ae7a:	f994 3001 	ldrsb.w	r3, [r4, #1]
 800ae7e:	9300      	str	r3, [sp, #0]
 800ae80:	6861      	ldr	r1, [r4, #4]
 800ae82:	78e0      	ldrb	r0, [r4, #3]
 800ae84:	462b      	mov	r3, r5
 800ae86:	f7ff fd16 	bl	800a8b6 <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 800ae8a:	2800      	cmp	r0, #0
 800ae8c:	d0ef      	beq.n	800ae6e <RegionCommonGetNextLowerTxDr+0x10>

        return drLocal;
    }
}
 800ae8e:	4610      	mov	r0, r2
 800ae90:	b003      	add	sp, #12
 800ae92:	bd30      	pop	{r4, r5, pc}

0800ae94 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
}
 800ae94:	4288      	cmp	r0, r1
 800ae96:	bfb8      	it	lt
 800ae98:	4608      	movlt	r0, r1
 800ae9a:	4770      	bx	lr

0800ae9c <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 800ae9c:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 800aea0:	4b05      	ldr	r3, [pc, #20]	; (800aeb8 <RegionCommonGetBandwidth+0x1c>)
 800aea2:	4298      	cmp	r0, r3
 800aea4:	d005      	beq.n	800aeb2 <RegionCommonGetBandwidth+0x16>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 800aea6:	4b05      	ldr	r3, [pc, #20]	; (800aebc <RegionCommonGetBandwidth+0x20>)
 800aea8:	4298      	cmp	r0, r3
 800aeaa:	bf0c      	ite	eq
 800aeac:	2002      	moveq	r0, #2
 800aeae:	2000      	movne	r0, #0
 800aeb0:	4770      	bx	lr
    switch( bandwidths[drIndex] )
 800aeb2:	2001      	movs	r0, #1
    }
}
 800aeb4:	4770      	bx	lr
 800aeb6:	bf00      	nop
 800aeb8:	0003d090 	.word	0x0003d090
 800aebc:	0007a120 	.word	0x0007a120

0800aec0 <RegionCommonRxConfigPrint>:

/* ST_WORKAROUND_BEGIN: Print Tx/Rx config */
void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 800aec0:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 800aec2:	4d13      	ldr	r5, [pc, #76]	; (800af10 <RegionCommonRxConfigPrint+0x50>)
{
 800aec4:	4606      	mov	r6, r0
 800aec6:	460f      	mov	r7, r1
 800aec8:	4694      	mov	ip, r2
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 800aeca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
 800aecc:	b08b      	sub	sp, #44	; 0x2c
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 800aece:	ac04      	add	r4, sp, #16
 800aed0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800aed2:	e895 0003 	ldmia.w	r5, {r0, r1}

    if ( rxSlot < RX_SLOT_NONE )
 800aed6:	2e05      	cmp	r6, #5
    const char *slotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
 800aed8:	e884 0003 	stmia.w	r4, {r0, r1}
    if ( rxSlot < RX_SLOT_NONE )
 800aedc:	d80f      	bhi.n	800aefe <RegionCommonRxConfigPrint+0x3e>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", slotStrings[rxSlot], frequency, dr );
 800aede:	ab0a      	add	r3, sp, #40	; 0x28
 800aee0:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 800aee4:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 800aee8:	2201      	movs	r2, #1
 800aeea:	f856 3c18 	ldr.w	r3, [r6, #-24]
 800aeee:	9300      	str	r3, [sp, #0]
 800aef0:	2100      	movs	r1, #0
 800aef2:	4b08      	ldr	r3, [pc, #32]	; (800af14 <RegionCommonRxConfigPrint+0x54>)
 800aef4:	2002      	movs	r0, #2
 800aef6:	f004 f807 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 800aefa:	b00b      	add	sp, #44	; 0x2c
 800aefc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 800aefe:	e9cd 7c00 	strd	r7, ip, [sp]
 800af02:	4b05      	ldr	r3, [pc, #20]	; (800af18 <RegionCommonRxConfigPrint+0x58>)
 800af04:	2201      	movs	r2, #1
 800af06:	2100      	movs	r1, #0
 800af08:	2002      	movs	r0, #2
 800af0a:	f003 fffd 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 800af0e:	e7f4      	b.n	800aefa <RegionCommonRxConfigPrint+0x3a>
 800af10:	08010374 	.word	0x08010374
 800af14:	08010a43 	.word	0x08010a43
 800af18:	08010a62 	.word	0x08010a62

0800af1c <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 800af1c:	b507      	push	{r0, r1, r2, lr}
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 800af1e:	4b05      	ldr	r3, [pc, #20]	; (800af34 <RegionCommonTxConfigPrint+0x18>)
 800af20:	e9cd 0100 	strd	r0, r1, [sp]
 800af24:	2201      	movs	r2, #1
 800af26:	2100      	movs	r1, #0
 800af28:	2002      	movs	r0, #2
 800af2a:	f003 ffed 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 800af2e:	b003      	add	sp, #12
 800af30:	f85d fb04 	ldr.w	pc, [sp], #4
 800af34:	08010a7e 	.word	0x08010a7e

0800af38 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 800af38:	b5f0      	push	{r4, r5, r6, r7, lr}
    int8_t phyDr = DataratesEU868[datarate];
 800af3a:	4b11      	ldr	r3, [pc, #68]	; (800af80 <GetTimeOnAir+0x48>)
{
 800af3c:	b085      	sub	sp, #20
 800af3e:	460c      	mov	r4, r1
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 800af40:	4910      	ldr	r1, [pc, #64]	; (800af84 <GetTimeOnAir+0x4c>)
    int8_t phyDr = DataratesEU868[datarate];
 800af42:	561f      	ldrsb	r7, [r3, r0]
{
 800af44:	4605      	mov	r5, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 800af46:	f7ff ffa9 	bl	800ae9c <RegionCommonGetBandwidth>
 800af4a:	4b0f      	ldr	r3, [pc, #60]	; (800af88 <GetTimeOnAir+0x50>)
 800af4c:	b2e4      	uxtb	r4, r4
 800af4e:	6a5e      	ldr	r6, [r3, #36]	; 0x24
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 800af50:	2d07      	cmp	r5, #7
 800af52:	f04f 0301 	mov.w	r3, #1
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 800af56:	e9cd 4302 	strd	r4, r3, [sp, #8]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 800af5a:	4601      	mov	r1, r0
    if( datarate == DR_7 )
 800af5c:	d10a      	bne.n	800af74 <GetTimeOnAir+0x3c>
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 800af5e:	2205      	movs	r2, #5
 800af60:	2300      	movs	r3, #0
 800af62:	e9cd 2300 	strd	r2, r3, [sp]
 800af66:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800af6a:	437a      	muls	r2, r7
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 800af6c:	4618      	mov	r0, r3
 800af6e:	47b0      	blx	r6
    }
    return timeOnAir;
}
 800af70:	b005      	add	sp, #20
 800af72:	bdf0      	pop	{r4, r5, r6, r7, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 800af74:	2208      	movs	r2, #8
 800af76:	2000      	movs	r0, #0
 800af78:	e9cd 2000 	strd	r2, r0, [sp]
 800af7c:	463a      	mov	r2, r7
 800af7e:	e7f5      	b.n	800af6c <GetTimeOnAir+0x34>
 800af80:	08010ac3 	.word	0x08010ac3
 800af84:	08010a9c 	.word	0x08010a9c
 800af88:	08010fe4 	.word	0x08010fe4

0800af8c <VerifyRfFreq>:
{
 800af8c:	b538      	push	{r3, r4, r5, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 800af8e:	4b19      	ldr	r3, [pc, #100]	; (800aff4 <VerifyRfFreq+0x68>)
 800af90:	6a1b      	ldr	r3, [r3, #32]
{
 800af92:	4605      	mov	r5, r0
 800af94:	460c      	mov	r4, r1
    if( Radio.CheckRfFrequency( freq ) == false )
 800af96:	4798      	blx	r3
 800af98:	b130      	cbz	r0, 800afa8 <VerifyRfFreq+0x1c>
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 800af9a:	4b17      	ldr	r3, [pc, #92]	; (800aff8 <VerifyRfFreq+0x6c>)
 800af9c:	4a17      	ldr	r2, [pc, #92]	; (800affc <VerifyRfFreq+0x70>)
 800af9e:	442b      	add	r3, r5
 800afa0:	4293      	cmp	r3, r2
 800afa2:	d802      	bhi.n	800afaa <VerifyRfFreq+0x1e>
        *band = 2;
 800afa4:	2302      	movs	r3, #2
        *band = 3;
 800afa6:	7023      	strb	r3, [r4, #0]
}
 800afa8:	bd38      	pop	{r3, r4, r5, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 800afaa:	4b15      	ldr	r3, [pc, #84]	; (800b000 <VerifyRfFreq+0x74>)
 800afac:	4a15      	ldr	r2, [pc, #84]	; (800b004 <VerifyRfFreq+0x78>)
 800afae:	442b      	add	r3, r5
 800afb0:	4293      	cmp	r3, r2
 800afb2:	d801      	bhi.n	800afb8 <VerifyRfFreq+0x2c>
        *band = 0;
 800afb4:	2300      	movs	r3, #0
 800afb6:	e7f6      	b.n	800afa6 <VerifyRfFreq+0x1a>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 800afb8:	4b13      	ldr	r3, [pc, #76]	; (800b008 <VerifyRfFreq+0x7c>)
 800afba:	4a14      	ldr	r2, [pc, #80]	; (800b00c <VerifyRfFreq+0x80>)
 800afbc:	442b      	add	r3, r5
 800afbe:	4293      	cmp	r3, r2
 800afc0:	d801      	bhi.n	800afc6 <VerifyRfFreq+0x3a>
        *band = 1;
 800afc2:	2301      	movs	r3, #1
 800afc4:	e7ef      	b.n	800afa6 <VerifyRfFreq+0x1a>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 800afc6:	4b12      	ldr	r3, [pc, #72]	; (800b010 <VerifyRfFreq+0x84>)
 800afc8:	4a12      	ldr	r2, [pc, #72]	; (800b014 <VerifyRfFreq+0x88>)
 800afca:	442b      	add	r3, r5
 800afcc:	4293      	cmp	r3, r2
 800afce:	d801      	bhi.n	800afd4 <VerifyRfFreq+0x48>
        *band = 5;
 800afd0:	2305      	movs	r3, #5
 800afd2:	e7e8      	b.n	800afa6 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 800afd4:	4b10      	ldr	r3, [pc, #64]	; (800b018 <VerifyRfFreq+0x8c>)
 800afd6:	4a11      	ldr	r2, [pc, #68]	; (800b01c <VerifyRfFreq+0x90>)
 800afd8:	442b      	add	r3, r5
 800afda:	4293      	cmp	r3, r2
 800afdc:	d801      	bhi.n	800afe2 <VerifyRfFreq+0x56>
        *band = 3;
 800afde:	2303      	movs	r3, #3
 800afe0:	e7e1      	b.n	800afa6 <VerifyRfFreq+0x1a>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 800afe2:	4b0f      	ldr	r3, [pc, #60]	; (800b020 <VerifyRfFreq+0x94>)
 800afe4:	4a0f      	ldr	r2, [pc, #60]	; (800b024 <VerifyRfFreq+0x98>)
 800afe6:	442b      	add	r3, r5
 800afe8:	4293      	cmp	r3, r2
 800afea:	d801      	bhi.n	800aff0 <VerifyRfFreq+0x64>
        *band = 4;
 800afec:	2304      	movs	r3, #4
 800afee:	e7da      	b.n	800afa6 <VerifyRfFreq+0x1a>
        return false;
 800aff0:	2000      	movs	r0, #0
 800aff2:	e7d9      	b.n	800afa8 <VerifyRfFreq+0x1c>
 800aff4:	08010fe4 	.word	0x08010fe4
 800aff8:	cc8faa40 	.word	0xcc8faa40
 800affc:	001e847f 	.word	0x001e847f
 800b000:	cc7125c0 	.word	0xcc7125c0
 800b004:	002dc6c0 	.word	0x002dc6c0
 800b008:	cc435eff 	.word	0xcc435eff
 800b00c:	000927bf 	.word	0x000927bf
 800b010:	cc38b0a0 	.word	0xcc38b0a0
 800b014:	0007a120 	.word	0x0007a120
 800b018:	cc2e0240 	.word	0xcc2e0240
 800b01c:	0003d090 	.word	0x0003d090
 800b020:	cc296e60 	.word	0xcc296e60
 800b024:	000493e0 	.word	0x000493e0

0800b028 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 800b028:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800b02a:	7802      	ldrb	r2, [r0, #0]
    PhyParam_t phyParam = { 0 };
 800b02c:	2300      	movs	r3, #0
 800b02e:	3a0b      	subs	r2, #11
 800b030:	9300      	str	r3, [sp, #0]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 800b032:	2a2e      	cmp	r2, #46	; 0x2e
 800b034:	d86c      	bhi.n	800b110 <RegionEU868GetPhyParam+0xe8>
 800b036:	e8df f002 	tbb	[pc, r2]
 800b03a:	302d      	.short	0x302d
 800b03c:	3d3b3732 	.word	0x3d3b3732
 800b040:	49464340 	.word	0x49464340
 800b044:	576b4f4c 	.word	0x576b4f4c
 800b048:	635e596b 	.word	0x635e596b
 800b04c:	686b6b65 	.word	0x686b6b65
 800b050:	6b6b186f 	.word	0x6b6b186f
 800b054:	6b6b6b6b 	.word	0x6b6b6b6b
 800b058:	6b6b6b6b 	.word	0x6b6b6b6b
 800b05c:	576b6b6b 	.word	0x576b6b6b
 800b060:	6b6b7871 	.word	0x6b6b7871
 800b064:	7a6b7857 	.word	0x7a6b7857
 800b068:	7e          	.byte	0x7e
 800b069:	00          	.byte	0x00
            phyParam.Value = EU868_DEFAULT_DATARATE;
            break;
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 800b06a:	7843      	ldrb	r3, [r0, #1]
 800b06c:	f88d 3004 	strb.w	r3, [sp, #4]
 800b070:	2307      	movs	r3, #7
 800b072:	f88d 3005 	strb.w	r3, [sp, #5]
 800b076:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800b07a:	f8ad 3006 	strh.w	r3, [sp, #6]
            {
                .CurrentDr = getPhy->Datarate,
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 800b07e:	4b31      	ldr	r3, [pc, #196]	; (800b144 <RegionEU868GetPhyParam+0x11c>)
 800b080:	681b      	ldr	r3, [r3, #0]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 800b082:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 800b084:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 800b088:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 800b08c:	f7ff fee7 	bl	800ae5e <RegionCommonGetNextLowerTxDr>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
            break;
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 800b090:	9000      	str	r0, [sp, #0]
            break;
 800b092:	e03d      	b.n	800b110 <RegionEU868GetPhyParam+0xe8>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 800b094:	2340      	movs	r3, #64	; 0x40
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 800b096:	9300      	str	r3, [sp, #0]
            break;
 800b098:	e03a      	b.n	800b110 <RegionEU868GetPhyParam+0xe8>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 800b09a:	2320      	movs	r3, #32
 800b09c:	e7fb      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 800b09e:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800b0a2:	4a29      	ldr	r2, [pc, #164]	; (800b148 <RegionEU868GetPhyParam+0x120>)
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 800b0a4:	5cd3      	ldrb	r3, [r2, r3]
 800b0a6:	e7f6      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 800b0a8:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800b0ac:	4a27      	ldr	r2, [pc, #156]	; (800b14c <RegionEU868GetPhyParam+0x124>)
 800b0ae:	e7f9      	b.n	800b0a4 <RegionEU868GetPhyParam+0x7c>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 800b0b0:	2301      	movs	r3, #1
 800b0b2:	e7f0      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 800b0b4:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800b0b8:	e7ed      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 800b0ba:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800b0be:	e7ea      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 800b0c0:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 800b0c4:	e7e7      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 800b0c6:	f241 3388 	movw	r3, #5000	; 0x1388
 800b0ca:	e7e4      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 800b0cc:	f241 7370 	movw	r3, #6000	; 0x1770
 800b0d0:	e7e1      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 800b0d2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800b0d6:	e7de      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 800b0d8:	481d      	ldr	r0, [pc, #116]	; (800b150 <RegionEU868GetPhyParam+0x128>)
 800b0da:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800b0de:	f002 f80d 	bl	800d0fc <randr>
 800b0e2:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 800b0e6:	e7d3      	b.n	800b090 <RegionEU868GetPhyParam+0x68>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 800b0e8:	4b1a      	ldr	r3, [pc, #104]	; (800b154 <RegionEU868GetPhyParam+0x12c>)
 800b0ea:	e7d4      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 800b0ec:	4b15      	ldr	r3, [pc, #84]	; (800b144 <RegionEU868GetPhyParam+0x11c>)
 800b0ee:	681b      	ldr	r3, [r3, #0]
 800b0f0:	f503 7358 	add.w	r3, r3, #864	; 0x360
 800b0f4:	e7cf      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 800b0f6:	4b13      	ldr	r3, [pc, #76]	; (800b144 <RegionEU868GetPhyParam+0x11c>)
 800b0f8:	681b      	ldr	r3, [r3, #0]
 800b0fa:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 800b0fe:	e7ca      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 800b100:	2310      	movs	r3, #16
 800b102:	e7c8      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 800b104:	4b0f      	ldr	r3, [pc, #60]	; (800b144 <RegionEU868GetPhyParam+0x11c>)
 800b106:	681b      	ldr	r3, [r3, #0]
 800b108:	e7c5      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 800b10a:	f04f 4383 	mov.w	r3, #1098907648	; 0x41800000
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 800b10e:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
}
 800b110:	9800      	ldr	r0, [sp, #0]
 800b112:	b005      	add	sp, #20
 800b114:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 800b118:	4b0f      	ldr	r3, [pc, #60]	; (800b158 <RegionEU868GetPhyParam+0x130>)
 800b11a:	e7f8      	b.n	800b10e <RegionEU868GetPhyParam+0xe6>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 800b11c:	f240 2211 	movw	r2, #529	; 0x211
 800b120:	f8ad 2000 	strh.w	r2, [sp]
            phyParam.BeaconFormat.Rfu2Size = EU868_RFU2_SIZE;
 800b124:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 800b128:	e7f2      	b.n	800b110 <RegionEU868GetPhyParam+0xe8>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 800b12a:	2303      	movs	r3, #3
 800b12c:	e7b3      	b.n	800b096 <RegionEU868GetPhyParam+0x6e>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 800b12e:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800b132:	4a0a      	ldr	r2, [pc, #40]	; (800b15c <RegionEU868GetPhyParam+0x134>)
 800b134:	e7b6      	b.n	800b0a4 <RegionEU868GetPhyParam+0x7c>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 800b136:	490a      	ldr	r1, [pc, #40]	; (800b160 <RegionEU868GetPhyParam+0x138>)
 800b138:	f990 0001 	ldrsb.w	r0, [r0, #1]
 800b13c:	f7ff feae 	bl	800ae9c <RegionCommonGetBandwidth>
 800b140:	e7a6      	b.n	800b090 <RegionEU868GetPhyParam+0x68>
 800b142:	bf00      	nop
 800b144:	200010f4 	.word	0x200010f4
 800b148:	08010acb 	.word	0x08010acb
 800b14c:	08010ad3 	.word	0x08010ad3
 800b150:	fffffc18 	.word	0xfffffc18
 800b154:	33d3e608 	.word	0x33d3e608
 800b158:	4009999a 	.word	0x4009999a
 800b15c:	08010ac3 	.word	0x08010ac3
 800b160:	08010a9c 	.word	0x08010a9c

0800b164 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 800b164:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_EU868 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 800b166:	4b0b      	ldr	r3, [pc, #44]	; (800b194 <RegionEU868SetBandTxDone+0x30>)
 800b168:	681a      	ldr	r2, [r3, #0]
 800b16a:	7803      	ldrb	r3, [r0, #0]
 800b16c:	210c      	movs	r1, #12
 800b16e:	fb01 2303 	mla	r3, r1, r3, r2
 800b172:	7a5b      	ldrb	r3, [r3, #9]
 800b174:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 800b178:	4b07      	ldr	r3, [pc, #28]	; (800b198 <RegionEU868SetBandTxDone+0x34>)
 800b17a:	681d      	ldr	r5, [r3, #0]
 800b17c:	6903      	ldr	r3, [r0, #16]
 800b17e:	9300      	str	r3, [sp, #0]
 800b180:	68c3      	ldr	r3, [r0, #12]
 800b182:	7842      	ldrb	r2, [r0, #1]
 800b184:	6881      	ldr	r1, [r0, #8]
 800b186:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 800b18a:	f7ff fc17 	bl	800a9bc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_EU868 */
}
 800b18e:	b003      	add	sp, #12
 800b190:	bd30      	pop	{r4, r5, pc}
 800b192:	bf00      	nop
 800b194:	200010f4 	.word	0x200010f4
 800b198:	200010f0 	.word	0x200010f0

0800b19c <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 800b19c:	b530      	push	{r4, r5, lr}
 800b19e:	b0a5      	sub	sp, #148	; 0x94
 800b1a0:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 800b1a2:	2290      	movs	r2, #144	; 0x90
 800b1a4:	2100      	movs	r1, #0
 800b1a6:	4668      	mov	r0, sp
 800b1a8:	f004 fc14 	bl	800f9d4 <memset>
 800b1ac:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b1b0:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
 800b1b4:	f8ad 2078 	strh.w	r2, [sp, #120]	; 0x78
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 800b1b8:	7a22      	ldrb	r2, [r4, #8]
    Band_t bands[EU868_MAX_NB_BANDS] =
 800b1ba:	2364      	movs	r3, #100	; 0x64
 800b1bc:	210a      	movs	r1, #10
    switch( params->Type )
 800b1be:	2a01      	cmp	r2, #1
    Band_t bands[EU868_MAX_NB_BANDS] =
 800b1c0:	f8ad 3000 	strh.w	r3, [sp]
 800b1c4:	f8ad 3018 	strh.w	r3, [sp, #24]
 800b1c8:	f8ad 1048 	strh.w	r1, [sp, #72]	; 0x48
 800b1cc:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
    switch( params->Type )
 800b1d0:	d02e      	beq.n	800b230 <RegionEU868InitDefaults+0x94>
 800b1d2:	2a02      	cmp	r2, #2
 800b1d4:	d037      	beq.n	800b246 <RegionEU868InitDefaults+0xaa>
 800b1d6:	bb4a      	cbnz	r2, 800b22c <RegionEU868InitDefaults+0x90>
    {
        case INIT_TYPE_DEFAULTS:
        {
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 800b1d8:	6820      	ldr	r0, [r4, #0]
 800b1da:	b338      	cbz	r0, 800b22c <RegionEU868InitDefaults+0x90>
 800b1dc:	6863      	ldr	r3, [r4, #4]
 800b1de:	b32b      	cbz	r3, 800b22c <RegionEU868InitDefaults+0x90>
            {
                return;
            }

            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 800b1e0:	4a1e      	ldr	r2, [pc, #120]	; (800b25c <RegionEU868InitDefaults+0xc0>)
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 800b1e2:	4c1f      	ldr	r4, [pc, #124]	; (800b260 <RegionEU868InitDefaults+0xc4>)
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 800b1e4:	6010      	str	r0, [r2, #0]

            // Default bands
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 800b1e6:	4669      	mov	r1, sp
 800b1e8:	2290      	movs	r2, #144	; 0x90
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 800b1ea:	6023      	str	r3, [r4, #0]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 800b1ec:	f001 ffa2 	bl	800d134 <memcpy1>

            // Default channels
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 800b1f0:	4b1c      	ldr	r3, [pc, #112]	; (800b264 <RegionEU868InitDefaults+0xc8>)
 800b1f2:	6824      	ldr	r4, [r4, #0]
 800b1f4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800b1f8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 800b1fc:	f103 020c 	add.w	r2, r3, #12
 800b200:	ca07      	ldmia	r2, {r0, r1, r2}
 800b202:	f104 050c 	add.w	r5, r4, #12
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 800b206:	3318      	adds	r3, #24
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 800b208:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 800b20c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800b210:	f104 0518 	add.w	r5, r4, #24

            // Default ChannelsMask
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 800b214:	2307      	movs	r3, #7
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 800b216:	e885 0007 	stmia.w	r5, {r0, r1, r2}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 800b21a:	f8a4 336c 	strh.w	r3, [r4, #876]	; 0x36c

            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 800b21e:	2201      	movs	r2, #1
 800b220:	f504 715b 	add.w	r1, r4, #876	; 0x36c
 800b224:	f504 7058 	add.w	r0, r4, #864	; 0x360
            // Reset Channels Rx1Frequency to default 0
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
            // Update the channels mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 800b228:	f7ff fbb9 	bl	800a99e <RegionCommonChanMaskCopy>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 800b22c:	b025      	add	sp, #148	; 0x94
 800b22e:	bd30      	pop	{r4, r5, pc}
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 800b230:	4b0b      	ldr	r3, [pc, #44]	; (800b260 <RegionEU868InitDefaults+0xc4>)
 800b232:	6818      	ldr	r0, [r3, #0]
 800b234:	2300      	movs	r3, #0
 800b236:	6043      	str	r3, [r0, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 800b238:	6103      	str	r3, [r0, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 800b23a:	61c3      	str	r3, [r0, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 800b23c:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 800b240:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800b244:	e7f0      	b.n	800b228 <RegionEU868InitDefaults+0x8c>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 800b246:	4b06      	ldr	r3, [pc, #24]	; (800b260 <RegionEU868InitDefaults+0xc4>)
 800b248:	681b      	ldr	r3, [r3, #0]
 800b24a:	f8b3 2360 	ldrh.w	r2, [r3, #864]	; 0x360
 800b24e:	f8b3 136c 	ldrh.w	r1, [r3, #876]	; 0x36c
 800b252:	430a      	orrs	r2, r1
 800b254:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
            break;
 800b258:	e7e8      	b.n	800b22c <RegionEU868InitDefaults+0x90>
 800b25a:	bf00      	nop
 800b25c:	200010f0 	.word	0x200010f0
 800b260:	200010f4 	.word	0x200010f4
 800b264:	0801038c 	.word	0x0801038c

0800b268 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 800b268:	b507      	push	{r0, r1, r2, lr}
 800b26a:	290f      	cmp	r1, #15
 800b26c:	d809      	bhi.n	800b282 <RegionEU868Verify+0x1a>
 800b26e:	e8df f001 	tbb	[pc, r1]
 800b272:	080c      	.short	0x080c
 800b274:	1f080808 	.word	0x1f080808
 800b278:	1f081f15 	.word	0x1f081f15
 800b27c:	0808081f 	.word	0x0808081f
 800b280:	2108      	.short	0x2108
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
        }
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
 800b282:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 800b284:	b003      	add	sp, #12
 800b286:	f85d fb04 	ldr.w	pc, [sp], #4
            uint8_t band = 0;
 800b28a:	2300      	movs	r3, #0
            return VerifyRfFreq( verify->Frequency, &band );
 800b28c:	f10d 0107 	add.w	r1, sp, #7
 800b290:	6800      	ldr	r0, [r0, #0]
            uint8_t band = 0;
 800b292:	f88d 3007 	strb.w	r3, [sp, #7]
            return VerifyRfFreq( verify->Frequency, &band );
 800b296:	f7ff fe79 	bl	800af8c <VerifyRfFreq>
 800b29a:	e7f3      	b.n	800b284 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 800b29c:	2205      	movs	r2, #5
 800b29e:	f990 0000 	ldrsb.w	r0, [r0]
 800b2a2:	2100      	movs	r1, #0
 800b2a4:	f7ff fb3b 	bl	800a91e <RegionCommonValueInRange>
 800b2a8:	3800      	subs	r0, #0
 800b2aa:	bf18      	it	ne
 800b2ac:	2001      	movne	r0, #1
 800b2ae:	e7e9      	b.n	800b284 <RegionEU868Verify+0x1c>
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 800b2b0:	2207      	movs	r2, #7
 800b2b2:	e7f4      	b.n	800b29e <RegionEU868Verify+0x36>
            return EU868_DUTY_CYCLE_ENABLED;
 800b2b4:	2001      	movs	r0, #1
 800b2b6:	e7e5      	b.n	800b284 <RegionEU868Verify+0x1c>

0800b2b8 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 800b2b8:	b510      	push	{r4, lr}
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 800b2ba:	7904      	ldrb	r4, [r0, #4]
 800b2bc:	b11c      	cbz	r4, 800b2c6 <RegionEU868ChanMaskSet+0xe>
 800b2be:	2c01      	cmp	r4, #1
 800b2c0:	d00b      	beq.n	800b2da <RegionEU868ChanMaskSet+0x22>
 800b2c2:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 800b2c4:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 800b2c6:	4b0a      	ldr	r3, [pc, #40]	; (800b2f0 <RegionEU868ChanMaskSet+0x38>)
 800b2c8:	6801      	ldr	r1, [r0, #0]
 800b2ca:	681b      	ldr	r3, [r3, #0]
 800b2cc:	2201      	movs	r2, #1
 800b2ce:	f503 7058 	add.w	r0, r3, #864	; 0x360
 800b2d2:	f7ff fb64 	bl	800a99e <RegionCommonChanMaskCopy>
    return true;
 800b2d6:	2001      	movs	r0, #1
            break;
 800b2d8:	e7f4      	b.n	800b2c4 <RegionEU868ChanMaskSet+0xc>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 800b2da:	4b05      	ldr	r3, [pc, #20]	; (800b2f0 <RegionEU868ChanMaskSet+0x38>)
 800b2dc:	6801      	ldr	r1, [r0, #0]
 800b2de:	681b      	ldr	r3, [r3, #0]
 800b2e0:	4622      	mov	r2, r4
 800b2e2:	f503 705b 	add.w	r0, r3, #876	; 0x36c
 800b2e6:	f7ff fb5a 	bl	800a99e <RegionCommonChanMaskCopy>
    return true;
 800b2ea:	4620      	mov	r0, r4
            break;
 800b2ec:	e7ea      	b.n	800b2c4 <RegionEU868ChanMaskSet+0xc>
 800b2ee:	bf00      	nop
 800b2f0:	200010f4 	.word	0x200010f4

0800b2f4 <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 800b2f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 800b2f6:	2807      	cmp	r0, #7
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 800b2f8:	4d14      	ldr	r5, [pc, #80]	; (800b34c <RegionEU868ComputeRxWindowParameters+0x58>)
{
 800b2fa:	461c      	mov	r4, r3
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 800b2fc:	bfa8      	it	ge
 800b2fe:	2007      	movge	r0, #7
 800b300:	7058      	strb	r0, [r3, #1]
{
 800b302:	460e      	mov	r6, r1
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 800b304:	4629      	mov	r1, r5
{
 800b306:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 800b308:	f7ff fdc8 	bl	800ae9c <RegionCommonGetBandwidth>

    if( rxConfigParams->Datarate == DR_7 )
 800b30c:	f994 3001 	ldrsb.w	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 800b310:	70a0      	strb	r0, [r4, #2]
    if( rxConfigParams->Datarate == DR_7 )
 800b312:	2b07      	cmp	r3, #7
 800b314:	d113      	bne.n	800b33e <RegionEU868ComputeRxWindowParameters+0x4a>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 800b316:	2032      	movs	r0, #50	; 0x32
 800b318:	f7ff fcc4 	bl	800aca4 <RegionCommonComputeSymbolTimeFsk>
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 800b31c:	4b0c      	ldr	r3, [pc, #48]	; (800b350 <RegionEU868ComputeRxWindowParameters+0x5c>)
 800b31e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 800b320:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 800b322:	4798      	blx	r3
 800b324:	f104 020c 	add.w	r2, r4, #12
 800b328:	3408      	adds	r4, #8
 800b32a:	4603      	mov	r3, r0
 800b32c:	9201      	str	r2, [sp, #4]
 800b32e:	9400      	str	r4, [sp, #0]
 800b330:	463a      	mov	r2, r7
 800b332:	4631      	mov	r1, r6
 800b334:	4628      	mov	r0, r5
 800b336:	f7ff fcba 	bl	800acae <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 800b33a:	b003      	add	sp, #12
 800b33c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 800b33e:	4a05      	ldr	r2, [pc, #20]	; (800b354 <RegionEU868ComputeRxWindowParameters+0x60>)
 800b340:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 800b344:	5cd0      	ldrb	r0, [r2, r3]
 800b346:	f7ff fca5 	bl	800ac94 <RegionCommonComputeSymbolTimeLoRa>
 800b34a:	e7e7      	b.n	800b31c <RegionEU868ComputeRxWindowParameters+0x28>
 800b34c:	08010a9c 	.word	0x08010a9c
 800b350:	08010fe4 	.word	0x08010fe4
 800b354:	08010ac3 	.word	0x08010ac3

0800b358 <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 800b358:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 800b35c:	4f34      	ldr	r7, [pc, #208]	; (800b430 <RegionEU868RxConfig+0xd8>)
    int8_t dr = rxConfig->Datarate;
 800b35e:	f990 6001 	ldrsb.w	r6, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 800b362:	687b      	ldr	r3, [r7, #4]
    uint32_t frequency = rxConfig->Frequency;
 800b364:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
 800b368:	b08b      	sub	sp, #44	; 0x2c
 800b36a:	4604      	mov	r4, r0
 800b36c:	4689      	mov	r9, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 800b36e:	4798      	blx	r3
 800b370:	4605      	mov	r5, r0
 800b372:	2800      	cmp	r0, #0
 800b374:	d159      	bne.n	800b42a <RegionEU868RxConfig+0xd2>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 800b376:	7ce3      	ldrb	r3, [r4, #19]
 800b378:	b963      	cbnz	r3, 800b394 <RegionEU868RxConfig+0x3c>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 800b37a:	4a2e      	ldr	r2, [pc, #184]	; (800b434 <RegionEU868RxConfig+0xdc>)
 800b37c:	7823      	ldrb	r3, [r4, #0]
 800b37e:	6812      	ldr	r2, [r2, #0]
 800b380:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800b384:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 800b388:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 800b38c:	684b      	ldr	r3, [r1, #4]
 800b38e:	2b00      	cmp	r3, #0
 800b390:	bf18      	it	ne
 800b392:	4698      	movne	r8, r3
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 800b394:	4b28      	ldr	r3, [pc, #160]	; (800b438 <RegionEU868RxConfig+0xe0>)

    Radio.SetChannel( frequency );
 800b396:	4640      	mov	r0, r8
    phyDr = DataratesEU868[dr];
 800b398:	f913 b006 	ldrsb.w	fp, [r3, r6]
    Radio.SetChannel( frequency );
 800b39c:	68fb      	ldr	r3, [r7, #12]
 800b39e:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 800b3a0:	7ca3      	ldrb	r3, [r4, #18]
 800b3a2:	f8d7 a018 	ldr.w	sl, [r7, #24]
 800b3a6:	68a0      	ldr	r0, [r4, #8]
    {
        modem = MODEM_FSK;
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 800b3a8:	9309      	str	r3, [sp, #36]	; 0x24
    if( dr == DR_7 )
 800b3aa:	2e07      	cmp	r6, #7
 800b3ac:	d129      	bne.n	800b402 <RegionEU868RxConfig+0xaa>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 800b3ae:	2300      	movs	r3, #0
 800b3b0:	2201      	movs	r2, #1
 800b3b2:	e9cd 3204 	strd	r3, r2, [sp, #16]
 800b3b6:	4a21      	ldr	r2, [pc, #132]	; (800b43c <RegionEU868RxConfig+0xe4>)
 800b3b8:	9306      	str	r3, [sp, #24]
 800b3ba:	2105      	movs	r1, #5
 800b3bc:	e9cd 3307 	strd	r3, r3, [sp, #28]
 800b3c0:	e9cd 2100 	strd	r2, r1, [sp]
 800b3c4:	b280      	uxth	r0, r0
 800b3c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b3ca:	9002      	str	r0, [sp, #8]
 800b3cc:	9303      	str	r3, [sp, #12]
 800b3ce:	fb02 f20b 	mul.w	r2, r2, fp
 800b3d2:	f24c 3150 	movw	r1, #50000	; 0xc350
 800b3d6:	4618      	mov	r0, r3
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 800b3d8:	47d0      	blx	sl
    }

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 800b3da:	7c63      	ldrb	r3, [r4, #17]
 800b3dc:	b31b      	cbz	r3, 800b426 <RegionEU868RxConfig+0xce>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 800b3de:	4b18      	ldr	r3, [pc, #96]	; (800b440 <RegionEU868RxConfig+0xe8>)
    }
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 800b3e0:	5d99      	ldrb	r1, [r3, r6]
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 800b3e2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b3e4:	310d      	adds	r1, #13
 800b3e6:	b2c9      	uxtb	r1, r1
 800b3e8:	4628      	mov	r0, r5
 800b3ea:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 800b3ec:	7ce0      	ldrb	r0, [r4, #19]
 800b3ee:	4632      	mov	r2, r6
 800b3f0:	4641      	mov	r1, r8
 800b3f2:	f7ff fd65 	bl	800aec0 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 800b3f6:	f889 6000 	strb.w	r6, [r9]
    return true;
 800b3fa:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 800b3fc:	b00b      	add	sp, #44	; 0x2c
 800b3fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 800b402:	b283      	uxth	r3, r0
 800b404:	2100      	movs	r1, #0
 800b406:	2501      	movs	r5, #1
 800b408:	9302      	str	r3, [sp, #8]
 800b40a:	2308      	movs	r3, #8
 800b40c:	e9cd 1300 	strd	r1, r3, [sp]
 800b410:	e9cd 1507 	strd	r1, r5, [sp, #28]
 800b414:	e9cd 1105 	strd	r1, r1, [sp, #20]
 800b418:	e9cd 1103 	strd	r1, r1, [sp, #12]
 800b41c:	462b      	mov	r3, r5
 800b41e:	78a1      	ldrb	r1, [r4, #2]
 800b420:	465a      	mov	r2, fp
 800b422:	4628      	mov	r0, r5
 800b424:	e7d8      	b.n	800b3d8 <RegionEU868RxConfig+0x80>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 800b426:	4b07      	ldr	r3, [pc, #28]	; (800b444 <RegionEU868RxConfig+0xec>)
 800b428:	e7da      	b.n	800b3e0 <RegionEU868RxConfig+0x88>
        return false;
 800b42a:	2000      	movs	r0, #0
 800b42c:	e7e6      	b.n	800b3fc <RegionEU868RxConfig+0xa4>
 800b42e:	bf00      	nop
 800b430:	08010fe4 	.word	0x08010fe4
 800b434:	200010f4 	.word	0x200010f4
 800b438:	08010ac3 	.word	0x08010ac3
 800b43c:	00014585 	.word	0x00014585
 800b440:	08010ad3 	.word	0x08010ad3
 800b444:	08010acb 	.word	0x08010acb

0800b448 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 800b448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b44c:	4604      	mov	r4, r0
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b44e:	4d3d      	ldr	r5, [pc, #244]	; (800b544 <RegionEU868TxConfig+0xfc>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 800b450:	f990 3001 	ldrsb.w	r3, [r0, #1]
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b454:	6828      	ldr	r0, [r5, #0]
{
 800b456:	b08f      	sub	sp, #60	; 0x3c
 800b458:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 800b45c:	4a3a      	ldr	r2, [pc, #232]	; (800b548 <RegionEU868TxConfig+0x100>)
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b45e:	7821      	ldrb	r1, [r4, #0]
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 800b460:	56d3      	ldrsb	r3, [r2, r3]
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b462:	4a3a      	ldr	r2, [pc, #232]	; (800b54c <RegionEU868TxConfig+0x104>)
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 800b464:	930d      	str	r3, [sp, #52]	; 0x34
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b466:	260c      	movs	r6, #12
 800b468:	fb06 0101 	mla	r1, r6, r1, r0
 800b46c:	6817      	ldr	r7, [r2, #0]
 800b46e:	7a4a      	ldrb	r2, [r1, #9]
 800b470:	f994 0002 	ldrsb.w	r0, [r4, #2]
 800b474:	2118      	movs	r1, #24
 800b476:	fb01 7202 	mla	r2, r1, r2, r7

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800b47a:	4f35      	ldr	r7, [pc, #212]	; (800b550 <RegionEU868TxConfig+0x108>)
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b47c:	f992 1002 	ldrsb.w	r1, [r2, #2]
 800b480:	f7ff fd08 	bl	800ae94 <RegionCommonLimitTxPower>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 800b484:	4933      	ldr	r1, [pc, #204]	; (800b554 <RegionEU868TxConfig+0x10c>)
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 800b486:	4681      	mov	r9, r0
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 800b488:	f994 0001 	ldrsb.w	r0, [r4, #1]
 800b48c:	f7ff fd06 	bl	800ae9c <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 800b490:	68a2      	ldr	r2, [r4, #8]
 800b492:	6861      	ldr	r1, [r4, #4]
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 800b494:	4683      	mov	fp, r0
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 800b496:	4648      	mov	r0, r9
 800b498:	f7ff fc31 	bl	800acfe <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800b49c:	7822      	ldrb	r2, [r4, #0]
 800b49e:	6829      	ldr	r1, [r5, #0]
 800b4a0:	4356      	muls	r6, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 800b4a2:	4682      	mov	sl, r0
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800b4a4:	68fa      	ldr	r2, [r7, #12]
 800b4a6:	5988      	ldr	r0, [r1, r6]
 800b4a8:	4790      	blx	r2

    if( txConfig->Datarate == DR_7 )
 800b4aa:	f994 2001 	ldrsb.w	r2, [r4, #1]
 800b4ae:	69fb      	ldr	r3, [r7, #28]
 800b4b0:	2a07      	cmp	r2, #7
 800b4b2:	46a8      	mov	r8, r5
 800b4b4:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 800b4b8:	f04f 0500 	mov.w	r5, #0
 800b4bc:	469c      	mov	ip, r3
    { // High Speed FSK channel
        modem = MODEM_FSK;
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 800b4be:	e9cd 5207 	strd	r5, r2, [sp, #28]
 800b4c2:	e9cd 5505 	strd	r5, r5, [sp, #20]
    if( txConfig->Datarate == DR_7 )
 800b4c6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800b4c8:	d12c      	bne.n	800b524 <RegionEU868TxConfig+0xdc>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 800b4ca:	2201      	movs	r2, #1
 800b4cc:	e9cd 5203 	strd	r5, r2, [sp, #12]
 800b4d0:	2205      	movs	r2, #5
 800b4d2:	e9cd 5201 	strd	r5, r2, [sp, #4]
 800b4d6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b4da:	4353      	muls	r3, r2
 800b4dc:	9300      	str	r3, [sp, #0]
 800b4de:	f246 12a8 	movw	r2, #25000	; 0x61a8
 800b4e2:	465b      	mov	r3, fp
 800b4e4:	4651      	mov	r1, sl
 800b4e6:	4628      	mov	r0, r5
 800b4e8:	4666      	mov	r6, ip
 800b4ea:	47b0      	blx	r6
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
    }
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 800b4ec:	7821      	ldrb	r1, [r4, #0]
 800b4ee:	f8d8 2000 	ldr.w	r2, [r8]
 800b4f2:	230c      	movs	r3, #12
 800b4f4:	434b      	muls	r3, r1
 800b4f6:	f994 1001 	ldrsb.w	r1, [r4, #1]
 800b4fa:	58d0      	ldr	r0, [r2, r3]
 800b4fc:	f7ff fd0e 	bl	800af1c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 800b500:	89a1      	ldrh	r1, [r4, #12]
 800b502:	f994 0001 	ldrsb.w	r0, [r4, #1]
 800b506:	f7ff fd17 	bl	800af38 <GetTimeOnAir>
 800b50a:	9b0c      	ldr	r3, [sp, #48]	; 0x30

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 800b50c:	7b21      	ldrb	r1, [r4, #12]
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 800b50e:	6018      	str	r0, [r3, #0]
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 800b510:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800b512:	4628      	mov	r0, r5
 800b514:	4798      	blx	r3

    *txPower = txPowerLimited;
 800b516:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 800b518:	2001      	movs	r0, #1
    *txPower = txPowerLimited;
 800b51a:	f883 9000 	strb.w	r9, [r3]
}
 800b51e:	b00f      	add	sp, #60	; 0x3c
 800b520:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 800b524:	2601      	movs	r6, #1
 800b526:	2208      	movs	r2, #8
 800b528:	e9cd 5603 	strd	r5, r6, [sp, #12]
 800b52c:	e9cd 6201 	strd	r6, r2, [sp, #4]
 800b530:	9300      	str	r3, [sp, #0]
 800b532:	462a      	mov	r2, r5
 800b534:	465b      	mov	r3, fp
 800b536:	4665      	mov	r5, ip
 800b538:	4651      	mov	r1, sl
 800b53a:	4630      	mov	r0, r6
 800b53c:	47a8      	blx	r5
        modem = MODEM_LORA;
 800b53e:	4635      	mov	r5, r6
 800b540:	e7d4      	b.n	800b4ec <RegionEU868TxConfig+0xa4>
 800b542:	bf00      	nop
 800b544:	200010f4 	.word	0x200010f4
 800b548:	08010ac3 	.word	0x08010ac3
 800b54c:	200010f0 	.word	0x200010f0
 800b550:	08010fe4 	.word	0x08010fe4
 800b554:	08010a9c 	.word	0x08010a9c

0800b558 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 800b558:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b55c:	b08d      	sub	sp, #52	; 0x34
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 800b55e:	2400      	movs	r4, #0
{
 800b560:	4605      	mov	r5, r0
 800b562:	468a      	mov	sl, r1
 800b564:	4691      	mov	r9, r2
 800b566:	4698      	mov	r8, r3
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 800b568:	9402      	str	r4, [sp, #8]
 800b56a:	f8ad 400c 	strh.w	r4, [sp, #12]
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 800b56e:	f8ad 4006 	strh.w	r4, [sp, #6]
    uint8_t status = 0x07;
 800b572:	2607      	movs	r6, #7
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
                    {
                        chMask |= 1 << i;
 800b574:	f04f 0b01 	mov.w	fp, #1
    while( bytesProcessed < linkAdrReq->PayloadSize )
 800b578:	7a2b      	ldrb	r3, [r5, #8]
 800b57a:	42a3      	cmp	r3, r4
 800b57c:	d906      	bls.n	800b58c <RegionEU868LinkAdrReq+0x34>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 800b57e:	6868      	ldr	r0, [r5, #4]
 800b580:	a902      	add	r1, sp, #8
 800b582:	4420      	add	r0, r4
 800b584:	f7ff fb2c 	bl	800abe0 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 800b588:	2800      	cmp	r0, #0
 800b58a:	d154      	bne.n	800b636 <RegionEU868LinkAdrReq+0xde>
    getPhy.Attribute = PHY_MIN_TX_DR;
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionEU868GetPhyParam( &getPhy );

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 800b58c:	7aab      	ldrb	r3, [r5, #10]
 800b58e:	f88d 3015 	strb.w	r3, [sp, #21]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 800b592:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800b596:	f88d 3016 	strb.w	r3, [sp, #22]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 800b59a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 800b59e:	f88d 3017 	strb.w	r3, [sp, #23]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 800b5a2:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800b5a6:	f88d 3018 	strb.w	r3, [sp, #24]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 800b5aa:	7aeb      	ldrb	r3, [r5, #11]
 800b5ac:	f88d 3019 	strb.w	r3, [sp, #25]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 800b5b0:	7b2b      	ldrb	r3, [r5, #12]
 800b5b2:	f88d 301a 	strb.w	r3, [sp, #26]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 800b5b6:	7b6b      	ldrb	r3, [r5, #13]
 800b5b8:	f88d 301b 	strb.w	r3, [sp, #27]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 800b5bc:	2310      	movs	r3, #16
    linkAdrVerifyParams.Status = status;
 800b5be:	f88d 6014 	strb.w	r6, [sp, #20]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 800b5c2:	f88d 301c 	strb.w	r3, [sp, #28]
    linkAdrVerifyParams.ChannelsMask = &chMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 800b5c6:	4e3a      	ldr	r6, [pc, #232]	; (800b6b0 <RegionEU868LinkAdrReq+0x158>)
    linkAdrVerifyParams.ChannelsMask = &chMask;
 800b5c8:	f10d 0306 	add.w	r3, sp, #6
 800b5cc:	9308      	str	r3, [sp, #32]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 800b5ce:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800b5d2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 800b5d6:	6833      	ldr	r3, [r6, #0]
 800b5d8:	930a      	str	r3, [sp, #40]	; 0x28
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 800b5da:	2307      	movs	r3, #7
 800b5dc:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 800b5e0:	682b      	ldr	r3, [r5, #0]
 800b5e2:	9304      	str	r3, [sp, #16]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 800b5e4:	f10d 020a 	add.w	r2, sp, #10
 800b5e8:	ab02      	add	r3, sp, #8
 800b5ea:	f10d 0109 	add.w	r1, sp, #9
 800b5ee:	a804      	add	r0, sp, #16
 800b5f0:	f7ff fb10 	bl	800ac14 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 800b5f4:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 800b5f6:	4605      	mov	r5, r0
    if( status == 0x07 )
 800b5f8:	d10b      	bne.n	800b612 <RegionEU868LinkAdrReq+0xba>
    {
        // Set the channels mask to a default value
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 800b5fa:	6830      	ldr	r0, [r6, #0]
 800b5fc:	220c      	movs	r2, #12
 800b5fe:	2100      	movs	r1, #0
 800b600:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800b604:	f001 fdaa 	bl	800d15c <memset1>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 800b608:	6833      	ldr	r3, [r6, #0]
 800b60a:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 800b60e:	f8a3 2360 	strh.w	r2, [r3, #864]	; 0x360
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 800b612:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800b616:	f88a 3000 	strb.w	r3, [sl]
    *txPowOut = linkAdrParams.TxPower;
 800b61a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 800b61e:	f889 3000 	strb.w	r3, [r9]
    *nbRepOut = linkAdrParams.NbRep;
 800b622:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800b626:	f888 3000 	strb.w	r3, [r8]
    *nbBytesParsed = bytesProcessed;
 800b62a:	9b16      	ldr	r3, [sp, #88]	; 0x58

#endif /* REGION_EU868 */
    return status;
}
 800b62c:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 800b62e:	701c      	strb	r4, [r3, #0]
}
 800b630:	b00d      	add	sp, #52	; 0x34
 800b632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 800b636:	f89d 300b 	ldrb.w	r3, [sp, #11]
        chMask = linkAdrParams.ChMask;
 800b63a:	f8bd 700c 	ldrh.w	r7, [sp, #12]
 800b63e:	f8ad 7006 	strh.w	r7, [sp, #6]
        bytesProcessed += nextIndex;
 800b642:	4404      	add	r4, r0
 800b644:	b2e4      	uxtb	r4, r4
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 800b646:	b9f3      	cbnz	r3, 800b686 <RegionEU868LinkAdrReq+0x12e>
 800b648:	b317      	cbz	r7, 800b690 <RegionEU868LinkAdrReq+0x138>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 800b64a:	4a19      	ldr	r2, [pc, #100]	; (800b6b0 <RegionEU868LinkAdrReq+0x158>)
 800b64c:	2000      	movs	r0, #0
 800b64e:	6811      	ldr	r1, [r2, #0]
 800b650:	2607      	movs	r6, #7
 800b652:	4602      	mov	r2, r0
 800b654:	f04f 0c0c 	mov.w	ip, #12
                if( linkAdrParams.ChMaskCtrl == 6 )
 800b658:	2b06      	cmp	r3, #6
 800b65a:	d11b      	bne.n	800b694 <RegionEU868LinkAdrReq+0x13c>
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 800b65c:	fb0c fe00 	mul.w	lr, ip, r0
 800b660:	f851 e00e 	ldr.w	lr, [r1, lr]
 800b664:	f1be 0f00 	cmp.w	lr, #0
 800b668:	d004      	beq.n	800b674 <RegionEU868LinkAdrReq+0x11c>
                        chMask |= 1 << i;
 800b66a:	fa0b f200 	lsl.w	r2, fp, r0
 800b66e:	4317      	orrs	r7, r2
 800b670:	b2bf      	uxth	r7, r7
 800b672:	2201      	movs	r2, #1
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 800b674:	3001      	adds	r0, #1
 800b676:	2810      	cmp	r0, #16
 800b678:	d1ee      	bne.n	800b658 <RegionEU868LinkAdrReq+0x100>
 800b67a:	2a00      	cmp	r2, #0
 800b67c:	f43f af7c 	beq.w	800b578 <RegionEU868LinkAdrReq+0x20>
 800b680:	f8ad 7006 	strh.w	r7, [sp, #6]
 800b684:	e778      	b.n	800b578 <RegionEU868LinkAdrReq+0x20>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 800b686:	1e5a      	subs	r2, r3, #1
 800b688:	2a04      	cmp	r2, #4
 800b68a:	d901      	bls.n	800b690 <RegionEU868LinkAdrReq+0x138>
 800b68c:	2b06      	cmp	r3, #6
 800b68e:	d0dc      	beq.n	800b64a <RegionEU868LinkAdrReq+0xf2>
            status &= 0xFE; // Channel mask KO
 800b690:	2606      	movs	r6, #6
 800b692:	e771      	b.n	800b578 <RegionEU868LinkAdrReq+0x20>
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 800b694:	fa47 fe00 	asr.w	lr, r7, r0
 800b698:	f01e 0f01 	tst.w	lr, #1
 800b69c:	d0ea      	beq.n	800b674 <RegionEU868LinkAdrReq+0x11c>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 800b69e:	fb0c fe00 	mul.w	lr, ip, r0
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 800b6a2:	f851 e00e 	ldr.w	lr, [r1, lr]
                        status &= 0xFE; // Channel mask KO
 800b6a6:	f1be 0f00 	cmp.w	lr, #0
 800b6aa:	bf08      	it	eq
 800b6ac:	2606      	moveq	r6, #6
 800b6ae:	e7e1      	b.n	800b674 <RegionEU868LinkAdrReq+0x11c>
 800b6b0:	200010f4 	.word	0x200010f4

0800b6b4 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 800b6b4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 800b6b6:	2600      	movs	r6, #0
{
 800b6b8:	4605      	mov	r5, r0

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 800b6ba:	f10d 0107 	add.w	r1, sp, #7
 800b6be:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 800b6c0:	f88d 6007 	strb.w	r6, [sp, #7]
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 800b6c4:	f7ff fc62 	bl	800af8c <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 800b6c8:	2207      	movs	r2, #7
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 800b6ca:	42b0      	cmp	r0, r6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 800b6cc:	4631      	mov	r1, r6
 800b6ce:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 800b6d2:	bf14      	ite	ne
 800b6d4:	2407      	movne	r4, #7
 800b6d6:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 800b6d8:	f7ff f921 	bl	800a91e <RegionCommonValueInRange>
 800b6dc:	b908      	cbnz	r0, 800b6e2 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 800b6de:	f004 0405 	and.w	r4, r4, #5
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 800b6e2:	f995 0001 	ldrsb.w	r0, [r5, #1]
 800b6e6:	2205      	movs	r2, #5
 800b6e8:	2100      	movs	r1, #0
 800b6ea:	f7ff f918 	bl	800a91e <RegionCommonValueInRange>
 800b6ee:	b908      	cbnz	r0, 800b6f4 <RegionEU868RxParamSetupReq+0x40>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 800b6f0:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_EU868 */
    return status;
}
 800b6f4:	4620      	mov	r0, r4
 800b6f6:	b002      	add	sp, #8
 800b6f8:	bd70      	pop	{r4, r5, r6, pc}

0800b6fa <RegionEU868TxParamSetupReq>:

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
}
 800b6fa:	f04f 30ff 	mov.w	r0, #4294967295
 800b6fe:	4770      	bx	lr

0800b700 <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 800b700:	b513      	push	{r0, r1, r4, lr}
 800b702:	4604      	mov	r4, r0
    uint8_t status = 0x03;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 800b704:	2300      	movs	r3, #0

    // Verify if the frequency is supported
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 800b706:	f10d 0107 	add.w	r1, sp, #7
 800b70a:	6840      	ldr	r0, [r0, #4]
    uint8_t band = 0;
 800b70c:	f88d 3007 	strb.w	r3, [sp, #7]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 800b710:	f7ff fc3c 	bl	800af8c <VerifyRfFreq>
 800b714:	7823      	ldrb	r3, [r4, #0]
 800b716:	4a0b      	ldr	r2, [pc, #44]	; (800b744 <RegionEU868DlChannelReq+0x44>)
 800b718:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800b71c:	6812      	ldr	r2, [r2, #0]
 800b71e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
    {
        status &= 0xFE;
    }

    // Verify if an uplink frequency exists
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 800b722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 800b726:	2800      	cmp	r0, #0
        status &= 0xFE;
 800b728:	bf14      	ite	ne
 800b72a:	2003      	movne	r0, #3
 800b72c:	2002      	moveq	r0, #2
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 800b72e:	b91b      	cbnz	r3, 800b738 <RegionEU868DlChannelReq+0x38>
    {
        status &= 0xFD;
 800b730:	f000 0001 	and.w	r0, r0, #1
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 800b734:	b002      	add	sp, #8
 800b736:	bd10      	pop	{r4, pc}
    if( status == 0x03 )
 800b738:	2803      	cmp	r0, #3
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 800b73a:	bf06      	itte	eq
 800b73c:	6863      	ldreq	r3, [r4, #4]
 800b73e:	604b      	streq	r3, [r1, #4]
 800b740:	2002      	movne	r0, #2
 800b742:	e7f7      	b.n	800b734 <RegionEU868DlChannelReq+0x34>
 800b744:	200010f4 	.word	0x200010f4

0800b748 <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 800b748:	4770      	bx	lr
	...

0800b74c <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 800b74c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 800b750:	4d39      	ldr	r5, [pc, #228]	; (800b838 <RegionEU868NextChannel+0xec>)
{
 800b752:	4604      	mov	r4, r0
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 800b754:	6828      	ldr	r0, [r5, #0]
{
 800b756:	b096      	sub	sp, #88	; 0x58
 800b758:	460e      	mov	r6, r1
 800b75a:	4690      	mov	r8, r2
    uint8_t nbEnabledChannels = 0;
 800b75c:	2100      	movs	r1, #0
{
 800b75e:	461f      	mov	r7, r3
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 800b760:	2201      	movs	r2, #1
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 800b762:	2307      	movs	r3, #7
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 800b764:	f500 7058 	add.w	r0, r0, #864	; 0x360
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 800b768:	e9cd 1104 	strd	r1, r1, [sp, #16]
 800b76c:	e9cd 1106 	strd	r1, r1, [sp, #24]
    uint8_t nbEnabledChannels = 0;
 800b770:	f88d 100c 	strb.w	r1, [sp, #12]
    uint8_t nbRestrictedChannels = 0;
 800b774:	f88d 100d 	strb.w	r1, [sp, #13]
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 800b778:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 800b77c:	f7ff f8f1 	bl	800a962 <RegionCommonCountChannels>
 800b780:	b930      	cbnz	r0, 800b790 <RegionEU868NextChannel+0x44>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 800b782:	682a      	ldr	r2, [r5, #0]
 800b784:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 800b788:	f043 0307 	orr.w	r3, r3, #7
 800b78c:	f8a2 3360 	strh.w	r3, [r2, #864]	; 0x360
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 800b790:	682a      	ldr	r2, [r5, #0]
    countChannelsParams.Joined = nextChanParams->Joined;
 800b792:	7a63      	ldrb	r3, [r4, #9]
 800b794:	f88d 3020 	strb.w	r3, [sp, #32]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 800b798:	f502 7158 	add.w	r1, r2, #864	; 0x360
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 800b79c:	e9cd 1209 	strd	r1, r2, [sp, #36]	; 0x24
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 800b7a0:	4a26      	ldr	r2, [pc, #152]	; (800b83c <RegionEU868NextChannel+0xf0>)
    countChannelsParams.Datarate = nextChanParams->Datarate;
 800b7a2:	f994 3008 	ldrsb.w	r3, [r4, #8]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 800b7a6:	6812      	ldr	r2, [r2, #0]
 800b7a8:	920b      	str	r2, [sp, #44]	; 0x2c
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 800b7aa:	2210      	movs	r2, #16
 800b7ac:	f8ad 2030 	strh.w	r2, [sp, #48]	; 0x30
    countChannelsParams.JoinChannels = &joinChannels;
 800b7b0:	f10d 020e 	add.w	r2, sp, #14
 800b7b4:	920d      	str	r2, [sp, #52]	; 0x34

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 800b7b6:	6822      	ldr	r2, [r4, #0]
 800b7b8:	920e      	str	r2, [sp, #56]	; 0x38
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 800b7ba:	6862      	ldr	r2, [r4, #4]
 800b7bc:	920f      	str	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 800b7be:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 800b7c2:	7aa2      	ldrb	r2, [r4, #10]
 800b7c4:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 800b7c8:	2206      	movs	r2, #6
 800b7ca:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 800b7ce:	aa11      	add	r2, sp, #68	; 0x44
 800b7d0:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 800b7d4:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800b7d6:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 800b7d8:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800b7dc:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 800b7de:	f88d 204c 	strb.w	r2, [sp, #76]	; 0x4c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800b7e2:	f7ff fba9 	bl	800af38 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 800b7e6:	ab08      	add	r3, sp, #32
 800b7e8:	9315      	str	r3, [sp, #84]	; 0x54

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 800b7ea:	f10d 030d 	add.w	r3, sp, #13
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800b7ee:	9014      	str	r0, [sp, #80]	; 0x50
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 800b7f0:	9300      	str	r3, [sp, #0]
 800b7f2:	f8cd 8004 	str.w	r8, [sp, #4]
 800b7f6:	ab03      	add	r3, sp, #12
 800b7f8:	aa04      	add	r2, sp, #16
 800b7fa:	4639      	mov	r1, r7
 800b7fc:	a80e      	add	r0, sp, #56	; 0x38
 800b7fe:	f7ff faea 	bl	800add6 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 800b802:	4604      	mov	r4, r0
 800b804:	b968      	cbnz	r0, 800b822 <RegionEU868NextChannel+0xd6>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 800b806:	f89d 100c 	ldrb.w	r1, [sp, #12]
 800b80a:	3901      	subs	r1, #1
 800b80c:	f001 fc76 	bl	800d0fc <randr>
 800b810:	ab16      	add	r3, sp, #88	; 0x58
 800b812:	4418      	add	r0, r3
 800b814:	f810 3c48 	ldrb.w	r3, [r0, #-72]
 800b818:	7033      	strb	r3, [r6, #0]
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 800b81a:	4620      	mov	r0, r4
 800b81c:	b016      	add	sp, #88	; 0x58
 800b81e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 800b822:	280c      	cmp	r0, #12
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 800b824:	bf01      	itttt	eq
 800b826:	682a      	ldreq	r2, [r5, #0]
 800b828:	f8b2 3360 	ldrheq.w	r3, [r2, #864]	; 0x360
 800b82c:	f043 0307 	orreq.w	r3, r3, #7
 800b830:	f8a2 3360 	strheq.w	r3, [r2, #864]	; 0x360
 800b834:	e7f1      	b.n	800b81a <RegionEU868NextChannel+0xce>
 800b836:	bf00      	nop
 800b838:	200010f4 	.word	0x200010f4
 800b83c:	200010f0 	.word	0x200010f0

0800b840 <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 800b840:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_EU868 )
    uint8_t band = 0;
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 800b842:	7906      	ldrb	r6, [r0, #4]
    uint8_t band = 0;
 800b844:	2700      	movs	r7, #0

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 800b846:	2e02      	cmp	r6, #2
{
 800b848:	4605      	mov	r5, r0
    uint8_t band = 0;
 800b84a:	f88d 7007 	strb.w	r7, [sp, #7]
    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 800b84e:	d802      	bhi.n	800b856 <RegionEU868ChannelAdd+0x16>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 800b850:	2006      	movs	r0, #6
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
    return LORAMAC_STATUS_OK;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 800b852:	b003      	add	sp, #12
 800b854:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( id >= EU868_MAX_NB_CHANNELS )
 800b856:	2e0f      	cmp	r6, #15
 800b858:	d82d      	bhi.n	800b8b6 <RegionEU868ChannelAdd+0x76>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 800b85a:	6803      	ldr	r3, [r0, #0]
 800b85c:	7a18      	ldrb	r0, [r3, #8]
 800b85e:	f340 0003 	sbfx	r0, r0, #0, #4
 800b862:	2207      	movs	r2, #7
 800b864:	4639      	mov	r1, r7
 800b866:	b240      	sxtb	r0, r0
 800b868:	f7ff f859 	bl	800a91e <RegionCommonValueInRange>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 800b86c:	682b      	ldr	r3, [r5, #0]
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 800b86e:	4604      	mov	r4, r0
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 800b870:	7a18      	ldrb	r0, [r3, #8]
 800b872:	f340 1003 	sbfx	r0, r0, #4, #4
 800b876:	2207      	movs	r2, #7
 800b878:	4639      	mov	r1, r7
 800b87a:	b240      	sxtb	r0, r0
 800b87c:	f7ff f84f 	bl	800a91e <RegionCommonValueInRange>
 800b880:	b1b8      	cbz	r0, 800b8b2 <RegionEU868ChannelAdd+0x72>
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 800b882:	fab4 f484 	clz	r4, r4
 800b886:	0964      	lsrs	r4, r4, #5
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 800b888:	6828      	ldr	r0, [r5, #0]
 800b88a:	7a03      	ldrb	r3, [r0, #8]
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 800b88c:	6800      	ldr	r0, [r0, #0]
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 800b88e:	f343 0203 	sbfx	r2, r3, #0, #4
 800b892:	f343 1303 	sbfx	r3, r3, #4, #4
 800b896:	b252      	sxtb	r2, r2
 800b898:	b25b      	sxtb	r3, r3
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 800b89a:	f10d 0107 	add.w	r1, sp, #7
        drInvalid = true;
 800b89e:	429a      	cmp	r2, r3
 800b8a0:	bfc8      	it	gt
 800b8a2:	2401      	movgt	r4, #1
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 800b8a4:	f7ff fb72 	bl	800af8c <VerifyRfFreq>
 800b8a8:	b948      	cbnz	r0, 800b8be <RegionEU868ChannelAdd+0x7e>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 800b8aa:	2c00      	cmp	r4, #0
 800b8ac:	d1d0      	bne.n	800b850 <RegionEU868ChannelAdd+0x10>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 800b8ae:	2004      	movs	r0, #4
 800b8b0:	e7cf      	b.n	800b852 <RegionEU868ChannelAdd+0x12>
        drInvalid = true;
 800b8b2:	2401      	movs	r4, #1
 800b8b4:	e7e8      	b.n	800b888 <RegionEU868ChannelAdd+0x48>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 800b8b6:	2003      	movs	r0, #3
 800b8b8:	e7cb      	b.n	800b852 <RegionEU868ChannelAdd+0x12>
        return LORAMAC_STATUS_DATARATE_INVALID;
 800b8ba:	2005      	movs	r0, #5
 800b8bc:	e7c9      	b.n	800b852 <RegionEU868ChannelAdd+0x12>
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 800b8be:	2c00      	cmp	r4, #0
 800b8c0:	d1fb      	bne.n	800b8ba <RegionEU868ChannelAdd+0x7a>
    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 800b8c2:	4f0d      	ldr	r7, [pc, #52]	; (800b8f8 <RegionEU868ChannelAdd+0xb8>)
 800b8c4:	6829      	ldr	r1, [r5, #0]
 800b8c6:	683b      	ldr	r3, [r7, #0]
 800b8c8:	eb06 0046 	add.w	r0, r6, r6, lsl #1
 800b8cc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800b8d0:	220c      	movs	r2, #12
 800b8d2:	f001 fc2f 	bl	800d134 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 800b8d6:	683a      	ldr	r2, [r7, #0]
 800b8d8:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800b8dc:	230c      	movs	r3, #12
 800b8de:	fb03 2306 	mla	r3, r3, r6, r2
    return LORAMAC_STATUS_OK;
 800b8e2:	4620      	mov	r0, r4
    RegionNvmGroup2->Channels[id].Band = band;
 800b8e4:	7259      	strb	r1, [r3, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 800b8e6:	2301      	movs	r3, #1
 800b8e8:	fa03 f606 	lsl.w	r6, r3, r6
 800b8ec:	f8b2 3360 	ldrh.w	r3, [r2, #864]	; 0x360
 800b8f0:	431e      	orrs	r6, r3
 800b8f2:	f8a2 6360 	strh.w	r6, [r2, #864]	; 0x360
    return LORAMAC_STATUS_OK;
 800b8f6:	e7ac      	b.n	800b852 <RegionEU868ChannelAdd+0x12>
 800b8f8:	200010f4 	.word	0x200010f4

0800b8fc <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 800b8fc:	b410      	push	{r4}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 800b8fe:	7801      	ldrb	r1, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 800b900:	2902      	cmp	r1, #2
 800b902:	d90e      	bls.n	800b922 <RegionEU868ChannelsRemove+0x26>
    {
        return false;
    }

    // Remove the channel from the list of channels
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 800b904:	4b08      	ldr	r3, [pc, #32]	; (800b928 <RegionEU868ChannelsRemove+0x2c>)
 800b906:	6818      	ldr	r0, [r3, #0]
 800b908:	230c      	movs	r3, #12
 800b90a:	434b      	muls	r3, r1
 800b90c:	18c4      	adds	r4, r0, r3
 800b90e:	2200      	movs	r2, #0
 800b910:	50c2      	str	r2, [r0, r3]
 800b912:	e9c4 2201 	strd	r2, r2, [r4, #4]

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 800b916:	f500 7058 	add.w	r0, r0, #864	; 0x360
#else
    return false;
#endif /* REGION_EU868 */
}
 800b91a:	bc10      	pop	{r4}
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 800b91c:	2210      	movs	r2, #16
 800b91e:	f7ff b807 	b.w	800a930 <RegionCommonChanDisable>
}
 800b922:	2000      	movs	r0, #0
 800b924:	bc10      	pop	{r4}
 800b926:	4770      	bx	lr
 800b928:	200010f4 	.word	0x200010f4

0800b92c <RegionEU868ApplyCFList>:
{
 800b92c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b930:	b086      	sub	sp, #24
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 800b932:	2350      	movs	r3, #80	; 0x50
 800b934:	f88d 3014 	strb.w	r3, [sp, #20]
    if( applyCFList->Size != 16 )
 800b938:	7903      	ldrb	r3, [r0, #4]
 800b93a:	2b10      	cmp	r3, #16
{
 800b93c:	4607      	mov	r7, r0
    if( applyCFList->Size != 16 )
 800b93e:	d130      	bne.n	800b9a2 <RegionEU868ApplyCFList+0x76>
    if( applyCFList->Payload[15] != 0 )
 800b940:	6803      	ldr	r3, [r0, #0]
 800b942:	7bdd      	ldrb	r5, [r3, #15]
 800b944:	bb6d      	cbnz	r5, 800b9a2 <RegionEU868ApplyCFList+0x76>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 800b946:	2403      	movs	r4, #3
            newChannel.Frequency = 0;
 800b948:	46a8      	mov	r8, r5
            newChannel.Frequency *= 100;
 800b94a:	2664      	movs	r6, #100	; 0x64
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 800b94c:	2c07      	cmp	r4, #7
 800b94e:	d814      	bhi.n	800b97a <RegionEU868ApplyCFList+0x4e>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 800b950:	683a      	ldr	r2, [r7, #0]
 800b952:	5d53      	ldrb	r3, [r2, r5]
 800b954:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 800b956:	442a      	add	r2, r5
 800b958:	7851      	ldrb	r1, [r2, #1]
 800b95a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800b95e:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 800b960:	7892      	ldrb	r2, [r2, #2]
 800b962:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            newChannel.Frequency *= 100;
 800b966:	4373      	muls	r3, r6
            newChannel.Rx1Frequency = 0;
 800b968:	e9cd 3803 	strd	r3, r8, [sp, #12]
        if( newChannel.Frequency != 0 )
 800b96c:	b963      	cbnz	r3, 800b988 <RegionEU868ApplyCFList+0x5c>
            RegionEU868ChannelsRemove( &channelRemove );
 800b96e:	4668      	mov	r0, sp
            channelRemove.ChannelId = chanIdx;
 800b970:	f88d 4000 	strb.w	r4, [sp]
            RegionEU868ChannelsRemove( &channelRemove );
 800b974:	f7ff ffc2 	bl	800b8fc <RegionEU868ChannelsRemove>
 800b978:	e00d      	b.n	800b996 <RegionEU868ApplyCFList+0x6a>
            newChannel.Frequency = 0;
 800b97a:	f8cd 800c 	str.w	r8, [sp, #12]
            newChannel.DrRange.Value = 0;
 800b97e:	f88d 8014 	strb.w	r8, [sp, #20]
            newChannel.Rx1Frequency = 0;
 800b982:	f8cd 8010 	str.w	r8, [sp, #16]
        if( newChannel.Frequency != 0 )
 800b986:	e7f2      	b.n	800b96e <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 800b988:	ab03      	add	r3, sp, #12
            RegionEU868ChannelAdd( &channelAdd );
 800b98a:	a801      	add	r0, sp, #4
            channelAdd.NewChannel = &newChannel;
 800b98c:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 800b98e:	f88d 4008 	strb.w	r4, [sp, #8]
            RegionEU868ChannelAdd( &channelAdd );
 800b992:	f7ff ff55 	bl	800b840 <RegionEU868ChannelAdd>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 800b996:	3401      	adds	r4, #1
 800b998:	b2e4      	uxtb	r4, r4
 800b99a:	2c10      	cmp	r4, #16
 800b99c:	f105 0503 	add.w	r5, r5, #3
 800b9a0:	d1d4      	bne.n	800b94c <RegionEU868ApplyCFList+0x20>
}
 800b9a2:	b006      	add	sp, #24
 800b9a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800b9a8 <RegionEU868NewChannelReq>:
{
 800b9a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if( newChannelReq->NewChannel->Frequency == 0 )
 800b9aa:	6802      	ldr	r2, [r0, #0]
 800b9ac:	7903      	ldrb	r3, [r0, #4]
 800b9ae:	6811      	ldr	r1, [r2, #0]
 800b9b0:	b951      	cbnz	r1, 800b9c8 <RegionEU868NewChannelReq+0x20>
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 800b9b2:	a801      	add	r0, sp, #4
        channelRemove.ChannelId = newChannelReq->ChannelId;
 800b9b4:	f88d 3004 	strb.w	r3, [sp, #4]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 800b9b8:	f7ff ffa0 	bl	800b8fc <RegionEU868ChannelsRemove>
 800b9bc:	b978      	cbnz	r0, 800b9de <RegionEU868NewChannelReq+0x36>
            status &= 0xFC;
 800b9be:	2000      	movs	r0, #0
}
 800b9c0:	b240      	sxtb	r0, r0
 800b9c2:	b005      	add	sp, #20
 800b9c4:	f85d fb04 	ldr.w	pc, [sp], #4
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 800b9c8:	a802      	add	r0, sp, #8
        channelAdd.NewChannel = newChannelReq->NewChannel;
 800b9ca:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 800b9cc:	f88d 300c 	strb.w	r3, [sp, #12]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 800b9d0:	f7ff ff36 	bl	800b840 <RegionEU868ChannelAdd>
 800b9d4:	2806      	cmp	r0, #6
 800b9d6:	d8f2      	bhi.n	800b9be <RegionEU868NewChannelReq+0x16>
 800b9d8:	4b02      	ldr	r3, [pc, #8]	; (800b9e4 <RegionEU868NewChannelReq+0x3c>)
 800b9da:	5c18      	ldrb	r0, [r3, r0]
 800b9dc:	e7f0      	b.n	800b9c0 <RegionEU868NewChannelReq+0x18>
    uint8_t status = 0x03;
 800b9de:	2003      	movs	r0, #3
 800b9e0:	e7ee      	b.n	800b9c0 <RegionEU868NewChannelReq+0x18>
 800b9e2:	bf00      	nop
 800b9e4:	08010abc 	.word	0x08010abc

0800b9e8 <RegionEU868SetContinuousWave>:

void RegionEU868SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 800b9e8:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 800b9ea:	4b11      	ldr	r3, [pc, #68]	; (800ba30 <RegionEU868SetContinuousWave+0x48>)
 800b9ec:	4e11      	ldr	r6, [pc, #68]	; (800ba34 <RegionEU868SetContinuousWave+0x4c>)
 800b9ee:	6819      	ldr	r1, [r3, #0]
 800b9f0:	7802      	ldrb	r2, [r0, #0]
 800b9f2:	6833      	ldr	r3, [r6, #0]
 800b9f4:	250c      	movs	r5, #12
 800b9f6:	fb05 3202 	mla	r2, r5, r2, r3
{
 800b9fa:	4604      	mov	r4, r0
    int8_t txPowerLimited = RegionCommonLimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower );
 800b9fc:	7a53      	ldrb	r3, [r2, #9]
 800b9fe:	f990 0002 	ldrsb.w	r0, [r0, #2]
 800ba02:	2218      	movs	r2, #24
 800ba04:	fb02 1303 	mla	r3, r2, r3, r1
 800ba08:	f993 1002 	ldrsb.w	r1, [r3, #2]
 800ba0c:	f7ff fa42 	bl	800ae94 <RegionCommonLimitTxPower>
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 800ba10:	7822      	ldrb	r2, [r4, #0]
 800ba12:	6833      	ldr	r3, [r6, #0]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 800ba14:	6861      	ldr	r1, [r4, #4]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 800ba16:	4355      	muls	r5, r2
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 800ba18:	68a2      	ldr	r2, [r4, #8]
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 800ba1a:	595d      	ldr	r5, [r3, r5]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 800ba1c:	f7ff f96f 	bl	800acfe <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800ba20:	4b05      	ldr	r3, [pc, #20]	; (800ba38 <RegionEU868SetContinuousWave+0x50>)
 800ba22:	89a2      	ldrh	r2, [r4, #12]
 800ba24:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, continuousWave->MaxEirp, continuousWave->AntennaGain );
 800ba26:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800ba28:	4628      	mov	r0, r5
#endif /* REGION_EU868 */
}
 800ba2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800ba2e:	4718      	bx	r3
 800ba30:	200010f0 	.word	0x200010f0
 800ba34:	200010f4 	.word	0x200010f4
 800ba38:	08010fe4 	.word	0x08010fe4

0800ba3c <RegionEU868ApplyDrOffset>:

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 800ba3c:	1a88      	subs	r0, r1, r2
 800ba3e:	b240      	sxtb	r0, r0

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 800ba40:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_EU868 */
}
 800ba44:	b2c0      	uxtb	r0, r0
 800ba46:	4770      	bx	lr

0800ba48 <GetTimeOnAir>:
    }
    return true;
}

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 800ba48:	b530      	push	{r4, r5, lr}
    int8_t phyDr = DataratesUS915[datarate];
 800ba4a:	4b0b      	ldr	r3, [pc, #44]	; (800ba78 <GetTimeOnAir+0x30>)
{
 800ba4c:	b085      	sub	sp, #20
 800ba4e:	460c      	mov	r4, r1
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 800ba50:	490a      	ldr	r1, [pc, #40]	; (800ba7c <GetTimeOnAir+0x34>)
    int8_t phyDr = DataratesUS915[datarate];
 800ba52:	561d      	ldrsb	r5, [r3, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 800ba54:	f7ff fa22 	bl	800ae9c <RegionCommonGetBandwidth>

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 800ba58:	2208      	movs	r2, #8
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 800ba5a:	4601      	mov	r1, r0
    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 800ba5c:	2000      	movs	r0, #0
 800ba5e:	e9cd 2000 	strd	r2, r0, [sp]
 800ba62:	4a07      	ldr	r2, [pc, #28]	; (800ba80 <GetTimeOnAir+0x38>)
 800ba64:	2301      	movs	r3, #1
 800ba66:	b2e4      	uxtb	r4, r4
 800ba68:	9402      	str	r4, [sp, #8]
 800ba6a:	9303      	str	r3, [sp, #12]
 800ba6c:	6a54      	ldr	r4, [r2, #36]	; 0x24
 800ba6e:	4618      	mov	r0, r3
 800ba70:	462a      	mov	r2, r5
 800ba72:	47a0      	blx	r4
}
 800ba74:	b005      	add	sp, #20
 800ba76:	bd30      	pop	{r4, r5, pc}
 800ba78:	08010b30 	.word	0x08010b30
 800ba7c:	08010adc 	.word	0x08010adc
 800ba80:	08010fe4 	.word	0x08010fe4

0800ba84 <VerifyRfFreq>:
    if( Radio.CheckRfFrequency( freq ) == false )
 800ba84:	4b0b      	ldr	r3, [pc, #44]	; (800bab4 <VerifyRfFreq+0x30>)
{
 800ba86:	b510      	push	{r4, lr}
    if( Radio.CheckRfFrequency( freq ) == false )
 800ba88:	6a1b      	ldr	r3, [r3, #32]
{
 800ba8a:	4604      	mov	r4, r0
    if( Radio.CheckRfFrequency( freq ) == false )
 800ba8c:	4798      	blx	r3
 800ba8e:	b168      	cbz	r0, 800baac <VerifyRfFreq+0x28>
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 800ba90:	4b09      	ldr	r3, [pc, #36]	; (800bab8 <VerifyRfFreq+0x34>)
 800ba92:	4a0a      	ldr	r2, [pc, #40]	; (800babc <VerifyRfFreq+0x38>)
 800ba94:	4423      	add	r3, r4
 800ba96:	4293      	cmp	r3, r2
 800ba98:	d809      	bhi.n	800baae <VerifyRfFreq+0x2a>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 800ba9a:	4a09      	ldr	r2, [pc, #36]	; (800bac0 <VerifyRfFreq+0x3c>)
 800ba9c:	4353      	muls	r3, r2
 800ba9e:	f641 32f6 	movw	r2, #7158	; 0x1bf6
 800baa2:	ebb2 1fb3 	cmp.w	r2, r3, ror #6
 800baa6:	bf2c      	ite	cs
 800baa8:	2001      	movcs	r0, #1
 800baaa:	2000      	movcc	r0, #0
}
 800baac:	bd10      	pop	{r4, pc}
        return false;
 800baae:	2000      	movs	r0, #0
 800bab0:	e7fc      	b.n	800baac <VerifyRfFreq+0x28>
 800bab2:	bf00      	nop
 800bab4:	08010fe4 	.word	0x08010fe4
 800bab8:	c8f78f60 	.word	0xc8f78f60
 800babc:	00401640 	.word	0x00401640
 800bac0:	5943f75f 	.word	0x5943f75f

0800bac4 <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 800bac4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    PhyParam_t phyParam = { 0 };
 800bac6:	2300      	movs	r3, #0
 800bac8:	9300      	str	r3, [sp, #0]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 800baca:	7803      	ldrb	r3, [r0, #0]
 800bacc:	3b01      	subs	r3, #1
 800bace:	2b38      	cmp	r3, #56	; 0x38
 800bad0:	d870      	bhi.n	800bbb4 <RegionUS915GetPhyParam+0xf0>
 800bad2:	e8df f003 	tbb	[pc, r3]
 800bad6:	6f1d      	.short	0x6f1d
 800bad8:	6f6f6f6f 	.word	0x6f6f6f6f
 800badc:	6f6f6f6f 	.word	0x6f6f6f6f
 800bae0:	3e393735 	.word	0x3e393735
 800bae4:	4845426f 	.word	0x4845426f
 800bae8:	54514e4b 	.word	0x54514e4b
 800baec:	5e1d5c6f 	.word	0x5e1d5c6f
 800baf0:	6f6a6863 	.word	0x6f6a6863
 800baf4:	20736d6f 	.word	0x20736d6f
 800baf8:	6f6f6f6f 	.word	0x6f6f6f6f
 800bafc:	6f6f6f6f 	.word	0x6f6f6f6f
 800bb00:	6f6f6f6f 	.word	0x6f6f6f6f
 800bb04:	1d7b756f 	.word	0x1d7b756f
 800bb08:	1d756f1d 	.word	0x1d756f1d
 800bb0c:	831d      	.short	0x831d
 800bb0e:	87          	.byte	0x87
 800bb0f:	00          	.byte	0x00
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 800bb10:	2308      	movs	r3, #8
            phyParam.Value = US915_BEACON_NB_CHANNELS;
            break;
        }
        case PHY_SF_FROM_DR:
        {
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 800bb12:	9300      	str	r3, [sp, #0]
            break;
 800bb14:	e04e      	b.n	800bbb4 <RegionUS915GetPhyParam+0xf0>
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 800bb16:	7843      	ldrb	r3, [r0, #1]
 800bb18:	f88d 3004 	strb.w	r3, [sp, #4]
 800bb1c:	2304      	movs	r3, #4
 800bb1e:	f88d 3005 	strb.w	r3, [sp, #5]
 800bb22:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800bb26:	f8ad 3006 	strh.w	r3, [sp, #6]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 800bb2a:	4b31      	ldr	r3, [pc, #196]	; (800bbf0 <RegionUS915GetPhyParam+0x12c>)
 800bb2c:	681b      	ldr	r3, [r3, #0]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 800bb2e:	a801      	add	r0, sp, #4
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 800bb30:	f503 7258 	add.w	r2, r3, #864	; 0x360
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 800bb34:	e9cd 2302 	strd	r2, r3, [sp, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 800bb38:	f7ff f991 	bl	800ae5e <RegionCommonGetNextLowerTxDr>
        }
        case PHY_BW_FROM_DR:
        {
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 800bb3c:	9000      	str	r0, [sp, #0]
            break;
 800bb3e:	e039      	b.n	800bbb4 <RegionUS915GetPhyParam+0xf0>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 800bb40:	2340      	movs	r3, #64	; 0x40
 800bb42:	e7e6      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 800bb44:	2320      	movs	r3, #32
 800bb46:	e7e4      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 800bb48:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800bb4c:	4a29      	ldr	r2, [pc, #164]	; (800bbf4 <RegionUS915GetPhyParam+0x130>)
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 800bb4e:	5cd3      	ldrb	r3, [r2, r3]
 800bb50:	e7df      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 800bb52:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800bb56:	4a28      	ldr	r2, [pc, #160]	; (800bbf8 <RegionUS915GetPhyParam+0x134>)
 800bb58:	e7f9      	b.n	800bb4e <RegionUS915GetPhyParam+0x8a>
            phyParam.Value = US915_MAX_RX_WINDOW;
 800bb5a:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800bb5e:	e7d8      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 800bb60:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800bb64:	e7d5      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 800bb66:	f44f 63fa 	mov.w	r3, #2000	; 0x7d0
 800bb6a:	e7d2      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 800bb6c:	f241 3388 	movw	r3, #5000	; 0x1388
 800bb70:	e7cf      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 800bb72:	f241 7370 	movw	r3, #6000	; 0x1770
 800bb76:	e7cc      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = REGION_COMMON_DEFAULT_MAX_FCNT_GAP;
 800bb78:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800bb7c:	e7c9      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = ( REGION_COMMON_DEFAULT_ACK_TIMEOUT + randr( -REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND, REGION_COMMON_DEFAULT_ACK_TIMEOUT_RND ) );
 800bb7e:	481f      	ldr	r0, [pc, #124]	; (800bbfc <RegionUS915GetPhyParam+0x138>)
 800bb80:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800bb84:	f001 faba 	bl	800d0fc <randr>
 800bb88:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 800bb8c:	e7d6      	b.n	800bb3c <RegionUS915GetPhyParam+0x78>
            phyParam.Value = US915_RX_WND_2_FREQ;
 800bb8e:	4b1c      	ldr	r3, [pc, #112]	; (800bc00 <RegionUS915GetPhyParam+0x13c>)
 800bb90:	e7bf      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 800bb92:	4b17      	ldr	r3, [pc, #92]	; (800bbf0 <RegionUS915GetPhyParam+0x12c>)
 800bb94:	681b      	ldr	r3, [r3, #0]
 800bb96:	f503 7358 	add.w	r3, r3, #864	; 0x360
 800bb9a:	e7ba      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 800bb9c:	4b14      	ldr	r3, [pc, #80]	; (800bbf0 <RegionUS915GetPhyParam+0x12c>)
 800bb9e:	681b      	ldr	r3, [r3, #0]
 800bba0:	f503 735b 	add.w	r3, r3, #876	; 0x36c
 800bba4:	e7b5      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 800bba6:	2348      	movs	r3, #72	; 0x48
 800bba8:	e7b3      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.Channels = RegionNvmGroup2->Channels;
 800bbaa:	4b11      	ldr	r3, [pc, #68]	; (800bbf0 <RegionUS915GetPhyParam+0x12c>)
 800bbac:	681b      	ldr	r3, [r3, #0]
 800bbae:	e7b0      	b.n	800bb12 <RegionUS915GetPhyParam+0x4e>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 800bbb0:	4b14      	ldr	r3, [pc, #80]	; (800bc04 <RegionUS915GetPhyParam+0x140>)
            phyParam.fValue = 0;
 800bbb2:	9300      	str	r3, [sp, #0]
        }
    }

#endif /* REGION_US915 */
    return phyParam;
}
 800bbb4:	9800      	ldr	r0, [sp, #0]
 800bbb6:	b005      	add	sp, #20
 800bbb8:	f85d fb04 	ldr.w	pc, [sp], #4
            phyParam.fValue = 0;
 800bbbc:	2300      	movs	r3, #0
 800bbbe:	e7f8      	b.n	800bbb2 <RegionUS915GetPhyParam+0xee>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 800bbc0:	4a11      	ldr	r2, [pc, #68]	; (800bc08 <RegionUS915GetPhyParam+0x144>)
 800bbc2:	490f      	ldr	r1, [pc, #60]	; (800bc00 <RegionUS915GetPhyParam+0x13c>)
 800bbc4:	7900      	ldrb	r0, [r0, #4]
 800bbc6:	f7fe fe73 	bl	800a8b0 <RegionBaseUSCalcDownlinkFrequency>
 800bbca:	e7b7      	b.n	800bb3c <RegionUS915GetPhyParam+0x78>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 800bbcc:	f240 5317 	movw	r3, #1303	; 0x517
 800bbd0:	f8ad 3000 	strh.w	r3, [sp]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 800bbd4:	2303      	movs	r3, #3
 800bbd6:	f88d 3002 	strb.w	r3, [sp, #2]
            break;
 800bbda:	e7eb      	b.n	800bbb4 <RegionUS915GetPhyParam+0xf0>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 800bbdc:	f990 3001 	ldrsb.w	r3, [r0, #1]
 800bbe0:	4a0a      	ldr	r2, [pc, #40]	; (800bc0c <RegionUS915GetPhyParam+0x148>)
 800bbe2:	e7b4      	b.n	800bb4e <RegionUS915GetPhyParam+0x8a>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 800bbe4:	490a      	ldr	r1, [pc, #40]	; (800bc10 <RegionUS915GetPhyParam+0x14c>)
 800bbe6:	f990 0001 	ldrsb.w	r0, [r0, #1]
 800bbea:	f7ff f957 	bl	800ae9c <RegionCommonGetBandwidth>
 800bbee:	e7a5      	b.n	800bb3c <RegionUS915GetPhyParam+0x78>
 800bbf0:	200010fc 	.word	0x200010fc
 800bbf4:	08010b50 	.word	0x08010b50
 800bbf8:	08010b40 	.word	0x08010b40
 800bbfc:	fffffc18 	.word	0xfffffc18
 800bc00:	370870a0 	.word	0x370870a0
 800bc04:	4200999a 	.word	0x4200999a
 800bc08:	000927c0 	.word	0x000927c0
 800bc0c:	08010b30 	.word	0x08010b30
 800bc10:	08010adc 	.word	0x08010adc

0800bc14 <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 800bc14:	b537      	push	{r0, r1, r2, r4, r5, lr}
#if defined( REGION_US915 )
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 800bc16:	4b0b      	ldr	r3, [pc, #44]	; (800bc44 <RegionUS915SetBandTxDone+0x30>)
 800bc18:	681a      	ldr	r2, [r3, #0]
 800bc1a:	7803      	ldrb	r3, [r0, #0]
 800bc1c:	210c      	movs	r1, #12
 800bc1e:	fb01 2303 	mla	r3, r1, r3, r2
 800bc22:	7a5b      	ldrb	r3, [r3, #9]
 800bc24:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 800bc28:	4b07      	ldr	r3, [pc, #28]	; (800bc48 <RegionUS915SetBandTxDone+0x34>)
 800bc2a:	681d      	ldr	r5, [r3, #0]
 800bc2c:	6903      	ldr	r3, [r0, #16]
 800bc2e:	9300      	str	r3, [sp, #0]
 800bc30:	68c3      	ldr	r3, [r0, #12]
 800bc32:	7842      	ldrb	r2, [r0, #1]
 800bc34:	6881      	ldr	r1, [r0, #8]
 800bc36:	eb05 00c4 	add.w	r0, r5, r4, lsl #3
 800bc3a:	f7fe febf 	bl	800a9bc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_US915 */
}
 800bc3e:	b003      	add	sp, #12
 800bc40:	bd30      	pop	{r4, r5, pc}
 800bc42:	bf00      	nop
 800bc44:	200010fc 	.word	0x200010fc
 800bc48:	200010f8 	.word	0x200010f8

0800bc4c <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 800bc4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bc4e:	b087      	sub	sp, #28
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 800bc50:	2301      	movs	r3, #1
    {
       US915_BAND0
    };

    switch( params->Type )
 800bc52:	7a04      	ldrb	r4, [r0, #8]
    Band_t bands[US915_MAX_NB_BANDS] =
 800bc54:	f8ad 3000 	strh.w	r3, [sp]
 800bc58:	2300      	movs	r3, #0
 800bc5a:	e9cd 3301 	strd	r3, r3, [sp, #4]
 800bc5e:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
 800bc62:	4602      	mov	r2, r0
    Band_t bands[US915_MAX_NB_BANDS] =
 800bc64:	f88d 3002 	strb.w	r3, [sp, #2]
 800bc68:	f88d 3014 	strb.w	r3, [sp, #20]
    switch( params->Type )
 800bc6c:	b124      	cbz	r4, 800bc78 <RegionUS915InitDefaults+0x2c>
 800bc6e:	3c01      	subs	r4, #1
 800bc70:	2c01      	cmp	r4, #1
 800bc72:	d94d      	bls.n	800bd10 <RegionUS915InitDefaults+0xc4>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 800bc74:	b007      	add	sp, #28
 800bc76:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 800bc78:	6800      	ldr	r0, [r0, #0]
 800bc7a:	2800      	cmp	r0, #0
 800bc7c:	d0fa      	beq.n	800bc74 <RegionUS915InitDefaults+0x28>
 800bc7e:	6853      	ldr	r3, [r2, #4]
 800bc80:	2b00      	cmp	r3, #0
 800bc82:	d0f7      	beq.n	800bc74 <RegionUS915InitDefaults+0x28>
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 800bc84:	4d2f      	ldr	r5, [pc, #188]	; (800bd44 <RegionUS915InitDefaults+0xf8>)
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 800bc86:	4e30      	ldr	r6, [pc, #192]	; (800bd48 <RegionUS915InitDefaults+0xfc>)
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 800bc88:	f8a0 409c 	strh.w	r4, [r0, #156]	; 0x9c
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 800bc8c:	2218      	movs	r2, #24
 800bc8e:	4669      	mov	r1, sp
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 800bc90:	6030      	str	r0, [r6, #0]
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 800bc92:	602b      	str	r3, [r5, #0]
            memcpy1( ( uint8_t* )RegionNvmGroup1->Bands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 800bc94:	f001 fa4e 	bl	800d134 <memcpy1>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 800bc98:	6828      	ldr	r0, [r5, #0]
 800bc9a:	4b2c      	ldr	r3, [pc, #176]	; (800bd4c <RegionUS915InitDefaults+0x100>)
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 800bc9c:	4f2c      	ldr	r7, [pc, #176]	; (800bd50 <RegionUS915InitDefaults+0x104>)
 800bc9e:	4602      	mov	r2, r0
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 800bca0:	4601      	mov	r1, r0
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 800bca2:	f04f 0c30 	mov.w	ip, #48	; 0x30
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 800bca6:	600b      	str	r3, [r1, #0]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 800bca8:	f503 3343 	add.w	r3, r3, #199680	; 0x30c00
 800bcac:	f503 73a0 	add.w	r3, r3, #320	; 0x140
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 800bcb0:	42bb      	cmp	r3, r7
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 800bcb2:	f881 c008 	strb.w	ip, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 800bcb6:	724c      	strb	r4, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 800bcb8:	f101 010c 	add.w	r1, r1, #12
 800bcbc:	d1f3      	bne.n	800bca6 <RegionUS915InitDefaults+0x5a>
 800bcbe:	4b25      	ldr	r3, [pc, #148]	; (800bd54 <RegionUS915InitDefaults+0x108>)
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 800bcc0:	4925      	ldr	r1, [pc, #148]	; (800bd58 <RegionUS915InitDefaults+0x10c>)
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 800bcc2:	2744      	movs	r7, #68	; 0x44
                RegionNvmGroup2->Channels[i].Band = 0;
 800bcc4:	2400      	movs	r4, #0
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 800bcc6:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 800bcca:	f503 13c3 	add.w	r3, r3, #1597440	; 0x186000
 800bcce:	f503 6320 	add.w	r3, r3, #2560	; 0xa00
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 800bcd2:	428b      	cmp	r3, r1
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 800bcd4:	f882 7308 	strb.w	r7, [r2, #776]	; 0x308
                RegionNvmGroup2->Channels[i].Band = 0;
 800bcd8:	f882 4309 	strb.w	r4, [r2, #777]	; 0x309
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 800bcdc:	f102 020c 	add.w	r2, r2, #12
 800bce0:	d1f1      	bne.n	800bcc6 <RegionUS915InitDefaults+0x7a>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 800bce2:	f04f 33ff 	mov.w	r3, #4294967295
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 800bce6:	e9c0 33db 	strd	r3, r3, [r0, #876]	; 0x36c
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 800bcea:	23ff      	movs	r3, #255	; 0xff
 800bcec:	f8c0 3374 	str.w	r3, [r0, #884]	; 0x374
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 800bcf0:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 800bcf4:	2206      	movs	r2, #6
 800bcf6:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800bcfa:	f7fe fe50 	bl	800a99e <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 800bcfe:	6829      	ldr	r1, [r5, #0]
 800bd00:	6830      	ldr	r0, [r6, #0]
 800bd02:	2206      	movs	r2, #6
 800bd04:	f501 7158 	add.w	r1, r1, #864	; 0x360
 800bd08:	3090      	adds	r0, #144	; 0x90
 800bd0a:	f7fe fe48 	bl	800a99e <RegionCommonChanMaskCopy>
            break;
 800bd0e:	e7b1      	b.n	800bc74 <RegionUS915InitDefaults+0x28>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 800bd10:	4c0c      	ldr	r4, [pc, #48]	; (800bd44 <RegionUS915InitDefaults+0xf8>)
 800bd12:	6820      	ldr	r0, [r4, #0]
 800bd14:	2206      	movs	r2, #6
 800bd16:	f500 715b 	add.w	r1, r0, #876	; 0x36c
 800bd1a:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800bd1e:	f7fe fe3e 	bl	800a99e <RegionCommonChanMaskCopy>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 800bd22:	4b09      	ldr	r3, [pc, #36]	; (800bd48 <RegionUS915InitDefaults+0xfc>)
 800bd24:	6821      	ldr	r1, [r4, #0]
 800bd26:	681b      	ldr	r3, [r3, #0]
 800bd28:	f501 7158 	add.w	r1, r1, #864	; 0x360
 800bd2c:	f103 0290 	add.w	r2, r3, #144	; 0x90
 800bd30:	339c      	adds	r3, #156	; 0x9c
 800bd32:	8810      	ldrh	r0, [r2, #0]
 800bd34:	f831 4b02 	ldrh.w	r4, [r1], #2
 800bd38:	4020      	ands	r0, r4
 800bd3a:	f822 0b02 	strh.w	r0, [r2], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 800bd3e:	429a      	cmp	r2, r3
 800bd40:	d1f7      	bne.n	800bd32 <RegionUS915InitDefaults+0xe6>
 800bd42:	e797      	b.n	800bc74 <RegionUS915InitDefaults+0x28>
 800bd44:	200010fc 	.word	0x200010fc
 800bd48:	200010f8 	.word	0x200010f8
 800bd4c:	35c80160 	.word	0x35c80160
 800bd50:	368b5160 	.word	0x368b5160
 800bd54:	35d2afc0 	.word	0x35d2afc0
 800bd58:	3695ffc0 	.word	0x3695ffc0

0800bd5c <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 800bd5c:	b508      	push	{r3, lr}
 800bd5e:	290a      	cmp	r1, #10
 800bd60:	d81b      	bhi.n	800bd9a <RegionUS915Verify+0x3e>
 800bd62:	e8df f001 	tbb	[pc, r1]
 800bd66:	1a06      	.short	0x1a06
 800bd68:	0b1a1a1a 	.word	0x0b1a1a1a
 800bd6c:	181a0e0b 	.word	0x181a0e0b
 800bd70:	18          	.byte	0x18
 800bd71:	00          	.byte	0x00
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 800bd72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            return VerifyRfFreq( verify->Frequency );
 800bd76:	6800      	ldr	r0, [r0, #0]
 800bd78:	f7ff be84 	b.w	800ba84 <VerifyRfFreq>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 800bd7c:	2204      	movs	r2, #4
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 800bd7e:	2100      	movs	r1, #0
 800bd80:	e001      	b.n	800bd86 <RegionUS915Verify+0x2a>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 800bd82:	220d      	movs	r2, #13
 800bd84:	2108      	movs	r1, #8
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 800bd86:	f990 0000 	ldrsb.w	r0, [r0]
 800bd8a:	f7fe fdc8 	bl	800a91e <RegionCommonValueInRange>
 800bd8e:	3800      	subs	r0, #0
 800bd90:	bf18      	it	ne
 800bd92:	2001      	movne	r0, #1
}
 800bd94:	bd08      	pop	{r3, pc}
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 800bd96:	220e      	movs	r2, #14
 800bd98:	e7f1      	b.n	800bd7e <RegionUS915Verify+0x22>
{
 800bd9a:	2000      	movs	r0, #0
 800bd9c:	e7fa      	b.n	800bd94 <RegionUS915Verify+0x38>
	...

0800bda0 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 800bda0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 800bda2:	7903      	ldrb	r3, [r0, #4]
 800bda4:	2b10      	cmp	r3, #16
 800bda6:	d123      	bne.n	800bdf0 <RegionUS915ApplyCFList+0x50>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 800bda8:	6804      	ldr	r4, [r0, #0]
 800bdaa:	7be3      	ldrb	r3, [r4, #15]
 800bdac:	2b01      	cmp	r3, #1
 800bdae:	d11f      	bne.n	800bdf0 <RegionUS915ApplyCFList+0x50>
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
    {
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 800bdb0:	4b10      	ldr	r3, [pc, #64]	; (800bdf4 <RegionUS915ApplyCFList+0x54>)
 800bdb2:	681d      	ldr	r5, [r3, #0]
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 800bdb4:	4b10      	ldr	r3, [pc, #64]	; (800bdf8 <RegionUS915ApplyCFList+0x58>)
 800bdb6:	6819      	ldr	r1, [r3, #0]
 800bdb8:	f505 7058 	add.w	r0, r5, #864	; 0x360
 800bdbc:	3190      	adds	r1, #144	; 0x90
 800bdbe:	2200      	movs	r2, #0
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 800bdc0:	1c67      	adds	r7, r4, #1
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 800bdc2:	f814 3012 	ldrb.w	r3, [r4, r2, lsl #1]
 800bdc6:	8003      	strh	r3, [r0, #0]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 800bdc8:	f817 6012 	ldrb.w	r6, [r7, r2, lsl #1]
        if( chMaskItr == 4 )
 800bdcc:	2a04      	cmp	r2, #4
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 800bdce:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 800bdd2:	f820 3b02 	strh.w	r3, [r0], #2
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 800bdd6:	bf04      	itt	eq
 800bdd8:	b2db      	uxtbeq	r3, r3
 800bdda:	f8a5 3368 	strheq.w	r3, [r5, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 800bdde:	880b      	ldrh	r3, [r1, #0]
 800bde0:	f830 6c02 	ldrh.w	r6, [r0, #-2]
 800bde4:	3201      	adds	r2, #1
 800bde6:	4033      	ands	r3, r6
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 800bde8:	2a05      	cmp	r2, #5
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 800bdea:	f821 3b02 	strh.w	r3, [r1], #2
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 800bdee:	d1e8      	bne.n	800bdc2 <RegionUS915ApplyCFList+0x22>
    }
#endif /* REGION_US915 */
}
 800bdf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bdf2:	bf00      	nop
 800bdf4:	200010fc 	.word	0x200010fc
 800bdf8:	200010f8 	.word	0x200010f8

0800bdfc <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 800bdfc:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 800bdfe:	2204      	movs	r2, #4
{
 800be00:	4605      	mov	r5, r0
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 800be02:	2100      	movs	r1, #0
 800be04:	6800      	ldr	r0, [r0, #0]
 800be06:	f7fe fdac 	bl	800a962 <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 800be0a:	2801      	cmp	r0, #1
 800be0c:	d003      	beq.n	800be16 <RegionUS915ChanMaskSet+0x1a>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 800be0e:	792c      	ldrb	r4, [r5, #4]
 800be10:	b11c      	cbz	r4, 800be1a <RegionUS915ChanMaskSet+0x1e>
 800be12:	2c01      	cmp	r4, #1
 800be14:	d021      	beq.n	800be5a <RegionUS915ChanMaskSet+0x5e>
        return false;
 800be16:	2000      	movs	r0, #0
 800be18:	e01e      	b.n	800be58 <RegionUS915ChanMaskSet+0x5c>
    {
        case CHANNELS_MASK:
        {
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 800be1a:	4e14      	ldr	r6, [pc, #80]	; (800be6c <RegionUS915ChanMaskSet+0x70>)
 800be1c:	6829      	ldr	r1, [r5, #0]
 800be1e:	6830      	ldr	r0, [r6, #0]
 800be20:	2206      	movs	r2, #6
 800be22:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800be26:	f7fe fdba 	bl	800a99e <RegionCommonChanMaskCopy>

            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 800be2a:	6833      	ldr	r3, [r6, #0]
 800be2c:	f893 2374 	ldrb.w	r2, [r3, #884]	; 0x374
 800be30:	f8a3 2374 	strh.w	r2, [r3, #884]	; 0x374
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;

            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 800be34:	4a0e      	ldr	r2, [pc, #56]	; (800be70 <RegionUS915ChanMaskSet+0x74>)
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 800be36:	f8a3 4376 	strh.w	r4, [r3, #886]	; 0x376
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 800be3a:	6812      	ldr	r2, [r2, #0]
 800be3c:	f503 7358 	add.w	r3, r3, #864	; 0x360
 800be40:	f102 0190 	add.w	r1, r2, #144	; 0x90
 800be44:	329c      	adds	r2, #156	; 0x9c
 800be46:	8808      	ldrh	r0, [r1, #0]
 800be48:	f833 4b02 	ldrh.w	r4, [r3], #2
 800be4c:	4020      	ands	r0, r4
 800be4e:	f821 0b02 	strh.w	r0, [r1], #2
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 800be52:	4291      	cmp	r1, r2
 800be54:	d1f7      	bne.n	800be46 <RegionUS915ChanMaskSet+0x4a>
            break;
        }
        default:
            return false;
    }
    return true;
 800be56:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 800be58:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 800be5a:	4b04      	ldr	r3, [pc, #16]	; (800be6c <RegionUS915ChanMaskSet+0x70>)
 800be5c:	6829      	ldr	r1, [r5, #0]
 800be5e:	6818      	ldr	r0, [r3, #0]
 800be60:	2206      	movs	r2, #6
 800be62:	f500 705b 	add.w	r0, r0, #876	; 0x36c
 800be66:	f7fe fd9a 	bl	800a99e <RegionCommonChanMaskCopy>
            break;
 800be6a:	e7f4      	b.n	800be56 <RegionUS915ChanMaskSet+0x5a>
 800be6c:	200010fc 	.word	0x200010fc
 800be70:	200010f8 	.word	0x200010f8

0800be74 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 800be74:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 800be76:	280d      	cmp	r0, #13
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 800be78:	4d11      	ldr	r5, [pc, #68]	; (800bec0 <RegionUS915ComputeRxWindowParameters+0x4c>)
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 800be7a:	bfa8      	it	ge
 800be7c:	200d      	movge	r0, #13
{
 800be7e:	461c      	mov	r4, r3
 800be80:	460e      	mov	r6, r1
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 800be82:	7058      	strb	r0, [r3, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 800be84:	4629      	mov	r1, r5
{
 800be86:	4617      	mov	r7, r2
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 800be88:	f7ff f808 	bl	800ae9c <RegionCommonGetBandwidth>

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 800be8c:	f994 3001 	ldrsb.w	r3, [r4, #1]
 800be90:	4a0c      	ldr	r2, [pc, #48]	; (800bec4 <RegionUS915ComputeRxWindowParameters+0x50>)
 800be92:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 800be96:	70a0      	strb	r0, [r4, #2]
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 800be98:	5cd0      	ldrb	r0, [r2, r3]
 800be9a:	f7fe fefb 	bl	800ac94 <RegionCommonComputeSymbolTimeLoRa>

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 800be9e:	4b0a      	ldr	r3, [pc, #40]	; (800bec8 <RegionUS915ComputeRxWindowParameters+0x54>)
 800bea0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 800bea2:	4605      	mov	r5, r0
    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 800bea4:	4798      	blx	r3
 800bea6:	f104 020c 	add.w	r2, r4, #12
 800beaa:	3408      	adds	r4, #8
 800beac:	4603      	mov	r3, r0
 800beae:	9201      	str	r2, [sp, #4]
 800beb0:	9400      	str	r4, [sp, #0]
 800beb2:	463a      	mov	r2, r7
 800beb4:	4631      	mov	r1, r6
 800beb6:	4628      	mov	r0, r5
 800beb8:	f7fe fef9 	bl	800acae <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 800bebc:	b003      	add	sp, #12
 800bebe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800bec0:	08010adc 	.word	0x08010adc
 800bec4:	08010b30 	.word	0x08010b30
 800bec8:	08010fe4 	.word	0x08010fe4

0800becc <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 800becc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int8_t dr = rxConfig->Datarate;
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;

    if( Radio.GetStatus( ) != RF_IDLE )
 800bed0:	4e23      	ldr	r6, [pc, #140]	; (800bf60 <RegionUS915RxConfig+0x94>)
    int8_t dr = rxConfig->Datarate;
 800bed2:	f990 8001 	ldrsb.w	r8, [r0, #1]
    if( Radio.GetStatus( ) != RF_IDLE )
 800bed6:	6873      	ldr	r3, [r6, #4]
    uint32_t frequency = rxConfig->Frequency;
 800bed8:	6845      	ldr	r5, [r0, #4]
{
 800beda:	b08a      	sub	sp, #40	; 0x28
 800bedc:	4604      	mov	r4, r0
 800bede:	4689      	mov	r9, r1
    if( Radio.GetStatus( ) != RF_IDLE )
 800bee0:	4798      	blx	r3
 800bee2:	2800      	cmp	r0, #0
 800bee4:	d13a      	bne.n	800bf5c <RegionUS915RxConfig+0x90>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 800bee6:	7ce3      	ldrb	r3, [r4, #19]
 800bee8:	b933      	cbnz	r3, 800bef8 <RegionUS915RxConfig+0x2c>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 800beea:	7825      	ldrb	r5, [r4, #0]
 800beec:	4a1d      	ldr	r2, [pc, #116]	; (800bf64 <RegionUS915RxConfig+0x98>)
 800beee:	4b1e      	ldr	r3, [pc, #120]	; (800bf68 <RegionUS915RxConfig+0x9c>)
 800bef0:	f005 0507 	and.w	r5, r5, #7
 800bef4:	fb02 3505 	mla	r5, r2, r5, r3
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 800bef8:	4b1c      	ldr	r3, [pc, #112]	; (800bf6c <RegionUS915RxConfig+0xa0>)

    Radio.SetChannel( frequency );
 800befa:	4628      	mov	r0, r5
    phyDr = DataratesUS915[dr];
 800befc:	f913 a008 	ldrsb.w	sl, [r3, r8]
    Radio.SetChannel( frequency );
 800bf00:	68f3      	ldr	r3, [r6, #12]
 800bf02:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 800bf04:	7ca3      	ldrb	r3, [r4, #18]
 800bf06:	8922      	ldrh	r2, [r4, #8]
 800bf08:	9309      	str	r3, [sp, #36]	; 0x24
 800bf0a:	2000      	movs	r0, #0
 800bf0c:	2301      	movs	r3, #1
 800bf0e:	9202      	str	r2, [sp, #8]
 800bf10:	2208      	movs	r2, #8
 800bf12:	e9cd 0307 	strd	r0, r3, [sp, #28]
 800bf16:	e9cd 0200 	strd	r0, r2, [sp]
 800bf1a:	e9cd 0005 	strd	r0, r0, [sp, #20]
 800bf1e:	e9cd 0003 	strd	r0, r0, [sp, #12]
 800bf22:	69b7      	ldr	r7, [r6, #24]
 800bf24:	78a1      	ldrb	r1, [r4, #2]
 800bf26:	4618      	mov	r0, r3
 800bf28:	4652      	mov	r2, sl
 800bf2a:	47b8      	blx	r7

    /* ST_WORKAROUND_BEGIN: Keep repeater feature */
    if( rxConfig->RepeaterSupport == true )
 800bf2c:	7c63      	ldrb	r3, [r4, #17]
 800bf2e:	b19b      	cbz	r3, 800bf58 <RegionUS915RxConfig+0x8c>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 800bf30:	4b0f      	ldr	r3, [pc, #60]	; (800bf70 <RegionUS915RxConfig+0xa4>)
    }
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 800bf32:	f813 3008 	ldrb.w	r3, [r3, r8]
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 800bf36:	f103 010d 	add.w	r1, r3, #13
 800bf3a:	b2c9      	uxtb	r1, r1
 800bf3c:	6d73      	ldr	r3, [r6, #84]	; 0x54
 800bf3e:	2001      	movs	r0, #1
 800bf40:	4798      	blx	r3
    /* ST_WORKAROUND_END */

    /* ST_WORKAROUND_BEGIN: Print Rx config */
    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 800bf42:	7ce0      	ldrb	r0, [r4, #19]
 800bf44:	4642      	mov	r2, r8
 800bf46:	4629      	mov	r1, r5
 800bf48:	f7fe ffba 	bl	800aec0 <RegionCommonRxConfigPrint>
    /* ST_WORKAROUND_END */

    *datarate = (uint8_t) dr;
 800bf4c:	f889 8000 	strb.w	r8, [r9]
    return true;
 800bf50:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 800bf52:	b00a      	add	sp, #40	; 0x28
 800bf54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 800bf58:	4b06      	ldr	r3, [pc, #24]	; (800bf74 <RegionUS915RxConfig+0xa8>)
 800bf5a:	e7ea      	b.n	800bf32 <RegionUS915RxConfig+0x66>
        return false;
 800bf5c:	2000      	movs	r0, #0
 800bf5e:	e7f8      	b.n	800bf52 <RegionUS915RxConfig+0x86>
 800bf60:	08010fe4 	.word	0x08010fe4
 800bf64:	000927c0 	.word	0x000927c0
 800bf68:	370870a0 	.word	0x370870a0
 800bf6c:	08010b30 	.word	0x08010b30
 800bf70:	08010b40 	.word	0x08010b40
 800bf74:	08010b50 	.word	0x08010b50

0800bf78 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 800bf78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 800bf7c:	4b3e      	ldr	r3, [pc, #248]	; (800c078 <RegionUS915TxConfig+0x100>)
 800bf7e:	f990 b001 	ldrsb.w	fp, [r0, #1]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 800bf82:	f8df 8104 	ldr.w	r8, [pc, #260]	; 800c088 <RegionUS915TxConfig+0x110>
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 800bf86:	f913 700b 	ldrsb.w	r7, [r3, fp]
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 800bf8a:	4b3c      	ldr	r3, [pc, #240]	; (800c07c <RegionUS915TxConfig+0x104>)
 800bf8c:	f8d8 9000 	ldr.w	r9, [r8]
 800bf90:	f990 6002 	ldrsb.w	r6, [r0, #2]
{
 800bf94:	b08f      	sub	sp, #60	; 0x3c
 800bf96:	4692      	mov	sl, r2
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 800bf98:	7802      	ldrb	r2, [r0, #0]
{
 800bf9a:	910b      	str	r1, [sp, #44]	; 0x2c
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 800bf9c:	6819      	ldr	r1, [r3, #0]
 800bf9e:	230c      	movs	r3, #12
 800bfa0:	fb03 9202 	mla	r2, r3, r2, r9
{
 800bfa4:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 800bfa6:	7a53      	ldrb	r3, [r2, #9]
 800bfa8:	2218      	movs	r2, #24
 800bfaa:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 800bfae:	4630      	mov	r0, r6
 800bfb0:	f993 1002 	ldrsb.w	r1, [r3, #2]
 800bfb4:	f7fe ff6e 	bl	800ae94 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 800bfb8:	f1bb 0f04 	cmp.w	fp, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 800bfbc:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 800bfbe:	d14d      	bne.n	800c05c <RegionUS915TxConfig+0xe4>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 800bfc0:	2e02      	cmp	r6, #2
 800bfc2:	4635      	mov	r5, r6
 800bfc4:	bfb8      	it	lt
 800bfc6:	2502      	movlt	r5, #2
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 800bfc8:	492d      	ldr	r1, [pc, #180]	; (800c080 <RegionUS915TxConfig+0x108>)
 800bfca:	f994 0001 	ldrsb.w	r0, [r4, #1]

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800bfce:	f8df b0bc 	ldr.w	fp, [pc, #188]	; 800c08c <RegionUS915TxConfig+0x114>
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 800bfd2:	f7fe ff63 	bl	800ae9c <RegionCommonGetBandwidth>
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800bfd6:	492b      	ldr	r1, [pc, #172]	; (800c084 <RegionUS915TxConfig+0x10c>)
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 800bfd8:	900d      	str	r0, [sp, #52]	; 0x34
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800bfda:	2200      	movs	r2, #0
 800bfdc:	4628      	mov	r0, r5
 800bfde:	f7fe fe8e 	bl	800acfe <RegionCommonComputeTxPower>
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800bfe2:	7826      	ldrb	r6, [r4, #0]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800bfe4:	900c      	str	r0, [sp, #48]	; 0x30
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 800bfe6:	f04f 090c 	mov.w	r9, #12
 800bfea:	f8d8 0000 	ldr.w	r0, [r8]
 800bfee:	f8db 200c 	ldr.w	r2, [fp, #12]
 800bff2:	fb09 f606 	mul.w	r6, r9, r6
 800bff6:	5980      	ldr	r0, [r0, r6]
 800bff8:	4790      	blx	r2

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 800bffa:	2601      	movs	r6, #1
 800bffc:	2200      	movs	r2, #0
 800bffe:	f44f 637a 	mov.w	r3, #4000	; 0xfa0
 800c002:	2008      	movs	r0, #8
 800c004:	e9cd 2307 	strd	r2, r3, [sp, #28]
 800c008:	e9cd 2205 	strd	r2, r2, [sp, #20]
 800c00c:	e9dd 130c 	ldrd	r1, r3, [sp, #48]	; 0x30
 800c010:	e9cd 2603 	strd	r2, r6, [sp, #12]
 800c014:	e9cd 6001 	strd	r6, r0, [sp, #4]
 800c018:	9700      	str	r7, [sp, #0]
 800c01a:	4630      	mov	r0, r6
 800c01c:	f8db 701c 	ldr.w	r7, [fp, #28]
 800c020:	47b8      	blx	r7
    /* ST_WORKAROUND_BEGIN: Print Tx config */
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 800c022:	7822      	ldrb	r2, [r4, #0]
 800c024:	f8d8 3000 	ldr.w	r3, [r8]
 800c028:	f994 1001 	ldrsb.w	r1, [r4, #1]
 800c02c:	fb09 f902 	mul.w	r9, r9, r2
 800c030:	f853 0009 	ldr.w	r0, [r3, r9]
 800c034:	f7fe ff72 	bl	800af1c <RegionCommonTxConfigPrint>
    /* ST_WORKAROUND_END */

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 800c038:	f8db 3054 	ldr.w	r3, [fp, #84]	; 0x54
 800c03c:	7b21      	ldrb	r1, [r4, #12]
 800c03e:	4630      	mov	r0, r6
 800c040:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 800c042:	89a1      	ldrh	r1, [r4, #12]
 800c044:	f994 0001 	ldrsb.w	r0, [r4, #1]
 800c048:	f7ff fcfe 	bl	800ba48 <GetTimeOnAir>

    *txPower = txPowerLimited;
 800c04c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 800c04e:	f8ca 0000 	str.w	r0, [sl]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 800c052:	4630      	mov	r0, r6
    *txPower = txPowerLimited;
 800c054:	701d      	strb	r5, [r3, #0]
}
 800c056:	b00f      	add	sp, #60	; 0x3c
 800c058:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 800c05c:	2204      	movs	r2, #4
 800c05e:	2100      	movs	r1, #0
 800c060:	f509 7058 	add.w	r0, r9, #864	; 0x360
 800c064:	f7fe fc7d 	bl	800a962 <RegionCommonCountChannels>
 800c068:	2831      	cmp	r0, #49	; 0x31
 800c06a:	d8ad      	bhi.n	800bfc8 <RegionUS915TxConfig+0x50>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 800c06c:	2e05      	cmp	r6, #5
 800c06e:	4635      	mov	r5, r6
 800c070:	bfb8      	it	lt
 800c072:	2505      	movlt	r5, #5
 800c074:	e7a8      	b.n	800bfc8 <RegionUS915TxConfig+0x50>
 800c076:	bf00      	nop
 800c078:	08010b30 	.word	0x08010b30
 800c07c:	200010f8 	.word	0x200010f8
 800c080:	08010adc 	.word	0x08010adc
 800c084:	41f00000 	.word	0x41f00000
 800c088:	200010fc 	.word	0x200010fc
 800c08c:	08010fe4 	.word	0x08010fe4

0800c090 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 800c090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 800c094:	4e88      	ldr	r6, [pc, #544]	; (800c2b8 <RegionUS915LinkAdrReq+0x228>)
{
 800c096:	b095      	sub	sp, #84	; 0x54
 800c098:	e9cd 1201 	strd	r1, r2, [sp, #4]
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 800c09c:	6831      	ldr	r1, [r6, #0]
{
 800c09e:	9303      	str	r3, [sp, #12]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 800c0a0:	af09      	add	r7, sp, #36	; 0x24
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 800c0a2:	2400      	movs	r4, #0
{
 800c0a4:	4605      	mov	r5, r0
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 800c0a6:	2206      	movs	r2, #6
 800c0a8:	f501 7158 	add.w	r1, r1, #864	; 0x360
 800c0ac:	4638      	mov	r0, r7
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 800c0ae:	e9c7 4401 	strd	r4, r4, [r7, #4]
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 800c0b2:	9407      	str	r4, [sp, #28]
 800c0b4:	f8ad 4020 	strh.w	r4, [sp, #32]
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
 800c0b8:	9409      	str	r4, [sp, #36]	; 0x24
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 800c0ba:	f7fe fc70 	bl	800a99e <RegionCommonChanMaskCopy>
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
        {
            // Disable all 125 kHz channels
            channelsMask[0] = 0x0000;
 800c0be:	46a0      	mov	r8, r4
            channelsMask[0] = 0xFFFF;
 800c0c0:	f04f 39ff 	mov.w	r9, #4294967295
    while( bytesProcessed < linkAdrReq->PayloadSize )
 800c0c4:	7a2b      	ldrb	r3, [r5, #8]
 800c0c6:	42a3      	cmp	r3, r4
 800c0c8:	d907      	bls.n	800c0da <RegionUS915LinkAdrReq+0x4a>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 800c0ca:	6868      	ldr	r0, [r5, #4]
 800c0cc:	a907      	add	r1, sp, #28
 800c0ce:	4420      	add	r0, r4
 800c0d0:	f7fe fd86 	bl	800abe0 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 800c0d4:	2800      	cmp	r0, #0
 800c0d6:	f040 808d 	bne.w	800c1f4 <RegionUS915LinkAdrReq+0x164>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 800c0da:	f99d 301d 	ldrsb.w	r3, [sp, #29]
 800c0de:	2b03      	cmp	r3, #3
 800c0e0:	dc07      	bgt.n	800c0f2 <RegionUS915LinkAdrReq+0x62>
 800c0e2:	2204      	movs	r2, #4
 800c0e4:	2100      	movs	r1, #0
 800c0e6:	a809      	add	r0, sp, #36	; 0x24
 800c0e8:	f7fe fc3b 	bl	800a962 <RegionCommonCountChannels>
 800c0ec:	2801      	cmp	r0, #1
 800c0ee:	f240 80e0 	bls.w	800c2b2 <RegionUS915LinkAdrReq+0x222>
    uint8_t bytesProcessed = 0;
 800c0f2:	f04f 0807 	mov.w	r8, #7
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 800c0f6:	2302      	movs	r3, #2
 800c0f8:	f88d 3014 	strb.w	r3, [sp, #20]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
    phyParam = RegionUS915GetPhyParam( &getPhy );
 800c0fc:	a805      	add	r0, sp, #20
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 800c0fe:	7a6b      	ldrb	r3, [r5, #9]
 800c100:	f88d 3016 	strb.w	r3, [sp, #22]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 800c104:	f7ff fcde 	bl	800bac4 <RegionUS915GetPhyParam>

    linkAdrVerifyParams.Status = status;
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 800c108:	7aab      	ldrb	r3, [r5, #10]
 800c10a:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 800c10e:	f89d 301d 	ldrb.w	r3, [sp, #29]
 800c112:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 800c116:	f89d 301e 	ldrb.w	r3, [sp, #30]
 800c11a:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 800c11e:	f89d 301c 	ldrb.w	r3, [sp, #28]
 800c122:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 800c126:	7aeb      	ldrb	r3, [r5, #11]
 800c128:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 800c12c:	7b2b      	ldrb	r3, [r5, #12]
 800c12e:	f88d 303a 	strb.w	r3, [sp, #58]	; 0x3a
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 800c132:	7b6b      	ldrb	r3, [r5, #13]
 800c134:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 800c138:	2348      	movs	r3, #72	; 0x48
 800c13a:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
    linkAdrVerifyParams.ChannelsMask = channelsMask;
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 800c13e:	2304      	movs	r3, #4
 800c140:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 800c144:	6833      	ldr	r3, [r6, #0]
 800c146:	9312      	str	r3, [sp, #72]	; 0x48
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 800c148:	230e      	movs	r3, #14
 800c14a:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 800c14e:	682b      	ldr	r3, [r5, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 800c150:	9004      	str	r0, [sp, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 800c152:	f88d 0044 	strb.w	r0, [sp, #68]	; 0x44
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 800c156:	930c      	str	r3, [sp, #48]	; 0x30

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 800c158:	f10d 021e 	add.w	r2, sp, #30
 800c15c:	ab07      	add	r3, sp, #28
 800c15e:	f10d 011d 	add.w	r1, sp, #29
 800c162:	a80c      	add	r0, sp, #48	; 0x30
    linkAdrVerifyParams.Status = status;
 800c164:	f88d 8034 	strb.w	r8, [sp, #52]	; 0x34
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 800c168:	9710      	str	r7, [sp, #64]	; 0x40
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 800c16a:	f7fe fd53 	bl	800ac14 <RegionCommonLinkAdrReqVerifyParams>

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 800c16e:	2807      	cmp	r0, #7
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 800c170:	4605      	mov	r5, r0
    if( status == 0x07 )
 800c172:	d12d      	bne.n	800c1d0 <RegionUS915LinkAdrReq+0x140>
    {
        // Copy Mask
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 800c174:	6830      	ldr	r0, [r6, #0]
 800c176:	2206      	movs	r2, #6
 800c178:	4639      	mov	r1, r7
 800c17a:	f500 7058 	add.w	r0, r0, #864	; 0x360
 800c17e:	f7fe fc0e 	bl	800a99e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 800c182:	4b4e      	ldr	r3, [pc, #312]	; (800c2bc <RegionUS915LinkAdrReq+0x22c>)
 800c184:	6832      	ldr	r2, [r6, #0]
 800c186:	681b      	ldr	r3, [r3, #0]
 800c188:	f8b2 0360 	ldrh.w	r0, [r2, #864]	; 0x360
 800c18c:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
 800c190:	4001      	ands	r1, r0
 800c192:	f8a3 1090 	strh.w	r1, [r3, #144]	; 0x90
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 800c196:	f8b2 0362 	ldrh.w	r0, [r2, #866]	; 0x362
 800c19a:	f8b3 1092 	ldrh.w	r1, [r3, #146]	; 0x92
 800c19e:	4001      	ands	r1, r0
 800c1a0:	f8a3 1092 	strh.w	r1, [r3, #146]	; 0x92
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 800c1a4:	f8b2 0364 	ldrh.w	r0, [r2, #868]	; 0x364
 800c1a8:	f8b3 1094 	ldrh.w	r1, [r3, #148]	; 0x94
 800c1ac:	4001      	ands	r1, r0
 800c1ae:	f8a3 1094 	strh.w	r1, [r3, #148]	; 0x94
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 800c1b2:	f8b2 0366 	ldrh.w	r0, [r2, #870]	; 0x366
 800c1b6:	f8b3 1096 	ldrh.w	r1, [r3, #150]	; 0x96
 800c1ba:	4001      	ands	r1, r0
 800c1bc:	f8a3 1096 	strh.w	r1, [r3, #150]	; 0x96
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 800c1c0:	f8b2 1368 	ldrh.w	r1, [r2, #872]	; 0x368
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 800c1c4:	f8b2 236a 	ldrh.w	r2, [r2, #874]	; 0x36a
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 800c1c8:	f8a3 1098 	strh.w	r1, [r3, #152]	; 0x98
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 800c1cc:	f8a3 209a 	strh.w	r2, [r3, #154]	; 0x9a
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 800c1d0:	9a01      	ldr	r2, [sp, #4]
 800c1d2:	f89d 301d 	ldrb.w	r3, [sp, #29]
 800c1d6:	7013      	strb	r3, [r2, #0]
    *txPowOut = linkAdrParams.TxPower;
 800c1d8:	9a02      	ldr	r2, [sp, #8]
 800c1da:	f89d 301e 	ldrb.w	r3, [sp, #30]
 800c1de:	7013      	strb	r3, [r2, #0]
    *nbRepOut = linkAdrParams.NbRep;
 800c1e0:	9a03      	ldr	r2, [sp, #12]
 800c1e2:	f89d 301c 	ldrb.w	r3, [sp, #28]
 800c1e6:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 800c1e8:	9b1e      	ldr	r3, [sp, #120]	; 0x78

#endif /* REGION_US915 */
    return status;
}
 800c1ea:	4628      	mov	r0, r5
    *nbBytesParsed = bytesProcessed;
 800c1ec:	701c      	strb	r4, [r3, #0]
}
 800c1ee:	b015      	add	sp, #84	; 0x54
 800c1f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( linkAdrParams.ChMaskCtrl == 6 )
 800c1f4:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800c1f8:	f8bd 2020 	ldrh.w	r2, [sp, #32]
        bytesProcessed += nextIndex;
 800c1fc:	4404      	add	r4, r0
        if( linkAdrParams.ChMaskCtrl == 6 )
 800c1fe:	2b06      	cmp	r3, #6
        bytesProcessed += nextIndex;
 800c200:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 800c202:	d105      	bne.n	800c210 <RegionUS915LinkAdrReq+0x180>
            channelsMask[2] = 0xFFFF;
 800c204:	e9cd 9909 	strd	r9, r9, [sp, #36]	; 0x24
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 800c208:	b2d2      	uxtb	r2, r2
 800c20a:	f8ad 202c 	strh.w	r2, [sp, #44]	; 0x2c
 800c20e:	e759      	b.n	800c0c4 <RegionUS915LinkAdrReq+0x34>
        else if( linkAdrParams.ChMaskCtrl == 7 )
 800c210:	2b07      	cmp	r3, #7
 800c212:	d102      	bne.n	800c21a <RegionUS915LinkAdrReq+0x18a>
            channelsMask[2] = 0x0000;
 800c214:	e9cd 8809 	strd	r8, r8, [sp, #36]	; 0x24
 800c218:	e7f6      	b.n	800c208 <RegionUS915LinkAdrReq+0x178>
        else if( linkAdrParams.ChMaskCtrl == 5 )
 800c21a:	2b05      	cmp	r3, #5
 800c21c:	d143      	bne.n	800c2a6 <RegionUS915LinkAdrReq+0x216>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 800c21e:	f04f 0c00 	mov.w	ip, #0
 800c222:	b2d2      	uxtb	r2, r2
            uint8_t cntChannelMask = 0;
 800c224:	4661      	mov	r1, ip
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 800c226:	2301      	movs	r3, #1
 800c228:	fa03 fa0c 	lsl.w	sl, r3, ip
 800c22c:	ea0c 0b03 	and.w	fp, ip, r3
 800c230:	ab14      	add	r3, sp, #80	; 0x50
 800c232:	eb03 0e41 	add.w	lr, r3, r1, lsl #1
 800c236:	ea12 0f0a 	tst.w	r2, sl
 800c23a:	f83e 3c2c 	ldrh.w	r3, [lr, #-44]
 800c23e:	fa0f f08a 	sxth.w	r0, sl
 800c242:	d01d      	beq.n	800c280 <RegionUS915LinkAdrReq+0x1f0>
                    if( ( i % 2 ) == 0 )
 800c244:	f1bb 0f00 	cmp.w	fp, #0
 800c248:	d10e      	bne.n	800c268 <RegionUS915LinkAdrReq+0x1d8>
                        channelsMask[cntChannelMask] |= 0x00FF;
 800c24a:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 800c24e:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 800c252:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 800c256:	4318      	orrs	r0, r3
                        channelsMask[4] &= ~( bitMask << i );
 800c258:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
            for( uint8_t i = 0; i <= 7; i++ )
 800c25c:	f10c 0c01 	add.w	ip, ip, #1
 800c260:	f1bc 0f08 	cmp.w	ip, #8
 800c264:	d1df      	bne.n	800c226 <RegionUS915LinkAdrReq+0x196>
 800c266:	e72d      	b.n	800c0c4 <RegionUS915LinkAdrReq+0x34>
                        channelsMask[cntChannelMask] |= 0xFF00;
 800c268:	f063 03ff 	orn	r3, r3, #255	; 0xff
 800c26c:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] |= ( bitMask << i );
 800c270:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 800c274:	4318      	orrs	r0, r3
                        cntChannelMask++;
 800c276:	3101      	adds	r1, #1
                        channelsMask[4] &= ~( bitMask << i );
 800c278:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c
                        cntChannelMask++;
 800c27c:	b2c9      	uxtb	r1, r1
 800c27e:	e7ed      	b.n	800c25c <RegionUS915LinkAdrReq+0x1cc>
                    if( ( i % 2 ) == 0 )
 800c280:	43c0      	mvns	r0, r0
 800c282:	f1bb 0f00 	cmp.w	fp, #0
 800c286:	d107      	bne.n	800c298 <RegionUS915LinkAdrReq+0x208>
                        channelsMask[cntChannelMask] &= 0xFF00;
 800c288:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 800c28c:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 800c290:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 800c294:	4018      	ands	r0, r3
 800c296:	e7df      	b.n	800c258 <RegionUS915LinkAdrReq+0x1c8>
                        channelsMask[cntChannelMask] &= 0x00FF;
 800c298:	b2db      	uxtb	r3, r3
 800c29a:	f82e 3c2c 	strh.w	r3, [lr, #-44]
                        channelsMask[4] &= ~( bitMask << i );
 800c29e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 800c2a2:	4018      	ands	r0, r3
 800c2a4:	e7e7      	b.n	800c276 <RegionUS915LinkAdrReq+0x1e6>
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 800c2a6:	a914      	add	r1, sp, #80	; 0x50
 800c2a8:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800c2ac:	f823 2c2c 	strh.w	r2, [r3, #-44]
 800c2b0:	e708      	b.n	800c0c4 <RegionUS915LinkAdrReq+0x34>
        status &= 0xFE; // Channel mask KO
 800c2b2:	f04f 0806 	mov.w	r8, #6
 800c2b6:	e71e      	b.n	800c0f6 <RegionUS915LinkAdrReq+0x66>
 800c2b8:	200010fc 	.word	0x200010fc
 800c2bc:	200010f8 	.word	0x200010f8

0800c2c0 <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 800c2c0:	b538      	push	{r3, r4, r5, lr}
 800c2c2:	4605      	mov	r5, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 800c2c4:	6840      	ldr	r0, [r0, #4]
 800c2c6:	f7ff fbdd 	bl	800ba84 <VerifyRfFreq>
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 800c2ca:	220d      	movs	r2, #13
        status &= 0xFE; // Channel frequency KO
 800c2cc:	2800      	cmp	r0, #0
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 800c2ce:	f04f 0108 	mov.w	r1, #8
 800c2d2:	f995 0000 	ldrsb.w	r0, [r5]
        status &= 0xFE; // Channel frequency KO
 800c2d6:	bf14      	ite	ne
 800c2d8:	2407      	movne	r4, #7
 800c2da:	2406      	moveq	r4, #6
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 800c2dc:	f7fe fb1f 	bl	800a91e <RegionCommonValueInRange>
 800c2e0:	b908      	cbnz	r0, 800c2e6 <RegionUS915RxParamSetupReq+0x26>
    {
        status &= 0xFD; // Datarate KO
 800c2e2:	f004 0405 	and.w	r4, r4, #5
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 800c2e6:	f995 0000 	ldrsb.w	r0, [r5]
 800c2ea:	2207      	movs	r2, #7
 800c2ec:	2105      	movs	r1, #5
 800c2ee:	f7fe fb16 	bl	800a91e <RegionCommonValueInRange>
 800c2f2:	2801      	cmp	r0, #1
 800c2f4:	d003      	beq.n	800c2fe <RegionUS915RxParamSetupReq+0x3e>
 800c2f6:	f995 3000 	ldrsb.w	r3, [r5]
 800c2fa:	2b0d      	cmp	r3, #13
 800c2fc:	dd01      	ble.n	800c302 <RegionUS915RxParamSetupReq+0x42>
        ( rxParamSetupReq->Datarate > DR_13 ) )
    {
        status &= 0xFD; // Datarate KO
 800c2fe:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 800c302:	f995 0001 	ldrsb.w	r0, [r5, #1]
 800c306:	2203      	movs	r2, #3
 800c308:	2100      	movs	r1, #0
 800c30a:	f7fe fb08 	bl	800a91e <RegionCommonValueInRange>
 800c30e:	b908      	cbnz	r0, 800c314 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 800c310:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
    }

#endif /* REGION_US915 */
    return status;
}
 800c314:	4620      	mov	r0, r4
 800c316:	bd38      	pop	{r3, r4, r5, pc}

0800c318 <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
}
 800c318:	f04f 30ff 	mov.w	r0, #4294967295
 800c31c:	4770      	bx	lr

0800c31e <RegionUS915TxParamSetupReq>:
 800c31e:	f04f 30ff 	mov.w	r0, #4294967295
 800c322:	4770      	bx	lr

0800c324 <RegionUS915DlChannelReq>:
 800c324:	f04f 30ff 	mov.w	r0, #4294967295
 800c328:	4770      	bx	lr
	...

0800c32c <RegionUS915AlternateDr>:
int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 800c32c:	4b0a      	ldr	r3, [pc, #40]	; (800c358 <RegionUS915AlternateDr+0x2c>)
 800c32e:	681a      	ldr	r2, [r3, #0]
 800c330:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 800c334:	b971      	cbnz	r1, 800c354 <RegionUS915AlternateDr+0x28>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 800c336:	3301      	adds	r3, #1
    }
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
 800c338:	f882 309d 	strb.w	r3, [r2, #157]	; 0x9d
 800c33c:	f892 309d 	ldrb.w	r3, [r2, #157]	; 0x9d
 800c340:	ebc3 02c3 	rsb	r2, r3, r3, lsl #3
 800c344:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 800c348:	b2db      	uxtb	r3, r3
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 800c34a:	2b1d      	cmp	r3, #29
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 800c34c:	bf34      	ite	cc
 800c34e:	2004      	movcc	r0, #4
 800c350:	2000      	movcs	r0, #0
 800c352:	4770      	bx	lr
        RegionNvmGroup1->JoinTrialsCounter--;
 800c354:	3b01      	subs	r3, #1
 800c356:	e7ef      	b.n	800c338 <RegionUS915AlternateDr+0xc>
 800c358:	200010f8 	.word	0x200010f8

0800c35c <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 800c35c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 800c360:	2600      	movs	r6, #0
{
 800c362:	b0a4      	sub	sp, #144	; 0x90
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 800c364:	4d4c      	ldr	r5, [pc, #304]	; (800c498 <RegionUS915NextChannel+0x13c>)
    uint8_t nbEnabledChannels = 0;
 800c366:	f88d 600e 	strb.w	r6, [sp, #14]
{
 800c36a:	4604      	mov	r4, r0
 800c36c:	460f      	mov	r7, r1
 800c36e:	4691      	mov	r9, r2
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 800c370:	4631      	mov	r1, r6
 800c372:	2244      	movs	r2, #68	; 0x44
 800c374:	a813      	add	r0, sp, #76	; 0x4c
{
 800c376:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannels = 0;
 800c378:	f88d 600f 	strb.w	r6, [sp, #15]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 800c37c:	9612      	str	r6, [sp, #72]	; 0x48
 800c37e:	f003 fb29 	bl	800f9d4 <memset>
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 800c382:	6828      	ldr	r0, [r5, #0]
 800c384:	f8df a114 	ldr.w	sl, [pc, #276]	; 800c49c <RegionUS915NextChannel+0x140>
 800c388:	4631      	mov	r1, r6
 800c38a:	2204      	movs	r2, #4
 800c38c:	3090      	adds	r0, #144	; 0x90
 800c38e:	f7fe fae8 	bl	800a962 <RegionCommonCountChannels>
 800c392:	4606      	mov	r6, r0
 800c394:	b958      	cbnz	r0, 800c3ae <RegionUS915NextChannel+0x52>
    { // Reactivate default channels
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 800c396:	f8da 1000 	ldr.w	r1, [sl]
 800c39a:	6828      	ldr	r0, [r5, #0]
 800c39c:	2204      	movs	r2, #4
 800c39e:	f501 7158 	add.w	r1, r1, #864	; 0x360
 800c3a2:	3090      	adds	r0, #144	; 0x90
 800c3a4:	f7fe fafb 	bl	800a99e <RegionCommonChanMaskCopy>

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 800c3a8:	682b      	ldr	r3, [r5, #0]
 800c3aa:	f883 609c 	strb.w	r6, [r3, #156]	; 0x9c
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 800c3ae:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800c3b2:	6829      	ldr	r1, [r5, #0]
 800c3b4:	f8da 2000 	ldr.w	r2, [sl]
 800c3b8:	2b03      	cmp	r3, #3
 800c3ba:	dd06      	ble.n	800c3ca <RegionUS915NextChannel+0x6e>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 800c3bc:	f891 0098 	ldrb.w	r0, [r1, #152]	; 0x98
 800c3c0:	b918      	cbnz	r0, 800c3ca <RegionUS915NextChannel+0x6e>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 800c3c2:	f8b2 0368 	ldrh.w	r0, [r2, #872]	; 0x368
 800c3c6:	f8a1 0098 	strh.w	r0, [r1, #152]	; 0x98
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 800c3ca:	7a60      	ldrb	r0, [r4, #9]
 800c3cc:	f88d 0010 	strb.w	r0, [sp, #16]
    countChannelsParams.Datarate = nextChanParams->Datarate;
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 800c3d0:	f101 0090 	add.w	r0, r1, #144	; 0x90
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 800c3d4:	e9cd 0205 	strd	r0, r2, [sp, #20]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 800c3d8:	2248      	movs	r2, #72	; 0x48
 800c3da:	f8ad 2020 	strh.w	r2, [sp, #32]
    countChannelsParams.JoinChannels = NULL;
 800c3de:	2200      	movs	r2, #0
 800c3e0:	9209      	str	r2, [sp, #36]	; 0x24

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 800c3e2:	6822      	ldr	r2, [r4, #0]
 800c3e4:	920a      	str	r2, [sp, #40]	; 0x28
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 800c3e6:	6862      	ldr	r2, [r4, #4]
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
 800c3e8:	9107      	str	r1, [sp, #28]
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 800c3ea:	920b      	str	r2, [sp, #44]	; 0x2c
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 800c3ec:	e9d4 0103 	ldrd	r0, r1, [r4, #12]
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 800c3f0:	7aa2      	ldrb	r2, [r4, #10]
 800c3f2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 800c3f6:	2201      	movs	r2, #1
 800c3f8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 800c3fc:	aa0d      	add	r2, sp, #52	; 0x34
 800c3fe:	e882 0003 	stmia.w	r2, {r0, r1}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 800c402:	7d22      	ldrb	r2, [r4, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800c404:	8ae1      	ldrh	r1, [r4, #22]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 800c406:	f88d 3011 	strb.w	r3, [sp, #17]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800c40a:	4618      	mov	r0, r3
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 800c40c:	f88d 203c 	strb.w	r2, [sp, #60]	; 0x3c
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800c410:	f7ff fb1a 	bl	800ba48 <GetTimeOnAir>

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 800c414:	ab04      	add	r3, sp, #16
 800c416:	9311      	str	r3, [sp, #68]	; 0x44

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 800c418:	f10d 030f 	add.w	r3, sp, #15
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 800c41c:	9010      	str	r0, [sp, #64]	; 0x40
    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 800c41e:	9300      	str	r3, [sp, #0]
 800c420:	f8cd 9004 	str.w	r9, [sp, #4]
 800c424:	f10d 030e 	add.w	r3, sp, #14
 800c428:	aa12      	add	r2, sp, #72	; 0x48
 800c42a:	4641      	mov	r1, r8
 800c42c:	a80a      	add	r0, sp, #40	; 0x28
 800c42e:	f7fe fcd2 	bl	800add6 <RegionCommonIdentifyChannels>
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 800c432:	4606      	mov	r6, r0
 800c434:	b988      	cbnz	r0, 800c45a <RegionUS915NextChannel+0xfe>
    {
        if( nextChanParams->Joined == true )
 800c436:	7a63      	ldrb	r3, [r4, #9]
 800c438:	b19b      	cbz	r3, 800c462 <RegionUS915NextChannel+0x106>
        {
            // Choose randomly on of the remaining channels
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 800c43a:	f89d 100e 	ldrb.w	r1, [sp, #14]
 800c43e:	3901      	subs	r1, #1
 800c440:	f000 fe5c 	bl	800d0fc <randr>
 800c444:	ab24      	add	r3, sp, #144	; 0x90
 800c446:	4418      	add	r0, r3
 800c448:	f810 3c48 	ldrb.w	r3, [r0, #-72]
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
                }
                *channel = 64 + i;
 800c44c:	703b      	strb	r3, [r7, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 800c44e:	6828      	ldr	r0, [r5, #0]
 800c450:	7839      	ldrb	r1, [r7, #0]
 800c452:	2248      	movs	r2, #72	; 0x48
 800c454:	3090      	adds	r0, #144	; 0x90
 800c456:	f7fe fa6b 	bl	800a930 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 800c45a:	4630      	mov	r0, r6
 800c45c:	b024      	add	sp, #144	; 0x90
 800c45e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            if( nextChanParams->Datarate == DR_0 )
 800c462:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800c466:	6828      	ldr	r0, [r5, #0]
 800c468:	b15b      	cbz	r3, 800c482 <RegionUS915NextChannel+0x126>
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 800c46a:	f890 0098 	ldrb.w	r0, [r0, #152]	; 0x98
 800c46e:	4632      	mov	r2, r6
 800c470:	b2d3      	uxtb	r3, r2
 800c472:	fa40 f103 	asr.w	r1, r0, r3
 800c476:	07c9      	lsls	r1, r1, #31
 800c478:	f102 0201 	add.w	r2, r2, #1
 800c47c:	d5f8      	bpl.n	800c470 <RegionUS915NextChannel+0x114>
                *channel = 64 + i;
 800c47e:	3340      	adds	r3, #64	; 0x40
 800c480:	e7e4      	b.n	800c44c <RegionUS915NextChannel+0xf0>
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 800c482:	f100 019c 	add.w	r1, r0, #156	; 0x9c
 800c486:	463a      	mov	r2, r7
 800c488:	3090      	adds	r0, #144	; 0x90
 800c48a:	f7fe f9cd 	bl	800a828 <RegionBaseUSComputeNext125kHzJoinChannel>
 800c48e:	2803      	cmp	r0, #3
 800c490:	d1dd      	bne.n	800c44e <RegionUS915NextChannel+0xf2>
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 800c492:	4606      	mov	r6, r0
 800c494:	e7e1      	b.n	800c45a <RegionUS915NextChannel+0xfe>
 800c496:	bf00      	nop
 800c498:	200010f8 	.word	0x200010f8
 800c49c:	200010fc 	.word	0x200010fc

0800c4a0 <RegionUS915SetContinuousWave>:
{
    return LORAMAC_STATUS_PARAMETER_INVALID;
}

void RegionUS915SetContinuousWave( ContinuousWaveParams_t* continuousWave )
{
 800c4a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#if defined( REGION_US915 )
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 800c4a4:	4e1f      	ldr	r6, [pc, #124]	; (800c524 <RegionUS915SetContinuousWave+0x84>)
 800c4a6:	4b20      	ldr	r3, [pc, #128]	; (800c528 <RegionUS915SetContinuousWave+0x88>)
 800c4a8:	7802      	ldrb	r2, [r0, #0]
 800c4aa:	f8d6 8000 	ldr.w	r8, [r6]
 800c4ae:	6819      	ldr	r1, [r3, #0]
 800c4b0:	f990 7002 	ldrsb.w	r7, [r0, #2]
 800c4b4:	f990 9001 	ldrsb.w	r9, [r0, #1]
 800c4b8:	230c      	movs	r3, #12
 800c4ba:	fb03 8202 	mla	r2, r3, r2, r8
{
 800c4be:	4604      	mov	r4, r0
    int8_t txPowerLimited = LimitTxPower( continuousWave->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[continuousWave->Channel].Band].TxMaxPower, continuousWave->Datarate, RegionNvmGroup2->ChannelsMask );
 800c4c0:	7a53      	ldrb	r3, [r2, #9]
 800c4c2:	2218      	movs	r2, #24
 800c4c4:	fb02 1303 	mla	r3, r2, r3, r1
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 800c4c8:	4638      	mov	r0, r7
 800c4ca:	f993 1002 	ldrsb.w	r1, [r3, #2]
 800c4ce:	f7fe fce1 	bl	800ae94 <RegionCommonLimitTxPower>
    if( datarate == DR_4 )
 800c4d2:	f1b9 0f04 	cmp.w	r9, #4
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 800c4d6:	4605      	mov	r5, r0
    if( datarate == DR_4 )
 800c4d8:	d117      	bne.n	800c50a <RegionUS915SetContinuousWave+0x6a>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 800c4da:	2f02      	cmp	r7, #2
 800c4dc:	463d      	mov	r5, r7
 800c4de:	bfb8      	it	lt
 800c4e0:	2502      	movlt	r5, #2
    int8_t phyTxPower = 0;
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 800c4e2:	7821      	ldrb	r1, [r4, #0]
 800c4e4:	6832      	ldr	r2, [r6, #0]
 800c4e6:	230c      	movs	r3, #12
 800c4e8:	434b      	muls	r3, r1

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800c4ea:	4628      	mov	r0, r5
    uint32_t frequency = RegionNvmGroup2->Channels[continuousWave->Channel].Frequency;
 800c4ec:	58d6      	ldr	r6, [r2, r3]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800c4ee:	490f      	ldr	r1, [pc, #60]	; (800c52c <RegionUS915SetContinuousWave+0x8c>)
 800c4f0:	2200      	movs	r2, #0
 800c4f2:	f7fe fc04 	bl	800acfe <RegionCommonComputeTxPower>

    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800c4f6:	4b0e      	ldr	r3, [pc, #56]	; (800c530 <RegionUS915SetContinuousWave+0x90>)
 800c4f8:	89a2      	ldrh	r2, [r4, #12]
 800c4fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c4fc:	9301      	str	r3, [sp, #4]
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 800c4fe:	4601      	mov	r1, r0
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800c500:	4630      	mov	r0, r6
#endif /* REGION_US915 */
}
 800c502:	b003      	add	sp, #12
 800c504:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Radio.SetTxContinuousWave( frequency, phyTxPower, continuousWave->Timeout );
 800c508:	4718      	bx	r3
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 800c50a:	2204      	movs	r2, #4
 800c50c:	2100      	movs	r1, #0
 800c50e:	f508 7058 	add.w	r0, r8, #864	; 0x360
 800c512:	f7fe fa26 	bl	800a962 <RegionCommonCountChannels>
 800c516:	2831      	cmp	r0, #49	; 0x31
 800c518:	d8e3      	bhi.n	800c4e2 <RegionUS915SetContinuousWave+0x42>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 800c51a:	2f05      	cmp	r7, #5
 800c51c:	463d      	mov	r5, r7
 800c51e:	bfb8      	it	lt
 800c520:	2505      	movlt	r5, #5
 800c522:	e7de      	b.n	800c4e2 <RegionUS915SetContinuousWave+0x42>
 800c524:	200010fc 	.word	0x200010fc
 800c528:	200010f8 	.word	0x200010f8
 800c52c:	41f00000 	.word	0x41f00000
 800c530:	08010fe4 	.word	0x08010fe4

0800c534 <RegionUS915ApplyDrOffset>:

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 800c534:	4b03      	ldr	r3, [pc, #12]	; (800c544 <RegionUS915ApplyDrOffset+0x10>)
 800c536:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800c53a:	5698      	ldrsb	r0, [r3, r2]

    if( datarate < 0 )
    {
        datarate = DR_0;
    }
    return datarate;
 800c53c:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
#else
    return 0;
#endif /* REGION_US915 */
}
 800c540:	b2c0      	uxtb	r0, r0
 800c542:	4770      	bx	lr
 800c544:	08010b1c 	.word	0x08010b1c

0800c548 <AES_CMAC_Init>:
            ( r )[i] = ( r )[i] ^ ( v )[i]; \
        }                                   \
    } while( 0 )

void AES_CMAC_Init( AES_CMAC_CTX* ctx )
{
 800c548:	b510      	push	{r4, lr}
    memset1( ctx->X, 0, sizeof ctx->X );
 800c54a:	2210      	movs	r2, #16
{
 800c54c:	4604      	mov	r4, r0
    memset1( ctx->X, 0, sizeof ctx->X );
 800c54e:	2100      	movs	r1, #0
 800c550:	30f1      	adds	r0, #241	; 0xf1
 800c552:	f000 fe03 	bl	800d15c <memset1>
    ctx->M_n = 0;
 800c556:	2100      	movs	r1, #0
 800c558:	f8c4 1114 	str.w	r1, [r4, #276]	; 0x114
    memset1( ctx->rijndael.ksch, '\0', 240 );
 800c55c:	4620      	mov	r0, r4
 800c55e:	22f0      	movs	r2, #240	; 0xf0
}
 800c560:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    memset1( ctx->rijndael.ksch, '\0', 240 );
 800c564:	f000 bdfa 	b.w	800d15c <memset1>

0800c568 <AES_CMAC_SetKey>:

void AES_CMAC_SetKey( AES_CMAC_CTX* ctx, const uint8_t key[AES_CMAC_KEY_LENGTH] )
{
 800c568:	4602      	mov	r2, r0
 800c56a:	4608      	mov	r0, r1
    lorawan_aes_set_key( key, AES_CMAC_KEY_LENGTH, &ctx->rijndael );
 800c56c:	2110      	movs	r1, #16
 800c56e:	f000 b99b 	b.w	800c8a8 <lorawan_aes_set_key>

0800c572 <AES_CMAC_Update>:
}

void AES_CMAC_Update( AES_CMAC_CTX* ctx, const uint8_t* data, uint32_t len )
{
 800c572:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800c576:	4604      	mov	r4, r0
    uint32_t mlen;
    uint8_t  in[16];

    if( ctx->M_n > 0 )
 800c578:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
{
 800c57c:	b085      	sub	sp, #20
 800c57e:	460e      	mov	r6, r1
 800c580:	4615      	mov	r5, r2
 800c582:	f204 1701 	addw	r7, r4, #257	; 0x101
    if( ctx->M_n > 0 )
 800c586:	b388      	cbz	r0, 800c5ec <AES_CMAC_Update+0x7a>
    {
        mlen = MIN( 16 - ctx->M_n, len );
 800c588:	f1c0 0910 	rsb	r9, r0, #16
 800c58c:	4591      	cmp	r9, r2
 800c58e:	46c8      	mov	r8, r9
 800c590:	bf28      	it	cs
 800c592:	4690      	movcs	r8, r2
        memcpy1( ctx->M_last + ctx->M_n, data, mlen );
 800c594:	fa1f f288 	uxth.w	r2, r8
 800c598:	4438      	add	r0, r7
 800c59a:	f000 fdcb 	bl	800d134 <memcpy1>
        ctx->M_n += mlen;
 800c59e:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 800c5a2:	4443      	add	r3, r8
        if( ctx->M_n < 16 || len == mlen )
 800c5a4:	2b0f      	cmp	r3, #15
        ctx->M_n += mlen;
 800c5a6:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
        if( ctx->M_n < 16 || len == mlen )
 800c5aa:	d928      	bls.n	800c5fe <AES_CMAC_Update+0x8c>
 800c5ac:	45a9      	cmp	r9, r5
 800c5ae:	d226      	bcs.n	800c5fe <AES_CMAC_Update+0x8c>
 800c5b0:	f104 03f1 	add.w	r3, r4, #241	; 0xf1
 800c5b4:	4699      	mov	r9, r3
            return;
        XOR( ctx->M_last, ctx->X );
 800c5b6:	f813 2b01 	ldrb.w	r2, [r3], #1
 800c5ba:	7bd9      	ldrb	r1, [r3, #15]
 800c5bc:	42bb      	cmp	r3, r7
 800c5be:	ea82 0201 	eor.w	r2, r2, r1
 800c5c2:	f803 2c01 	strb.w	r2, [r3, #-1]
 800c5c6:	d1f6      	bne.n	800c5b6 <AES_CMAC_Update+0x44>

        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800c5c8:	2210      	movs	r2, #16
 800c5ca:	4649      	mov	r1, r9
 800c5cc:	4668      	mov	r0, sp
 800c5ce:	f000 fdb1 	bl	800d134 <memcpy1>
        lorawan_aes_encrypt( in, in, &ctx->rijndael );
 800c5d2:	4622      	mov	r2, r4
 800c5d4:	4669      	mov	r1, sp
 800c5d6:	4668      	mov	r0, sp
 800c5d8:	f000 f9e0 	bl	800c99c <lorawan_aes_encrypt>
        memcpy1( &ctx->X[0], in, 16 );
 800c5dc:	2210      	movs	r2, #16
 800c5de:	4669      	mov	r1, sp
 800c5e0:	4648      	mov	r0, r9
 800c5e2:	f000 fda7 	bl	800d134 <memcpy1>

        data += mlen;
 800c5e6:	4446      	add	r6, r8
        len -= mlen;
 800c5e8:	eba5 0508 	sub.w	r5, r5, r8
    }
    while( len > 16 )
 800c5ec:	2d10      	cmp	r5, #16
 800c5ee:	d809      	bhi.n	800c604 <AES_CMAC_Update+0x92>

        data += 16;
        len -= 16;
    }
    /* potential last block, save it */
    memcpy1( ctx->M_last, data, len );
 800c5f0:	b2aa      	uxth	r2, r5
 800c5f2:	4631      	mov	r1, r6
 800c5f4:	4638      	mov	r0, r7
 800c5f6:	f000 fd9d 	bl	800d134 <memcpy1>
    ctx->M_n = len;
 800c5fa:	f8c4 5114 	str.w	r5, [r4, #276]	; 0x114
}
 800c5fe:	b005      	add	sp, #20
 800c600:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800c604:	f104 03f1 	add.w	r3, r4, #241	; 0xf1
 800c608:	1e71      	subs	r1, r6, #1
 800c60a:	4698      	mov	r8, r3
        XOR( data, ctx->X );
 800c60c:	781a      	ldrb	r2, [r3, #0]
 800c60e:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 800c612:	4042      	eors	r2, r0
 800c614:	f803 2b01 	strb.w	r2, [r3], #1
 800c618:	42bb      	cmp	r3, r7
 800c61a:	d1f7      	bne.n	800c60c <AES_CMAC_Update+0x9a>
        memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800c61c:	2210      	movs	r2, #16
 800c61e:	4641      	mov	r1, r8
 800c620:	4668      	mov	r0, sp
 800c622:	f000 fd87 	bl	800d134 <memcpy1>
        lorawan_aes_encrypt( in, in, &ctx->rijndael );
 800c626:	4622      	mov	r2, r4
 800c628:	4669      	mov	r1, sp
 800c62a:	4668      	mov	r0, sp
 800c62c:	f000 f9b6 	bl	800c99c <lorawan_aes_encrypt>
        memcpy1( &ctx->X[0], in, 16 );
 800c630:	2210      	movs	r2, #16
 800c632:	4669      	mov	r1, sp
 800c634:	4640      	mov	r0, r8
 800c636:	f000 fd7d 	bl	800d134 <memcpy1>
        data += 16;
 800c63a:	3610      	adds	r6, #16
        len -= 16;
 800c63c:	3d10      	subs	r5, #16
 800c63e:	e7d5      	b.n	800c5ec <AES_CMAC_Update+0x7a>

0800c640 <AES_CMAC_Final>:

void AES_CMAC_Final( uint8_t digest[AES_CMAC_DIGEST_LENGTH], AES_CMAC_CTX* ctx )
{
 800c640:	b570      	push	{r4, r5, r6, lr}
 800c642:	b088      	sub	sp, #32
 800c644:	460c      	mov	r4, r1
    uint8_t K[16];
    uint8_t in[16];
    /* generate subkey K1 */
    memset1( K, '\0', 16 );
 800c646:	2210      	movs	r2, #16
 800c648:	2100      	movs	r1, #0
{
 800c64a:	4605      	mov	r5, r0
    memset1( K, '\0', 16 );
 800c64c:	4668      	mov	r0, sp
 800c64e:	f000 fd85 	bl	800d15c <memset1>

    lorawan_aes_encrypt( K, K, &ctx->rijndael );
 800c652:	4622      	mov	r2, r4
 800c654:	4669      	mov	r1, sp
 800c656:	4668      	mov	r0, sp
 800c658:	f000 f9a0 	bl	800c99c <lorawan_aes_encrypt>

    if( K[0] & 0x80 )
 800c65c:	f99d 3000 	ldrsb.w	r3, [sp]
 800c660:	2b00      	cmp	r3, #0
 800c662:	466a      	mov	r2, sp
    {
        LSHIFT( K, K );
 800c664:	f04f 0100 	mov.w	r1, #0
    if( K[0] & 0x80 )
 800c668:	da41      	bge.n	800c6ee <AES_CMAC_Final+0xae>
        LSHIFT( K, K );
 800c66a:	7813      	ldrb	r3, [r2, #0]
 800c66c:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 800c670:	3101      	adds	r1, #1
 800c672:	005b      	lsls	r3, r3, #1
 800c674:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
 800c678:	290f      	cmp	r1, #15
 800c67a:	f802 3c01 	strb.w	r3, [r2, #-1]
 800c67e:	d1f4      	bne.n	800c66a <AES_CMAC_Final+0x2a>
 800c680:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800c684:	005b      	lsls	r3, r3, #1
        K[15] ^= 0x87;
 800c686:	f083 0387 	eor.w	r3, r3, #135	; 0x87
    }
    else
        LSHIFT( K, K );
 800c68a:	f88d 300f 	strb.w	r3, [sp, #15]

    if( ctx->M_n == 16 )
 800c68e:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
 800c692:	2b10      	cmp	r3, #16
 800c694:	d13a      	bne.n	800c70c <AES_CMAC_Final+0xcc>
 800c696:	f204 1301 	addw	r3, r4, #257	; 0x101
 800c69a:	4669      	mov	r1, sp
 800c69c:	f204 1011 	addw	r0, r4, #273	; 0x111
    {
        /* last block was a complete block */
        XOR( K, ctx->M_last );
 800c6a0:	781a      	ldrb	r2, [r3, #0]
 800c6a2:	f811 6b01 	ldrb.w	r6, [r1], #1
 800c6a6:	4072      	eors	r2, r6
 800c6a8:	f803 2b01 	strb.w	r2, [r3], #1
 800c6ac:	4298      	cmp	r0, r3
 800c6ae:	d1f7      	bne.n	800c6a0 <AES_CMAC_Final+0x60>
 800c6b0:	f104 03f1 	add.w	r3, r4, #241	; 0xf1
 800c6b4:	f204 1001 	addw	r0, r4, #257	; 0x101
 800c6b8:	4619      	mov	r1, r3
        while( ++ctx->M_n < 16 )
            ctx->M_last[ctx->M_n] = 0;

        XOR( K, ctx->M_last );
    }
    XOR( ctx->M_last, ctx->X );
 800c6ba:	f813 2b01 	ldrb.w	r2, [r3], #1
 800c6be:	7bde      	ldrb	r6, [r3, #15]
 800c6c0:	4298      	cmp	r0, r3
 800c6c2:	ea82 0206 	eor.w	r2, r2, r6
 800c6c6:	f803 2c01 	strb.w	r2, [r3, #-1]
 800c6ca:	d1f6      	bne.n	800c6ba <AES_CMAC_Final+0x7a>

    memcpy1( in, &ctx->X[0], 16 );  // Otherwise it does not look good
 800c6cc:	2210      	movs	r2, #16
 800c6ce:	eb0d 0002 	add.w	r0, sp, r2
 800c6d2:	f000 fd2f 	bl	800d134 <memcpy1>
    lorawan_aes_encrypt( in, digest, &ctx->rijndael );
 800c6d6:	4622      	mov	r2, r4
 800c6d8:	4629      	mov	r1, r5
 800c6da:	a804      	add	r0, sp, #16
 800c6dc:	f000 f95e 	bl	800c99c <lorawan_aes_encrypt>
    memset1( K, 0, sizeof K );
 800c6e0:	2210      	movs	r2, #16
 800c6e2:	2100      	movs	r1, #0
 800c6e4:	4668      	mov	r0, sp
 800c6e6:	f000 fd39 	bl	800d15c <memset1>
}
 800c6ea:	b008      	add	sp, #32
 800c6ec:	bd70      	pop	{r4, r5, r6, pc}
        LSHIFT( K, K );
 800c6ee:	7813      	ldrb	r3, [r2, #0]
 800c6f0:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 800c6f4:	3101      	adds	r1, #1
 800c6f6:	005b      	lsls	r3, r3, #1
 800c6f8:	ea43 13d0 	orr.w	r3, r3, r0, lsr #7
 800c6fc:	290f      	cmp	r1, #15
 800c6fe:	f802 3c01 	strb.w	r3, [r2, #-1]
 800c702:	d1f4      	bne.n	800c6ee <AES_CMAC_Final+0xae>
 800c704:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800c708:	005b      	lsls	r3, r3, #1
 800c70a:	e7be      	b.n	800c68a <AES_CMAC_Final+0x4a>
        if( K[0] & 0x80 )
 800c70c:	f99d 2000 	ldrsb.w	r2, [sp]
 800c710:	2a00      	cmp	r2, #0
 800c712:	4669      	mov	r1, sp
            LSHIFT( K, K );
 800c714:	f04f 0000 	mov.w	r0, #0
        if( K[0] & 0x80 )
 800c718:	da31      	bge.n	800c77e <AES_CMAC_Final+0x13e>
            LSHIFT( K, K );
 800c71a:	780a      	ldrb	r2, [r1, #0]
 800c71c:	f811 6f01 	ldrb.w	r6, [r1, #1]!
 800c720:	3001      	adds	r0, #1
 800c722:	0052      	lsls	r2, r2, #1
 800c724:	ea42 12d6 	orr.w	r2, r2, r6, lsr #7
 800c728:	280f      	cmp	r0, #15
 800c72a:	f801 2c01 	strb.w	r2, [r1, #-1]
 800c72e:	d1f4      	bne.n	800c71a <AES_CMAC_Final+0xda>
 800c730:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800c734:	0052      	lsls	r2, r2, #1
            K[15] ^= 0x87;
 800c736:	f082 0287 	eor.w	r2, r2, #135	; 0x87
            LSHIFT( K, K );
 800c73a:	f88d 200f 	strb.w	r2, [sp, #15]
        ctx->M_last[ctx->M_n] = 0x80;
 800c73e:	18e2      	adds	r2, r4, r3
 800c740:	2180      	movs	r1, #128	; 0x80
 800c742:	1c58      	adds	r0, r3, #1
 800c744:	f882 1101 	strb.w	r1, [r2, #257]	; 0x101
            ctx->M_last[ctx->M_n] = 0;
 800c748:	2600      	movs	r6, #0
        while( ++ctx->M_n < 16 )
 800c74a:	4601      	mov	r1, r0
 800c74c:	f204 1201 	addw	r2, r4, #257	; 0x101
 800c750:	290f      	cmp	r1, #15
 800c752:	d923      	bls.n	800c79c <AES_CMAC_Final+0x15c>
 800c754:	2810      	cmp	r0, #16
 800c756:	f1c3 030f 	rsb	r3, r3, #15
 800c75a:	bf88      	it	hi
 800c75c:	2300      	movhi	r3, #0
 800c75e:	4403      	add	r3, r0
 800c760:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
 800c764:	4669      	mov	r1, sp
 800c766:	4613      	mov	r3, r2
 800c768:	f204 1011 	addw	r0, r4, #273	; 0x111
        XOR( K, ctx->M_last );
 800c76c:	781a      	ldrb	r2, [r3, #0]
 800c76e:	f811 6b01 	ldrb.w	r6, [r1], #1
 800c772:	4072      	eors	r2, r6
 800c774:	f803 2b01 	strb.w	r2, [r3], #1
 800c778:	4298      	cmp	r0, r3
 800c77a:	d1f7      	bne.n	800c76c <AES_CMAC_Final+0x12c>
 800c77c:	e798      	b.n	800c6b0 <AES_CMAC_Final+0x70>
            LSHIFT( K, K );
 800c77e:	780a      	ldrb	r2, [r1, #0]
 800c780:	f811 6f01 	ldrb.w	r6, [r1, #1]!
 800c784:	3001      	adds	r0, #1
 800c786:	0052      	lsls	r2, r2, #1
 800c788:	ea42 12d6 	orr.w	r2, r2, r6, lsr #7
 800c78c:	280f      	cmp	r0, #15
 800c78e:	f801 2c01 	strb.w	r2, [r1, #-1]
 800c792:	d1f4      	bne.n	800c77e <AES_CMAC_Final+0x13e>
 800c794:	f89d 200f 	ldrb.w	r2, [sp, #15]
 800c798:	0052      	lsls	r2, r2, #1
 800c79a:	e7ce      	b.n	800c73a <AES_CMAC_Final+0xfa>
            ctx->M_last[ctx->M_n] = 0;
 800c79c:	5456      	strb	r6, [r2, r1]
 800c79e:	3101      	adds	r1, #1
 800c7a0:	e7d6      	b.n	800c750 <AES_CMAC_Final+0x110>

0800c7a2 <xor_block>:
    ((uint32_t*)d)[ 0] ^= ((uint32_t*)s)[ 0];
    ((uint32_t*)d)[ 1] ^= ((uint32_t*)s)[ 1];
    ((uint32_t*)d)[ 2] ^= ((uint32_t*)s)[ 2];
    ((uint32_t*)d)[ 3] ^= ((uint32_t*)s)[ 3];
#else
    ((uint8_t*)d)[ 0] ^= ((uint8_t*)s)[ 0];
 800c7a2:	780a      	ldrb	r2, [r1, #0]
 800c7a4:	7803      	ldrb	r3, [r0, #0]
 800c7a6:	4053      	eors	r3, r2
 800c7a8:	7003      	strb	r3, [r0, #0]
    ((uint8_t*)d)[ 1] ^= ((uint8_t*)s)[ 1];
 800c7aa:	784a      	ldrb	r2, [r1, #1]
 800c7ac:	7843      	ldrb	r3, [r0, #1]
 800c7ae:	4053      	eors	r3, r2
 800c7b0:	7043      	strb	r3, [r0, #1]
    ((uint8_t*)d)[ 2] ^= ((uint8_t*)s)[ 2];
 800c7b2:	788a      	ldrb	r2, [r1, #2]
 800c7b4:	7883      	ldrb	r3, [r0, #2]
 800c7b6:	4053      	eors	r3, r2
 800c7b8:	7083      	strb	r3, [r0, #2]
    ((uint8_t*)d)[ 3] ^= ((uint8_t*)s)[ 3];
 800c7ba:	78ca      	ldrb	r2, [r1, #3]
 800c7bc:	78c3      	ldrb	r3, [r0, #3]
 800c7be:	4053      	eors	r3, r2
 800c7c0:	70c3      	strb	r3, [r0, #3]
    ((uint8_t*)d)[ 4] ^= ((uint8_t*)s)[ 4];
 800c7c2:	790a      	ldrb	r2, [r1, #4]
 800c7c4:	7903      	ldrb	r3, [r0, #4]
 800c7c6:	4053      	eors	r3, r2
 800c7c8:	7103      	strb	r3, [r0, #4]
    ((uint8_t*)d)[ 5] ^= ((uint8_t*)s)[ 5];
 800c7ca:	794a      	ldrb	r2, [r1, #5]
 800c7cc:	7943      	ldrb	r3, [r0, #5]
 800c7ce:	4053      	eors	r3, r2
 800c7d0:	7143      	strb	r3, [r0, #5]
    ((uint8_t*)d)[ 6] ^= ((uint8_t*)s)[ 6];
 800c7d2:	798a      	ldrb	r2, [r1, #6]
 800c7d4:	7983      	ldrb	r3, [r0, #6]
 800c7d6:	4053      	eors	r3, r2
 800c7d8:	7183      	strb	r3, [r0, #6]
    ((uint8_t*)d)[ 7] ^= ((uint8_t*)s)[ 7];
 800c7da:	79ca      	ldrb	r2, [r1, #7]
 800c7dc:	79c3      	ldrb	r3, [r0, #7]
 800c7de:	4053      	eors	r3, r2
 800c7e0:	71c3      	strb	r3, [r0, #7]
    ((uint8_t*)d)[ 8] ^= ((uint8_t*)s)[ 8];
 800c7e2:	7a0a      	ldrb	r2, [r1, #8]
 800c7e4:	7a03      	ldrb	r3, [r0, #8]
 800c7e6:	4053      	eors	r3, r2
 800c7e8:	7203      	strb	r3, [r0, #8]
    ((uint8_t*)d)[ 9] ^= ((uint8_t*)s)[ 9];
 800c7ea:	7a4a      	ldrb	r2, [r1, #9]
 800c7ec:	7a43      	ldrb	r3, [r0, #9]
 800c7ee:	4053      	eors	r3, r2
 800c7f0:	7243      	strb	r3, [r0, #9]
    ((uint8_t*)d)[10] ^= ((uint8_t*)s)[10];
 800c7f2:	7a8a      	ldrb	r2, [r1, #10]
 800c7f4:	7a83      	ldrb	r3, [r0, #10]
 800c7f6:	4053      	eors	r3, r2
 800c7f8:	7283      	strb	r3, [r0, #10]
    ((uint8_t*)d)[11] ^= ((uint8_t*)s)[11];
 800c7fa:	7aca      	ldrb	r2, [r1, #11]
 800c7fc:	7ac3      	ldrb	r3, [r0, #11]
 800c7fe:	4053      	eors	r3, r2
 800c800:	72c3      	strb	r3, [r0, #11]
    ((uint8_t*)d)[12] ^= ((uint8_t*)s)[12];
 800c802:	7b0a      	ldrb	r2, [r1, #12]
 800c804:	7b03      	ldrb	r3, [r0, #12]
 800c806:	4053      	eors	r3, r2
 800c808:	7303      	strb	r3, [r0, #12]
    ((uint8_t*)d)[13] ^= ((uint8_t*)s)[13];
 800c80a:	7b4a      	ldrb	r2, [r1, #13]
 800c80c:	7b43      	ldrb	r3, [r0, #13]
 800c80e:	4053      	eors	r3, r2
 800c810:	7343      	strb	r3, [r0, #13]
    ((uint8_t*)d)[14] ^= ((uint8_t*)s)[14];
 800c812:	7b8a      	ldrb	r2, [r1, #14]
 800c814:	7b83      	ldrb	r3, [r0, #14]
 800c816:	4053      	eors	r3, r2
 800c818:	7383      	strb	r3, [r0, #14]
    ((uint8_t*)d)[15] ^= ((uint8_t*)s)[15];
 800c81a:	7bca      	ldrb	r2, [r1, #15]
 800c81c:	7bc3      	ldrb	r3, [r0, #15]
 800c81e:	4053      	eors	r3, r2
 800c820:	73c3      	strb	r3, [r0, #15]
#endif
}
 800c822:	4770      	bx	lr

0800c824 <copy_and_key>:

static void copy_and_key( void *d, const void *s, const void *k )
{
 800c824:	b510      	push	{r4, lr}
    ((uint32_t*)d)[ 0] = ((uint32_t*)s)[ 0] ^ ((uint32_t*)k)[ 0];
    ((uint32_t*)d)[ 1] = ((uint32_t*)s)[ 1] ^ ((uint32_t*)k)[ 1];
    ((uint32_t*)d)[ 2] = ((uint32_t*)s)[ 2] ^ ((uint32_t*)k)[ 2];
    ((uint32_t*)d)[ 3] = ((uint32_t*)s)[ 3] ^ ((uint32_t*)k)[ 3];
#elif 1
    ((uint8_t*)d)[ 0] = ((uint8_t*)s)[ 0] ^ ((uint8_t*)k)[ 0];
 800c826:	780b      	ldrb	r3, [r1, #0]
 800c828:	7814      	ldrb	r4, [r2, #0]
 800c82a:	4063      	eors	r3, r4
 800c82c:	7003      	strb	r3, [r0, #0]
    ((uint8_t*)d)[ 1] = ((uint8_t*)s)[ 1] ^ ((uint8_t*)k)[ 1];
 800c82e:	7854      	ldrb	r4, [r2, #1]
 800c830:	784b      	ldrb	r3, [r1, #1]
 800c832:	4063      	eors	r3, r4
 800c834:	7043      	strb	r3, [r0, #1]
    ((uint8_t*)d)[ 2] = ((uint8_t*)s)[ 2] ^ ((uint8_t*)k)[ 2];
 800c836:	7894      	ldrb	r4, [r2, #2]
 800c838:	788b      	ldrb	r3, [r1, #2]
 800c83a:	4063      	eors	r3, r4
 800c83c:	7083      	strb	r3, [r0, #2]
    ((uint8_t*)d)[ 3] = ((uint8_t*)s)[ 3] ^ ((uint8_t*)k)[ 3];
 800c83e:	78d4      	ldrb	r4, [r2, #3]
 800c840:	78cb      	ldrb	r3, [r1, #3]
 800c842:	4063      	eors	r3, r4
 800c844:	70c3      	strb	r3, [r0, #3]
    ((uint8_t*)d)[ 4] = ((uint8_t*)s)[ 4] ^ ((uint8_t*)k)[ 4];
 800c846:	7914      	ldrb	r4, [r2, #4]
 800c848:	790b      	ldrb	r3, [r1, #4]
 800c84a:	4063      	eors	r3, r4
 800c84c:	7103      	strb	r3, [r0, #4]
    ((uint8_t*)d)[ 5] = ((uint8_t*)s)[ 5] ^ ((uint8_t*)k)[ 5];
 800c84e:	7954      	ldrb	r4, [r2, #5]
 800c850:	794b      	ldrb	r3, [r1, #5]
 800c852:	4063      	eors	r3, r4
 800c854:	7143      	strb	r3, [r0, #5]
    ((uint8_t*)d)[ 6] = ((uint8_t*)s)[ 6] ^ ((uint8_t*)k)[ 6];
 800c856:	7994      	ldrb	r4, [r2, #6]
 800c858:	798b      	ldrb	r3, [r1, #6]
 800c85a:	4063      	eors	r3, r4
 800c85c:	7183      	strb	r3, [r0, #6]
    ((uint8_t*)d)[ 7] = ((uint8_t*)s)[ 7] ^ ((uint8_t*)k)[ 7];
 800c85e:	79d4      	ldrb	r4, [r2, #7]
 800c860:	79cb      	ldrb	r3, [r1, #7]
 800c862:	4063      	eors	r3, r4
 800c864:	71c3      	strb	r3, [r0, #7]
    ((uint8_t*)d)[ 8] = ((uint8_t*)s)[ 8] ^ ((uint8_t*)k)[ 8];
 800c866:	7a14      	ldrb	r4, [r2, #8]
 800c868:	7a0b      	ldrb	r3, [r1, #8]
 800c86a:	4063      	eors	r3, r4
 800c86c:	7203      	strb	r3, [r0, #8]
    ((uint8_t*)d)[ 9] = ((uint8_t*)s)[ 9] ^ ((uint8_t*)k)[ 9];
 800c86e:	7a54      	ldrb	r4, [r2, #9]
 800c870:	7a4b      	ldrb	r3, [r1, #9]
 800c872:	4063      	eors	r3, r4
 800c874:	7243      	strb	r3, [r0, #9]
    ((uint8_t*)d)[10] = ((uint8_t*)s)[10] ^ ((uint8_t*)k)[10];
 800c876:	7a8b      	ldrb	r3, [r1, #10]
 800c878:	7a94      	ldrb	r4, [r2, #10]
 800c87a:	4063      	eors	r3, r4
 800c87c:	7283      	strb	r3, [r0, #10]
    ((uint8_t*)d)[11] = ((uint8_t*)s)[11] ^ ((uint8_t*)k)[11];
 800c87e:	7ad4      	ldrb	r4, [r2, #11]
 800c880:	7acb      	ldrb	r3, [r1, #11]
 800c882:	4063      	eors	r3, r4
 800c884:	72c3      	strb	r3, [r0, #11]
    ((uint8_t*)d)[12] = ((uint8_t*)s)[12] ^ ((uint8_t*)k)[12];
 800c886:	7b14      	ldrb	r4, [r2, #12]
 800c888:	7b0b      	ldrb	r3, [r1, #12]
 800c88a:	4063      	eors	r3, r4
 800c88c:	7303      	strb	r3, [r0, #12]
    ((uint8_t*)d)[13] = ((uint8_t*)s)[13] ^ ((uint8_t*)k)[13];
 800c88e:	7b54      	ldrb	r4, [r2, #13]
 800c890:	7b4b      	ldrb	r3, [r1, #13]
 800c892:	4063      	eors	r3, r4
 800c894:	7343      	strb	r3, [r0, #13]
    ((uint8_t*)d)[14] = ((uint8_t*)s)[14] ^ ((uint8_t*)k)[14];
 800c896:	7b94      	ldrb	r4, [r2, #14]
 800c898:	7b8b      	ldrb	r3, [r1, #14]
 800c89a:	4063      	eors	r3, r4
 800c89c:	7383      	strb	r3, [r0, #14]
    ((uint8_t*)d)[15] = ((uint8_t*)s)[15] ^ ((uint8_t*)k)[15];
 800c89e:	7bcb      	ldrb	r3, [r1, #15]
 800c8a0:	7bd2      	ldrb	r2, [r2, #15]
 800c8a2:	4053      	eors	r3, r2
 800c8a4:	73c3      	strb	r3, [r0, #15]
#else
    block_copy(d, s);
    xor_block(d, k);
#endif
}
 800c8a6:	bd10      	pop	{r4, pc}

0800c8a8 <lorawan_aes_set_key>:

return_type lorawan_aes_set_key( const uint8_t key[], length_type keylen, lorawan_aes_context ctx[1] )
{
    uint8_t cc, rc, hi;

    switch( keylen )
 800c8a8:	f1a1 0310 	sub.w	r3, r1, #16
{
 800c8ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c8b0:	b2dc      	uxtb	r4, r3
 800c8b2:	2c10      	cmp	r4, #16
 800c8b4:	d806      	bhi.n	800c8c4 <lorawan_aes_set_key+0x1c>
 800c8b6:	2301      	movs	r3, #1
 800c8b8:	40a3      	lsls	r3, r4
 800c8ba:	f003 3301 	and.w	r3, r3, #16843009	; 0x1010101
 800c8be:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800c8c2:	b92b      	cbnz	r3, 800c8d0 <lorawan_aes_set_key+0x28>
    case 16:
    case 24:
    case 32:
        break;
    default:
        ctx->rnd = 0;
 800c8c4:	2300      	movs	r3, #0
 800c8c6:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
        return ( uint8_t )-1;
 800c8ca:	20ff      	movs	r0, #255	; 0xff
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
    }
    return 0;
}
 800c8cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while( nn-- )
 800c8d0:	1e53      	subs	r3, r2, #1
 800c8d2:	1844      	adds	r4, r0, r1
 800c8d4:	42a0      	cmp	r0, r4
 800c8d6:	d14f      	bne.n	800c978 <lorawan_aes_set_key+0xd0>
    hi = (keylen + 28) << 2;
 800c8d8:	f101 031c 	add.w	r3, r1, #28
 800c8dc:	009b      	lsls	r3, r3, #2
 800c8de:	fa5f f883 	uxtb.w	r8, r3
    ctx->rnd = (hi >> 4) - 1;
 800c8e2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800c8e6:	3b01      	subs	r3, #1
            t0 = s_box(t0);
 800c8e8:	4c2b      	ldr	r4, [pc, #172]	; (800c998 <lorawan_aes_set_key+0xf0>)
    ctx->rnd = (hi >> 4) - 1;
 800c8ea:	f882 30f0 	strb.w	r3, [r2, #240]	; 0xf0
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800c8ee:	f04f 0901 	mov.w	r9, #1
    ctx->rnd = (hi >> 4) - 1;
 800c8f2:	460b      	mov	r3, r1
        t0 = ctx->ksch[cc - 4];
 800c8f4:	18d5      	adds	r5, r2, r3
        if( cc % keylen == 0 )
 800c8f6:	fbb3 f0f1 	udiv	r0, r3, r1
 800c8fa:	fb01 3010 	mls	r0, r1, r0, r3
 800c8fe:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
        t0 = ctx->ksch[cc - 4];
 800c902:	f815 ac04 	ldrb.w	sl, [r5, #-4]
        t1 = ctx->ksch[cc - 3];
 800c906:	f815 cc03 	ldrb.w	ip, [r5, #-3]
        t2 = ctx->ksch[cc - 2];
 800c90a:	f815 7c02 	ldrb.w	r7, [r5, #-2]
        t3 = ctx->ksch[cc - 1];
 800c90e:	f815 6c01 	ldrb.w	r6, [r5, #-1]
        if( cc % keylen == 0 )
 800c912:	d136      	bne.n	800c982 <lorawan_aes_set_key+0xda>
            rc = f2(rc);
 800c914:	ea4f 10d9 	mov.w	r0, r9, lsr #7
            t0 = s_box(t1) ^ rc;
 800c918:	f814 e00c 	ldrb.w	lr, [r4, ip]
            t1 = s_box(t2);
 800c91c:	f814 c007 	ldrb.w	ip, [r4, r7]
            t2 = s_box(t3);
 800c920:	5da7      	ldrb	r7, [r4, r6]
            t3 = s_box(tt);
 800c922:	f814 600a 	ldrb.w	r6, [r4, sl]
            rc = f2(rc);
 800c926:	ea4f 0a40 	mov.w	sl, r0, lsl #1
 800c92a:	4450      	add	r0, sl
 800c92c:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
            t0 = s_box(t1) ^ rc;
 800c930:	ea89 0e0e 	eor.w	lr, r9, lr
            rc = f2(rc);
 800c934:	ea80 0049 	eor.w	r0, r0, r9, lsl #1
 800c938:	fa5f f980 	uxtb.w	r9, r0
            t0 = s_box(t1) ^ rc;
 800c93c:	46f2      	mov	sl, lr
        ctx->ksch[cc + 0] = ctx->ksch[tt + 0] ^ t0;
 800c93e:	1a58      	subs	r0, r3, r1
 800c940:	b2c0      	uxtb	r0, r0
 800c942:	f812 e000 	ldrb.w	lr, [r2, r0]
 800c946:	ea8a 0a0e 	eor.w	sl, sl, lr
 800c94a:	f802 a003 	strb.w	sl, [r2, r3]
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
 800c94e:	4410      	add	r0, r2
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800c950:	3304      	adds	r3, #4
        ctx->ksch[cc + 1] = ctx->ksch[tt + 1] ^ t1;
 800c952:	f890 e001 	ldrb.w	lr, [r0, #1]
 800c956:	ea8c 0c0e 	eor.w	ip, ip, lr
 800c95a:	f885 c001 	strb.w	ip, [r5, #1]
        ctx->ksch[cc + 2] = ctx->ksch[tt + 2] ^ t2;
 800c95e:	f890 c002 	ldrb.w	ip, [r0, #2]
 800c962:	ea87 070c 	eor.w	r7, r7, ip
 800c966:	70af      	strb	r7, [r5, #2]
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800c968:	78c0      	ldrb	r0, [r0, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800c96a:	b2db      	uxtb	r3, r3
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800c96c:	4046      	eors	r6, r0
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800c96e:	4598      	cmp	r8, r3
        ctx->ksch[cc + 3] = ctx->ksch[tt + 3] ^ t3;
 800c970:	70ee      	strb	r6, [r5, #3]
    for( cc = keylen, rc = 1; cc < hi; cc += 4 )
 800c972:	d8bf      	bhi.n	800c8f4 <lorawan_aes_set_key+0x4c>
    return 0;
 800c974:	2000      	movs	r0, #0
 800c976:	e7a9      	b.n	800c8cc <lorawan_aes_set_key+0x24>
        *d++ = *s++;
 800c978:	f810 5b01 	ldrb.w	r5, [r0], #1
 800c97c:	f803 5f01 	strb.w	r5, [r3, #1]!
 800c980:	e7a8      	b.n	800c8d4 <lorawan_aes_set_key+0x2c>
        else if( keylen > 24 && cc % keylen == 16 )
 800c982:	2918      	cmp	r1, #24
 800c984:	d9db      	bls.n	800c93e <lorawan_aes_set_key+0x96>
 800c986:	2810      	cmp	r0, #16
            t0 = s_box(t0);
 800c988:	bf01      	itttt	eq
 800c98a:	f814 a00a 	ldrbeq.w	sl, [r4, sl]
            t1 = s_box(t1);
 800c98e:	f814 c00c 	ldrbeq.w	ip, [r4, ip]
            t2 = s_box(t2);
 800c992:	5de7      	ldrbeq	r7, [r4, r7]
            t3 = s_box(t3);
 800c994:	5da6      	ldrbeq	r6, [r4, r6]
 800c996:	e7d2      	b.n	800c93e <lorawan_aes_set_key+0x96>
 800c998:	08010d60 	.word	0x08010d60

0800c99c <lorawan_aes_encrypt>:
#if defined( AES_ENC_PREKEYED )

/*  Encrypt a single block of 16 bytes */

return_type lorawan_aes_encrypt( const uint8_t in[N_BLOCK], uint8_t  out[N_BLOCK], const lorawan_aes_context ctx[1] )
{
 800c99c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( ctx->rnd )
 800c9a0:	f892 30f0 	ldrb.w	r3, [r2, #240]	; 0xf0
{
 800c9a4:	b0a1      	sub	sp, #132	; 0x84
 800c9a6:	e9cd 211a 	strd	r2, r1, [sp, #104]	; 0x68
    if( ctx->rnd )
 800c9aa:	2b00      	cmp	r3, #0
 800c9ac:	f000 8156 	beq.w	800cc5c <lorawan_aes_encrypt+0x2c0>
    {
        uint8_t s1[N_BLOCK], r;
        copy_and_key( s1, in, ctx->ksch );
 800c9b0:	4601      	mov	r1, r0
 800c9b2:	a81c      	add	r0, sp, #112	; 0x70
 800c9b4:	f7ff ff36 	bl	800c824 <copy_and_key>

        for( r = 1 ; r < ctx->rnd ; ++r )
 800c9b8:	4ca9      	ldr	r4, [pc, #676]	; (800cc60 <lorawan_aes_encrypt+0x2c4>)
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800c9ba:	4daa      	ldr	r5, [pc, #680]	; (800cc64 <lorawan_aes_encrypt+0x2c8>)
 800c9bc:	4eaa      	ldr	r6, [pc, #680]	; (800cc68 <lorawan_aes_encrypt+0x2cc>)
        for( r = 1 ; r < ctx->rnd ; ++r )
 800c9be:	f04f 0801 	mov.w	r8, #1
 800c9c2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800c9c4:	f89d 907f 	ldrb.w	r9, [sp, #127]	; 0x7f
 800c9c8:	f89d a07a 	ldrb.w	sl, [sp, #122]	; 0x7a
 800c9cc:	eb03 1e08 	add.w	lr, r3, r8, lsl #4
 800c9d0:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800c9d4:	9300      	str	r3, [sp, #0]
 800c9d6:	f89d 3075 	ldrb.w	r3, [sp, #117]	; 0x75
 800c9da:	9301      	str	r3, [sp, #4]
 800c9dc:	f814 3009 	ldrb.w	r3, [r4, r9]
 800c9e0:	9302      	str	r3, [sp, #8]
 800c9e2:	9b00      	ldr	r3, [sp, #0]
 800c9e4:	f814 100a 	ldrb.w	r1, [r4, sl]
 800c9e8:	5ce0      	ldrb	r0, [r4, r3]
 800c9ea:	9b01      	ldr	r3, [sp, #4]
 800c9ec:	f814 c003 	ldrb.w	ip, [r4, r3]
 800c9f0:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
 800c9f4:	9303      	str	r3, [sp, #12]
 800c9f6:	f89d 3079 	ldrb.w	r3, [sp, #121]	; 0x79
 800c9fa:	9304      	str	r3, [sp, #16]
 800c9fc:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
 800ca00:	9305      	str	r3, [sp, #20]
 800ca02:	5ce3      	ldrb	r3, [r4, r3]
 800ca04:	9306      	str	r3, [sp, #24]
 800ca06:	f89d 3073 	ldrb.w	r3, [sp, #115]	; 0x73
 800ca0a:	9307      	str	r3, [sp, #28]
 800ca0c:	5ce2      	ldrb	r2, [r4, r3]
 800ca0e:	9b03      	ldr	r3, [sp, #12]
 800ca10:	5ce3      	ldrb	r3, [r4, r3]
 800ca12:	9308      	str	r3, [sp, #32]
 800ca14:	9b04      	ldr	r3, [sp, #16]
 800ca16:	5ce3      	ldrb	r3, [r4, r3]
 800ca18:	9309      	str	r3, [sp, #36]	; 0x24
 800ca1a:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
 800ca1e:	930a      	str	r3, [sp, #40]	; 0x28
 800ca20:	f89d 307d 	ldrb.w	r3, [sp, #125]	; 0x7d
 800ca24:	930b      	str	r3, [sp, #44]	; 0x2c
 800ca26:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
 800ca2a:	930c      	str	r3, [sp, #48]	; 0x30
 800ca2c:	5ce3      	ldrb	r3, [r4, r3]
 800ca2e:	930d      	str	r3, [sp, #52]	; 0x34
 800ca30:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
 800ca34:	930e      	str	r3, [sp, #56]	; 0x38
 800ca36:	5ce3      	ldrb	r3, [r4, r3]
 800ca38:	930f      	str	r3, [sp, #60]	; 0x3c
 800ca3a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca3c:	5ce3      	ldrb	r3, [r4, r3]
 800ca3e:	9310      	str	r3, [sp, #64]	; 0x40
 800ca40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ca42:	5ce3      	ldrb	r3, [r4, r3]
 800ca44:	9311      	str	r3, [sp, #68]	; 0x44
 800ca46:	f89d 307c 	ldrb.w	r3, [sp, #124]	; 0x7c
 800ca4a:	9312      	str	r3, [sp, #72]	; 0x48
 800ca4c:	f89d 3071 	ldrb.w	r3, [sp, #113]	; 0x71
 800ca50:	9313      	str	r3, [sp, #76]	; 0x4c
 800ca52:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
 800ca56:	9314      	str	r3, [sp, #80]	; 0x50
 800ca58:	5ce3      	ldrb	r3, [r4, r3]
 800ca5a:	9315      	str	r3, [sp, #84]	; 0x54
 800ca5c:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
 800ca60:	9316      	str	r3, [sp, #88]	; 0x58
 800ca62:	5ce3      	ldrb	r3, [r4, r3]
 800ca64:	9317      	str	r3, [sp, #92]	; 0x5c
 800ca66:	9b12      	ldr	r3, [sp, #72]	; 0x48
 800ca68:	5ce3      	ldrb	r3, [r4, r3]
 800ca6a:	9318      	str	r3, [sp, #96]	; 0x60
 800ca6c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800ca6e:	5ce3      	ldrb	r3, [r4, r3]
 800ca70:	9319      	str	r3, [sp, #100]	; 0x64
 800ca72:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800ca74:	f893 70f0 	ldrb.w	r7, [r3, #240]	; 0xf0
 800ca78:	4547      	cmp	r7, r8
 800ca7a:	d834      	bhi.n	800cae6 <lorawan_aes_encrypt+0x14a>
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800ca7c:	9b08      	ldr	r3, [sp, #32]
 800ca7e:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
    st[ 8] = s_box(st[ 8]); st[12] = s_box(st[12]);
 800ca82:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ca84:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
 800ca88:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800ca8a:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
    tt = st[1]; st[ 1] = s_box(st[ 5]); st[ 5] = s_box(st[ 9]);
 800ca8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ca90:	f88d 3075 	strb.w	r3, [sp, #117]	; 0x75
    st[ 9] = s_box(st[13]); st[13] = s_box( tt );
 800ca94:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800ca96:	f88d 3079 	strb.w	r3, [sp, #121]	; 0x79
 800ca9a:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800ca9c:	f88d 307d 	strb.w	r3, [sp, #125]	; 0x7d
    tt = st[2]; st[ 2] = s_box(st[10]); st[10] = s_box( tt );
 800caa0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800caa2:	f88d 307a 	strb.w	r3, [sp, #122]	; 0x7a
    tt = st[6]; st[ 6] = s_box(st[14]); st[14] = s_box( tt );
 800caa6:	9b06      	ldr	r3, [sp, #24]
 800caa8:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
 800caac:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800caae:	f88d 307e 	strb.w	r3, [sp, #126]	; 0x7e
    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
 800cab2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800cab4:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
 800cab8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    st[ 0] = s_box(st[ 0]); st[ 4] = s_box(st[ 4]);
 800caba:	f88d 0070 	strb.w	r0, [sp, #112]	; 0x70
    tt = st[2]; st[ 2] = s_box(st[10]); st[10] = s_box( tt );
 800cabe:	f88d 1072 	strb.w	r1, [sp, #114]	; 0x72
            mix_sub_columns( s2, s1 );
            copy_and_key( s1, s2, ctx->ksch + r * N_BLOCK);
        }
#endif
        shift_sub_rows( s1 );
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800cac2:	981b      	ldr	r0, [sp, #108]	; 0x6c
    tt = st[15]; st[15] = s_box(st[11]); st[11] = s_box(st[ 7]);
 800cac4:	f88d 307b 	strb.w	r3, [sp, #123]	; 0x7b
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
 800cac8:	f88d 2077 	strb.w	r2, [sp, #119]	; 0x77
 800cacc:	9b02      	ldr	r3, [sp, #8]
    tt = st[1]; st[ 1] = s_box(st[ 5]); st[ 5] = s_box(st[ 9]);
 800cace:	f88d c071 	strb.w	ip, [sp, #113]	; 0x71
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800cad2:	4672      	mov	r2, lr
 800cad4:	a91c      	add	r1, sp, #112	; 0x70
    st[ 7] = s_box(st[ 3]); st[ 3] = s_box( tt );
 800cad6:	f88d 3073 	strb.w	r3, [sp, #115]	; 0x73
        copy_and_key( out, s1, ctx->ksch + r * N_BLOCK );
 800cada:	f7ff fea3 	bl	800c824 <copy_and_key>
    }
    else
        return ( uint8_t )-1;
    return 0;
 800cade:	2000      	movs	r0, #0
}
 800cae0:	b021      	add	sp, #132	; 0x84
 800cae2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800cae6:	9b02      	ldr	r3, [sp, #8]
 800cae8:	ea81 0703 	eor.w	r7, r1, r3
 800caec:	9b00      	ldr	r3, [sp, #0]
 800caee:	f815 b003 	ldrb.w	fp, [r5, r3]
 800caf2:	9b01      	ldr	r3, [sp, #4]
 800caf4:	ea8b 0707 	eor.w	r7, fp, r7
 800caf8:	f816 b003 	ldrb.w	fp, [r6, r3]
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800cafc:	9b02      	ldr	r3, [sp, #8]
    dt[ 0] = gfm2_sb(st[0]) ^ gfm3_sb(st[5]) ^ s_box(st[10]) ^ s_box(st[15]);
 800cafe:	ea87 070b 	eor.w	r7, r7, fp
 800cb02:	f88d 7070 	strb.w	r7, [sp, #112]	; 0x70
    dt[ 1] = s_box(st[0]) ^ gfm2_sb(st[5]) ^ gfm3_sb(st[10]) ^ s_box(st[15]);
 800cb06:	9f01      	ldr	r7, [sp, #4]
 800cb08:	5def      	ldrb	r7, [r5, r7]
 800cb0a:	4043      	eors	r3, r0
 800cb0c:	407b      	eors	r3, r7
 800cb0e:	f816 700a 	ldrb.w	r7, [r6, sl]
 800cb12:	407b      	eors	r3, r7
 800cb14:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800cb18:	f815 300a 	ldrb.w	r3, [r5, sl]
 800cb1c:	ea80 000c 	eor.w	r0, r0, ip
 800cb20:	4058      	eors	r0, r3
 800cb22:	f816 3009 	ldrb.w	r3, [r6, r9]
 800cb26:	4058      	eors	r0, r3
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800cb28:	9b00      	ldr	r3, [sp, #0]
    dt[ 2] = s_box(st[0]) ^ s_box(st[5]) ^ gfm2_sb(st[10]) ^ gfm3_sb(st[15]);
 800cb2a:	f88d 0072 	strb.w	r0, [sp, #114]	; 0x72
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800cb2e:	ea81 010c 	eor.w	r1, r1, ip
 800cb32:	f816 c003 	ldrb.w	ip, [r6, r3]
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800cb36:	9b06      	ldr	r3, [sp, #24]
    dt[ 3] = gfm3_sb(st[0]) ^ s_box(st[5]) ^ s_box(st[10]) ^ gfm2_sb(st[15]);
 800cb38:	ea8c 0101 	eor.w	r1, ip, r1
 800cb3c:	f815 c009 	ldrb.w	ip, [r5, r9]
 800cb40:	ea81 010c 	eor.w	r1, r1, ip
 800cb44:	f88d 1073 	strb.w	r1, [sp, #115]	; 0x73
    dt[ 4] = gfm2_sb(st[4]) ^ gfm3_sb(st[9]) ^ s_box(st[14]) ^ s_box(st[3]);
 800cb48:	9903      	ldr	r1, [sp, #12]
 800cb4a:	5c69      	ldrb	r1, [r5, r1]
 800cb4c:	4053      	eors	r3, r2
 800cb4e:	404b      	eors	r3, r1
 800cb50:	9904      	ldr	r1, [sp, #16]
 800cb52:	5c71      	ldrb	r1, [r6, r1]
 800cb54:	404b      	eors	r3, r1
 800cb56:	f88d 3074 	strb.w	r3, [sp, #116]	; 0x74
    dt[ 5] = s_box(st[4]) ^ gfm2_sb(st[9]) ^ gfm3_sb(st[14]) ^ s_box(st[3]);
 800cb5a:	9b08      	ldr	r3, [sp, #32]
 800cb5c:	405a      	eors	r2, r3
 800cb5e:	9b04      	ldr	r3, [sp, #16]
 800cb60:	5ceb      	ldrb	r3, [r5, r3]
 800cb62:	405a      	eors	r2, r3
 800cb64:	9b05      	ldr	r3, [sp, #20]
 800cb66:	5cf3      	ldrb	r3, [r6, r3]
 800cb68:	405a      	eors	r2, r3
 800cb6a:	f88d 2075 	strb.w	r2, [sp, #117]	; 0x75
    dt[ 6] = s_box(st[4]) ^ s_box(st[9]) ^ gfm2_sb(st[14]) ^ gfm3_sb(st[3]);
 800cb6e:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 800cb72:	4053      	eors	r3, r2
 800cb74:	9a05      	ldr	r2, [sp, #20]
 800cb76:	5caa      	ldrb	r2, [r5, r2]
 800cb78:	4053      	eors	r3, r2
 800cb7a:	9a07      	ldr	r2, [sp, #28]
 800cb7c:	5cb2      	ldrb	r2, [r6, r2]
 800cb7e:	4053      	eors	r3, r2
 800cb80:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
    dt[ 7] = gfm3_sb(st[4]) ^ s_box(st[9]) ^ s_box(st[14]) ^ gfm2_sb(st[3]);
 800cb84:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800cb86:	9b06      	ldr	r3, [sp, #24]
 800cb88:	4053      	eors	r3, r2
 800cb8a:	9a03      	ldr	r2, [sp, #12]
 800cb8c:	5cb2      	ldrb	r2, [r6, r2]
 800cb8e:	4053      	eors	r3, r2
 800cb90:	9a07      	ldr	r2, [sp, #28]
 800cb92:	5caa      	ldrb	r2, [r5, r2]
 800cb94:	4053      	eors	r3, r2
 800cb96:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
    dt[ 8] = gfm2_sb(st[8]) ^ gfm3_sb(st[13]) ^ s_box(st[2]) ^ s_box(st[7]);
 800cb9a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800cb9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800cb9e:	4053      	eors	r3, r2
 800cba0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cba2:	5caa      	ldrb	r2, [r5, r2]
 800cba4:	4053      	eors	r3, r2
 800cba6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800cba8:	5cb2      	ldrb	r2, [r6, r2]
 800cbaa:	4053      	eors	r3, r2
 800cbac:	f88d 3078 	strb.w	r3, [sp, #120]	; 0x78
    dt[ 9] = s_box(st[8]) ^ gfm2_sb(st[13]) ^ gfm3_sb(st[2]) ^ s_box(st[7]);
 800cbb0:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 800cbb4:	4053      	eors	r3, r2
 800cbb6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800cbb8:	5caa      	ldrb	r2, [r5, r2]
 800cbba:	4053      	eors	r3, r2
 800cbbc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800cbbe:	5cb2      	ldrb	r2, [r6, r2]
 800cbc0:	4053      	eors	r3, r2
 800cbc2:	f88d 3079 	strb.w	r3, [sp, #121]	; 0x79
    dt[10] = s_box(st[8]) ^ s_box(st[13]) ^ gfm2_sb(st[2]) ^ gfm3_sb(st[7]);
 800cbc6:	e9dd 3210 	ldrd	r3, r2, [sp, #64]	; 0x40
 800cbca:	4053      	eors	r3, r2
 800cbcc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800cbce:	5caa      	ldrb	r2, [r5, r2]
 800cbd0:	4053      	eors	r3, r2
 800cbd2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800cbd4:	5cb2      	ldrb	r2, [r6, r2]
 800cbd6:	4053      	eors	r3, r2
 800cbd8:	f88d 307a 	strb.w	r3, [sp, #122]	; 0x7a
    dt[11] = gfm3_sb(st[8]) ^ s_box(st[13]) ^ s_box(st[2]) ^ gfm2_sb(st[7]);
 800cbdc:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800cbde:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800cbe0:	4053      	eors	r3, r2
 800cbe2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800cbe4:	5cb2      	ldrb	r2, [r6, r2]
 800cbe6:	4053      	eors	r3, r2
 800cbe8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800cbea:	5caa      	ldrb	r2, [r5, r2]
 800cbec:	4053      	eors	r3, r2
 800cbee:	f88d 307b 	strb.w	r3, [sp, #123]	; 0x7b
    dt[12] = gfm2_sb(st[12]) ^ gfm3_sb(st[1]) ^ s_box(st[6]) ^ s_box(st[11]);
 800cbf2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 800cbf4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800cbf6:	4053      	eors	r3, r2
 800cbf8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800cbfa:	5caa      	ldrb	r2, [r5, r2]
 800cbfc:	4053      	eors	r3, r2
 800cbfe:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800cc00:	5cb2      	ldrb	r2, [r6, r2]
 800cc02:	4053      	eors	r3, r2
 800cc04:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
    dt[13] = s_box(st[12]) ^ gfm2_sb(st[1]) ^ gfm3_sb(st[6]) ^ s_box(st[11]);
 800cc08:	e9dd 3217 	ldrd	r3, r2, [sp, #92]	; 0x5c
 800cc0c:	4053      	eors	r3, r2
 800cc0e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800cc10:	5caa      	ldrb	r2, [r5, r2]
 800cc12:	4053      	eors	r3, r2
 800cc14:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800cc16:	5cb2      	ldrb	r2, [r6, r2]
 800cc18:	4053      	eors	r3, r2
 800cc1a:	f88d 307d 	strb.w	r3, [sp, #125]	; 0x7d
    dt[14] = s_box(st[12]) ^ s_box(st[1]) ^ gfm2_sb(st[6]) ^ gfm3_sb(st[11]);
 800cc1e:	e9dd 3218 	ldrd	r3, r2, [sp, #96]	; 0x60
 800cc22:	4053      	eors	r3, r2
 800cc24:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800cc26:	5caa      	ldrb	r2, [r5, r2]
 800cc28:	4053      	eors	r3, r2
 800cc2a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800cc2c:	5cb2      	ldrb	r2, [r6, r2]
 800cc2e:	4053      	eors	r3, r2
 800cc30:	f88d 307e 	strb.w	r3, [sp, #126]	; 0x7e
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800cc34:	9a19      	ldr	r2, [sp, #100]	; 0x64
 800cc36:	9b15      	ldr	r3, [sp, #84]	; 0x54
 800cc38:	4053      	eors	r3, r2
 800cc3a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800cc3c:	5cb2      	ldrb	r2, [r6, r2]
 800cc3e:	4053      	eors	r3, r2
 800cc40:	9a16      	ldr	r2, [sp, #88]	; 0x58
 800cc42:	5caa      	ldrb	r2, [r5, r2]
    xor_block(d, k);
 800cc44:	4671      	mov	r1, lr
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800cc46:	4053      	eors	r3, r2
    xor_block(d, k);
 800cc48:	a81c      	add	r0, sp, #112	; 0x70
    dt[15] = gfm3_sb(st[12]) ^ s_box(st[1]) ^ s_box(st[6]) ^ gfm2_sb(st[11]);
 800cc4a:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
    xor_block(d, k);
 800cc4e:	f7ff fda8 	bl	800c7a2 <xor_block>
        for( r = 1 ; r < ctx->rnd ; ++r )
 800cc52:	f108 0301 	add.w	r3, r8, #1
 800cc56:	fa5f f883 	uxtb.w	r8, r3
 800cc5a:	e6b2      	b.n	800c9c2 <lorawan_aes_encrypt+0x26>
        return ( uint8_t )-1;
 800cc5c:	20ff      	movs	r0, #255	; 0xff
 800cc5e:	e73f      	b.n	800cae0 <lorawan_aes_encrypt+0x144>
 800cc60:	08010d60 	.word	0x08010d60
 800cc64:	08010b60 	.word	0x08010b60
 800cc68:	08010c60 	.word	0x08010c60

0800cc6c <SecureElementGetKeyByID>:
{
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
#if (defined (KEY_EXTRACTABLE) && (KEY_EXTRACTABLE == 1))
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
    {
        if (SeNvm->KeyList[i].KeyID == keyID)
 800cc6c:	4b0a      	ldr	r3, [pc, #40]	; (800cc98 <SecureElementGetKeyByID+0x2c>)
 800cc6e:	681a      	ldr	r2, [r3, #0]
{
 800cc70:	b570      	push	{r4, r5, r6, lr}
        if (SeNvm->KeyList[i].KeyID == keyID)
 800cc72:	2300      	movs	r3, #0
 800cc74:	f102 0510 	add.w	r5, r2, #16
 800cc78:	eb03 1403 	add.w	r4, r3, r3, lsl #4
 800cc7c:	5d2e      	ldrb	r6, [r5, r4]
 800cc7e:	4286      	cmp	r6, r0
 800cc80:	d104      	bne.n	800cc8c <SecureElementGetKeyByID+0x20>
        {
            *keyItem = &(SeNvm->KeyList[i]);
 800cc82:	3410      	adds	r4, #16
 800cc84:	4422      	add	r2, r4
 800cc86:	600a      	str	r2, [r1, #0]
            return SECURE_ELEMENT_SUCCESS;
 800cc88:	2000      	movs	r0, #0
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;

#endif /* LORAWAN_KMS == 1 */
}
 800cc8a:	bd70      	pop	{r4, r5, r6, pc}
    for (uint8_t i = 0; i < NUM_OF_KEYS; i++)
 800cc8c:	3301      	adds	r3, #1
 800cc8e:	2b0a      	cmp	r3, #10
 800cc90:	d1f2      	bne.n	800cc78 <SecureElementGetKeyByID+0xc>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800cc92:	2003      	movs	r0, #3
 800cc94:	e7f9      	b.n	800cc8a <SecureElementGetKeyByID+0x1e>
 800cc96:	bf00      	nop
 800cc98:	20001100 	.word	0x20001100

0800cc9c <ComputeCmac>:
{
 800cc9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800cca0:	b0cc      	sub	sp, #304	; 0x130
 800cca2:	4606      	mov	r6, r0
 800cca4:	f8dd 8148 	ldr.w	r8, [sp, #328]	; 0x148
 800cca8:	4617      	mov	r7, r2
 800ccaa:	461c      	mov	r4, r3
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 800ccac:	460d      	mov	r5, r1
 800ccae:	b331      	cbz	r1, 800ccfe <ComputeCmac+0x62>
 800ccb0:	f1b8 0f00 	cmp.w	r8, #0
 800ccb4:	d023      	beq.n	800ccfe <ComputeCmac+0x62>
    AES_CMAC_Init( aesCmacCtx );
 800ccb6:	a806      	add	r0, sp, #24
 800ccb8:	f7ff fc46 	bl	800c548 <AES_CMAC_Init>
    SecureElementStatus_t retval = GetKeyByID( keyID, &keyItem );
 800ccbc:	4620      	mov	r0, r4
 800ccbe:	a901      	add	r1, sp, #4
 800ccc0:	f7ff ffd4 	bl	800cc6c <SecureElementGetKeyByID>
    if( retval == SECURE_ELEMENT_SUCCESS )
 800ccc4:	4604      	mov	r4, r0
 800ccc6:	b9b0      	cbnz	r0, 800ccf6 <ComputeCmac+0x5a>
        AES_CMAC_SetKey( aesCmacCtx, keyItem->KeyValue );
 800ccc8:	9901      	ldr	r1, [sp, #4]
 800ccca:	a806      	add	r0, sp, #24
 800cccc:	3101      	adds	r1, #1
 800ccce:	f7ff fc4b 	bl	800c568 <AES_CMAC_SetKey>
        if( micBxBuffer != NULL )
 800ccd2:	b126      	cbz	r6, 800ccde <ComputeCmac+0x42>
            AES_CMAC_Update( aesCmacCtx, micBxBuffer, 16 );
 800ccd4:	2210      	movs	r2, #16
 800ccd6:	4631      	mov	r1, r6
 800ccd8:	a806      	add	r0, sp, #24
 800ccda:	f7ff fc4a 	bl	800c572 <AES_CMAC_Update>
        AES_CMAC_Update( aesCmacCtx, buffer, size );
 800ccde:	463a      	mov	r2, r7
 800cce0:	4629      	mov	r1, r5
 800cce2:	a806      	add	r0, sp, #24
 800cce4:	f7ff fc45 	bl	800c572 <AES_CMAC_Update>
        AES_CMAC_Final( Cmac, aesCmacCtx );
 800cce8:	a906      	add	r1, sp, #24
 800ccea:	a802      	add	r0, sp, #8
 800ccec:	f7ff fca8 	bl	800c640 <AES_CMAC_Final>
        *cmac = ( uint32_t )( ( uint32_t ) Cmac[3] << 24 | ( uint32_t ) Cmac[2] << 16 | ( uint32_t ) Cmac[1] << 8 |
 800ccf0:	9b02      	ldr	r3, [sp, #8]
 800ccf2:	f8c8 3000 	str.w	r3, [r8]
}
 800ccf6:	4620      	mov	r0, r4
 800ccf8:	b04c      	add	sp, #304	; 0x130
 800ccfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800ccfe:	2402      	movs	r4, #2
 800cd00:	e7f9      	b.n	800ccf6 <ComputeCmac+0x5a>
	...

0800cd04 <PrintKey>:
{
 800cd04:	b510      	push	{r4, lr}
 800cd06:	b092      	sub	sp, #72	; 0x48
    retval = SecureElementGetKeyByID(key, &keyItem);
 800cd08:	a911      	add	r1, sp, #68	; 0x44
{
 800cd0a:	4604      	mov	r4, r0
    retval = SecureElementGetKeyByID(key, &keyItem);
 800cd0c:	f7ff ffae 	bl	800cc6c <SecureElementGetKeyByID>
    if (retval == SECURE_ELEMENT_SUCCESS)
 800cd10:	4602      	mov	r2, r0
 800cd12:	2800      	cmp	r0, #0
 800cd14:	d12e      	bne.n	800cd74 <PrintKey+0x70>
        if (key == APP_KEY)
 800cd16:	2c00      	cmp	r4, #0
 800cd18:	d12e      	bne.n	800cd78 <PrintKey+0x74>
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppKey:      ");
 800cd1a:	4b1c      	ldr	r3, [pc, #112]	; (800cd8c <PrintKey+0x88>)
 800cd1c:	4622      	mov	r2, r4
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 800cd1e:	4611      	mov	r1, r2
 800cd20:	2002      	movs	r0, #2
 800cd22:	f002 f8f1 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
        MW_LOG(TS_OFF, VLEVEL_M, "%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n",
 800cd26:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800cd28:	7c1a      	ldrb	r2, [r3, #16]
 800cd2a:	920f      	str	r2, [sp, #60]	; 0x3c
 800cd2c:	7bda      	ldrb	r2, [r3, #15]
 800cd2e:	920e      	str	r2, [sp, #56]	; 0x38
 800cd30:	7b9a      	ldrb	r2, [r3, #14]
 800cd32:	920d      	str	r2, [sp, #52]	; 0x34
 800cd34:	7b5a      	ldrb	r2, [r3, #13]
 800cd36:	920c      	str	r2, [sp, #48]	; 0x30
 800cd38:	7b1a      	ldrb	r2, [r3, #12]
 800cd3a:	920b      	str	r2, [sp, #44]	; 0x2c
 800cd3c:	7ada      	ldrb	r2, [r3, #11]
 800cd3e:	920a      	str	r2, [sp, #40]	; 0x28
 800cd40:	7a9a      	ldrb	r2, [r3, #10]
 800cd42:	9209      	str	r2, [sp, #36]	; 0x24
 800cd44:	7a5a      	ldrb	r2, [r3, #9]
 800cd46:	9208      	str	r2, [sp, #32]
 800cd48:	7a1a      	ldrb	r2, [r3, #8]
 800cd4a:	9207      	str	r2, [sp, #28]
 800cd4c:	79da      	ldrb	r2, [r3, #7]
 800cd4e:	9206      	str	r2, [sp, #24]
 800cd50:	799a      	ldrb	r2, [r3, #6]
 800cd52:	9205      	str	r2, [sp, #20]
 800cd54:	795a      	ldrb	r2, [r3, #5]
 800cd56:	9204      	str	r2, [sp, #16]
 800cd58:	791a      	ldrb	r2, [r3, #4]
 800cd5a:	9203      	str	r2, [sp, #12]
 800cd5c:	78da      	ldrb	r2, [r3, #3]
 800cd5e:	9202      	str	r2, [sp, #8]
 800cd60:	789a      	ldrb	r2, [r3, #2]
 800cd62:	9201      	str	r2, [sp, #4]
 800cd64:	785b      	ldrb	r3, [r3, #1]
 800cd66:	9300      	str	r3, [sp, #0]
 800cd68:	2200      	movs	r2, #0
 800cd6a:	4b09      	ldr	r3, [pc, #36]	; (800cd90 <PrintKey+0x8c>)
 800cd6c:	4611      	mov	r1, r2
 800cd6e:	2002      	movs	r0, #2
 800cd70:	f002 f8ca 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 800cd74:	b012      	add	sp, #72	; 0x48
 800cd76:	bd10      	pop	{r4, pc}
        else if (key == NWK_KEY)
 800cd78:	2c01      	cmp	r4, #1
 800cd7a:	d101      	bne.n	800cd80 <PrintKey+0x7c>
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkKey:      ");
 800cd7c:	4b05      	ldr	r3, [pc, #20]	; (800cd94 <PrintKey+0x90>)
 800cd7e:	e7ce      	b.n	800cd1e <PrintKey+0x1a>
        else if (key == APP_S_KEY)
 800cd80:	2c03      	cmp	r4, #3
            MW_LOG(TS_OFF, VLEVEL_M, "###### AppSKey:     ");
 800cd82:	bf0c      	ite	eq
 800cd84:	4b04      	ldreq	r3, [pc, #16]	; (800cd98 <PrintKey+0x94>)
            MW_LOG(TS_OFF, VLEVEL_M, "###### NwkSKey:     ");
 800cd86:	4b05      	ldrne	r3, [pc, #20]	; (800cd9c <PrintKey+0x98>)
 800cd88:	e7c9      	b.n	800cd1e <PrintKey+0x1a>
 800cd8a:	bf00      	nop
 800cd8c:	08010e60 	.word	0x08010e60
 800cd90:	08010eb4 	.word	0x08010eb4
 800cd94:	08010e75 	.word	0x08010e75
 800cd98:	08010e8a 	.word	0x08010e8a
 800cd9c:	08010e9f 	.word	0x08010e9f

0800cda0 <SecureElementInit>:
{
 800cda0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cda2:	b0b1      	sub	sp, #196	; 0xc4
    SecureElementNvmData_t seNvmInit =
 800cda4:	22b8      	movs	r2, #184	; 0xb8
{
 800cda6:	4605      	mov	r5, r0
 800cda8:	460c      	mov	r4, r1
    SecureElementNvmData_t seNvmInit =
 800cdaa:	a802      	add	r0, sp, #8
 800cdac:	2100      	movs	r1, #0
 800cdae:	f002 fe11 	bl	800f9d4 <memset>
 800cdb2:	4a3a      	ldr	r2, [pc, #232]	; (800ce9c <SecureElementInit+0xfc>)
 800cdb4:	6851      	ldr	r1, [r2, #4]
 800cdb6:	6810      	ldr	r0, [r2, #0]
 800cdb8:	466b      	mov	r3, sp
 800cdba:	c303      	stmia	r3!, {r0, r1}
 800cdbc:	4b38      	ldr	r3, [pc, #224]	; (800cea0 <SecureElementInit+0x100>)
 800cdbe:	f103 0210 	add.w	r2, r3, #16
 800cdc2:	f10d 0111 	add.w	r1, sp, #17
 800cdc6:	4617      	mov	r7, r2
 800cdc8:	f853 0b04 	ldr.w	r0, [r3], #4
 800cdcc:	f841 0b04 	str.w	r0, [r1], #4
 800cdd0:	4293      	cmp	r3, r2
 800cdd2:	d1f9      	bne.n	800cdc8 <SecureElementInit+0x28>
 800cdd4:	2301      	movs	r3, #1
 800cdd6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
 800cdda:	4b32      	ldr	r3, [pc, #200]	; (800cea4 <SecureElementInit+0x104>)
 800cddc:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 800cde0:	f103 0110 	add.w	r1, r3, #16
 800cde4:	f853 0b04 	ldr.w	r0, [r3], #4
 800cde8:	f842 0b04 	str.w	r0, [r2], #4
 800cdec:	428b      	cmp	r3, r1
 800cdee:	d1f9      	bne.n	800cde4 <SecureElementInit+0x44>
 800cdf0:	2302      	movs	r3, #2
 800cdf2:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
 800cdf6:	4b2a      	ldr	r3, [pc, #168]	; (800cea0 <SecureElementInit+0x100>)
 800cdf8:	f10d 0233 	add.w	r2, sp, #51	; 0x33
 800cdfc:	f853 1b04 	ldr.w	r1, [r3], #4
 800ce00:	f842 1b04 	str.w	r1, [r2], #4
 800ce04:	42bb      	cmp	r3, r7
 800ce06:	d1f9      	bne.n	800cdfc <SecureElementInit+0x5c>
 800ce08:	2303      	movs	r3, #3
 800ce0a:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
 800ce0e:	4b24      	ldr	r3, [pc, #144]	; (800cea0 <SecureElementInit+0x100>)
 800ce10:	ae11      	add	r6, sp, #68	; 0x44
 800ce12:	6818      	ldr	r0, [r3, #0]
 800ce14:	6859      	ldr	r1, [r3, #4]
 800ce16:	4632      	mov	r2, r6
 800ce18:	c203      	stmia	r2!, {r0, r1}
 800ce1a:	3308      	adds	r3, #8
 800ce1c:	42bb      	cmp	r3, r7
 800ce1e:	4616      	mov	r6, r2
 800ce20:	d1f7      	bne.n	800ce12 <SecureElementInit+0x72>
 800ce22:	2304      	movs	r3, #4
 800ce24:	f88d 3054 	strb.w	r3, [sp, #84]	; 0x54
 800ce28:	237f      	movs	r3, #127	; 0x7f
 800ce2a:	f88d 3065 	strb.w	r3, [sp, #101]	; 0x65
 800ce2e:	2380      	movs	r3, #128	; 0x80
 800ce30:	f88d 3076 	strb.w	r3, [sp, #118]	; 0x76
 800ce34:	2381      	movs	r3, #129	; 0x81
 800ce36:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
 800ce3a:	2382      	movs	r3, #130	; 0x82
 800ce3c:	f88d 3098 	strb.w	r3, [sp, #152]	; 0x98
 800ce40:	2383      	movs	r3, #131	; 0x83
 800ce42:	f88d 30a9 	strb.w	r3, [sp, #169]	; 0xa9
    if( nvm == NULL )
 800ce46:	b325      	cbz	r5, 800ce92 <SecureElementInit+0xf2>
    SeNvm = nvm;
 800ce48:	4e17      	ldr	r6, [pc, #92]	; (800cea8 <SecureElementInit+0x108>)
    memcpy1( ( uint8_t* )SeNvm, ( uint8_t* )&seNvmInit, sizeof( seNvmInit ) );
 800ce4a:	22c0      	movs	r2, #192	; 0xc0
 800ce4c:	4669      	mov	r1, sp
 800ce4e:	4628      	mov	r0, r5
    SeNvm = nvm;
 800ce50:	6035      	str	r5, [r6, #0]
    memcpy1( ( uint8_t* )SeNvm, ( uint8_t* )&seNvmInit, sizeof( seNvmInit ) );
 800ce52:	f000 f96f 	bl	800d134 <memcpy1>
    MW_LOG(TS_OFF, VLEVEL_M, "###### OTAA ######\r\n");
 800ce56:	2200      	movs	r2, #0
 800ce58:	4611      	mov	r1, r2
 800ce5a:	4b14      	ldr	r3, [pc, #80]	; (800ceac <SecureElementInit+0x10c>)
 800ce5c:	2002      	movs	r0, #2
 800ce5e:	f002 f853 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_KEY);
 800ce62:	2000      	movs	r0, #0
 800ce64:	f7ff ff4e 	bl	800cd04 <PrintKey>
    PrintKey(NWK_KEY);
 800ce68:	2001      	movs	r0, #1
 800ce6a:	f7ff ff4b 	bl	800cd04 <PrintKey>
    MW_LOG(TS_OFF, VLEVEL_M, "###### ABP  ######\r\n");
 800ce6e:	2200      	movs	r2, #0
 800ce70:	4b0f      	ldr	r3, [pc, #60]	; (800ceb0 <SecureElementInit+0x110>)
 800ce72:	4611      	mov	r1, r2
 800ce74:	2002      	movs	r0, #2
 800ce76:	f002 f847 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
    PrintKey(APP_S_KEY);
 800ce7a:	2003      	movs	r0, #3
 800ce7c:	f7ff ff42 	bl	800cd04 <PrintKey>
    PrintKey(NWK_S_KEY);
 800ce80:	2002      	movs	r0, #2
 800ce82:	f7ff ff3f 	bl	800cd04 <PrintKey>
    if (seGetUniqueId != NULL)
 800ce86:	b134      	cbz	r4, 800ce96 <SecureElementInit+0xf6>
        seGetUniqueId(SeNvm->DevEui);
 800ce88:	6830      	ldr	r0, [r6, #0]
 800ce8a:	47a0      	blx	r4
    return SECURE_ELEMENT_SUCCESS;
 800ce8c:	2000      	movs	r0, #0
}
 800ce8e:	b031      	add	sp, #196	; 0xc4
 800ce90:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800ce92:	2002      	movs	r0, #2
 800ce94:	e7fb      	b.n	800ce8e <SecureElementInit+0xee>
    return SECURE_ELEMENT_SUCCESS;
 800ce96:	4620      	mov	r0, r4
 800ce98:	e7f9      	b.n	800ce8e <SecureElementInit+0xee>
 800ce9a:	bf00      	nop
 800ce9c:	080103b0 	.word	0x080103b0
 800cea0:	08010f30 	.word	0x08010f30
 800cea4:	08010f41 	.word	0x08010f41
 800cea8:	20001100 	.word	0x20001100
 800ceac:	08010f06 	.word	0x08010f06
 800ceb0:	08010f1b 	.word	0x08010f1b

0800ceb4 <SecureElementComputeAesCmac>:
}

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t* micBxBuffer, uint8_t* buffer, uint16_t size,
                                                   KeyIdentifier_t keyID, uint32_t* cmac )
{
    if( keyID >= LORAMAC_CRYPTO_MULTICAST_KEYS )
 800ceb4:	2b7e      	cmp	r3, #126	; 0x7e
 800ceb6:	d801      	bhi.n	800cebc <SecureElementComputeAesCmac+0x8>
    {
        // Never accept multicast key identifier for cmac computation
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 800ceb8:	f7ff bef0 	b.w	800cc9c <ComputeCmac>
}
 800cebc:	2003      	movs	r0, #3
 800cebe:	4770      	bx	lr

0800cec0 <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t* buffer, uint16_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 800cec0:	b530      	push	{r4, r5, lr}
 800cec2:	460d      	mov	r5, r1
 800cec4:	b085      	sub	sp, #20
 800cec6:	4614      	mov	r4, r2
    if( buffer == NULL )
 800cec8:	4601      	mov	r1, r0
 800ceca:	b168      	cbz	r0, 800cee8 <SecureElementVerifyAesCmac+0x28>
    }

    SecureElementStatus_t retval   = SECURE_ELEMENT_ERROR;
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    uint32_t              compCmac = 0;
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800cecc:	aa03      	add	r2, sp, #12
    uint32_t              compCmac = 0;
 800cece:	2000      	movs	r0, #0
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800ced0:	9200      	str	r2, [sp, #0]
 800ced2:	462a      	mov	r2, r5
    uint32_t              compCmac = 0;
 800ced4:	9003      	str	r0, [sp, #12]
    retval                         = ComputeCmac( NULL, buffer, size, keyID, &compCmac );
 800ced6:	f7ff fee1 	bl	800cc9c <ComputeCmac>
    if( retval != SECURE_ELEMENT_SUCCESS )
 800ceda:	b918      	cbnz	r0, 800cee4 <SecureElementVerifyAesCmac+0x24>
        return SECURE_ELEMENT_ERROR_NPE;
 800cedc:	9803      	ldr	r0, [sp, #12]
 800cede:	1b00      	subs	r0, r0, r4
 800cee0:	bf18      	it	ne
 800cee2:	2001      	movne	r0, #1
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 800cee4:	b005      	add	sp, #20
 800cee6:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800cee8:	2002      	movs	r0, #2
 800ceea:	e7fb      	b.n	800cee4 <SecureElementVerifyAesCmac+0x24>

0800ceec <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t* buffer, uint16_t size, KeyIdentifier_t keyID,
                                               uint8_t* encBuffer )
{
 800ceec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cef0:	460e      	mov	r6, r1
 800cef2:	b0bf      	sub	sp, #252	; 0xfc
 800cef4:	4614      	mov	r4, r2
 800cef6:	4699      	mov	r9, r3
    if( buffer == NULL || encBuffer == NULL )
 800cef8:	4680      	mov	r8, r0
 800cefa:	b328      	cbz	r0, 800cf48 <SecureElementAesEncrypt+0x5c>
 800cefc:	b323      	cbz	r3, 800cf48 <SecureElementAesEncrypt+0x5c>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check if the size is divisible by 16,
    if( ( size % 16 ) != 0 )
 800cefe:	f011 010f 	ands.w	r1, r1, #15
 800cf02:	d123      	bne.n	800cf4c <SecureElementAesEncrypt+0x60>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
    }

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    lorawan_aes_context aesContext;
    memset1( aesContext.ksch, '\0', 240 );
 800cf04:	22f0      	movs	r2, #240	; 0xf0
 800cf06:	a801      	add	r0, sp, #4
 800cf08:	f000 f928 	bl	800d15c <memset1>

    Key_t*                pItem;
    SecureElementStatus_t retval = GetKeyByID( keyID, &pItem );
 800cf0c:	4620      	mov	r0, r4
 800cf0e:	4669      	mov	r1, sp
 800cf10:	f7ff feac 	bl	800cc6c <SecureElementGetKeyByID>

    if( retval == SECURE_ELEMENT_SUCCESS )
 800cf14:	4604      	mov	r4, r0
 800cf16:	b948      	cbnz	r0, 800cf2c <SecureElementAesEncrypt+0x40>
    {
        lorawan_aes_set_key(pItem->KeyValue, 16, &aesContext);
 800cf18:	9800      	ldr	r0, [sp, #0]
 800cf1a:	aa01      	add	r2, sp, #4
 800cf1c:	2110      	movs	r1, #16
 800cf1e:	3001      	adds	r0, #1
 800cf20:	f7ff fcc2 	bl	800c8a8 <lorawan_aes_set_key>

        uint8_t block = 0;

        while( size != 0 )
 800cf24:	4635      	mov	r5, r6
 800cf26:	1b77      	subs	r7, r6, r5
 800cf28:	b2ff      	uxtb	r7, r7
 800cf2a:	b91d      	cbnz	r5, 800cf34 <SecureElementAesEncrypt+0x48>
        retval = SECURE_ELEMENT_ERROR;
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 800cf2c:	4620      	mov	r0, r4
 800cf2e:	b03f      	add	sp, #252	; 0xfc
 800cf30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            lorawan_aes_encrypt(&buffer[block], &encBuffer[block], &aesContext);
 800cf34:	aa01      	add	r2, sp, #4
 800cf36:	eb09 0107 	add.w	r1, r9, r7
 800cf3a:	eb08 0007 	add.w	r0, r8, r7
            size  = size - 16;
 800cf3e:	3d10      	subs	r5, #16
            lorawan_aes_encrypt(&buffer[block], &encBuffer[block], &aesContext);
 800cf40:	f7ff fd2c 	bl	800c99c <lorawan_aes_encrypt>
            size  = size - 16;
 800cf44:	b2ad      	uxth	r5, r5
 800cf46:	e7ee      	b.n	800cf26 <SecureElementAesEncrypt+0x3a>
        return SECURE_ELEMENT_ERROR_NPE;
 800cf48:	2402      	movs	r4, #2
 800cf4a:	e7ef      	b.n	800cf2c <SecureElementAesEncrypt+0x40>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 800cf4c:	2405      	movs	r4, #5
 800cf4e:	e7ed      	b.n	800cf2c <SecureElementAesEncrypt+0x40>

0800cf50 <SecureElementSetKey.part.0>:
SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )
 800cf50:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
        if( SeNvm->KeyList[i].KeyID == keyID )
 800cf52:	4e18      	ldr	r6, [pc, #96]	; (800cfb4 <SecureElementSetKey.part.0+0x64>)
 800cf54:	6835      	ldr	r5, [r6, #0]
SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )
 800cf56:	4602      	mov	r2, r0
        if( SeNvm->KeyList[i].KeyID == keyID )
 800cf58:	2300      	movs	r3, #0
SecureElementStatus_t SecureElementSetKey( KeyIdentifier_t keyID, uint8_t* key )
 800cf5a:	4608      	mov	r0, r1
        if( SeNvm->KeyList[i].KeyID == keyID )
 800cf5c:	f105 0110 	add.w	r1, r5, #16
 800cf60:	eb03 1403 	add.w	r4, r3, r3, lsl #4
 800cf64:	3301      	adds	r3, #1
 800cf66:	5d0c      	ldrb	r4, [r1, r4]
 800cf68:	4294      	cmp	r4, r2
 800cf6a:	d11e      	bne.n	800cfaa <SecureElementSetKey.part.0+0x5a>
            if ( keyID == MC_KEY_0 )
 800cf6c:	2a80      	cmp	r2, #128	; 0x80
 800cf6e:	eb03 1403 	add.w	r4, r3, r3, lsl #4
 800cf72:	d113      	bne.n	800cf9c <SecureElementSetKey.part.0+0x4c>
                uint8_t               decryptedKey[16] = { 0 };
 800cf74:	2300      	movs	r3, #0
 800cf76:	e9cd 3300 	strd	r3, r3, [sp]
 800cf7a:	e9cd 3302 	strd	r3, r3, [sp, #8]
                retval = SecureElementAesEncrypt( key, 16, MC_KE_KEY, decryptedKey );
 800cf7e:	227f      	movs	r2, #127	; 0x7f
 800cf80:	2110      	movs	r1, #16
 800cf82:	466b      	mov	r3, sp
 800cf84:	f7ff ffb2 	bl	800ceec <SecureElementAesEncrypt>
 800cf88:	4605      	mov	r5, r0
                memcpy1( SeNvm->KeyList[i].KeyValue, decryptedKey, SE_KEY_SIZE );
 800cf8a:	6830      	ldr	r0, [r6, #0]
 800cf8c:	2210      	movs	r2, #16
 800cf8e:	4669      	mov	r1, sp
 800cf90:	4420      	add	r0, r4
 800cf92:	f000 f8cf 	bl	800d134 <memcpy1>
}
 800cf96:	4628      	mov	r0, r5
 800cf98:	b004      	add	sp, #16
 800cf9a:	bd70      	pop	{r4, r5, r6, pc}
                memcpy1( SeNvm->KeyList[i].KeyValue, key, SE_KEY_SIZE );
 800cf9c:	4601      	mov	r1, r0
 800cf9e:	2210      	movs	r2, #16
 800cfa0:	1928      	adds	r0, r5, r4
 800cfa2:	f000 f8c7 	bl	800d134 <memcpy1>
                return SECURE_ELEMENT_SUCCESS;
 800cfa6:	2500      	movs	r5, #0
 800cfa8:	e7f5      	b.n	800cf96 <SecureElementSetKey.part.0+0x46>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 800cfaa:	2b0a      	cmp	r3, #10
 800cfac:	d1d8      	bne.n	800cf60 <SecureElementSetKey.part.0+0x10>
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800cfae:	2503      	movs	r5, #3
 800cfb0:	e7f1      	b.n	800cf96 <SecureElementSetKey.part.0+0x46>
 800cfb2:	bf00      	nop
 800cfb4:	20001100 	.word	0x20001100

0800cfb8 <SecureElementSetKey>:
    if( key == NULL )
 800cfb8:	b109      	cbz	r1, 800cfbe <SecureElementSetKey+0x6>
 800cfba:	f7ff bfc9 	b.w	800cf50 <SecureElementSetKey.part.0>
}
 800cfbe:	2002      	movs	r0, #2
 800cfc0:	4770      	bx	lr

0800cfc2 <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t* input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 800cfc2:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800cfc4:	4614      	mov	r4, r2
    if( input == NULL )
 800cfc6:	b1a0      	cbz	r0, 800cff2 <SecureElementDeriveAndStoreKey+0x30>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    // In case of MC_KE_KEY, only McRootKey can be used as root key
    if( targetKeyID == MC_KE_KEY )
 800cfc8:	2a7f      	cmp	r2, #127	; 0x7f
 800cfca:	d101      	bne.n	800cfd0 <SecureElementDeriveAndStoreKey+0xe>
    {
        if( rootKeyID != MC_ROOT_KEY )
 800cfcc:	2904      	cmp	r1, #4
 800cfce:	d112      	bne.n	800cff6 <SecureElementDeriveAndStoreKey+0x34>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
        }
    }

#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    uint8_t key[16] = { 0 };
 800cfd0:	2300      	movs	r3, #0
 800cfd2:	e9cd 3300 	strd	r3, r3, [sp]
 800cfd6:	e9cd 3302 	strd	r3, r3, [sp, #8]
    // Derive key
    retval = SecureElementAesEncrypt( input, 16, rootKeyID, key );
 800cfda:	460a      	mov	r2, r1
 800cfdc:	466b      	mov	r3, sp
 800cfde:	2110      	movs	r1, #16
 800cfe0:	f7ff ff84 	bl	800ceec <SecureElementAesEncrypt>
    if( retval != SECURE_ELEMENT_SUCCESS )
 800cfe4:	b918      	cbnz	r0, 800cfee <SecureElementDeriveAndStoreKey+0x2c>
    if( key == NULL )
 800cfe6:	4669      	mov	r1, sp
 800cfe8:	4620      	mov	r0, r4
 800cfea:	f7ff ffb1 	bl	800cf50 <SecureElementSetKey.part.0>
    {
        retval = SECURE_ELEMENT_ERROR;
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 800cfee:	b004      	add	sp, #16
 800cff0:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800cff2:	2002      	movs	r0, #2
 800cff4:	e7fb      	b.n	800cfee <SecureElementDeriveAndStoreKey+0x2c>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 800cff6:	2003      	movs	r0, #3
 800cff8:	e7f9      	b.n	800cfee <SecureElementDeriveAndStoreKey+0x2c>

0800cffa <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t* joinEui,
                                                      uint16_t devNonce, uint8_t* encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t* decJoinAccept,
                                                      uint8_t* versionMinor )
{
 800cffa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 800cffe:	461f      	mov	r7, r3
{
 800d000:	e9dd 5807 	ldrd	r5, r8, [sp, #28]
 800d004:	f89d 4018 	ldrb.w	r4, [sp, #24]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 800d008:	b393      	cbz	r3, 800d070 <SecureElementProcessJoinAccept+0x76>
 800d00a:	b38d      	cbz	r5, 800d070 <SecureElementProcessJoinAccept+0x76>
 800d00c:	f1b8 0f00 	cmp.w	r8, #0
 800d010:	d02e      	beq.n	800d070 <SecureElementProcessJoinAccept+0x76>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    // Check that frame size isn't bigger than a JoinAccept with CFList size
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 800d012:	2c21      	cmp	r4, #33	; 0x21
 800d014:	d82e      	bhi.n	800d074 <SecureElementProcessJoinAccept+0x7a>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* USE_LRWAN_1_1_X_CRYPTO == 1 */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 800d016:	b2a6      	uxth	r6, r4
 800d018:	4619      	mov	r1, r3
 800d01a:	4632      	mov	r2, r6
 800d01c:	4628      	mov	r0, r5
 800d01e:	f000 f889 	bl	800d134 <memcpy1>

    // Decrypt JoinAccept, skip MHDR
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 800d022:	1e71      	subs	r1, r6, #1
 800d024:	2201      	movs	r2, #1
 800d026:	1c6b      	adds	r3, r5, #1
 800d028:	b289      	uxth	r1, r1
 800d02a:	18b8      	adds	r0, r7, r2
 800d02c:	f7ff ff5e 	bl	800ceec <SecureElementAesEncrypt>
 800d030:	bb10      	cbnz	r0, 800d078 <SecureElementProcessJoinAccept+0x7e>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 800d032:	7aeb      	ldrb	r3, [r5, #11]
 800d034:	09db      	lsrs	r3, r3, #7
 800d036:	f888 3000 	strb.w	r3, [r8]
    //  - Header buffer to be used for MIC computation
    //        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
    //        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]

    // Verify mic
    if( *versionMinor == 0 )
 800d03a:	b9fb      	cbnz	r3, 800d07c <SecureElementProcessJoinAccept+0x82>
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 800d03c:	192b      	adds	r3, r5, r4
    {
        // For LoRaWAN 1.0.x
        //   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
        //   CFListType)
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 800d03e:	1f31      	subs	r1, r6, #4
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 800d040:	f813 0c01 	ldrb.w	r0, [r3, #-1]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2] << 16 );
 800d044:	f813 2c02 	ldrb.w	r2, [r3, #-2]
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3] << 24 );
 800d048:	0600      	lsls	r0, r0, #24
 800d04a:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
    mic = ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE] << 0 );
 800d04e:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 800d052:	4310      	orrs	r0, r2
    mic |= ( ( uint32_t ) decJoinAccept[encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1] << 8 );
 800d054:	f813 2c03 	ldrb.w	r2, [r3, #-3]
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 800d058:	b289      	uxth	r1, r1
 800d05a:	ea40 2202 	orr.w	r2, r0, r2, lsl #8
 800d05e:	2301      	movs	r3, #1
 800d060:	4628      	mov	r0, r5
 800d062:	f7ff ff2d 	bl	800cec0 <SecureElementVerifyAesCmac>
        return SECURE_ELEMENT_ERROR_NPE;
 800d066:	3800      	subs	r0, #0
 800d068:	bf18      	it	ne
 800d06a:	2001      	movne	r0, #1
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 800d06c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800d070:	2002      	movs	r0, #2
 800d072:	e7fb      	b.n	800d06c <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 800d074:	2005      	movs	r0, #5
 800d076:	e7f9      	b.n	800d06c <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 800d078:	2007      	movs	r0, #7
 800d07a:	e7f7      	b.n	800d06c <SecureElementProcessJoinAccept+0x72>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 800d07c:	2004      	movs	r0, #4
 800d07e:	e7f5      	b.n	800d06c <SecureElementProcessJoinAccept+0x72>

0800d080 <SecureElementRandomNumber>:

SecureElementStatus_t SecureElementRandomNumber( uint32_t* randomNum )
{
 800d080:	b510      	push	{r4, lr}
    if( randomNum == NULL )
 800d082:	4604      	mov	r4, r0
 800d084:	b128      	cbz	r0, 800d092 <SecureElementRandomNumber+0x12>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    *randomNum = Radio.Random();
 800d086:	4b04      	ldr	r3, [pc, #16]	; (800d098 <SecureElementRandomNumber+0x18>)
 800d088:	695b      	ldr	r3, [r3, #20]
 800d08a:	4798      	blx	r3
 800d08c:	6020      	str	r0, [r4, #0]
    return SECURE_ELEMENT_SUCCESS;
 800d08e:	2000      	movs	r0, #0
}
 800d090:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800d092:	2002      	movs	r0, #2
 800d094:	e7fc      	b.n	800d090 <SecureElementRandomNumber+0x10>
 800d096:	bf00      	nop
 800d098:	08010fe4 	.word	0x08010fe4

0800d09c <SecureElementSetDevEui>:

SecureElementStatus_t SecureElementSetDevEui( uint8_t* devEui )
{
 800d09c:	b508      	push	{r3, lr}
    if( devEui == NULL )
 800d09e:	4601      	mov	r1, r0
 800d0a0:	b130      	cbz	r0, 800d0b0 <SecureElementSetDevEui+0x14>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->DevEui, devEui, SE_EUI_SIZE );
 800d0a2:	4b04      	ldr	r3, [pc, #16]	; (800d0b4 <SecureElementSetDevEui+0x18>)
 800d0a4:	2208      	movs	r2, #8
 800d0a6:	6818      	ldr	r0, [r3, #0]
 800d0a8:	f000 f844 	bl	800d134 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800d0ac:	2000      	movs	r0, #0
}
 800d0ae:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800d0b0:	2002      	movs	r0, #2
 800d0b2:	e7fc      	b.n	800d0ae <SecureElementSetDevEui+0x12>
 800d0b4:	20001100 	.word	0x20001100

0800d0b8 <SecureElementGetDevEui>:

uint8_t* SecureElementGetDevEui( void )
{
    return SeNvm->DevEui;
}
 800d0b8:	4b01      	ldr	r3, [pc, #4]	; (800d0c0 <SecureElementGetDevEui+0x8>)
 800d0ba:	6818      	ldr	r0, [r3, #0]
 800d0bc:	4770      	bx	lr
 800d0be:	bf00      	nop
 800d0c0:	20001100 	.word	0x20001100

0800d0c4 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t* joinEui )
{
 800d0c4:	b508      	push	{r3, lr}
    if( joinEui == NULL )
 800d0c6:	4601      	mov	r1, r0
 800d0c8:	b138      	cbz	r0, 800d0da <SecureElementSetJoinEui+0x16>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }
    memcpy1( SeNvm->JoinEui, joinEui, SE_EUI_SIZE );
 800d0ca:	4b05      	ldr	r3, [pc, #20]	; (800d0e0 <SecureElementSetJoinEui+0x1c>)
 800d0cc:	6818      	ldr	r0, [r3, #0]
 800d0ce:	2208      	movs	r2, #8
 800d0d0:	4410      	add	r0, r2
 800d0d2:	f000 f82f 	bl	800d134 <memcpy1>
    return SECURE_ELEMENT_SUCCESS;
 800d0d6:	2000      	movs	r0, #0
}
 800d0d8:	bd08      	pop	{r3, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 800d0da:	2002      	movs	r0, #2
 800d0dc:	e7fc      	b.n	800d0d8 <SecureElementSetJoinEui+0x14>
 800d0de:	bf00      	nop
 800d0e0:	20001100 	.word	0x20001100

0800d0e4 <SecureElementGetJoinEui>:

uint8_t* SecureElementGetJoinEui( void )
{
    return SeNvm->JoinEui;
 800d0e4:	4b01      	ldr	r3, [pc, #4]	; (800d0ec <SecureElementGetJoinEui+0x8>)
 800d0e6:	6818      	ldr	r0, [r3, #0]
}
 800d0e8:	3008      	adds	r0, #8
 800d0ea:	4770      	bx	lr
 800d0ec:	20001100 	.word	0x20001100

0800d0f0 <srand1>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
}

void srand1( uint32_t seed )
{
    next = seed;
 800d0f0:	4b01      	ldr	r3, [pc, #4]	; (800d0f8 <srand1+0x8>)
 800d0f2:	6018      	str	r0, [r3, #0]
}
 800d0f4:	4770      	bx	lr
 800d0f6:	bf00      	nop
 800d0f8:	200000cc 	.word	0x200000cc

0800d0fc <randr>:
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 800d0fc:	4a0b      	ldr	r2, [pc, #44]	; (800d12c <randr+0x30>)
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 800d0fe:	b530      	push	{r4, r5, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 800d100:	6813      	ldr	r3, [r2, #0]
 800d102:	4d0b      	ldr	r5, [pc, #44]	; (800d130 <randr+0x34>)
 800d104:	f243 0439 	movw	r4, #12345	; 0x3039
 800d108:	fb05 4303 	mla	r3, r5, r3, r4
 800d10c:	6013      	str	r3, [r2, #0]
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 800d10e:	1a09      	subs	r1, r1, r0
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 800d110:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
 800d114:	fbb3 f2f2 	udiv	r2, r3, r2
 800d118:	ebc2 72c2 	rsb	r2, r2, r2, lsl #31
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 800d11c:	3101      	adds	r1, #1
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 800d11e:	1a9b      	subs	r3, r3, r2
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 800d120:	fb93 f2f1 	sdiv	r2, r3, r1
 800d124:	fb01 3312 	mls	r3, r1, r2, r3
}
 800d128:	4418      	add	r0, r3
 800d12a:	bd30      	pop	{r4, r5, pc}
 800d12c:	200000cc 	.word	0x200000cc
 800d130:	41c64e6d 	.word	0x41c64e6d

0800d134 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 800d134:	3801      	subs	r0, #1
 800d136:	440a      	add	r2, r1
 800d138:	4291      	cmp	r1, r2
 800d13a:	d100      	bne.n	800d13e <memcpy1+0xa>
    {
        *dst++ = *src++;
    }
}
 800d13c:	4770      	bx	lr
        *dst++ = *src++;
 800d13e:	f811 3b01 	ldrb.w	r3, [r1], #1
 800d142:	f800 3f01 	strb.w	r3, [r0, #1]!
 800d146:	e7f7      	b.n	800d138 <memcpy1+0x4>

0800d148 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
    while( size-- )
 800d148:	4410      	add	r0, r2
 800d14a:	440a      	add	r2, r1
 800d14c:	4291      	cmp	r1, r2
 800d14e:	d100      	bne.n	800d152 <memcpyr+0xa>
    {
        *dst-- = *src++;
    }
}
 800d150:	4770      	bx	lr
        *dst-- = *src++;
 800d152:	f811 3b01 	ldrb.w	r3, [r1], #1
 800d156:	f800 3d01 	strb.w	r3, [r0, #-1]!
 800d15a:	e7f7      	b.n	800d14c <memcpyr+0x4>

0800d15c <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 800d15c:	4402      	add	r2, r0
 800d15e:	4290      	cmp	r0, r2
 800d160:	d100      	bne.n	800d164 <memset1+0x8>
    {
        *dst++ = value;
    }
}
 800d162:	4770      	bx	lr
        *dst++ = value;
 800d164:	f800 1b01 	strb.w	r1, [r0], #1
 800d168:	e7f9      	b.n	800d15e <memset1+0x2>
	...

0800d16c <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 800d16c:	b530      	push	{r4, r5, lr}
    const uint32_t reversedPolynom = 0xEDB88320;

    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 800d16e:	b130      	cbz	r0, 800d17e <Crc32+0x12>
    for( uint16_t i = 0; i < length; ++i )
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 800d170:	4d0a      	ldr	r5, [pc, #40]	; (800d19c <Crc32+0x30>)
 800d172:	4401      	add	r1, r0
    uint32_t crc = 0xFFFFFFFF;
 800d174:	f04f 33ff 	mov.w	r3, #4294967295
    for( uint16_t i = 0; i < length; ++i )
 800d178:	4281      	cmp	r1, r0
 800d17a:	d101      	bne.n	800d180 <Crc32+0x14>
        }
    }

    return ~crc;
 800d17c:	43d8      	mvns	r0, r3
}
 800d17e:	bd30      	pop	{r4, r5, pc}
        crc ^= ( uint32_t )buffer[i];
 800d180:	f810 2b01 	ldrb.w	r2, [r0], #1
 800d184:	4053      	eors	r3, r2
 800d186:	2208      	movs	r2, #8
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 800d188:	f343 0400 	sbfx	r4, r3, #0, #1
 800d18c:	3a01      	subs	r2, #1
 800d18e:	402c      	ands	r4, r5
 800d190:	b292      	uxth	r2, r2
 800d192:	ea84 0353 	eor.w	r3, r4, r3, lsr #1
        for( uint16_t i = 0; i < 8; i++ )
 800d196:	2a00      	cmp	r2, #0
 800d198:	d1f6      	bne.n	800d188 <Crc32+0x1c>
 800d19a:	e7ed      	b.n	800d178 <Crc32+0xc>
 800d19c:	edb88320 	.word	0xedb88320

0800d1a0 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 800d1a0:	2001      	movs	r0, #1
 800d1a2:	4770      	bx	lr

0800d1a4 <RadioOnTxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_TX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 800d1a4:	4b03      	ldr	r3, [pc, #12]	; (800d1b4 <RadioOnTxTimeoutIrq+0x10>)
 800d1a6:	681b      	ldr	r3, [r3, #0]
 800d1a8:	b113      	cbz	r3, 800d1b0 <RadioOnTxTimeoutIrq+0xc>
 800d1aa:	685b      	ldr	r3, [r3, #4]
 800d1ac:	b103      	cbz	r3, 800d1b0 <RadioOnTxTimeoutIrq+0xc>
    {
        RadioEvents->TxTimeout( );
 800d1ae:	4718      	bx	r3
}
 800d1b0:	4770      	bx	lr
 800d1b2:	bf00      	nop
 800d1b4:	20001204 	.word	0x20001204

0800d1b8 <RadioOnRxTimeoutIrq>:
{
    /* ST_WORKAROUND_BEGIN: Reset DBG pin */
    DBG_GPIO_RADIO_RX(RST);
    /* ST_WORKAROUND_END */

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 800d1b8:	4b03      	ldr	r3, [pc, #12]	; (800d1c8 <RadioOnRxTimeoutIrq+0x10>)
 800d1ba:	681b      	ldr	r3, [r3, #0]
 800d1bc:	b113      	cbz	r3, 800d1c4 <RadioOnRxTimeoutIrq+0xc>
 800d1be:	68db      	ldr	r3, [r3, #12]
 800d1c0:	b103      	cbz	r3, 800d1c4 <RadioOnRxTimeoutIrq+0xc>
    {
        RadioEvents->RxTimeout( );
 800d1c2:	4718      	bx	r3
}
 800d1c4:	4770      	bx	lr
 800d1c6:	bf00      	nop
 800d1c8:	20001204 	.word	0x20001204

0800d1cc <RadioRead>:
    return SUBGRF_ReadRegister(addr);
 800d1cc:	f001 baf0 	b.w	800e7b0 <SUBGRF_ReadRegister>

0800d1d0 <RadioWrite>:
    SUBGRF_WriteRegister(addr, data );
 800d1d0:	f001 ba28 	b.w	800e624 <SUBGRF_WriteRegister>

0800d1d4 <RadioTxCw>:
    SUBGRF_SetTxInfinitePreamble( );
    SUBGRF_SetTx( 0x0fffff );
}

static void RadioTxCw( int8_t power )
{
 800d1d4:	b508      	push	{r3, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 800d1d6:	f001 fd22 	bl	800ec1e <SUBGRF_SetRfTxPower>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 800d1da:	2101      	movs	r1, #1
 800d1dc:	f001 fd09 	bl	800ebf2 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
}
 800d1e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTxContinuousWave( );
 800d1e4:	f001 b906 	b.w	800e3f4 <SUBGRF_SetTxContinuousWave>

0800d1e8 <RadioSetRxDutyCycle>:
{
 800d1e8:	b538      	push	{r3, r4, r5, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 800d1ea:	4b07      	ldr	r3, [pc, #28]	; (800d208 <RadioSetRxDutyCycle+0x20>)
{
 800d1ec:	4604      	mov	r4, r0
 800d1ee:	460d      	mov	r5, r1
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 800d1f0:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 800d1f4:	2100      	movs	r1, #0
 800d1f6:	f001 fcfc 	bl	800ebf2 <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 800d1fa:	4629      	mov	r1, r5
 800d1fc:	4620      	mov	r0, r4
}
 800d1fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 800d202:	f001 b8cf 	b.w	800e3a4 <SUBGRF_SetRxDutyCycle>
 800d206:	bf00      	nop
 800d208:	20001af4 	.word	0x20001af4

0800d20c <RadioStandby>:
    SUBGRF_SetStandby( STDBY_RC );
 800d20c:	2000      	movs	r0, #0
 800d20e:	f001 b887 	b.w	800e320 <SUBGRF_SetStandby>
	...

0800d214 <RadioGetStatus>:
{
 800d214:	b508      	push	{r3, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 800d216:	f001 f87d 	bl	800e314 <SUBGRF_GetOperatingMode>
 800d21a:	3804      	subs	r0, #4
 800d21c:	b2c0      	uxtb	r0, r0
 800d21e:	2803      	cmp	r0, #3
 800d220:	bf96      	itet	ls
 800d222:	4b02      	ldrls	r3, [pc, #8]	; (800d22c <RadioGetStatus+0x18>)
 800d224:	2000      	movhi	r0, #0
 800d226:	5c18      	ldrbls	r0, [r3, r0]
}
 800d228:	bd08      	pop	{r3, pc}
 800d22a:	bf00      	nop
 800d22c:	08010fe0 	.word	0x08010fe0

0800d230 <RadioIrqProcess>:
{
 800d230:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch ( SubgRf.RadioIrq )
 800d232:	4e83      	ldr	r6, [pc, #524]	; (800d440 <RadioIrqProcess+0x210>)
 800d234:	f8b6 3054 	ldrh.w	r3, [r6, #84]	; 0x54
    uint8_t size = 0;
 800d238:	2400      	movs	r4, #0
    switch ( SubgRf.RadioIrq )
 800d23a:	2b20      	cmp	r3, #32
    uint8_t size = 0;
 800d23c:	f88d 4003 	strb.w	r4, [sp, #3]
    int32_t cfo = 0;
 800d240:	9401      	str	r4, [sp, #4]
    switch ( SubgRf.RadioIrq )
 800d242:	4635      	mov	r5, r6
 800d244:	f000 80d8 	beq.w	800d3f8 <RadioIrqProcess+0x1c8>
 800d248:	d810      	bhi.n	800d26c <RadioIrqProcess+0x3c>
 800d24a:	2b08      	cmp	r3, #8
 800d24c:	d809      	bhi.n	800d262 <RadioIrqProcess+0x32>
 800d24e:	b15b      	cbz	r3, 800d268 <RadioIrqProcess+0x38>
 800d250:	3b01      	subs	r3, #1
 800d252:	2b07      	cmp	r3, #7
 800d254:	d808      	bhi.n	800d268 <RadioIrqProcess+0x38>
 800d256:	e8df f003 	tbb	[pc, r3]
 800d25a:	4e39      	.short	0x4e39
 800d25c:	0707b807 	.word	0x0707b807
 800d260:	bf07      	.short	0xbf07
 800d262:	2b10      	cmp	r3, #16
 800d264:	f000 80c6 	beq.w	800d3f4 <RadioIrqProcess+0x1c4>
}
 800d268:	b002      	add	sp, #8
 800d26a:	bd70      	pop	{r4, r5, r6, pc}
    switch ( SubgRf.RadioIrq )
 800d26c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800d270:	f000 808b 	beq.w	800d38a <RadioIrqProcess+0x15a>
 800d274:	d811      	bhi.n	800d29a <RadioIrqProcess+0x6a>
 800d276:	2b40      	cmp	r3, #64	; 0x40
 800d278:	f000 80d1 	beq.w	800d41e <RadioIrqProcess+0x1ee>
 800d27c:	2b80      	cmp	r3, #128	; 0x80
 800d27e:	d1f3      	bne.n	800d268 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 800d280:	4620      	mov	r0, r4
 800d282:	f001 f84d 	bl	800e320 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 800d286:	4b6f      	ldr	r3, [pc, #444]	; (800d444 <RadioIrqProcess+0x214>)
 800d288:	681b      	ldr	r3, [r3, #0]
 800d28a:	2b00      	cmp	r3, #0
 800d28c:	d0ec      	beq.n	800d268 <RadioIrqProcess+0x38>
 800d28e:	699b      	ldr	r3, [r3, #24]
 800d290:	2b00      	cmp	r3, #0
 800d292:	d0e9      	beq.n	800d268 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( false );
 800d294:	4620      	mov	r0, r4
            RadioEvents->CadDone( true );
 800d296:	4798      	blx	r3
 800d298:	e7e6      	b.n	800d268 <RadioIrqProcess+0x38>
    switch ( SubgRf.RadioIrq )
 800d29a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800d29e:	d1e3      	bne.n	800d268 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 800d2a0:	4b69      	ldr	r3, [pc, #420]	; (800d448 <RadioIrqProcess+0x218>)
 800d2a2:	2201      	movs	r2, #1
 800d2a4:	4621      	mov	r1, r4
 800d2a6:	2002      	movs	r0, #2
 800d2a8:	f001 fe2e 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 800d2ac:	f001 f832 	bl	800e314 <SUBGRF_GetOperatingMode>
 800d2b0:	2804      	cmp	r0, #4
 800d2b2:	d178      	bne.n	800d3a6 <RadioIrqProcess+0x176>
            TimerStop( &TxTimeoutTimer );
 800d2b4:	4865      	ldr	r0, [pc, #404]	; (800d44c <RadioIrqProcess+0x21c>)
 800d2b6:	f002 f963 	bl	800f580 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 800d2ba:	4620      	mov	r0, r4
 800d2bc:	f001 f830 	bl	800e320 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 800d2c0:	4b60      	ldr	r3, [pc, #384]	; (800d444 <RadioIrqProcess+0x214>)
 800d2c2:	681b      	ldr	r3, [r3, #0]
 800d2c4:	2b00      	cmp	r3, #0
 800d2c6:	d0cf      	beq.n	800d268 <RadioIrqProcess+0x38>
 800d2c8:	685b      	ldr	r3, [r3, #4]
 800d2ca:	e010      	b.n	800d2ee <RadioIrqProcess+0xbe>
        TimerStop( &TxTimeoutTimer );
 800d2cc:	485f      	ldr	r0, [pc, #380]	; (800d44c <RadioIrqProcess+0x21c>)
 800d2ce:	f002 f957 	bl	800f580 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 800d2d2:	2000      	movs	r0, #0
 800d2d4:	f001 f824 	bl	800e320 <SUBGRF_SetStandby>
        if ( RFW_Is_LongPacketModeEnabled() == 1 )
 800d2d8:	f001 fd5a 	bl	800ed90 <RFW_Is_LongPacketModeEnabled>
 800d2dc:	2801      	cmp	r0, #1
 800d2de:	d101      	bne.n	800d2e4 <RadioIrqProcess+0xb4>
            RFW_DeInit_TxLongPacket( );
 800d2e0:	f001 fd5f 	bl	800eda2 <RFW_DeInit_TxLongPacket>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 800d2e4:	4b57      	ldr	r3, [pc, #348]	; (800d444 <RadioIrqProcess+0x214>)
 800d2e6:	681b      	ldr	r3, [r3, #0]
 800d2e8:	2b00      	cmp	r3, #0
 800d2ea:	d0bd      	beq.n	800d268 <RadioIrqProcess+0x38>
 800d2ec:	681b      	ldr	r3, [r3, #0]
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 800d2ee:	2b00      	cmp	r3, #0
 800d2f0:	d0ba      	beq.n	800d268 <RadioIrqProcess+0x38>
            RadioEvents->RxError( );
 800d2f2:	4798      	blx	r3
}
 800d2f4:	e7b8      	b.n	800d268 <RadioIrqProcess+0x38>
        TimerStop( &RxTimeoutTimer );
 800d2f6:	4856      	ldr	r0, [pc, #344]	; (800d450 <RadioIrqProcess+0x220>)
 800d2f8:	f002 f942 	bl	800f580 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 800d2fc:	7874      	ldrb	r4, [r6, #1]
 800d2fe:	b994      	cbnz	r4, 800d326 <RadioIrqProcess+0xf6>
            SUBGRF_SetStandby( STDBY_RC );
 800d300:	4620      	mov	r0, r4
 800d302:	f001 f80d 	bl	800e320 <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( 0x0902, 0x00 );
 800d306:	4621      	mov	r1, r4
 800d308:	f640 1002 	movw	r0, #2306	; 0x902
 800d30c:	f001 f98a 	bl	800e624 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( 0x0944, SUBGRF_ReadRegister( 0x0944 ) | ( 1 << 1 ) );
 800d310:	f640 1044 	movw	r0, #2372	; 0x944
 800d314:	f001 fa4c 	bl	800e7b0 <SUBGRF_ReadRegister>
 800d318:	f040 0102 	orr.w	r1, r0, #2
 800d31c:	b2c9      	uxtb	r1, r1
 800d31e:	f640 1044 	movw	r0, #2372	; 0x944
 800d322:	f001 f97f 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 800d326:	22ff      	movs	r2, #255	; 0xff
 800d328:	f10d 0103 	add.w	r1, sp, #3
 800d32c:	4849      	ldr	r0, [pc, #292]	; (800d454 <RadioIrqProcess+0x224>)
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 800d32e:	4c45      	ldr	r4, [pc, #276]	; (800d444 <RadioIrqProcess+0x214>)
        SUBGRF_GetPayload( RadioBuffer, &size , 255 );
 800d330:	f001 fc46 	bl	800ebc0 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &(SubgRf.PacketStatus) );
 800d334:	4848      	ldr	r0, [pc, #288]	; (800d458 <RadioIrqProcess+0x228>)
 800d336:	f001 f939 	bl	800e5ac <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 800d33a:	6823      	ldr	r3, [r4, #0]
 800d33c:	2b00      	cmp	r3, #0
 800d33e:	d093      	beq.n	800d268 <RadioIrqProcess+0x38>
 800d340:	689e      	ldr	r6, [r3, #8]
 800d342:	2e00      	cmp	r6, #0
 800d344:	d090      	beq.n	800d268 <RadioIrqProcess+0x38>
            switch ( SubgRf.PacketStatus.packetType )
 800d346:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
 800d34a:	2b01      	cmp	r3, #1
 800d34c:	d108      	bne.n	800d360 <RadioIrqProcess+0x130>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt, SubgRf.PacketStatus.Params.LoRa.SnrPkt );
 800d34e:	f995 3031 	ldrsb.w	r3, [r5, #49]	; 0x31
 800d352:	f995 2030 	ldrsb.w	r2, [r5, #48]	; 0x30
 800d356:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800d35a:	483e      	ldr	r0, [pc, #248]	; (800d454 <RadioIrqProcess+0x224>)
 800d35c:	47b0      	blx	r6
                break;
 800d35e:	e783      	b.n	800d268 <RadioIrqProcess+0x38>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 800d360:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 800d362:	a901      	add	r1, sp, #4
 800d364:	f001 fcc8 	bl	800ecf8 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, (int8_t) DIVR(cfo, 1000) );
 800d368:	9b01      	ldr	r3, [sp, #4]
 800d36a:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800d36e:	4839      	ldr	r0, [pc, #228]	; (800d454 <RadioIrqProcess+0x224>)
 800d370:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800d374:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 800d378:	fb93 f3f2 	sdiv	r3, r3, r2
 800d37c:	6822      	ldr	r2, [r4, #0]
 800d37e:	b25b      	sxtb	r3, r3
 800d380:	6894      	ldr	r4, [r2, #8]
 800d382:	f995 2029 	ldrsb.w	r2, [r5, #41]	; 0x29
 800d386:	47a0      	blx	r4
                break;
 800d388:	e76e      	b.n	800d268 <RadioIrqProcess+0x38>
        SUBGRF_SetStandby( STDBY_RC );
 800d38a:	4620      	mov	r0, r4
 800d38c:	f000 ffc8 	bl	800e320 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 800d390:	4b2c      	ldr	r3, [pc, #176]	; (800d444 <RadioIrqProcess+0x214>)
 800d392:	681b      	ldr	r3, [r3, #0]
 800d394:	2b00      	cmp	r3, #0
 800d396:	f43f af67 	beq.w	800d268 <RadioIrqProcess+0x38>
 800d39a:	699b      	ldr	r3, [r3, #24]
 800d39c:	2b00      	cmp	r3, #0
 800d39e:	f43f af63 	beq.w	800d268 <RadioIrqProcess+0x38>
            RadioEvents->CadDone( true );
 800d3a2:	2001      	movs	r0, #1
 800d3a4:	e777      	b.n	800d296 <RadioIrqProcess+0x66>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 800d3a6:	f000 ffb5 	bl	800e314 <SUBGRF_GetOperatingMode>
 800d3aa:	2805      	cmp	r0, #5
 800d3ac:	f47f af5c 	bne.w	800d268 <RadioIrqProcess+0x38>
            TimerStop( &RxTimeoutTimer );
 800d3b0:	4827      	ldr	r0, [pc, #156]	; (800d450 <RadioIrqProcess+0x220>)
 800d3b2:	f002 f8e5 	bl	800f580 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 800d3b6:	4620      	mov	r0, r4
 800d3b8:	f000 ffb2 	bl	800e320 <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 800d3bc:	4b21      	ldr	r3, [pc, #132]	; (800d444 <RadioIrqProcess+0x214>)
 800d3be:	681b      	ldr	r3, [r3, #0]
 800d3c0:	2b00      	cmp	r3, #0
 800d3c2:	f43f af51 	beq.w	800d268 <RadioIrqProcess+0x38>
 800d3c6:	68db      	ldr	r3, [r3, #12]
 800d3c8:	e791      	b.n	800d2ee <RadioIrqProcess+0xbe>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 800d3ca:	4b24      	ldr	r3, [pc, #144]	; (800d45c <RadioIrqProcess+0x22c>)
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 800d3cc:	2201      	movs	r2, #1
 800d3ce:	2100      	movs	r1, #0
 800d3d0:	2002      	movs	r0, #2
 800d3d2:	f001 fd99 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
 800d3d6:	e747      	b.n	800d268 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 800d3d8:	4b21      	ldr	r3, [pc, #132]	; (800d460 <RadioIrqProcess+0x230>)
 800d3da:	2201      	movs	r2, #1
 800d3dc:	2100      	movs	r1, #0
 800d3de:	2002      	movs	r0, #2
 800d3e0:	f001 fd92 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
        if ( 1UL == RFW_Is_Init( ) )
 800d3e4:	f001 fcd2 	bl	800ed8c <RFW_Is_Init>
 800d3e8:	2801      	cmp	r0, #1
 800d3ea:	f47f af3d 	bne.w	800d268 <RadioIrqProcess+0x38>
            RFW_ReceivePayload( );
 800d3ee:	f001 fcd9 	bl	800eda4 <RFW_ReceivePayload>
 800d3f2:	e739      	b.n	800d268 <RadioIrqProcess+0x38>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 800d3f4:	4b1b      	ldr	r3, [pc, #108]	; (800d464 <RadioIrqProcess+0x234>)
 800d3f6:	e7e9      	b.n	800d3cc <RadioIrqProcess+0x19c>
        TimerStop( &RxTimeoutTimer );
 800d3f8:	4815      	ldr	r0, [pc, #84]	; (800d450 <RadioIrqProcess+0x220>)
 800d3fa:	f002 f8c1 	bl	800f580 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 800d3fe:	7870      	ldrb	r0, [r6, #1]
 800d400:	b908      	cbnz	r0, 800d406 <RadioIrqProcess+0x1d6>
            SUBGRF_SetStandby( STDBY_RC );
 800d402:	f000 ff8d 	bl	800e320 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 800d406:	4b0f      	ldr	r3, [pc, #60]	; (800d444 <RadioIrqProcess+0x214>)
 800d408:	681b      	ldr	r3, [r3, #0]
 800d40a:	2b00      	cmp	r3, #0
 800d40c:	f43f af2c 	beq.w	800d268 <RadioIrqProcess+0x38>
 800d410:	68db      	ldr	r3, [r3, #12]
 800d412:	2b00      	cmp	r3, #0
 800d414:	f43f af28 	beq.w	800d268 <RadioIrqProcess+0x38>
            RadioEvents->RxTimeout( );
 800d418:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 800d41a:	4b13      	ldr	r3, [pc, #76]	; (800d468 <RadioIrqProcess+0x238>)
 800d41c:	e7d6      	b.n	800d3cc <RadioIrqProcess+0x19c>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 800d41e:	4b13      	ldr	r3, [pc, #76]	; (800d46c <RadioIrqProcess+0x23c>)
 800d420:	2201      	movs	r2, #1
 800d422:	4621      	mov	r1, r4
 800d424:	2002      	movs	r0, #2
 800d426:	f001 fd6f 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 800d42a:	7870      	ldrb	r0, [r6, #1]
 800d42c:	b908      	cbnz	r0, 800d432 <RadioIrqProcess+0x202>
            SUBGRF_SetStandby( STDBY_RC );
 800d42e:	f000 ff77 	bl	800e320 <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 800d432:	4b04      	ldr	r3, [pc, #16]	; (800d444 <RadioIrqProcess+0x214>)
 800d434:	681b      	ldr	r3, [r3, #0]
 800d436:	2b00      	cmp	r3, #0
 800d438:	f43f af16 	beq.w	800d268 <RadioIrqProcess+0x38>
 800d43c:	691b      	ldr	r3, [r3, #16]
 800d43e:	e756      	b.n	800d2ee <RadioIrqProcess+0xbe>
 800d440:	20001af4 	.word	0x20001af4
 800d444:	20001204 	.word	0x20001204
 800d448:	08010f52 	.word	0x08010f52
 800d44c:	20001b4c 	.word	0x20001b4c
 800d450:	20001b64 	.word	0x20001b64
 800d454:	20001104 	.word	0x20001104
 800d458:	20001b18 	.word	0x20001b18
 800d45c:	08010f66 	.word	0x08010f66
 800d460:	08010f6f 	.word	0x08010f6f
 800d464:	08010f79 	.word	0x08010f79
 800d468:	08010f82 	.word	0x08010f82
 800d46c:	08010f8b 	.word	0x08010f8b

0800d470 <RadioOnDioIrq>:
    SubgRf.RadioIrq = radioIrq;
 800d470:	4b02      	ldr	r3, [pc, #8]	; (800d47c <RadioOnDioIrq+0xc>)
 800d472:	f8a3 0054 	strh.w	r0, [r3, #84]	; 0x54
    RADIO_IRQ_PROCESS();
 800d476:	f7ff bedb 	b.w	800d230 <RadioIrqProcess>
 800d47a:	bf00      	nop
 800d47c:	20001af4 	.word	0x20001af4

0800d480 <RadioGetWakeupTime>:
{
 800d480:	b508      	push	{r3, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 800d482:	f001 fbe1 	bl	800ec48 <SUBGRF_GetRadioWakeUpTime>
}
 800d486:	3003      	adds	r0, #3
 800d488:	bd08      	pop	{r3, pc}

0800d48a <RadioReadRegisters>:
    SUBGRF_ReadRegisters( addr, buffer, size );
 800d48a:	f001 bb27 	b.w	800eadc <SUBGRF_ReadRegisters>

0800d48e <RadioWriteRegisters>:
    SUBGRF_WriteRegisters( addr, buffer, size );
 800d48e:	f001 ba83 	b.w	800e998 <SUBGRF_WriteRegisters>

0800d492 <RadioRssi>:
{
 800d492:	b508      	push	{r3, lr}
    return SUBGRF_GetRssiInst( );
 800d494:	f001 f87d 	bl	800e592 <SUBGRF_GetRssiInst>
}
 800d498:	b200      	sxth	r0, r0
 800d49a:	bd08      	pop	{r3, pc}

0800d49c <RadioSetTxContinuousWave>:
{
 800d49c:	b538      	push	{r3, r4, r5, lr}
 800d49e:	460d      	mov	r5, r1
 800d4a0:	4614      	mov	r4, r2
    SUBGRF_SetRfFrequency( freq );
 800d4a2:	f001 f84b 	bl	800e53c <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 800d4a6:	4628      	mov	r0, r5
 800d4a8:	f001 fbb9 	bl	800ec1e <SUBGRF_SetRfTxPower>
    TimerSetValue( &TxTimeoutTimer, timeout );
 800d4ac:	4d08      	ldr	r5, [pc, #32]	; (800d4d0 <RadioSetTxContinuousWave+0x34>)
    SUBGRF_SetSwitch(antswitchpow, RFSWITCH_TX);
 800d4ae:	2101      	movs	r1, #1
 800d4b0:	f001 fb9f 	bl	800ebf2 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 800d4b4:	f000 ff9e 	bl	800e3f4 <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 800d4b8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800d4bc:	4361      	muls	r1, r4
 800d4be:	4628      	mov	r0, r5
 800d4c0:	f002 f8e8 	bl	800f694 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 800d4c4:	4628      	mov	r0, r5
}
 800d4c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TimerStart( &TxTimeoutTimer );
 800d4ca:	f002 b8a9 	b.w	800f620 <UTIL_TIMER_Start>
 800d4ce:	bf00      	nop
 800d4d0:	20001b4c 	.word	0x20001b4c

0800d4d4 <RadioSetChannel>:
    SUBGRF_SetRfFrequency( freq );
 800d4d4:	f001 b832 	b.w	800e53c <SUBGRF_SetRfFrequency>

0800d4d8 <RadioStartCad>:
{
 800d4d8:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 800d4da:	4b08      	ldr	r3, [pc, #32]	; (800d4fc <RadioStartCad+0x24>)
 800d4dc:	2100      	movs	r1, #0
 800d4de:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 800d4e2:	f001 fb86 	bl	800ebf2 <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 800d4e6:	2300      	movs	r3, #0
 800d4e8:	f44f 71c0 	mov.w	r1, #384	; 0x180
 800d4ec:	461a      	mov	r2, r3
 800d4ee:	4608      	mov	r0, r1
 800d4f0:	f000 fffa 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
}
 800d4f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetCad( );
 800d4f8:	f000 bf70 	b.w	800e3dc <SUBGRF_SetCad>
 800d4fc:	20001af4 	.word	0x20001af4

0800d500 <RadioSleep>:
{
 800d500:	b508      	push	{r3, lr}
    SUBGRF_SetSleep( params );
 800d502:	f04f 0004 	mov.w	r0, #4
 800d506:	f001 f9ad 	bl	800e864 <SUBGRF_SetSleep>
}
 800d50a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RADIO_DELAY_MS( 2 );
 800d50e:	2002      	movs	r0, #2
 800d510:	f7f3 bfe2 	b.w	80014d8 <HAL_Delay>

0800d514 <RadioTimeOnAir>:
{
 800d514:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d516:	f8bd 5014 	ldrh.w	r5, [sp, #20]
 800d51a:	f89d e018 	ldrb.w	lr, [sp, #24]
 800d51e:	f89d c01c 	ldrb.w	ip, [sp, #28]
 800d522:	f89d 4020 	ldrb.w	r4, [sp, #32]
    switch( modem )
 800d526:	b140      	cbz	r0, 800d53a <RadioTimeOnAir+0x26>
 800d528:	2801      	cmp	r0, #1
 800d52a:	d019      	beq.n	800d560 <RadioTimeOnAir+0x4c>
 800d52c:	2201      	movs	r2, #1
 800d52e:	2300      	movs	r3, #0
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 800d530:	4413      	add	r3, r2
 800d532:	1e58      	subs	r0, r3, #1
 800d534:	fbb0 f0f2 	udiv	r0, r0, r2
}
 800d538:	bdf0      	pop	{r4, r5, r6, r7, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 800d53a:	f1be 0f00 	cmp.w	lr, #0
 800d53e:	bf0c      	ite	eq
 800d540:	2308      	moveq	r3, #8
 800d542:	2300      	movne	r3, #0
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 800d544:	2c00      	cmp	r4, #0
    return ( preambleLen << 3 ) +
 800d546:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 800d54a:	bf14      	ite	ne
 800d54c:	2402      	movne	r4, #2
 800d54e:	2400      	moveq	r4, #0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 800d550:	3318      	adds	r3, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 800d552:	4464      	add	r4, ip
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 800d554:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 800d558:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800d55c:	4363      	muls	r3, r4
        break;
 800d55e:	e7e7      	b.n	800d530 <RadioTimeOnAir+0x1c>
    int32_t crDenom           = coderate + 4;
 800d560:	1d1e      	adds	r6, r3, #4
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 800d562:	1f53      	subs	r3, r2, #5
 800d564:	2b01      	cmp	r3, #1
 800d566:	d802      	bhi.n	800d56e <RadioTimeOnAir+0x5a>
        if( preambleLen < 12 )
 800d568:	2d0c      	cmp	r5, #12
 800d56a:	bf38      	it	cc
 800d56c:	250c      	movcc	r5, #12
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800d56e:	2900      	cmp	r1, #0
 800d570:	d138      	bne.n	800d5e4 <RadioTimeOnAir+0xd0>
 800d572:	f1a2 070b 	sub.w	r7, r2, #11
 800d576:	2f01      	cmp	r7, #1
 800d578:	bf8c      	ite	hi
 800d57a:	2700      	movhi	r7, #0
 800d57c:	2701      	movls	r7, #1
                            ( crcOn ? 16 : 0 ) -
 800d57e:	2c00      	cmp	r4, #0
 800d580:	bf14      	ite	ne
 800d582:	2410      	movne	r4, #16
 800d584:	2400      	moveq	r4, #0
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 800d586:	eb04 04cc 	add.w	r4, r4, ip, lsl #3
                            ( fixLen ? 0 : 20 );
 800d58a:	f1be 0f00 	cmp.w	lr, #0
 800d58e:	bf14      	ite	ne
 800d590:	2000      	movne	r0, #0
 800d592:	2014      	moveq	r0, #20
                            ( crcOn ? 16 : 0 ) -
 800d594:	eba4 0482 	sub.w	r4, r4, r2, lsl #2
    if( datarate <= 6 )
 800d598:	2a06      	cmp	r2, #6
                            ( 4 * datarate ) +
 800d59a:	4404      	add	r4, r0
 800d59c:	ea4f 0382 	mov.w	r3, r2, lsl #2
 800d5a0:	f1a2 0002 	sub.w	r0, r2, #2
    if( datarate <= 6 )
 800d5a4:	d902      	bls.n	800d5ac <RadioTimeOnAir+0x98>
        ceilNumerator += 8;
 800d5a6:	3408      	adds	r4, #8
        if( lowDatareOptimize == true )
 800d5a8:	b107      	cbz	r7, 800d5ac <RadioTimeOnAir+0x98>
            ceilDenominator = 4 * ( datarate - 2 );
 800d5aa:	0083      	lsls	r3, r0, #2
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 800d5ac:	2c00      	cmp	r4, #0
 800d5ae:	bfac      	ite	ge
 800d5b0:	191c      	addge	r4, r3, r4
 800d5b2:	1c1c      	addlt	r4, r3, #0
    if( datarate <= 6 )
 800d5b4:	2a06      	cmp	r2, #6
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 800d5b6:	4a10      	ldr	r2, [pc, #64]	; (800d5f8 <RadioTimeOnAir+0xe4>)
 800d5b8:	5c51      	ldrb	r1, [r2, r1]
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 800d5ba:	f104 34ff 	add.w	r4, r4, #4294967295
 800d5be:	fb94 f3f3 	sdiv	r3, r4, r3
 800d5c2:	fb06 5303 	mla	r3, r6, r3, r5
    int32_t intermediate =
 800d5c6:	bf8c      	ite	hi
 800d5c8:	330c      	addhi	r3, #12
        intermediate += 2;
 800d5ca:	330e      	addls	r3, #14
    switch( bw )
 800d5cc:	290a      	cmp	r1, #10
 800d5ce:	d812      	bhi.n	800d5f6 <RadioTimeOnAir+0xe2>
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 800d5d0:	009b      	lsls	r3, r3, #2
 800d5d2:	3301      	adds	r3, #1
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 800d5d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 800d5d8:	4083      	lsls	r3, r0
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 800d5da:	4353      	muls	r3, r2
 800d5dc:	4a07      	ldr	r2, [pc, #28]	; (800d5fc <RadioTimeOnAir+0xe8>)
 800d5de:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 800d5e2:	e7a5      	b.n	800d530 <RadioTimeOnAir+0x1c>
    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800d5e4:	2901      	cmp	r1, #1
 800d5e6:	d104      	bne.n	800d5f2 <RadioTimeOnAir+0xde>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 800d5e8:	f1a2 030c 	sub.w	r3, r2, #12
 800d5ec:	425f      	negs	r7, r3
 800d5ee:	415f      	adcs	r7, r3
 800d5f0:	e7c5      	b.n	800d57e <RadioTimeOnAir+0x6a>
    bool    lowDatareOptimize = false;
 800d5f2:	2700      	movs	r7, #0
 800d5f4:	e7c3      	b.n	800d57e <RadioTimeOnAir+0x6a>
    return DIVC(numerator, denominator); /* ST_WORKAROUND : simplified calculation with macro usage */
 800d5f6:	deff      	udf	#255	; 0xff
 800d5f8:	08010fb0 	.word	0x08010fb0
 800d5fc:	08010fb4 	.word	0x08010fb4

0800d600 <RadioSetMaxPayloadLength>:
    if( modem == MODEM_LORA )
 800d600:	2801      	cmp	r0, #1
 800d602:	4808      	ldr	r0, [pc, #32]	; (800d624 <RadioSetMaxPayloadLength+0x24>)
 800d604:	d105      	bne.n	800d612 <RadioSetMaxPayloadLength+0x12>
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 800d606:	4b08      	ldr	r3, [pc, #32]	; (800d628 <RadioSetMaxPayloadLength+0x28>)
 800d608:	77c1      	strb	r1, [r0, #31]
 800d60a:	7019      	strb	r1, [r3, #0]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800d60c:	300e      	adds	r0, #14
 800d60e:	f001 ba01 	b.w	800ea14 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 800d612:	7d43      	ldrb	r3, [r0, #21]
 800d614:	2b01      	cmp	r3, #1
 800d616:	d103      	bne.n	800d620 <RadioSetMaxPayloadLength+0x20>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 800d618:	4b03      	ldr	r3, [pc, #12]	; (800d628 <RadioSetMaxPayloadLength+0x28>)
 800d61a:	7581      	strb	r1, [r0, #22]
 800d61c:	7019      	strb	r1, [r3, #0]
 800d61e:	e7f5      	b.n	800d60c <RadioSetMaxPayloadLength+0xc>
}
 800d620:	4770      	bx	lr
 800d622:	bf00      	nop
 800d624:	20001af4 	.word	0x20001af4
 800d628:	200000d0 	.word	0x200000d0

0800d62c <RadioRxBoosted>:
{
 800d62c:	b510      	push	{r4, lr}
 800d62e:	4604      	mov	r4, r0
    if (1UL==RFW_Is_Init())
 800d630:	f001 fbac 	bl	800ed8c <RFW_Is_Init>
 800d634:	2801      	cmp	r0, #1
 800d636:	d117      	bne.n	800d668 <RadioRxBoosted+0x3c>
      RFW_ReceiveInit();
 800d638:	f001 fbb0 	bl	800ed9c <RFW_ReceiveInit>
    if( timeout != 0 )
 800d63c:	b134      	cbz	r4, 800d64c <RadioRxBoosted+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 800d63e:	4810      	ldr	r0, [pc, #64]	; (800d680 <RadioRxBoosted+0x54>)
 800d640:	4621      	mov	r1, r4
 800d642:	f002 f827 	bl	800f694 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 800d646:	480e      	ldr	r0, [pc, #56]	; (800d680 <RadioRxBoosted+0x54>)
 800d648:	f001 ffea 	bl	800f620 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 800d64c:	4c0d      	ldr	r4, [pc, #52]	; (800d684 <RadioRxBoosted+0x58>)
 800d64e:	2100      	movs	r1, #0
 800d650:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 800d654:	f001 facd 	bl	800ebf2 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 800d658:	7863      	ldrb	r3, [r4, #1]
 800d65a:	b16b      	cbz	r3, 800d678 <RadioRxBoosted+0x4c>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 800d65c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 800d660:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 800d664:	f000 bfee 	b.w	800e644 <SUBGRF_SetRxBoosted>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 800d668:	2300      	movs	r3, #0
 800d66a:	f240 2162 	movw	r1, #610	; 0x262
 800d66e:	461a      	mov	r2, r3
 800d670:	4608      	mov	r0, r1
 800d672:	f000 ff39 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
 800d676:	e7e1      	b.n	800d63c <RadioRxBoosted+0x10>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 800d678:	68a0      	ldr	r0, [r4, #8]
 800d67a:	0180      	lsls	r0, r0, #6
 800d67c:	e7f0      	b.n	800d660 <RadioRxBoosted+0x34>
 800d67e:	bf00      	nop
 800d680:	20001b64 	.word	0x20001b64
 800d684:	20001af4 	.word	0x20001af4

0800d688 <RadioRx>:
{
 800d688:	b510      	push	{r4, lr}
 800d68a:	4604      	mov	r4, r0
    if ( 1UL == RFW_Is_Init( ) )
 800d68c:	f001 fb7e 	bl	800ed8c <RFW_Is_Init>
 800d690:	2801      	cmp	r0, #1
 800d692:	d117      	bne.n	800d6c4 <RadioRx+0x3c>
      RFW_ReceiveInit( );
 800d694:	f001 fb82 	bl	800ed9c <RFW_ReceiveInit>
    if( timeout != 0 )
 800d698:	b134      	cbz	r4, 800d6a8 <RadioRx+0x20>
        TimerSetValue( &RxTimeoutTimer, timeout );
 800d69a:	4810      	ldr	r0, [pc, #64]	; (800d6dc <RadioRx+0x54>)
 800d69c:	4621      	mov	r1, r4
 800d69e:	f001 fff9 	bl	800f694 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 800d6a2:	480e      	ldr	r0, [pc, #56]	; (800d6dc <RadioRx+0x54>)
 800d6a4:	f001 ffbc 	bl	800f620 <UTIL_TIMER_Start>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_RX);
 800d6a8:	4c0d      	ldr	r4, [pc, #52]	; (800d6e0 <RadioRx+0x58>)
 800d6aa:	2100      	movs	r1, #0
 800d6ac:	f894 0056 	ldrb.w	r0, [r4, #86]	; 0x56
 800d6b0:	f001 fa9f 	bl	800ebf2 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 800d6b4:	7863      	ldrb	r3, [r4, #1]
 800d6b6:	b16b      	cbz	r3, 800d6d4 <RadioRx+0x4c>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 800d6b8:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
}
 800d6bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 800d6c0:	f000 be5a 	b.w	800e378 <SUBGRF_SetRx>
      SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 800d6c4:	2300      	movs	r3, #0
 800d6c6:	f240 2162 	movw	r1, #610	; 0x262
 800d6ca:	461a      	mov	r2, r3
 800d6cc:	4608      	mov	r0, r1
 800d6ce:	f000 ff0b 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
 800d6d2:	e7e1      	b.n	800d698 <RadioRx+0x10>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 800d6d4:	68a0      	ldr	r0, [r4, #8]
 800d6d6:	0180      	lsls	r0, r0, #6
 800d6d8:	e7f0      	b.n	800d6bc <RadioRx+0x34>
 800d6da:	bf00      	nop
 800d6dc:	20001b64 	.word	0x20001b64
 800d6e0:	20001af4 	.word	0x20001af4

0800d6e4 <RadioSetPublicNetwork>:
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 800d6e4:	4b0d      	ldr	r3, [pc, #52]	; (800d71c <RadioSetPublicNetwork+0x38>)
{
 800d6e6:	b510      	push	{r4, lr}
 800d6e8:	4604      	mov	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 800d6ea:	7318      	strb	r0, [r3, #12]
 800d6ec:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 800d6ee:	2001      	movs	r0, #1
 800d6f0:	f000 f816 	bl	800d720 <RadioSetModem>
    if( enable == true )
 800d6f4:	b15c      	cbz	r4, 800d70e <RadioSetPublicNetwork+0x2a>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 800d6f6:	2134      	movs	r1, #52	; 0x34
 800d6f8:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 800d6fc:	f000 ff92 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 800d700:	2144      	movs	r1, #68	; 0x44
}
 800d702:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 800d706:	f240 7041 	movw	r0, #1857	; 0x741
 800d70a:	f000 bf8b 	b.w	800e624 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 800d70e:	2114      	movs	r1, #20
 800d710:	f44f 60e8 	mov.w	r0, #1856	; 0x740
 800d714:	f000 ff86 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 800d718:	2124      	movs	r1, #36	; 0x24
 800d71a:	e7f2      	b.n	800d702 <RadioSetPublicNetwork+0x1e>
 800d71c:	20001af4 	.word	0x20001af4

0800d720 <RadioSetModem>:
{
 800d720:	b538      	push	{r3, r4, r5, lr}
    SubgRf.Modem = modem;
 800d722:	4d0f      	ldr	r5, [pc, #60]	; (800d760 <RadioSetModem+0x40>)
{
 800d724:	4604      	mov	r4, r0
    SubgRf.Modem = modem;
 800d726:	7028      	strb	r0, [r5, #0]
    RFW_SetRadioModem(modem);
 800d728:	f001 fb3d 	bl	800eda6 <RFW_SetRadioModem>
    switch( modem )
 800d72c:	2c01      	cmp	r4, #1
 800d72e:	d00a      	beq.n	800d746 <RadioSetModem+0x26>
 800d730:	3c02      	subs	r4, #2
 800d732:	2c01      	cmp	r4, #1
 800d734:	f04f 0400 	mov.w	r4, #0
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 800d738:	bf94      	ite	ls
 800d73a:	2002      	movls	r0, #2
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 800d73c:	4620      	movhi	r0, r4
 800d73e:	f000 ffb5 	bl	800e6ac <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 800d742:	736c      	strb	r4, [r5, #13]
}
 800d744:	bd38      	pop	{r3, r4, r5, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 800d746:	4620      	mov	r0, r4
 800d748:	f000 ffb0 	bl	800e6ac <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 800d74c:	7b28      	ldrb	r0, [r5, #12]
 800d74e:	7b6b      	ldrb	r3, [r5, #13]
 800d750:	4283      	cmp	r3, r0
 800d752:	d0f7      	beq.n	800d744 <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 800d754:	7368      	strb	r0, [r5, #13]
}
 800d756:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 800d75a:	f7ff bfc3 	b.w	800d6e4 <RadioSetPublicNetwork>
 800d75e:	bf00      	nop
 800d760:	20001af4 	.word	0x20001af4

0800d764 <RadioSetTxGenericConfig>:
    }
    return status;
}

static int32_t RadioSetTxGenericConfig( GenericModems_t modem, TxConfigGeneric_t* config, int8_t power, uint32_t timeout )
{
 800d764:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d768:	4605      	mov	r5, r0
 800d76a:	b087      	sub	sp, #28
    uint8_t syncword[8] = {0};
 800d76c:	2700      	movs	r7, #0
 800d76e:	e9cd 7701 	strd	r7, r7, [sp, #4]
{
 800d772:	460c      	mov	r4, r1
 800d774:	4691      	mov	r9, r2
 800d776:	4698      	mov	r8, r3
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 800d778:	f001 fb07 	bl	800ed8a <RFW_DeInit>
    switch( modem )
 800d77c:	2d01      	cmp	r5, #1
 800d77e:	d078      	beq.n	800d872 <RadioSetTxGenericConfig+0x10e>
 800d780:	2d02      	cmp	r5, #2
 800d782:	f000 80c4 	beq.w	800d90e <RadioSetTxGenericConfig+0x1aa>
 800d786:	2d00      	cmp	r5, #0
 800d788:	d15c      	bne.n	800d844 <RadioSetTxGenericConfig+0xe0>
    {
    case GENERIC_FSK:
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 800d78a:	68a3      	ldr	r3, [r4, #8]
 800d78c:	2b00      	cmp	r3, #0
 800d78e:	f000 80d2 	beq.w	800d936 <RadioSetTxGenericConfig+0x1d2>
 800d792:	6922      	ldr	r2, [r4, #16]
 800d794:	2a00      	cmp	r2, #0
 800d796:	f000 80ce 	beq.w	800d936 <RadioSetTxGenericConfig+0x1d2>
        {
            return -1;
        }
        if( config->fsk.SyncWordLength > 8 )
 800d79a:	7d22      	ldrb	r2, [r4, #20]
 800d79c:	2a08      	cmp	r2, #8
 800d79e:	f200 80ca 	bhi.w	800d936 <RadioSetTxGenericConfig+0x1d2>
        }
        else
        {
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
            {
                syncword[i] = config->fsk.SyncWord[i];
 800d7a2:	a901      	add	r1, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 800d7a4:	42aa      	cmp	r2, r5
 800d7a6:	dc5b      	bgt.n	800d860 <RadioSetTxGenericConfig+0xfc>
            }
        }
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800d7a8:	4d64      	ldr	r5, [pc, #400]	; (800d93c <RadioSetTxGenericConfig+0x1d8>)
 800d7aa:	2600      	movs	r6, #0
 800d7ac:	f885 6038 	strb.w	r6, [r5, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 800d7b0:	63eb      	str	r3, [r5, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = ( RadioModShapings_t ) config->fsk.ModulationShaping;
 800d7b2:	7823      	ldrb	r3, [r4, #0]
 800d7b4:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 800d7b8:	6860      	ldr	r0, [r4, #4]
 800d7ba:	f001 fa89 	bl	800ecd0 <SUBGRF_GetFskBandwidthRegValue>
 800d7be:	f885 0045 	strb.w	r0, [r5, #69]	; 0x45
        SubgRf.ModulationParams.Params.Gfsk.Fdev = config->fsk.FrequencyDeviation;
 800d7c2:	68e3      	ldr	r3, [r4, #12]
 800d7c4:	642b      	str	r3, [r5, #64]	; 0x40
    
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 800d7c6:	6923      	ldr	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx

        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 800d7c8:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 800d7cc:	73ae      	strb	r6, [r5, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3; // convert byte into bit
 800d7ce:	00db      	lsls	r3, r3, #3
 800d7d0:	822b      	strh	r3, [r5, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS; // don't care in tx
 800d7d2:	2304      	movs	r3, #4
 800d7d4:	74ab      	strb	r3, [r5, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 800d7d6:	7d23      	ldrb	r3, [r4, #20]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF; // don't care in tx
 800d7d8:	752e      	strb	r6, [r5, #20]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 800d7da:	00db      	lsls	r3, r3, #3
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 800d7dc:	2902      	cmp	r1, #2
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 800d7de:	74eb      	strb	r3, [r5, #19]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.HeaderType == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 800d7e0:	462e      	mov	r6, r5
 800d7e2:	7fe3      	ldrb	r3, [r4, #31]
 800d7e4:	d002      	beq.n	800d7ec <RadioSetTxGenericConfig+0x88>
 800d7e6:	7fa2      	ldrb	r2, [r4, #30]
 800d7e8:	2a02      	cmp	r2, #2
 800d7ea:	d13e      	bne.n	800d86a <RadioSetTxGenericConfig+0x106>
        {
            /* Supports only RADIO_FSK_CRC_2_BYTES_IBM or RADIO_FSK_CRC_2_BYTES_CCIT */
            if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) &&( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 800d7ec:	f103 020f 	add.w	r2, r3, #15
 800d7f0:	b2d2      	uxtb	r2, r2
 800d7f2:	2a01      	cmp	r2, #1
 800d7f4:	d902      	bls.n	800d7fc <RadioSetTxGenericConfig+0x98>
 800d7f6:	2b01      	cmp	r3, #1
 800d7f8:	f040 809d 	bne.w	800d936 <RadioSetTxGenericConfig+0x1d2>
                return -1;
            }
            ConfigGeneric_t ConfigGeneric;
            ConfigGeneric.rtx = CONFIG_TX;
            ConfigGeneric.TxConfig = config;
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 800d7fc:	4b50      	ldr	r3, [pc, #320]	; (800d940 <RadioSetTxGenericConfig+0x1dc>)
 800d7fe:	4a51      	ldr	r2, [pc, #324]	; (800d944 <RadioSetTxGenericConfig+0x1e0>)
 800d800:	6819      	ldr	r1, [r3, #0]
            ConfigGeneric.TxConfig = config;
 800d802:	9403      	str	r4, [sp, #12]
            ConfigGeneric.rtx = CONFIG_TX;
 800d804:	2501      	movs	r5, #1
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 800d806:	a803      	add	r0, sp, #12
            ConfigGeneric.rtx = CONFIG_TX;
 800d808:	f88d 5014 	strb.w	r5, [sp, #20]
            if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &TxTimeoutTimer ) )
 800d80c:	f001 faba 	bl	800ed84 <RFW_Init>
 800d810:	2800      	cmp	r0, #0
 800d812:	f040 8090 	bne.w	800d936 <RadioSetTxGenericConfig+0x1d2>
            {
              return -1;
            }
            /* whitening off, will be processed by FW, switch off built-in radio whitening */
            SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 800d816:	7630      	strb	r0, [r6, #24]
            /* Crc processed by FW, switch off built-in radio Crc */
            SubgRf.PacketParams.Params.Gfsk.CrcLength = (RadioCrcTypes_t) RADIO_CRC_OFF;
 800d818:	75f5      	strb	r5, [r6, #23]
            /* length contained in Tx, but will be processed by FW after de-whitening */
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 800d81a:	7570      	strb	r0, [r6, #21]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
        }

        RadioStandby( );
 800d81c:	f7ff fcf6 	bl	800d20c <RadioStandby>
        RadioSetModem( MODEM_FSK );
 800d820:	2000      	movs	r0, #0
 800d822:	f7ff ff7d 	bl	800d720 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800d826:	4848      	ldr	r0, [pc, #288]	; (800d948 <RadioSetTxGenericConfig+0x1e4>)
 800d828:	f000 ff56 	bl	800e6d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800d82c:	4847      	ldr	r0, [pc, #284]	; (800d94c <RadioSetTxGenericConfig+0x1e8>)
 800d82e:	f001 f8f1 	bl	800ea14 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 800d832:	a801      	add	r0, sp, #4
 800d834:	f001 f8c0 	bl	800e9b8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 800d838:	8ba0      	ldrh	r0, [r4, #28]
 800d83a:	f001 f82d 	bl	800e898 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial(config->fsk.CrcPolynomial );
 800d83e:	8c20      	ldrh	r0, [r4, #32]
 800d840:	f001 f8d6 	bl	800e9f0 <SUBGRF_SetCrcPolynomial>
        break;
    default:
        break;
    }

    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 800d844:	4648      	mov	r0, r9
 800d846:	f001 f9ea 	bl	800ec1e <SUBGRF_SetRfTxPower>
 800d84a:	4c3c      	ldr	r4, [pc, #240]	; (800d93c <RadioSetTxGenericConfig+0x1d8>)
 800d84c:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 800d850:	f001 faa0 	bl	800ed94 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 800d854:	f8c4 8004 	str.w	r8, [r4, #4]
    return 0;
 800d858:	2000      	movs	r0, #0
}
 800d85a:	b007      	add	sp, #28
 800d85c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                syncword[i] = config->fsk.SyncWord[i];
 800d860:	69a0      	ldr	r0, [r4, #24]
 800d862:	5d40      	ldrb	r0, [r0, r5]
 800d864:	5468      	strb	r0, [r5, r1]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 800d866:	3501      	adds	r5, #1
 800d868:	e79c      	b.n	800d7a4 <RadioSetTxGenericConfig+0x40>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 800d86a:	75eb      	strb	r3, [r5, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 800d86c:	7629      	strb	r1, [r5, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.HeaderType;
 800d86e:	756a      	strb	r2, [r5, #21]
 800d870:	e7d4      	b.n	800d81c <RadioSetTxGenericConfig+0xb8>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 800d872:	4e32      	ldr	r6, [pc, #200]	; (800d93c <RadioSetTxGenericConfig+0x1d8>)
 800d874:	f886 5038 	strb.w	r5, [r6, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 800d878:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 800d87c:	f886 3050 	strb.w	r3, [r6, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 800d880:	f894 2029 	ldrb.w	r2, [r4, #41]	; 0x29
 800d884:	f886 2051 	strb.w	r2, [r6, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 800d888:	f894 202a 	ldrb.w	r2, [r4, #42]	; 0x2a
 800d88c:	f886 2052 	strb.w	r2, [r6, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 800d890:	f894 102b 	ldrb.w	r1, [r4, #43]	; 0x2b
 800d894:	2901      	cmp	r1, #1
 800d896:	d002      	beq.n	800d89e <RadioSetTxGenericConfig+0x13a>
 800d898:	2902      	cmp	r1, #2
 800d89a:	d02b      	beq.n	800d8f4 <RadioSetTxGenericConfig+0x190>
 800d89c:	b909      	cbnz	r1, 800d8a2 <RadioSetTxGenericConfig+0x13e>
            SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 800d89e:	f886 1053 	strb.w	r1, [r6, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 800d8a2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800d8a4:	83b3      	strh	r3, [r6, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 800d8a6:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
 800d8aa:	77b3      	strb	r3, [r6, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 800d8ac:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
 800d8b0:	f886 3020 	strb.w	r3, [r6, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800d8b4:	2501      	movs	r5, #1
        SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t ) config->lora.IqInverted;
 800d8b6:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 800d8ba:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800d8be:	73b5      	strb	r5, [r6, #14]
        RadioStandby( );
 800d8c0:	f7ff fca4 	bl	800d20c <RadioStandby>
        RadioSetModem( MODEM_LORA );
 800d8c4:	4628      	mov	r0, r5
 800d8c6:	f7ff ff2b 	bl	800d720 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800d8ca:	481f      	ldr	r0, [pc, #124]	; (800d948 <RadioSetTxGenericConfig+0x1e4>)
 800d8cc:	f000 ff04 	bl	800e6d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800d8d0:	481e      	ldr	r0, [pc, #120]	; (800d94c <RadioSetTxGenericConfig+0x1e8>)
 800d8d2:	f001 f89f 	bl	800ea14 <SUBGRF_SetPacketParams>
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 800d8d6:	f896 3051 	ldrb.w	r3, [r6, #81]	; 0x51
 800d8da:	2b06      	cmp	r3, #6
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 800d8dc:	f640 0089 	movw	r0, #2185	; 0x889
        if( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 )
 800d8e0:	d10f      	bne.n	800d902 <RadioSetTxGenericConfig+0x19e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 800d8e2:	f000 ff65 	bl	800e7b0 <SUBGRF_ReadRegister>
 800d8e6:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 800d8ea:	f640 0089 	movw	r0, #2185	; 0x889
 800d8ee:	f000 fe99 	bl	800e624 <SUBGRF_WriteRegister>
 800d8f2:	e7a7      	b.n	800d844 <RadioSetTxGenericConfig+0xe0>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 800d8f4:	3b0b      	subs	r3, #11
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 800d8f6:	2b01      	cmp	r3, #1
 800d8f8:	bf88      	it	hi
 800d8fa:	463d      	movhi	r5, r7
 800d8fc:	f886 5053 	strb.w	r5, [r6, #83]	; 0x53
 800d900:	e7cf      	b.n	800d8a2 <RadioSetTxGenericConfig+0x13e>
            SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 800d902:	f000 ff55 	bl	800e7b0 <SUBGRF_ReadRegister>
 800d906:	f040 0104 	orr.w	r1, r0, #4
 800d90a:	b2c9      	uxtb	r1, r1
 800d90c:	e7ed      	b.n	800d8ea <RadioSetTxGenericConfig+0x186>
        if( ( config->bpsk.BitRate == 0 ) || ( config->bpsk.BitRate > 1000 ) )
 800d90e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800d910:	3b01      	subs	r3, #1
 800d912:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800d916:	d20e      	bcs.n	800d936 <RadioSetTxGenericConfig+0x1d2>
        RadioSetModem( MODEM_BPSK );
 800d918:	4628      	mov	r0, r5
 800d91a:	f7ff ff01 	bl	800d720 <RadioSetModem>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 800d91e:	4807      	ldr	r0, [pc, #28]	; (800d93c <RadioSetTxGenericConfig+0x1d8>)
 800d920:	f880 5038 	strb.w	r5, [r0, #56]	; 0x38
        SubgRf.ModulationParams.Params.Bpsk.BitRate = config->bpsk.BitRate;
 800d924:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800d926:	6483      	str	r3, [r0, #72]	; 0x48
        SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 800d928:	2316      	movs	r3, #22
 800d92a:	f880 304c 	strb.w	r3, [r0, #76]	; 0x4c
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800d92e:	3038      	adds	r0, #56	; 0x38
 800d930:	f000 fed2 	bl	800e6d8 <SUBGRF_SetModulationParams>
        break;
 800d934:	e786      	b.n	800d844 <RadioSetTxGenericConfig+0xe0>
            return -1;
 800d936:	f04f 30ff 	mov.w	r0, #4294967295
 800d93a:	e78e      	b.n	800d85a <RadioSetTxGenericConfig+0xf6>
 800d93c:	20001af4 	.word	0x20001af4
 800d940:	20001204 	.word	0x20001204
 800d944:	20001b4c 	.word	0x20001b4c
 800d948:	20001b2c 	.word	0x20001b2c
 800d94c:	20001b02 	.word	0x20001b02

0800d950 <RadioSetRxGenericConfig>:
{
 800d950:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t syncword[8] = {0};
 800d954:	2600      	movs	r6, #0
{
 800d956:	b086      	sub	sp, #24
 800d958:	4698      	mov	r8, r3
 800d95a:	4614      	mov	r4, r2
    uint8_t syncword[8] = {0};
 800d95c:	e9cd 6601 	strd	r6, r6, [sp, #4]
{
 800d960:	4607      	mov	r7, r0
 800d962:	460d      	mov	r5, r1
    RFW_DeInit( ); /* switch Off FwPacketDecoding by default */
 800d964:	f001 fa11 	bl	800ed8a <RFW_DeInit>
        symbTimeout = 0;
 800d968:	42b4      	cmp	r4, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 800d96a:	4c77      	ldr	r4, [pc, #476]	; (800db48 <RadioSetRxGenericConfig+0x1f8>)
 800d96c:	bf16      	itet	ne
 800d96e:	2301      	movne	r3, #1
 800d970:	4633      	moveq	r3, r6
        symbTimeout = 0;
 800d972:	46b0      	movne	r8, r6
    SubgRf.RxContinuous = ( rxContinuous == 0 ) ? false : true;
 800d974:	7063      	strb	r3, [r4, #1]
    switch( modem )
 800d976:	b137      	cbz	r7, 800d986 <RadioSetRxGenericConfig+0x36>
 800d978:	2f01      	cmp	r7, #1
 800d97a:	f000 8082 	beq.w	800da82 <RadioSetRxGenericConfig+0x132>
    return status;
 800d97e:	2000      	movs	r0, #0
}
 800d980:	b006      	add	sp, #24
 800d982:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( ( config->fsk.BitRate == 0 ) || ( config->fsk.PreambleLen == 0 ) )
 800d986:	68eb      	ldr	r3, [r5, #12]
 800d988:	2b00      	cmp	r3, #0
 800d98a:	f000 80d9 	beq.w	800db40 <RadioSetRxGenericConfig+0x1f0>
 800d98e:	692b      	ldr	r3, [r5, #16]
 800d990:	2b00      	cmp	r3, #0
 800d992:	f000 80d5 	beq.w	800db40 <RadioSetRxGenericConfig+0x1f0>
        if( config->fsk.SyncWordLength > 8 )
 800d996:	7d6b      	ldrb	r3, [r5, #21]
 800d998:	2b08      	cmp	r3, #8
 800d99a:	f200 80d1 	bhi.w	800db40 <RadioSetRxGenericConfig+0x1f0>
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 800d99e:	4638      	mov	r0, r7
                syncword[i] = config->fsk.SyncWord[i];
 800d9a0:	aa01      	add	r2, sp, #4
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 800d9a2:	4283      	cmp	r3, r0
 800d9a4:	dc62      	bgt.n	800da6c <RadioSetRxGenericConfig+0x11c>
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 800d9a6:	6828      	ldr	r0, [r5, #0]
 800d9a8:	3800      	subs	r0, #0
 800d9aa:	bf18      	it	ne
 800d9ac:	2001      	movne	r0, #1
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800d9ae:	2600      	movs	r6, #0
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->fsk.StopTimerOnPreambleDetect == 0 ) ? false : true );
 800d9b0:	f000 fd2a 	bl	800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800d9b4:	f884 6038 	strb.w	r6, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.Gfsk.BitRate = config->fsk.BitRate;
 800d9b8:	68eb      	ldr	r3, [r5, #12]
 800d9ba:	63e3      	str	r3, [r4, #60]	; 0x3c
        SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = (RadioModShapings_t) config->fsk.ModulationShaping;
 800d9bc:	792b      	ldrb	r3, [r5, #4]
 800d9be:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( config->fsk.Bandwidth );
 800d9c2:	68a8      	ldr	r0, [r5, #8]
 800d9c4:	f001 f984 	bl	800ecd0 <SUBGRF_GetFskBandwidthRegValue>
 800d9c8:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 800d9cc:	692b      	ldr	r3, [r5, #16]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 800d9ce:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( config->fsk.PreambleLen ) << 3 ; // convert byte into bit
 800d9d0:	00db      	lsls	r3, r3, #3
 800d9d2:	8223      	strh	r3, [r4, #16]
        SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = ( RadioPreambleDetection_t ) config->fsk.PreambleMinDetect;
 800d9d4:	7d2b      	ldrb	r3, [r5, #20]
 800d9d6:	74a3      	strb	r3, [r4, #18]
        SubgRf.PacketParams.Params.Gfsk.SyncWordLength = ( config->fsk.SyncWordLength ) << 3; // convert byte into bit
 800d9d8:	7d6b      	ldrb	r3, [r5, #21]
 800d9da:	00db      	lsls	r3, r3, #3
 800d9dc:	74e3      	strb	r3, [r4, #19]
        SubgRf.PacketParams.Params.Gfsk.AddrComp = ( RadioAddressComp_t ) config->fsk.AddrComp;
 800d9de:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 800d9e2:	7523      	strb	r3, [r4, #20]
        if( config->fsk.LengthMode == RADIO_FSK_PACKET_FIXED_LENGTH )
 800d9e4:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 800d9e8:	2b00      	cmp	r3, #0
 800d9ea:	d144      	bne.n	800da76 <RadioSetRxGenericConfig+0x126>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = config->fsk.MaxPayloadLength;
 800d9ec:	69ea      	ldr	r2, [r5, #28]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 800d9ee:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 800d9f2:	75a2      	strb	r2, [r4, #22]
        if( ( config->fsk.Whitening == RADIO_FSK_DC_IBM_WHITENING ) || ( config->fsk.LengthMode == RADIO_FSK_PACKET_2BYTES_LENGTH ) )
 800d9f4:	2902      	cmp	r1, #2
 800d9f6:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 800d9fa:	d001      	beq.n	800da00 <RadioSetRxGenericConfig+0xb0>
 800d9fc:	2b02      	cmp	r3, #2
 800d9fe:	d13c      	bne.n	800da7a <RadioSetRxGenericConfig+0x12a>
          if( ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_IBM ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_2_BYTES_CCIT ) && ( config->fsk.CrcLength != RADIO_FSK_CRC_OFF ) )
 800da00:	f102 030f 	add.w	r3, r2, #15
 800da04:	b2db      	uxtb	r3, r3
 800da06:	2b01      	cmp	r3, #1
 800da08:	d902      	bls.n	800da10 <RadioSetRxGenericConfig+0xc0>
 800da0a:	2a01      	cmp	r2, #1
 800da0c:	f040 8098 	bne.w	800db40 <RadioSetRxGenericConfig+0x1f0>
          ConfigGeneric.rtx = CONFIG_RX;
 800da10:	2300      	movs	r3, #0
 800da12:	f88d 3014 	strb.w	r3, [sp, #20]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 800da16:	4b4d      	ldr	r3, [pc, #308]	; (800db4c <RadioSetRxGenericConfig+0x1fc>)
 800da18:	4a4d      	ldr	r2, [pc, #308]	; (800db50 <RadioSetRxGenericConfig+0x200>)
 800da1a:	6819      	ldr	r1, [r3, #0]
          ConfigGeneric.RxConfig = config;
 800da1c:	9504      	str	r5, [sp, #16]
          if( 0UL != RFW_Init( &ConfigGeneric, RadioEvents, &RxTimeoutTimer ) )
 800da1e:	a803      	add	r0, sp, #12
 800da20:	f001 f9b0 	bl	800ed84 <RFW_Init>
 800da24:	2800      	cmp	r0, #0
 800da26:	f040 808b 	bne.w	800db40 <RadioSetRxGenericConfig+0x1f0>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 800da2a:	2301      	movs	r3, #1
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) RADIO_FSK_DC_FREE_OFF;
 800da2c:	7620      	strb	r0, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) RADIO_CRC_OFF;
 800da2e:	75e3      	strb	r3, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) RADIO_PACKET_FIXED_LENGTH;
 800da30:	7560      	strb	r0, [r4, #21]
        RadioStandby( );
 800da32:	f7ff fbeb 	bl	800d20c <RadioStandby>
        RadioSetModem( MODEM_FSK );
 800da36:	2000      	movs	r0, #0
 800da38:	f7ff fe72 	bl	800d720 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800da3c:	4845      	ldr	r0, [pc, #276]	; (800db54 <RadioSetRxGenericConfig+0x204>)
 800da3e:	f000 fe4b 	bl	800e6d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800da42:	4845      	ldr	r0, [pc, #276]	; (800db58 <RadioSetRxGenericConfig+0x208>)
 800da44:	f000 ffe6 	bl	800ea14 <SUBGRF_SetPacketParams>
        SUBGRF_SetSyncWord( syncword );
 800da48:	a801      	add	r0, sp, #4
 800da4a:	f000 ffb5 	bl	800e9b8 <SUBGRF_SetSyncWord>
        SUBGRF_SetWhiteningSeed( config->fsk.whiteSeed );
 800da4e:	8c28      	ldrh	r0, [r5, #32]
 800da50:	f000 ff22 	bl	800e898 <SUBGRF_SetWhiteningSeed>
        SUBGRF_SetCrcPolynomial( config->fsk.CrcPolynomial );
 800da54:	8ce8      	ldrh	r0, [r5, #38]	; 0x26
 800da56:	f000 ffcb 	bl	800e9f0 <SUBGRF_SetCrcPolynomial>
        SubgRf.RxTimeout = ( uint32_t )( ( symbTimeout * 1000 * 8 ) / config->fsk.BitRate );
 800da5a:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 800da5e:	fb03 f808 	mul.w	r8, r3, r8
 800da62:	68eb      	ldr	r3, [r5, #12]
 800da64:	fbb8 f3f3 	udiv	r3, r8, r3
        SubgRf.RxTimeout = 0xFFFF;
 800da68:	60a3      	str	r3, [r4, #8]
 800da6a:	e788      	b.n	800d97e <RadioSetRxGenericConfig+0x2e>
                syncword[i] = config->fsk.SyncWord[i];
 800da6c:	69a9      	ldr	r1, [r5, #24]
 800da6e:	5c09      	ldrb	r1, [r1, r0]
 800da70:	5481      	strb	r1, [r0, r2]
            for(int i = 0; i < config->fsk.SyncWordLength; i++)
 800da72:	3001      	adds	r0, #1
 800da74:	e795      	b.n	800d9a2 <RadioSetRxGenericConfig+0x52>
          SubgRf.PacketParams.Params.Gfsk.PayloadLength = 0xFF;
 800da76:	22ff      	movs	r2, #255	; 0xff
 800da78:	e7b9      	b.n	800d9ee <RadioSetRxGenericConfig+0x9e>
          SubgRf.PacketParams.Params.Gfsk.CrcLength = ( RadioCrcTypes_t ) config->fsk.CrcLength;
 800da7a:	75e2      	strb	r2, [r4, #23]
          SubgRf.PacketParams.Params.Gfsk.DcFree = ( RadioDcFree_t ) config->fsk.Whitening;
 800da7c:	7621      	strb	r1, [r4, #24]
          SubgRf.PacketParams.Params.Gfsk.HeaderType = ( RadioPacketLengthModes_t ) config->fsk.LengthMode;
 800da7e:	7563      	strb	r3, [r4, #21]
 800da80:	e7d7      	b.n	800da32 <RadioSetRxGenericConfig+0xe2>
        if( config->lora.PreambleLen == 0 )
 800da82:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 800da84:	2b00      	cmp	r3, #0
 800da86:	d05b      	beq.n	800db40 <RadioSetRxGenericConfig+0x1f0>
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 800da88:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 800da8c:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
        if( config->lora.LengthMode == RADIO_LORA_PACKET_FIXED_LENGTH )
 800da8e:	2b01      	cmp	r3, #1
            MaxPayloadLength = config->fsk.MaxPayloadLength;
 800da90:	bf0c      	ite	eq
 800da92:	7f2f      	ldrbeq	r7, [r5, #28]
            MaxPayloadLength = 0xFF;
 800da94:	27ff      	movne	r7, #255	; 0xff
        SUBGRF_SetStopRxTimerOnPreambleDetect( ( config->lora.StopTimerOnPreambleDetect == 0 ) ? false : true );
 800da96:	3800      	subs	r0, #0
 800da98:	bf18      	it	ne
 800da9a:	2001      	movne	r0, #1
 800da9c:	f000 fcb4 	bl	800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>
        SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 800daa0:	fa5f f088 	uxtb.w	r0, r8
 800daa4:	f000 fdea 	bl	800e67c <SUBGRF_SetLoRaSymbNumTimeout>
        SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 800daa8:	2101      	movs	r1, #1
 800daaa:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
        SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) config->lora.SpreadingFactor;
 800daae:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
 800dab2:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        SubgRf.ModulationParams.Params.LoRa.Bandwidth = ( RadioLoRaBandwidths_t ) config->lora.Bandwidth;
 800dab6:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
 800daba:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
        SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t ) config->lora.Coderate;
 800dabe:	f895 3032 	ldrb.w	r3, [r5, #50]	; 0x32
 800dac2:	f884 3052 	strb.w	r3, [r4, #82]	; 0x52
        switch( config->lora.LowDatarateOptimize )
 800dac6:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
 800daca:	428b      	cmp	r3, r1
 800dacc:	d002      	beq.n	800dad4 <RadioSetRxGenericConfig+0x184>
 800dace:	2b02      	cmp	r3, #2
 800dad0:	d003      	beq.n	800dada <RadioSetRxGenericConfig+0x18a>
 800dad2:	b93b      	cbnz	r3, 800dae4 <RadioSetRxGenericConfig+0x194>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 800dad4:	f884 3053 	strb.w	r3, [r4, #83]	; 0x53
 800dad8:	e004      	b.n	800dae4 <RadioSetRxGenericConfig+0x194>
            if( ( config->lora.SpreadingFactor == RADIO_LORA_SF11 ) || ( config->lora.SpreadingFactor == RADIO_LORA_SF12 ) )
 800dada:	3a0b      	subs	r2, #11
 800dadc:	2a01      	cmp	r2, #1
 800dade:	d827      	bhi.n	800db30 <RadioSetRxGenericConfig+0x1e0>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 1;
 800dae0:	f884 1053 	strb.w	r1, [r4, #83]	; 0x53
        SubgRf.PacketParams.Params.LoRa.PreambleLength = config->lora.PreambleLen;
 800dae4:	8eab      	ldrh	r3, [r5, #52]	; 0x34
 800dae6:	83a3      	strh	r3, [r4, #28]
        SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t ) config->lora.LengthMode;
 800dae8:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
 800daec:	77a3      	strb	r3, [r4, #30]
        SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t ) config->lora.CrcMode;
 800daee:	8f2b      	ldrh	r3, [r5, #56]	; 0x38
 800daf0:	8423      	strh	r3, [r4, #32]
        SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800daf2:	2601      	movs	r6, #1
 800daf4:	73a6      	strb	r6, [r4, #14]
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 800daf6:	77e7      	strb	r7, [r4, #31]
        RadioStandby( );
 800daf8:	f7ff fb88 	bl	800d20c <RadioStandby>
        RadioSetModem( MODEM_LORA );
 800dafc:	4630      	mov	r0, r6
 800dafe:	f7ff fe0f 	bl	800d720 <RadioSetModem>
        SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800db02:	4814      	ldr	r0, [pc, #80]	; (800db54 <RadioSetRxGenericConfig+0x204>)
 800db04:	f000 fde8 	bl	800e6d8 <SUBGRF_SetModulationParams>
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800db08:	4813      	ldr	r0, [pc, #76]	; (800db58 <RadioSetRxGenericConfig+0x208>)
 800db0a:	f000 ff83 	bl	800ea14 <SUBGRF_SetPacketParams>
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 800db0e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 800db12:	42b3      	cmp	r3, r6
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 800db14:	f240 7036 	movw	r0, #1846	; 0x736
        if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 800db18:	d10c      	bne.n	800db34 <RadioSetRxGenericConfig+0x1e4>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 800db1a:	f000 fe49 	bl	800e7b0 <SUBGRF_ReadRegister>
 800db1e:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 800db22:	f240 7036 	movw	r0, #1846	; 0x736
 800db26:	f000 fd7d 	bl	800e624 <SUBGRF_WriteRegister>
        SubgRf.RxTimeout = 0xFFFF;
 800db2a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800db2e:	e79b      	b.n	800da68 <RadioSetRxGenericConfig+0x118>
              SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0;
 800db30:	2300      	movs	r3, #0
 800db32:	e7cf      	b.n	800dad4 <RadioSetRxGenericConfig+0x184>
            SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 800db34:	f000 fe3c 	bl	800e7b0 <SUBGRF_ReadRegister>
 800db38:	f040 0104 	orr.w	r1, r0, #4
 800db3c:	b2c9      	uxtb	r1, r1
 800db3e:	e7f0      	b.n	800db22 <RadioSetRxGenericConfig+0x1d2>
            return -1;
 800db40:	f04f 30ff 	mov.w	r0, #4294967295
 800db44:	e71c      	b.n	800d980 <RadioSetRxGenericConfig+0x30>
 800db46:	bf00      	nop
 800db48:	20001af4 	.word	0x20001af4
 800db4c:	20001204 	.word	0x20001204
 800db50:	20001b64 	.word	0x20001b64
 800db54:	20001b2c 	.word	0x20001b2c
 800db58:	20001b02 	.word	0x20001b02

0800db5c <RadioSetTxConfig>:
{
 800db5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800db60:	b085      	sub	sp, #20
 800db62:	4682      	mov	sl, r0
 800db64:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 800db66:	f8bd b040 	ldrh.w	fp, [sp, #64]	; 0x40
 800db6a:	f89d 7044 	ldrb.w	r7, [sp, #68]	; 0x44
 800db6e:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
 800db72:	9201      	str	r2, [sp, #4]
 800db74:	4688      	mov	r8, r1
 800db76:	461e      	mov	r6, r3
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 800db78:	f001 f907 	bl	800ed8a <RFW_DeInit>
    switch( modem )
 800db7c:	f1ba 0f01 	cmp.w	sl, #1
 800db80:	4c53      	ldr	r4, [pc, #332]	; (800dcd0 <RadioSetTxConfig+0x174>)
 800db82:	d051      	beq.n	800dc28 <RadioSetTxConfig+0xcc>
 800db84:	f1ba 0f03 	cmp.w	sl, #3
 800db88:	f000 8093 	beq.w	800dcb2 <RadioSetTxConfig+0x156>
 800db8c:	f1ba 0f00 	cmp.w	sl, #0
 800db90:	d13e      	bne.n	800dc10 <RadioSetTxConfig+0xb4>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 800db92:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800db94:	4630      	mov	r0, r6
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 800db96:	f884 2044 	strb.w	r2, [r4, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800db9a:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 800db9e:	63e5      	str	r5, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800dba0:	f001 f896 	bl	800ecd0 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 800dba4:	9b01      	ldr	r3, [sp, #4]
 800dba6:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800dba8:	ea4f 03cb 	mov.w	r3, fp, lsl #3
            if( crcOn == true )
 800dbac:	f1b9 0f00 	cmp.w	r9, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800dbb0:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 800dbb2:	f641 0304 	movw	r3, #6148	; 0x1804
 800dbb6:	8263      	strh	r3, [r4, #18]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800dbb8:	bf14      	ite	ne
 800dbba:	23f2      	movne	r3, #242	; 0xf2
 800dbbc:	2301      	moveq	r3, #1
 800dbbe:	75e3      	strb	r3, [r4, #23]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 800dbc0:	f087 0701 	eor.w	r7, r7, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 800dbc4:	2301      	movs	r3, #1
 800dbc6:	7623      	strb	r3, [r4, #24]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800dbc8:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 800dbcc:	f884 a00e 	strb.w	sl, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 800dbd0:	f884 a014 	strb.w	sl, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 800dbd4:	7567      	strb	r7, [r4, #21]
            RadioStandby( );
 800dbd6:	f7ff fb19 	bl	800d20c <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 800dbda:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 800dbde:	3800      	subs	r0, #0
 800dbe0:	bf18      	it	ne
 800dbe2:	2001      	movne	r0, #1
 800dbe4:	f7ff fd9c 	bl	800d720 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800dbe8:	f104 0038 	add.w	r0, r4, #56	; 0x38
 800dbec:	f000 fd74 	bl	800e6d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800dbf0:	f104 000e 	add.w	r0, r4, #14
 800dbf4:	f000 ff0e 	bl	800ea14 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 800dbf8:	4a36      	ldr	r2, [pc, #216]	; (800dcd4 <RadioSetTxConfig+0x178>)
 800dbfa:	6810      	ldr	r0, [r2, #0]
 800dbfc:	6851      	ldr	r1, [r2, #4]
 800dbfe:	ab02      	add	r3, sp, #8
 800dc00:	c303      	stmia	r3!, {r0, r1}
 800dc02:	a802      	add	r0, sp, #8
 800dc04:	f000 fed8 	bl	800e9b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 800dc08:	f240 10ff 	movw	r0, #511	; 0x1ff
 800dc0c:	f000 fe44 	bl	800e898 <SUBGRF_SetWhiteningSeed>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 800dc10:	4640      	mov	r0, r8
 800dc12:	f001 f804 	bl	800ec1e <SUBGRF_SetRfTxPower>
 800dc16:	f884 0056 	strb.w	r0, [r4, #86]	; 0x56
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect ); /* ST_WORKAROUND: ?????? */
 800dc1a:	f001 f8bb 	bl	800ed94 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 800dc1e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800dc20:	6063      	str	r3, [r4, #4]
}
 800dc22:	b005      	add	sp, #20
 800dc24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 800dc28:	492b      	ldr	r1, [pc, #172]	; (800dcd8 <RadioSetTxConfig+0x17c>)
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 800dc2a:	f884 a038 	strb.w	sl, [r4, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 800dc2e:	5d89      	ldrb	r1, [r1, r6]
 800dc30:	f884 1051 	strb.w	r1, [r4, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 800dc34:	b2ea      	uxtb	r2, r5
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 800dc36:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 800dc3a:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 800dc3e:	f884 1052 	strb.w	r1, [r4, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800dc42:	bb56      	cbnz	r6, 800dc9a <RadioSetTxConfig+0x13e>
 800dc44:	3d0b      	subs	r5, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 800dc46:	2d01      	cmp	r5, #1
 800dc48:	bf8c      	ite	hi
 800dc4a:	2500      	movhi	r5, #0
 800dc4c:	2501      	movls	r5, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800dc4e:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 800dc50:	3a05      	subs	r2, #5
 800dc52:	428a      	cmp	r2, r1
 800dc54:	f884 5053 	strb.w	r5, [r4, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800dc58:	73a1      	strb	r1, [r4, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 800dc5a:	d827      	bhi.n	800dcac <RadioSetTxConfig+0x150>
                if( preambleLen < 12 )
 800dc5c:	f1bb 0f0b 	cmp.w	fp, #11
 800dc60:	d824      	bhi.n	800dcac <RadioSetTxConfig+0x150>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 800dc62:	230c      	movs	r3, #12
 800dc64:	83a3      	strh	r3, [r4, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 800dc66:	4b1d      	ldr	r3, [pc, #116]	; (800dcdc <RadioSetTxConfig+0x180>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 800dc68:	77a7      	strb	r7, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 800dc6a:	781b      	ldrb	r3, [r3, #0]
 800dc6c:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 800dc6e:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 800dc72:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 800dc76:	f884 9020 	strb.w	r9, [r4, #32]
            RadioStandby( );
 800dc7a:	f7ff fac7 	bl	800d20c <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 800dc7e:	f894 0038 	ldrb.w	r0, [r4, #56]	; 0x38
 800dc82:	3800      	subs	r0, #0
 800dc84:	bf18      	it	ne
 800dc86:	2001      	movne	r0, #1
 800dc88:	f7ff fd4a 	bl	800d720 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800dc8c:	4814      	ldr	r0, [pc, #80]	; (800dce0 <RadioSetTxConfig+0x184>)
 800dc8e:	f000 fd23 	bl	800e6d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800dc92:	4814      	ldr	r0, [pc, #80]	; (800dce4 <RadioSetTxConfig+0x188>)
 800dc94:	f000 febe 	bl	800ea14 <SUBGRF_SetPacketParams>
            break;
 800dc98:	e7ba      	b.n	800dc10 <RadioSetTxConfig+0xb4>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800dc9a:	2e01      	cmp	r6, #1
 800dc9c:	d104      	bne.n	800dca8 <RadioSetTxConfig+0x14c>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 800dc9e:	f1a5 030c 	sub.w	r3, r5, #12
 800dca2:	425d      	negs	r5, r3
 800dca4:	415d      	adcs	r5, r3
 800dca6:	e7d2      	b.n	800dc4e <RadioSetTxConfig+0xf2>
 800dca8:	2500      	movs	r5, #0
 800dcaa:	e7d0      	b.n	800dc4e <RadioSetTxConfig+0xf2>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 800dcac:	f8a4 b01c 	strh.w	fp, [r4, #28]
 800dcb0:	e7d9      	b.n	800dc66 <RadioSetTxConfig+0x10a>
            RadioSetModem(MODEM_SIGFOX_TX);
 800dcb2:	4650      	mov	r0, sl
 800dcb4:	f7ff fd34 	bl	800d720 <RadioSetModem>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_BPSK;
 800dcb8:	2302      	movs	r3, #2
 800dcba:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800dcbe:	f104 0038 	add.w	r0, r4, #56	; 0x38
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 800dcc2:	2316      	movs	r3, #22
            SubgRf.ModulationParams.Params.Bpsk.BitRate           = datarate;
 800dcc4:	64a5      	str	r5, [r4, #72]	; 0x48
            SubgRf.ModulationParams.Params.Bpsk.ModulationShaping = MOD_SHAPING_DBPSK;
 800dcc6:	f884 304c 	strb.w	r3, [r4, #76]	; 0x4c
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800dcca:	f000 fd05 	bl	800e6d8 <SUBGRF_SetModulationParams>
            break;
 800dcce:	e79f      	b.n	800dc10 <RadioSetTxConfig+0xb4>
 800dcd0:	20001af4 	.word	0x20001af4
 800dcd4:	080103b8 	.word	0x080103b8
 800dcd8:	08010fb0 	.word	0x08010fb0
 800dcdc:	200000d0 	.word	0x200000d0
 800dce0:	20001b2c 	.word	0x20001b2c
 800dce4:	20001b02 	.word	0x20001b02

0800dce8 <RadioSetRxConfig>:
{
 800dce8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dcec:	b087      	sub	sp, #28
    SubgRf.RxContinuous = rxContinuous;
 800dcee:	f8df b2d0 	ldr.w	fp, [pc, #720]	; 800dfc0 <RadioSetRxConfig+0x2d8>
{
 800dcf2:	9301      	str	r3, [sp, #4]
 800dcf4:	4605      	mov	r5, r0
 800dcf6:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 800dcfa:	f89d 0050 	ldrb.w	r0, [sp, #80]	; 0x50
 800dcfe:	f8bd 8048 	ldrh.w	r8, [sp, #72]	; 0x48
 800dd02:	f89d 904c 	ldrb.w	r9, [sp, #76]	; 0x4c
 800dd06:	9003      	str	r0, [sp, #12]
 800dd08:	460f      	mov	r7, r1
 800dd0a:	f89d 1064 	ldrb.w	r1, [sp, #100]	; 0x64
    SubgRf.RxContinuous = rxContinuous;
 800dd0e:	f88b 1001 	strb.w	r1, [fp, #1]
 800dd12:	9102      	str	r1, [sp, #8]
{
 800dd14:	f8bd 6044 	ldrh.w	r6, [sp, #68]	; 0x44
 800dd18:	9300      	str	r3, [sp, #0]
 800dd1a:	4614      	mov	r4, r2
    RFW_DeInit(); /* ST_WORKAROUND: Switch Off FwPacketDecoding by default */
 800dd1c:	f001 f835 	bl	800ed8a <RFW_DeInit>
        symbTimeout = 0;
 800dd20:	9902      	ldr	r1, [sp, #8]
        MaxPayloadLength = 0xFF;
 800dd22:	9803      	ldr	r0, [sp, #12]
        symbTimeout = 0;
 800dd24:	2900      	cmp	r1, #0
 800dd26:	bf18      	it	ne
 800dd28:	f04f 0800 	movne.w	r8, #0
    if( fixLen == true )
 800dd2c:	499e      	ldr	r1, [pc, #632]	; (800dfa8 <RadioSetRxConfig+0x2c0>)
        MaxPayloadLength = 0xFF;
 800dd2e:	f1b9 0f00 	cmp.w	r9, #0
 800dd32:	bf08      	it	eq
 800dd34:	20ff      	moveq	r0, #255	; 0xff
    switch( modem )
 800dd36:	2d01      	cmp	r5, #1
 800dd38:	46da      	mov	sl, fp
 800dd3a:	7008      	strb	r0, [r1, #0]
 800dd3c:	f000 80cc 	beq.w	800ded8 <RadioSetRxConfig+0x1f0>
 800dd40:	2d04      	cmp	r5, #4
 800dd42:	d04c      	beq.n	800ddde <RadioSetRxConfig+0xf6>
 800dd44:	2d00      	cmp	r5, #0
 800dd46:	f040 80c4 	bne.w	800ded2 <RadioSetRxConfig+0x1ea>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 800dd4a:	4628      	mov	r0, r5
 800dd4c:	f000 fb5c 	bl	800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 800dd50:	220b      	movs	r2, #11
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800dd52:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 800dd54:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800dd58:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 800dd5c:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800dd60:	f000 ffb6 	bl	800ecd0 <SUBGRF_GetFskBandwidthRegValue>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800dd64:	9b00      	ldr	r3, [sp, #0]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 800dd66:	4990      	ldr	r1, [pc, #576]	; (800dfa8 <RadioSetRxConfig+0x2c0>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800dd68:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 800dd6c:	f641 0204 	movw	r2, #6148	; 0x1804
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800dd70:	2b00      	cmp	r3, #0
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 800dd72:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 800dd76:	780a      	ldrb	r2, [r1, #0]
 800dd78:	f88b 2016 	strb.w	r2, [fp, #22]
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800dd7c:	bf14      	ite	ne
 800dd7e:	22f2      	movne	r2, #242	; 0xf2
 800dd80:	2201      	moveq	r2, #1
 800dd82:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800dd86:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 800dd88:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 800dd8a:	f089 0901 	eor.w	r9, r9, #1
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 800dd8e:	f88b 2018 	strb.w	r2, [fp, #24]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 800dd92:	f88b 500e 	strb.w	r5, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800dd96:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 800dd9a:	f88b 5014 	strb.w	r5, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 800dd9e:	f88b 9015 	strb.w	r9, [fp, #21]
            RadioStandby( );
 800dda2:	f7ff fa33 	bl	800d20c <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 800dda6:	f89b 0038 	ldrb.w	r0, [fp, #56]	; 0x38
 800ddaa:	3800      	subs	r0, #0
 800ddac:	bf18      	it	ne
 800ddae:	2001      	movne	r0, #1
 800ddb0:	f7ff fcb6 	bl	800d720 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800ddb4:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 800ddb8:	f000 fc8e 	bl	800e6d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800ddbc:	f10b 000e 	add.w	r0, fp, #14
 800ddc0:	f000 fe28 	bl	800ea14 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 800ddc4:	4979      	ldr	r1, [pc, #484]	; (800dfac <RadioSetRxConfig+0x2c4>)
 800ddc6:	6808      	ldr	r0, [r1, #0]
 800ddc8:	6849      	ldr	r1, [r1, #4]
 800ddca:	aa04      	add	r2, sp, #16
 800ddcc:	c203      	stmia	r2!, {r0, r1}
 800ddce:	a804      	add	r0, sp, #16
 800ddd0:	f000 fdf2 	bl	800e9b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 800ddd4:	f240 10ff 	movw	r0, #511	; 0x1ff
 800ddd8:	f000 fd5e 	bl	800e898 <SUBGRF_SetWhiteningSeed>
 800dddc:	e071      	b.n	800dec2 <RadioSetRxConfig+0x1da>
            SUBGRF_SetStopRxTimerOnPreambleDetect( true );
 800ddde:	2001      	movs	r0, #1
 800dde0:	f000 fb12 	bl	800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 800dde4:	2209      	movs	r2, #9
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800dde6:	f04f 0900 	mov.w	r9, #0
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_05;
 800ddea:	f88b 2044 	strb.w	r2, [fp, #68]	; 0x44
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800ddee:	4638      	mov	r0, r7
            SubgRf.ModulationParams.Params.Gfsk.Fdev = 800;
 800ddf0:	f44f 7248 	mov.w	r2, #800	; 0x320
 800ddf4:	f8cb 2040 	str.w	r2, [fp, #64]	; 0x40
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 800ddf8:	f88b 9038 	strb.w	r9, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 800ddfc:	f8cb 403c 	str.w	r4, [fp, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800de00:	f000 ff66 	bl	800ecd0 <SUBGRF_GetFskBandwidthRegValue>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 800de04:	4968      	ldr	r1, [pc, #416]	; (800dfa8 <RadioSetRxConfig+0x2c0>)
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 800de06:	f88b 0045 	strb.w	r0, [fp, #69]	; 0x45
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_OFF;
 800de0a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800de0e:	f8ab 2012 	strh.w	r2, [fp, #18]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 800de12:	780a      	ldrb	r2, [r1, #0]
 800de14:	f88b 2016 	strb.w	r2, [fp, #22]
            RadioSetModem( MODEM_SIGFOX_RX );
 800de18:	4628      	mov	r0, r5
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800de1a:	2201      	movs	r2, #1
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800de1c:	00f6      	lsls	r6, r6, #3
            SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 800de1e:	f88b 2017 	strb.w	r2, [fp, #23]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 800de22:	f88b 900e 	strb.w	r9, [fp, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 800de26:	f8ab 6010 	strh.w	r6, [fp, #16]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 800de2a:	f8ab 9014 	strh.w	r9, [fp, #20]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREE_OFF;
 800de2e:	f88b 9018 	strb.w	r9, [fp, #24]
            RadioSetModem( MODEM_SIGFOX_RX );
 800de32:	f7ff fc75 	bl	800d720 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800de36:	f10b 0038 	add.w	r0, fp, #56	; 0x38
 800de3a:	f000 fc4d 	bl	800e6d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800de3e:	f10b 000e 	add.w	r0, fp, #14
 800de42:	f000 fde7 	bl	800ea14 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){0xB2, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 800de46:	495a      	ldr	r1, [pc, #360]	; (800dfb0 <RadioSetRxConfig+0x2c8>)
 800de48:	6808      	ldr	r0, [r1, #0]
 800de4a:	6849      	ldr	r1, [r1, #4]
 800de4c:	aa04      	add	r2, sp, #16
 800de4e:	c203      	stmia	r2!, {r0, r1}
 800de50:	a804      	add	r0, sp, #16
 800de52:	f000 fdb1 	bl	800e9b8 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 800de56:	f240 10ff 	movw	r0, #511	; 0x1ff
 800de5a:	f000 fd1d 	bl	800e898 <SUBGRF_SetWhiteningSeed>
    return SUBGRF_ReadRegister(addr);
 800de5e:	f640 00b8 	movw	r0, #2232	; 0x8b8
 800de62:	f000 fca5 	bl	800e7b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister(addr, data );
 800de66:	f000 01ef 	and.w	r1, r0, #239	; 0xef
 800de6a:	f640 00b8 	movw	r0, #2232	; 0x8b8
 800de6e:	f000 fbd9 	bl	800e624 <SUBGRF_WriteRegister>
 800de72:	4629      	mov	r1, r5
 800de74:	f640 00b9 	movw	r0, #2233	; 0x8b9
 800de78:	f000 fbd4 	bl	800e624 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 800de7c:	f640 009b 	movw	r0, #2203	; 0x89b
 800de80:	f000 fc96 	bl	800e7b0 <SUBGRF_ReadRegister>
            RadioWrite(0x89b, (modReg| (0x1<<3) ) );
 800de84:	f000 01e3 	and.w	r1, r0, #227	; 0xe3
    SUBGRF_WriteRegister(addr, data );
 800de88:	f041 0108 	orr.w	r1, r1, #8
 800de8c:	f640 009b 	movw	r0, #2203	; 0x89b
 800de90:	f000 fbc8 	bl	800e624 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 800de94:	f240 60d1 	movw	r0, #1745	; 0x6d1
 800de98:	f000 fc8a 	bl	800e7b0 <SUBGRF_ReadRegister>
            RadioWrite(0x6d1, (modReg| (0x3<<3) ));
 800de9c:	f040 0118 	orr.w	r1, r0, #24
    SUBGRF_WriteRegister(addr, data );
 800dea0:	b2c9      	uxtb	r1, r1
 800dea2:	f240 60d1 	movw	r0, #1745	; 0x6d1
 800dea6:	f000 fbbd 	bl	800e624 <SUBGRF_WriteRegister>
    return SUBGRF_ReadRegister(addr);
 800deaa:	f240 60ac 	movw	r0, #1708	; 0x6ac
 800deae:	f000 fc7f 	bl	800e7b0 <SUBGRF_ReadRegister>
            RadioWrite(0x6ac, (modReg| (0x5<<4) ));
 800deb2:	f000 018f 	and.w	r1, r0, #143	; 0x8f
    SUBGRF_WriteRegister(addr, data );
 800deb6:	f041 0150 	orr.w	r1, r1, #80	; 0x50
 800deba:	f240 60ac 	movw	r0, #1708	; 0x6ac
 800debe:	f000 fbb1 	bl	800e624 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 800dec2:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 800dec6:	fb02 f808 	mul.w	r8, r2, r8
 800deca:	fbb8 f4f4 	udiv	r4, r8, r4
 800dece:	f8cb 4008 	str.w	r4, [fp, #8]
}
 800ded2:	b007      	add	sp, #28
 800ded4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 800ded8:	2000      	movs	r0, #0
 800deda:	f000 fa95 	bl	800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 800dede:	4935      	ldr	r1, [pc, #212]	; (800dfb4 <RadioSetRxConfig+0x2cc>)
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 800dee0:	9a01      	ldr	r2, [sp, #4]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 800dee2:	5dc9      	ldrb	r1, [r1, r7]
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 800dee4:	f88b 5038 	strb.w	r5, [fp, #56]	; 0x38
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 800dee8:	b2e3      	uxtb	r3, r4
 800deea:	f88b 3050 	strb.w	r3, [fp, #80]	; 0x50
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 800deee:	f88b 1051 	strb.w	r1, [fp, #81]	; 0x51
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 800def2:	f88b 2052 	strb.w	r2, [fp, #82]	; 0x52
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800def6:	2f00      	cmp	r7, #0
 800def8:	d144      	bne.n	800df84 <RadioSetRxConfig+0x29c>
 800defa:	3c0b      	subs	r4, #11
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 800defc:	2c01      	cmp	r4, #1
 800defe:	bf8c      	ite	hi
 800df00:	2400      	movhi	r4, #0
 800df02:	2401      	movls	r4, #1
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800df04:	2101      	movs	r1, #1
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 800df06:	3b05      	subs	r3, #5
 800df08:	428b      	cmp	r3, r1
 800df0a:	f88a 4053 	strb.w	r4, [sl, #83]	; 0x53
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 800df0e:	f88a 100e 	strb.w	r1, [sl, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 800df12:	d840      	bhi.n	800df96 <RadioSetRxConfig+0x2ae>
                if( preambleLen < 12 )
 800df14:	2e0b      	cmp	r6, #11
 800df16:	d83e      	bhi.n	800df96 <RadioSetRxConfig+0x2ae>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 800df18:	230c      	movs	r3, #12
 800df1a:	f8aa 301c 	strh.w	r3, [sl, #28]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 800df1e:	4b22      	ldr	r3, [pc, #136]	; (800dfa8 <RadioSetRxConfig+0x2c0>)
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 800df20:	f88a 901e 	strb.w	r9, [sl, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 800df24:	781b      	ldrb	r3, [r3, #0]
 800df26:	f88a 301f 	strb.w	r3, [sl, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 800df2a:	9b00      	ldr	r3, [sp, #0]
 800df2c:	f88a 3020 	strb.w	r3, [sl, #32]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 800df30:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
 800df34:	f88a 3021 	strb.w	r3, [sl, #33]	; 0x21
            RadioStandby( );
 800df38:	f7ff f968 	bl	800d20c <RadioStandby>
            RadioSetModem( ( SubgRf.ModulationParams.PacketType == PACKET_TYPE_GFSK ) ? MODEM_FSK : MODEM_LORA );
 800df3c:	f89a 0038 	ldrb.w	r0, [sl, #56]	; 0x38
 800df40:	3800      	subs	r0, #0
 800df42:	bf18      	it	ne
 800df44:	2001      	movne	r0, #1
 800df46:	f7ff fbeb 	bl	800d720 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 800df4a:	481b      	ldr	r0, [pc, #108]	; (800dfb8 <RadioSetRxConfig+0x2d0>)
 800df4c:	f000 fbc4 	bl	800e6d8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800df50:	481a      	ldr	r0, [pc, #104]	; (800dfbc <RadioSetRxConfig+0x2d4>)
 800df52:	f000 fd5f 	bl	800ea14 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 800df56:	fa5f f088 	uxtb.w	r0, r8
 800df5a:	f000 fb8f 	bl	800e67c <SUBGRF_SetLoRaSymbNumTimeout>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 800df5e:	f89a 3021 	ldrb.w	r3, [sl, #33]	; 0x21
 800df62:	2b01      	cmp	r3, #1
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 800df64:	f240 7036 	movw	r0, #1846	; 0x736
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 800df68:	d118      	bne.n	800df9c <RadioSetRxConfig+0x2b4>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) & ~( 1 << 2 ) );
 800df6a:	f000 fc21 	bl	800e7b0 <SUBGRF_ReadRegister>
 800df6e:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 800df72:	f240 7036 	movw	r0, #1846	; 0x736
 800df76:	f000 fb55 	bl	800e624 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 800df7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800df7e:	f8ca 3008 	str.w	r3, [sl, #8]
}
 800df82:	e7a6      	b.n	800ded2 <RadioSetRxConfig+0x1ea>
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 800df84:	2f01      	cmp	r7, #1
 800df86:	d104      	bne.n	800df92 <RadioSetRxConfig+0x2aa>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 800df88:	f1a4 020c 	sub.w	r2, r4, #12
 800df8c:	4254      	negs	r4, r2
 800df8e:	4154      	adcs	r4, r2
 800df90:	e7b8      	b.n	800df04 <RadioSetRxConfig+0x21c>
 800df92:	2400      	movs	r4, #0
 800df94:	e7b6      	b.n	800df04 <RadioSetRxConfig+0x21c>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 800df96:	f8aa 601c 	strh.w	r6, [sl, #28]
 800df9a:	e7c0      	b.n	800df1e <RadioSetRxConfig+0x236>
                SUBGRF_WriteRegister( 0x0736, SUBGRF_ReadRegister( 0x0736 ) | ( 1 << 2 ) );
 800df9c:	f000 fc08 	bl	800e7b0 <SUBGRF_ReadRegister>
 800dfa0:	f040 0104 	orr.w	r1, r0, #4
 800dfa4:	b2c9      	uxtb	r1, r1
 800dfa6:	e7e4      	b.n	800df72 <RadioSetRxConfig+0x28a>
 800dfa8:	200000d0 	.word	0x200000d0
 800dfac:	080103b8 	.word	0x080103b8
 800dfb0:	080103c0 	.word	0x080103c0
 800dfb4:	08010fb0 	.word	0x08010fb0
 800dfb8:	20001b2c 	.word	0x20001b2c
 800dfbc:	20001b02 	.word	0x20001b02
 800dfc0:	20001af4 	.word	0x20001af4

0800dfc4 <RadioRandom>:
{
 800dfc4:	b508      	push	{r3, lr}
    RadioSetModem( MODEM_LORA );
 800dfc6:	2001      	movs	r0, #1
 800dfc8:	f7ff fbaa 	bl	800d720 <RadioSetModem>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 800dfcc:	2300      	movs	r3, #0
 800dfce:	461a      	mov	r2, r3
 800dfd0:	4619      	mov	r1, r3
 800dfd2:	4618      	mov	r0, r3
 800dfd4:	f000 fa88 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
}
 800dfd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    rnd = SUBGRF_GetRandom();
 800dfdc:	f000 bd8e 	b.w	800eafc <SUBGRF_GetRandom>

0800dfe0 <RadioIsChannelFree>:
{
 800dfe0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800dfe2:	b08b      	sub	sp, #44	; 0x2c
 800dfe4:	460d      	mov	r5, r1
 800dfe6:	4604      	mov	r4, r0
 800dfe8:	4617      	mov	r7, r2
 800dfea:	461e      	mov	r6, r3
    RadioStandby( );
 800dfec:	f7ff f90e 	bl	800d20c <RadioStandby>
    RadioSetModem( MODEM_FSK );
 800dff0:	2000      	movs	r0, #0
 800dff2:	f7ff fb95 	bl	800d720 <RadioSetModem>
    SUBGRF_SetRfFrequency( freq );
 800dff6:	4620      	mov	r0, r4
 800dff8:	f000 faa0 	bl	800e53c <SUBGRF_SetRfFrequency>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 800dffc:	2400      	movs	r4, #0
 800dffe:	2301      	movs	r3, #1
 800e000:	e9cd 4308 	strd	r4, r3, [sp, #32]
 800e004:	2303      	movs	r3, #3
 800e006:	f44f 7216 	mov.w	r2, #600	; 0x258
 800e00a:	4629      	mov	r1, r5
 800e00c:	4620      	mov	r0, r4
 800e00e:	e9cd 4406 	strd	r4, r4, [sp, #24]
 800e012:	e9cd 4404 	strd	r4, r4, [sp, #16]
 800e016:	e9cd 4402 	strd	r4, r4, [sp, #8]
 800e01a:	e9cd 5300 	strd	r5, r3, [sp]
 800e01e:	4623      	mov	r3, r4
 800e020:	f7ff fe62 	bl	800dce8 <RadioSetRxConfig>
    RadioRx( 0 );
 800e024:	4620      	mov	r0, r4
 800e026:	f7ff fb2f 	bl	800d688 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 800e02a:	f7ff fa29 	bl	800d480 <RadioGetWakeupTime>
 800e02e:	f7f3 fa53 	bl	80014d8 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 800e032:	f001 fa61 	bl	800f4f8 <UTIL_TIMER_GetCurrentTime>
 800e036:	4604      	mov	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 800e038:	4620      	mov	r0, r4
 800e03a:	f001 fa67 	bl	800f50c <UTIL_TIMER_GetElapsedTime>
 800e03e:	42b0      	cmp	r0, r6
 800e040:	d305      	bcc.n	800e04e <RadioIsChannelFree+0x6e>
    bool status = true;
 800e042:	2401      	movs	r4, #1
    RadioStandby( );
 800e044:	f7ff f8e2 	bl	800d20c <RadioStandby>
}
 800e048:	4620      	mov	r0, r4
 800e04a:	b00b      	add	sp, #44	; 0x2c
 800e04c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return SUBGRF_GetRssiInst( );
 800e04e:	f000 faa0 	bl	800e592 <SUBGRF_GetRssiInst>
        if( rssi > rssiThresh )
 800e052:	b200      	sxth	r0, r0
 800e054:	4287      	cmp	r7, r0
 800e056:	daef      	bge.n	800e038 <RadioIsChannelFree+0x58>
            status = false;
 800e058:	2400      	movs	r4, #0
 800e05a:	e7f3      	b.n	800e044 <RadioIsChannelFree+0x64>

0800e05c <RadioInit>:
    RadioEvents = events;
 800e05c:	4b1e      	ldr	r3, [pc, #120]	; (800e0d8 <RadioInit+0x7c>)
{
 800e05e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    RadioEvents = events;
 800e060:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 800e062:	4b1e      	ldr	r3, [pc, #120]	; (800e0dc <RadioInit+0x80>)
    SUBGRF_Init( RadioOnDioIrq );
 800e064:	481e      	ldr	r0, [pc, #120]	; (800e0e0 <RadioInit+0x84>)
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 800e066:	4e1f      	ldr	r6, [pc, #124]	; (800e0e4 <RadioInit+0x88>)
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 800e068:	4d1f      	ldr	r5, [pc, #124]	; (800e0e8 <RadioInit+0x8c>)
    SubgRf.RxContinuous = false;
 800e06a:	2400      	movs	r4, #0
    SubgRf.RxTimeout = 0;
 800e06c:	e9c3 4401 	strd	r4, r4, [r3, #4]
    SubgRf.RxContinuous = false;
 800e070:	705c      	strb	r4, [r3, #1]
    SUBGRF_Init( RadioOnDioIrq );
 800e072:	f000 fbc1 	bl	800e7f8 <SUBGRF_Init>
    RadioSetPublicNetwork( false );
 800e076:	4620      	mov	r0, r4
 800e078:	f7ff fb34 	bl	800d6e4 <RadioSetPublicNetwork>
    SUBGRF_SetRegulatorMode(  );
 800e07c:	f000 f9d0 	bl	800e420 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 800e080:	4621      	mov	r1, r4
 800e082:	4620      	mov	r0, r4
 800e084:	f000 fa78 	bl	800e578 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams(RFO_LP, 0, RADIO_RAMP_200_US);
 800e088:	4621      	mov	r1, r4
 800e08a:	2204      	movs	r2, #4
 800e08c:	2001      	movs	r0, #1
 800e08e:	f000 fc1f 	bl	800e8d0 <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 800e092:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800e096:	4623      	mov	r3, r4
 800e098:	4622      	mov	r2, r4
 800e09a:	4608      	mov	r0, r1
 800e09c:	f000 fa24 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 800e0a0:	f7ff fa2e 	bl	800d500 <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 800e0a4:	4622      	mov	r2, r4
 800e0a6:	4b11      	ldr	r3, [pc, #68]	; (800e0ec <RadioInit+0x90>)
 800e0a8:	9400      	str	r4, [sp, #0]
 800e0aa:	f04f 31ff 	mov.w	r1, #4294967295
 800e0ae:	4630      	mov	r0, r6
 800e0b0:	f001 fa08 	bl	800f4c4 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 800e0b4:	4b0e      	ldr	r3, [pc, #56]	; (800e0f0 <RadioInit+0x94>)
 800e0b6:	9400      	str	r4, [sp, #0]
 800e0b8:	4622      	mov	r2, r4
 800e0ba:	f04f 31ff 	mov.w	r1, #4294967295
 800e0be:	4628      	mov	r0, r5
 800e0c0:	f001 fa00 	bl	800f4c4 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 800e0c4:	4630      	mov	r0, r6
 800e0c6:	f001 fa5b 	bl	800f580 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 800e0ca:	4628      	mov	r0, r5
}
 800e0cc:	b002      	add	sp, #8
 800e0ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    TimerStop( &RxTimeoutTimer );
 800e0d2:	f001 ba55 	b.w	800f580 <UTIL_TIMER_Stop>
 800e0d6:	bf00      	nop
 800e0d8:	20001204 	.word	0x20001204
 800e0dc:	20001af4 	.word	0x20001af4
 800e0e0:	0800d471 	.word	0x0800d471
 800e0e4:	20001b4c 	.word	0x20001b4c
 800e0e8:	20001b64 	.word	0x20001b64
 800e0ec:	0800d1a5 	.word	0x0800d1a5
 800e0f0:	0800d1b9 	.word	0x0800d1b9

0800e0f4 <RadioSend>:
{
 800e0f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 800e0f6:	2300      	movs	r3, #0
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 800e0f8:	4d65      	ldr	r5, [pc, #404]	; (800e290 <RadioSend+0x19c>)
{
 800e0fa:	460c      	mov	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 800e0fc:	f240 2101 	movw	r1, #513	; 0x201
 800e100:	461a      	mov	r2, r3
{
 800e102:	4606      	mov	r6, r0
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 800e104:	4608      	mov	r0, r1
 800e106:	f000 f9ef 	bl	800e4e8 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch(SubgRf.AntSwitchPaSelect, RFSWITCH_TX);
 800e10a:	f895 0056 	ldrb.w	r0, [r5, #86]	; 0x56
 800e10e:	2101      	movs	r1, #1
 800e110:	f000 fd6f 	bl	800ebf2 <SUBGRF_SetSwitch>
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 800e114:	782b      	ldrb	r3, [r5, #0]
 800e116:	2b01      	cmp	r3, #1
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 800e118:	f640 0089 	movw	r0, #2185	; 0x889
    if((SubgRf.Modem==MODEM_LORA) && (SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ))
 800e11c:	d112      	bne.n	800e144 <RadioSend+0x50>
 800e11e:	f895 3051 	ldrb.w	r3, [r5, #81]	; 0x51
 800e122:	2b06      	cmp	r3, #6
 800e124:	d10e      	bne.n	800e144 <RadioSend+0x50>
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) & ~( 1 << 2 ) );
 800e126:	f000 fb43 	bl	800e7b0 <SUBGRF_ReadRegister>
 800e12a:	f000 01fb 	and.w	r1, r0, #251	; 0xfb
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 800e12e:	f640 0089 	movw	r0, #2185	; 0x889
 800e132:	f000 fa77 	bl	800e624 <SUBGRF_WriteRegister>
    switch(SubgRf.Modem)
 800e136:	782b      	ldrb	r3, [r5, #0]
 800e138:	2b03      	cmp	r3, #3
 800e13a:	d86d      	bhi.n	800e218 <RadioSend+0x124>
 800e13c:	e8df f003 	tbb	[pc, r3]
 800e140:	087e4c53 	.word	0x087e4c53
        SUBGRF_WriteRegister( 0x0889, SUBGRF_ReadRegister( 0x0889 ) | ( 1 << 2 ) );
 800e144:	f000 fb34 	bl	800e7b0 <SUBGRF_ReadRegister>
 800e148:	f040 0104 	orr.w	r1, r0, #4
 800e14c:	b2c9      	uxtb	r1, r1
 800e14e:	e7ee      	b.n	800e12e <RadioSend+0x3a>
 800e150:	4a50      	ldr	r2, [pc, #320]	; (800e294 <RadioSend+0x1a0>)
 800e152:	1e73      	subs	r3, r6, #1
 800e154:	4610      	mov	r0, r2
    for (i = 0; i < size; i++)
 800e156:	f1c6 0701 	rsb	r7, r6, #1
        outBuffer[i] = 0;
 800e15a:	f04f 0c00 	mov.w	ip, #0
    for (i = 0; i < size; i++)
 800e15e:	18f9      	adds	r1, r7, r3
 800e160:	428c      	cmp	r4, r1
 800e162:	dc6f      	bgt.n	800e244 <RadioSend+0x150>
    for (i = 0; i < (size * 8); i++)
 800e164:	2300      	movs	r3, #0
 800e166:	00e7      	lsls	r7, r4, #3
    uint8_t prevInt = 0;
 800e168:	4619      	mov	r1, r3
    for (i = 0; i < (size * 8); i++)
 800e16a:	42bb      	cmp	r3, r7
 800e16c:	d171      	bne.n	800e252 <RadioSend+0x15e>
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 800e16e:	2900      	cmp	r1, #0
 800e170:	ea4f 1381 	mov.w	r3, r1, lsl #6
 800e174:	bf0c      	ite	eq
 800e176:	2220      	moveq	r2, #32
 800e178:	2200      	movne	r2, #0
 800e17a:	ea43 13c1 	orr.w	r3, r3, r1, lsl #7
 800e17e:	4313      	orrs	r3, r2
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 800e180:	1c66      	adds	r6, r4, #1
    outBuffer[size] = ( prevInt << 7 ) | ( prevInt << 6 ) | ( ( ( !prevInt ) & 0x01 ) << 5 ) ;
 800e182:	5503      	strb	r3, [r0, r4]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 800e184:	b2f6      	uxtb	r6, r6
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 800e186:	2302      	movs	r3, #2
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e188:	4843      	ldr	r0, [pc, #268]	; (800e298 <RadioSend+0x1a4>)
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 800e18a:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size + 1;
 800e18c:	76ae      	strb	r6, [r5, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e18e:	f000 fc41 	bl	800ea14 <SUBGRF_SetPacketParams>
    SUBGRF_WriteRegister(addr, data );
 800e192:	2100      	movs	r1, #0
 800e194:	20f1      	movs	r0, #241	; 0xf1
 800e196:	f000 fa45 	bl	800e624 <SUBGRF_WriteRegister>
 800e19a:	2100      	movs	r1, #0
 800e19c:	20f0      	movs	r0, #240	; 0xf0
 800e19e:	f000 fa41 	bl	800e624 <SUBGRF_WriteRegister>
            if( SubgRf.ModulationParams.Params.Bpsk.BitRate == 100 )
 800e1a2:	6cab      	ldr	r3, [r5, #72]	; 0x48
 800e1a4:	2b64      	cmp	r3, #100	; 0x64
 800e1a6:	d16d      	bne.n	800e284 <RadioSend+0x190>
    SUBGRF_WriteRegister(addr, data );
 800e1a8:	2170      	movs	r1, #112	; 0x70
 800e1aa:	20f3      	movs	r0, #243	; 0xf3
 800e1ac:	f000 fa3a 	bl	800e624 <SUBGRF_WriteRegister>
 800e1b0:	211d      	movs	r1, #29
 800e1b2:	20f2      	movs	r0, #242	; 0xf2
 800e1b4:	f000 fa36 	bl	800e624 <SUBGRF_WriteRegister>
            uint16_t bitNum = ( size * 8 ) + 2;
 800e1b8:	00e1      	lsls	r1, r4, #3
 800e1ba:	1c8c      	adds	r4, r1, #2
    SUBGRF_WriteRegister(addr, data );
 800e1bc:	20f4      	movs	r0, #244	; 0xf4
 800e1be:	0a09      	lsrs	r1, r1, #8
 800e1c0:	f000 fa30 	bl	800e624 <SUBGRF_WriteRegister>
 800e1c4:	f004 01fe 	and.w	r1, r4, #254	; 0xfe
 800e1c8:	20f5      	movs	r0, #245	; 0xf5
 800e1ca:	f000 fa2b 	bl	800e624 <SUBGRF_WriteRegister>
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 800e1ce:	4831      	ldr	r0, [pc, #196]	; (800e294 <RadioSend+0x1a0>)
 800e1d0:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 800e1d4:	4631      	mov	r1, r6
 800e1d6:	e01d      	b.n	800e214 <RadioSend+0x120>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 800e1d8:	77ec      	strb	r4, [r5, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e1da:	482f      	ldr	r0, [pc, #188]	; (800e298 <RadioSend+0x1a4>)
 800e1dc:	f000 fc1a 	bl	800ea14 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 800e1e0:	2200      	movs	r2, #0
 800e1e2:	4621      	mov	r1, r4
 800e1e4:	e015      	b.n	800e212 <RadioSend+0x11e>
            if ( 1UL == RFW_Is_Init( ) )
 800e1e6:	f000 fdd1 	bl	800ed8c <RFW_Is_Init>
 800e1ea:	2801      	cmp	r0, #1
 800e1ec:	4607      	mov	r7, r0
 800e1ee:	d123      	bne.n	800e238 <RadioSend+0x144>
              if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 800e1f0:	4621      	mov	r1, r4
 800e1f2:	f10d 0207 	add.w	r2, sp, #7
 800e1f6:	4630      	mov	r0, r6
 800e1f8:	f000 fdcd 	bl	800ed96 <RFW_TransmitInit>
 800e1fc:	4604      	mov	r4, r0
 800e1fe:	b998      	cbnz	r0, 800e228 <RadioSend+0x134>
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 800e200:	f89d 3007 	ldrb.w	r3, [sp, #7]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e204:	4824      	ldr	r0, [pc, #144]	; (800e298 <RadioSend+0x1a4>)
                  SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 800e206:	75ab      	strb	r3, [r5, #22]
                  SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e208:	f000 fc04 	bl	800ea14 <SUBGRF_SetPacketParams>
                  SUBGRF_SendPayload( buffer, outsize, 0 );
 800e20c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800e210:	4622      	mov	r2, r4
            SUBGRF_SendPayload( buffer, size, 0 );
 800e212:	4630      	mov	r0, r6
            SUBGRF_SendPayload( RadioBuffer, size+1 , 0xFFFFFF );
 800e214:	f000 fcbb 	bl	800eb8e <SUBGRF_SendPayload>
    TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 800e218:	6869      	ldr	r1, [r5, #4]
 800e21a:	4820      	ldr	r0, [pc, #128]	; (800e29c <RadioSend+0x1a8>)
 800e21c:	f001 fa3a 	bl	800f694 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 800e220:	481e      	ldr	r0, [pc, #120]	; (800e29c <RadioSend+0x1a8>)
 800e222:	f001 f9fd 	bl	800f620 <UTIL_TIMER_Start>
 800e226:	e005      	b.n	800e234 <RadioSend+0x140>
                MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n");
 800e228:	4b1d      	ldr	r3, [pc, #116]	; (800e2a0 <RadioSend+0x1ac>)
 800e22a:	463a      	mov	r2, r7
 800e22c:	2100      	movs	r1, #0
 800e22e:	2002      	movs	r0, #2
 800e230:	f000 fe6a 	bl	800ef08 <UTIL_ADV_TRACE_COND_FSend>
}
 800e234:	b003      	add	sp, #12
 800e236:	bdf0      	pop	{r4, r5, r6, r7, pc}
              SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 800e238:	75ac      	strb	r4, [r5, #22]
              SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 800e23a:	e7ce      	b.n	800e1da <RadioSend+0xe6>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 800e23c:	2302      	movs	r3, #2
 800e23e:	73ab      	strb	r3, [r5, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 800e240:	76ac      	strb	r4, [r5, #26]
 800e242:	e7ca      	b.n	800e1da <RadioSend+0xe6>
        inBuffer[i] = ~inBuffer[i];
 800e244:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 800e248:	43c9      	mvns	r1, r1
 800e24a:	7019      	strb	r1, [r3, #0]
        outBuffer[i] = 0;
 800e24c:	f802 cb01 	strb.w	ip, [r2], #1
    for (i = 0; i < size; i++)
 800e250:	e785      	b.n	800e15e <RadioSend+0x6a>
        index_bit = 7 - ( i % 8 );
 800e252:	43da      	mvns	r2, r3
 800e254:	f002 0c07 	and.w	ip, r2, #7
        index_byte = i / 8;
 800e258:	10da      	asrs	r2, r3, #3
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 800e25a:	3301      	adds	r3, #1
        currBit = ( inBuffer[index_byte] >> index_bit ) & 0x01;
 800e25c:	5cb2      	ldrb	r2, [r6, r2]
 800e25e:	fa42 f20c 	asr.w	r2, r2, ip
 800e262:	f002 0201 	and.w	r2, r2, #1
        index_byte_out = ( i + 1 ) / 8;
 800e266:	ea4f 0ce3 	mov.w	ip, r3, asr #3
        prevInt ^= currBit;
 800e26a:	4051      	eors	r1, r2
        index_bit_out = 7 - ( ( i + 1 ) % 8 );
 800e26c:	43da      	mvns	r2, r3
        outBuffer[index_byte_out] |= ( prevInt << index_bit_out );
 800e26e:	f810 e00c 	ldrb.w	lr, [r0, ip]
 800e272:	f002 0207 	and.w	r2, r2, #7
 800e276:	fa01 f202 	lsl.w	r2, r1, r2
 800e27a:	ea42 020e 	orr.w	r2, r2, lr
 800e27e:	f800 200c 	strb.w	r2, [r0, ip]
    for (i = 0; i < (size * 8); i++)
 800e282:	e772      	b.n	800e16a <RadioSend+0x76>
    SUBGRF_WriteRegister(addr, data );
 800e284:	21e1      	movs	r1, #225	; 0xe1
 800e286:	20f3      	movs	r0, #243	; 0xf3
 800e288:	f000 f9cc 	bl	800e624 <SUBGRF_WriteRegister>
 800e28c:	2104      	movs	r1, #4
 800e28e:	e790      	b.n	800e1b2 <RadioSend+0xbe>
 800e290:	20001af4 	.word	0x20001af4
 800e294:	20001104 	.word	0x20001104
 800e298:	20001b02 	.word	0x20001b02
 800e29c:	20001b4c 	.word	0x20001b4c
 800e2a0:	08010f9b 	.word	0x08010f9b

0800e2a4 <RadioTxPrbs>:
{
 800e2a4:	b508      	push	{r3, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 800e2a6:	4b09      	ldr	r3, [pc, #36]	; (800e2cc <RadioTxPrbs+0x28>)
 800e2a8:	2101      	movs	r1, #1
 800e2aa:	f893 0056 	ldrb.w	r0, [r3, #86]	; 0x56
 800e2ae:	f000 fca0 	bl	800ebf2 <SUBGRF_SetSwitch>
    SUBGRF_WriteRegister(addr, data );
 800e2b2:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 800e2b6:	212d      	movs	r1, #45	; 0x2d
 800e2b8:	f000 f9b4 	bl	800e624 <SUBGRF_WriteRegister>
    SUBGRF_SetTxInfinitePreamble( );
 800e2bc:	f000 f89f 	bl	800e3fe <SUBGRF_SetTxInfinitePreamble>
}
 800e2c0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SUBGRF_SetTx( 0x0fffff );
 800e2c4:	4802      	ldr	r0, [pc, #8]	; (800e2d0 <RadioTxPrbs+0x2c>)
 800e2c6:	f000 b841 	b.w	800e34c <SUBGRF_SetTx>
 800e2ca:	bf00      	nop
 800e2cc:	20001af4 	.word	0x20001af4
 800e2d0:	000fffff 	.word	0x000fffff

0800e2d4 <SUBGRF_WriteCommand>:
    CRITICAL_SECTION_END();
}

void SUBGRF_WriteCommand( SUBGHZ_RadioSetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 800e2d4:	b510      	push	{r4, lr}
 800e2d6:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e2d8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800e2dc:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 800e2de:	460a      	mov	r2, r1
 800e2e0:	4601      	mov	r1, r0
 800e2e2:	4803      	ldr	r0, [pc, #12]	; (800e2f0 <SUBGRF_WriteCommand+0x1c>)
 800e2e4:	f7f7 f824 	bl	8005330 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e2e8:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 800e2ec:	bd10      	pop	{r4, pc}
 800e2ee:	bf00      	nop
 800e2f0:	200019c8 	.word	0x200019c8

0800e2f4 <SUBGRF_ReadCommand>:

void SUBGRF_ReadCommand( SUBGHZ_RadioGetCmd_t Command, uint8_t *pBuffer,
                                        uint16_t Size )
{
 800e2f4:	b510      	push	{r4, lr}
 800e2f6:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e2f8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800e2fc:	b672      	cpsid	i
    CRITICAL_SECTION_BEGIN();
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 800e2fe:	460a      	mov	r2, r1
 800e300:	4601      	mov	r1, r0
 800e302:	4803      	ldr	r0, [pc, #12]	; (800e310 <SUBGRF_ReadCommand+0x1c>)
 800e304:	f7f7 f8b6 	bl	8005474 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e308:	f384 8810 	msr	PRIMASK, r4
    CRITICAL_SECTION_END();
}
 800e30c:	bd10      	pop	{r4, pc}
 800e30e:	bf00      	nop
 800e310:	200019c8 	.word	0x200019c8

0800e314 <SUBGRF_GetOperatingMode>:
}
 800e314:	4b01      	ldr	r3, [pc, #4]	; (800e31c <SUBGRF_GetOperatingMode+0x8>)
 800e316:	7818      	ldrb	r0, [r3, #0]
 800e318:	4770      	bx	lr
 800e31a:	bf00      	nop
 800e31c:	2000120e 	.word	0x2000120e

0800e320 <SUBGRF_SetStandby>:
{
 800e320:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 800e322:	2201      	movs	r2, #1
{
 800e324:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 800e328:	f10d 0107 	add.w	r1, sp, #7
 800e32c:	2080      	movs	r0, #128	; 0x80
 800e32e:	f7ff ffd1 	bl	800e2d4 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 800e332:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800e336:	2b00      	cmp	r3, #0
 800e338:	4b03      	ldr	r3, [pc, #12]	; (800e348 <SUBGRF_SetStandby+0x28>)
        OperatingMode = MODE_STDBY_XOSC;
 800e33a:	bf0c      	ite	eq
 800e33c:	2201      	moveq	r2, #1
 800e33e:	2202      	movne	r2, #2
 800e340:	701a      	strb	r2, [r3, #0]
}
 800e342:	b003      	add	sp, #12
 800e344:	f85d fb04 	ldr.w	pc, [sp], #4
 800e348:	2000120e 	.word	0x2000120e

0800e34c <SUBGRF_SetTx>:
{
 800e34c:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_TX;
 800e34e:	4b09      	ldr	r3, [pc, #36]	; (800e374 <SUBGRF_SetTx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 800e350:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_TX;
 800e354:	2204      	movs	r2, #4
 800e356:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 800e358:	0c03      	lsrs	r3, r0, #16
 800e35a:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 800e35e:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e360:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 800e362:	a901      	add	r1, sp, #4
 800e364:	2083      	movs	r0, #131	; 0x83
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e366:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 800e36a:	f7ff ffb3 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e36e:	b003      	add	sp, #12
 800e370:	f85d fb04 	ldr.w	pc, [sp], #4
 800e374:	2000120e 	.word	0x2000120e

0800e378 <SUBGRF_SetRx>:
{
 800e378:	b507      	push	{r0, r1, r2, lr}
    OperatingMode = MODE_RX;
 800e37a:	4b09      	ldr	r3, [pc, #36]	; (800e3a0 <SUBGRF_SetRx+0x28>)
    buf[2] = ( uint8_t )( timeout & 0xFF );
 800e37c:	f88d 0006 	strb.w	r0, [sp, #6]
    OperatingMode = MODE_RX;
 800e380:	2205      	movs	r2, #5
 800e382:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 800e384:	0c03      	lsrs	r3, r0, #16
 800e386:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e38a:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e38c:	0a03      	lsrs	r3, r0, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e38e:	a901      	add	r1, sp, #4
 800e390:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e392:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e396:	f7ff ff9d 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e39a:	b003      	add	sp, #12
 800e39c:	f85d fb04 	ldr.w	pc, [sp], #4
 800e3a0:	2000120e 	.word	0x2000120e

0800e3a4 <SUBGRF_SetRxDutyCycle>:
{
 800e3a4:	b507      	push	{r0, r1, r2, lr}
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 800e3a6:	0c03      	lsrs	r3, r0, #16
 800e3a8:	f88d 3000 	strb.w	r3, [sp]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 800e3ac:	0a03      	lsrs	r3, r0, #8
 800e3ae:	f88d 3001 	strb.w	r3, [sp, #1]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 800e3b2:	0c0b      	lsrs	r3, r1, #16
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 800e3b4:	ba49      	rev16	r1, r1
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 800e3b6:	f88d 0002 	strb.w	r0, [sp, #2]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 800e3ba:	f8ad 1004 	strh.w	r1, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 800e3be:	2206      	movs	r2, #6
 800e3c0:	4669      	mov	r1, sp
 800e3c2:	2094      	movs	r0, #148	; 0x94
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 800e3c4:	f88d 3003 	strb.w	r3, [sp, #3]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 800e3c8:	f7ff ff84 	bl	800e2d4 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 800e3cc:	4b02      	ldr	r3, [pc, #8]	; (800e3d8 <SUBGRF_SetRxDutyCycle+0x34>)
 800e3ce:	2206      	movs	r2, #6
 800e3d0:	701a      	strb	r2, [r3, #0]
}
 800e3d2:	b003      	add	sp, #12
 800e3d4:	f85d fb04 	ldr.w	pc, [sp], #4
 800e3d8:	2000120e 	.word	0x2000120e

0800e3dc <SUBGRF_SetCad>:
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 800e3dc:	2200      	movs	r2, #0
{
 800e3de:	b508      	push	{r3, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 800e3e0:	4611      	mov	r1, r2
 800e3e2:	20c5      	movs	r0, #197	; 0xc5
 800e3e4:	f7ff ff76 	bl	800e2d4 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 800e3e8:	4b01      	ldr	r3, [pc, #4]	; (800e3f0 <SUBGRF_SetCad+0x14>)
 800e3ea:	2207      	movs	r2, #7
 800e3ec:	701a      	strb	r2, [r3, #0]
}
 800e3ee:	bd08      	pop	{r3, pc}
 800e3f0:	2000120e 	.word	0x2000120e

0800e3f4 <SUBGRF_SetTxContinuousWave>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 800e3f4:	2200      	movs	r2, #0
 800e3f6:	4611      	mov	r1, r2
 800e3f8:	20d1      	movs	r0, #209	; 0xd1
 800e3fa:	f7ff bf6b 	b.w	800e2d4 <SUBGRF_WriteCommand>

0800e3fe <SUBGRF_SetTxInfinitePreamble>:
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 800e3fe:	2200      	movs	r2, #0
 800e400:	4611      	mov	r1, r2
 800e402:	20d2      	movs	r0, #210	; 0xd2
 800e404:	f7ff bf66 	b.w	800e2d4 <SUBGRF_WriteCommand>

0800e408 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 800e408:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 800e40a:	2201      	movs	r2, #1
{
 800e40c:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 800e410:	f10d 0107 	add.w	r1, sp, #7
 800e414:	209f      	movs	r0, #159	; 0x9f
 800e416:	f7ff ff5d 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e41a:	b003      	add	sp, #12
 800e41c:	f85d fb04 	ldr.w	pc, [sp], #4

0800e420 <SUBGRF_SetRegulatorMode>:
{
 800e420:	b507      	push	{r0, r1, r2, lr}
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 800e422:	f7f3 ff03 	bl	800222c <RBI_IsDCDC>
 800e426:	1e43      	subs	r3, r0, #1
 800e428:	4258      	negs	r0, r3
 800e42a:	4158      	adcs	r0, r3
 800e42c:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 800e430:	2201      	movs	r2, #1
 800e432:	f10d 0107 	add.w	r1, sp, #7
 800e436:	2096      	movs	r0, #150	; 0x96
 800e438:	f7ff ff4c 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e43c:	b003      	add	sp, #12
 800e43e:	f85d fb04 	ldr.w	pc, [sp], #4

0800e442 <SUBGRF_Calibrate>:
{
 800e442:	b507      	push	{r0, r1, r2, lr}
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 800e444:	f000 007f 	and.w	r0, r0, #127	; 0x7f
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 800e448:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 800e44c:	2201      	movs	r2, #1
 800e44e:	f10d 0107 	add.w	r1, sp, #7
 800e452:	2089      	movs	r0, #137	; 0x89
 800e454:	f7ff ff3e 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e458:	b003      	add	sp, #12
 800e45a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800e460 <SUBGRF_CalibrateImage>:
    if( freq > 900000000 )
 800e460:	4b13      	ldr	r3, [pc, #76]	; (800e4b0 <SUBGRF_CalibrateImage+0x50>)
 800e462:	4298      	cmp	r0, r3
{
 800e464:	b507      	push	{r0, r1, r2, lr}
    if( freq > 900000000 )
 800e466:	d90b      	bls.n	800e480 <SUBGRF_CalibrateImage+0x20>
        calFreq[0] = 0xE1;
 800e468:	f64e 13e1 	movw	r3, #59873	; 0xe9e1
        calFreq[0] = 0x6B;
 800e46c:	f8ad 3004 	strh.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 800e470:	2202      	movs	r2, #2
 800e472:	a901      	add	r1, sp, #4
 800e474:	2098      	movs	r0, #152	; 0x98
 800e476:	f7ff ff2d 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e47a:	b003      	add	sp, #12
 800e47c:	f85d fb04 	ldr.w	pc, [sp], #4
    else if( freq > 850000000 )
 800e480:	4b0c      	ldr	r3, [pc, #48]	; (800e4b4 <SUBGRF_CalibrateImage+0x54>)
 800e482:	4298      	cmp	r0, r3
 800e484:	d902      	bls.n	800e48c <SUBGRF_CalibrateImage+0x2c>
        calFreq[0] = 0xD7;
 800e486:	f64d 33d7 	movw	r3, #56279	; 0xdbd7
 800e48a:	e7ef      	b.n	800e46c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 770000000 )
 800e48c:	4b0a      	ldr	r3, [pc, #40]	; (800e4b8 <SUBGRF_CalibrateImage+0x58>)
 800e48e:	4298      	cmp	r0, r3
 800e490:	d902      	bls.n	800e498 <SUBGRF_CalibrateImage+0x38>
        calFreq[0] = 0xC1;
 800e492:	f24c 53c1 	movw	r3, #50625	; 0xc5c1
 800e496:	e7e9      	b.n	800e46c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 460000000 )
 800e498:	4b08      	ldr	r3, [pc, #32]	; (800e4bc <SUBGRF_CalibrateImage+0x5c>)
 800e49a:	4298      	cmp	r0, r3
 800e49c:	d902      	bls.n	800e4a4 <SUBGRF_CalibrateImage+0x44>
        calFreq[0] = 0x75;
 800e49e:	f248 1375 	movw	r3, #33141	; 0x8175
 800e4a2:	e7e3      	b.n	800e46c <SUBGRF_CalibrateImage+0xc>
    else if( freq > 425000000 )
 800e4a4:	4b06      	ldr	r3, [pc, #24]	; (800e4c0 <SUBGRF_CalibrateImage+0x60>)
 800e4a6:	4298      	cmp	r0, r3
 800e4a8:	d9e2      	bls.n	800e470 <SUBGRF_CalibrateImage+0x10>
        calFreq[0] = 0x6B;
 800e4aa:	f646 736b 	movw	r3, #28523	; 0x6f6b
 800e4ae:	e7dd      	b.n	800e46c <SUBGRF_CalibrateImage+0xc>
 800e4b0:	35a4e900 	.word	0x35a4e900
 800e4b4:	32a9f880 	.word	0x32a9f880
 800e4b8:	2de54480 	.word	0x2de54480
 800e4bc:	1b6b0b00 	.word	0x1b6b0b00
 800e4c0:	1954fc40 	.word	0x1954fc40

0800e4c4 <SUBGRF_SetPaConfig>:
{
 800e4c4:	b507      	push	{r0, r1, r2, lr}
    buf[2] = deviceSel;
 800e4c6:	f88d 2006 	strb.w	r2, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 800e4ca:	2204      	movs	r2, #4
    buf[0] = paDutyCycle;
 800e4cc:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = hpMax;
 800e4d0:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 800e4d4:	2095      	movs	r0, #149	; 0x95
 800e4d6:	eb0d 0102 	add.w	r1, sp, r2
    buf[3] = paLut;
 800e4da:	f88d 3007 	strb.w	r3, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 800e4de:	f7ff fef9 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e4e2:	b003      	add	sp, #12
 800e4e4:	f85d fb04 	ldr.w	pc, [sp], #4

0800e4e8 <SUBGRF_SetDioIrqParams>:
{
 800e4e8:	b507      	push	{r0, r1, r2, lr}
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 800e4ea:	ba52      	rev16	r2, r2
 800e4ec:	f8ad 2004 	strh.w	r2, [sp, #4]
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 800e4f0:	ba40      	rev16	r0, r0
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 800e4f2:	2208      	movs	r2, #8
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 800e4f4:	ba49      	rev16	r1, r1
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 800e4f6:	f8ad 0000 	strh.w	r0, [sp]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 800e4fa:	f8ad 1002 	strh.w	r1, [sp, #2]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 800e4fe:	ba5b      	rev16	r3, r3
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 800e500:	4669      	mov	r1, sp
 800e502:	4610      	mov	r0, r2
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 800e504:	f8ad 3006 	strh.w	r3, [sp, #6]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 800e508:	f7ff fee4 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e50c:	b003      	add	sp, #12
 800e50e:	f85d fb04 	ldr.w	pc, [sp], #4

0800e512 <SUBGRF_SetTcxoMode>:
{
 800e512:	b507      	push	{r0, r1, r2, lr}
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 800e514:	0c0b      	lsrs	r3, r1, #16
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 800e516:	2204      	movs	r2, #4
    buf[0] = tcxoVoltage & 0x07;
 800e518:	f000 0007 	and.w	r0, r0, #7
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e51c:	ba49      	rev16	r1, r1
    buf[0] = tcxoVoltage & 0x07;
 800e51e:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e522:	f8ad 1006 	strh.w	r1, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 800e526:	2097      	movs	r0, #151	; 0x97
 800e528:	eb0d 0102 	add.w	r1, sp, r2
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 800e52c:	f88d 3005 	strb.w	r3, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 800e530:	f7ff fed0 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e534:	b003      	add	sp, #12
 800e536:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800e53c <SUBGRF_SetRfFrequency>:
{
 800e53c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    if( ImageCalibrated == false )
 800e53e:	4d0c      	ldr	r5, [pc, #48]	; (800e570 <SUBGRF_SetRfFrequency+0x34>)
 800e540:	782b      	ldrb	r3, [r5, #0]
{
 800e542:	4604      	mov	r4, r0
    if( ImageCalibrated == false )
 800e544:	b91b      	cbnz	r3, 800e54e <SUBGRF_SetRfFrequency+0x12>
        SUBGRF_CalibrateImage( frequency );
 800e546:	f7ff ff8b 	bl	800e460 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 800e54a:	2301      	movs	r3, #1
 800e54c:	702b      	strb	r3, [r5, #0]
    SX_FREQ_TO_CHANNEL(chan, frequency);   
 800e54e:	2300      	movs	r3, #0
 800e550:	4a08      	ldr	r2, [pc, #32]	; (800e574 <SUBGRF_SetRfFrequency+0x38>)
 800e552:	0660      	lsls	r0, r4, #25
 800e554:	09e1      	lsrs	r1, r4, #7
 800e556:	f7f2 fa2b 	bl	80009b0 <__aeabi_uldivmod>
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 800e55a:	2204      	movs	r2, #4
 800e55c:	ba00      	rev	r0, r0
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 800e55e:	9001      	str	r0, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 800e560:	eb0d 0102 	add.w	r1, sp, r2
 800e564:	2086      	movs	r0, #134	; 0x86
 800e566:	f7ff feb5 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e56a:	b003      	add	sp, #12
 800e56c:	bd30      	pop	{r4, r5, pc}
 800e56e:	bf00      	nop
 800e570:	2000120c 	.word	0x2000120c
 800e574:	01e84800 	.word	0x01e84800

0800e578 <SUBGRF_SetBufferBaseAddress>:
{
 800e578:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 800e57a:	2202      	movs	r2, #2
    buf[0] = txBaseAddress;
 800e57c:	f88d 0004 	strb.w	r0, [sp, #4]
    buf[1] = rxBaseAddress;
 800e580:	f88d 1005 	strb.w	r1, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 800e584:	208f      	movs	r0, #143	; 0x8f
 800e586:	a901      	add	r1, sp, #4
 800e588:	f7ff fea4 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e58c:	b003      	add	sp, #12
 800e58e:	f85d fb04 	ldr.w	pc, [sp], #4

0800e592 <SUBGRF_GetRssiInst>:
{
 800e592:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 800e594:	2201      	movs	r2, #1
 800e596:	a901      	add	r1, sp, #4
 800e598:	2015      	movs	r0, #21
 800e59a:	f7ff feab 	bl	800e2f4 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 800e59e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800e5a2:	4240      	negs	r0, r0
}
 800e5a4:	1040      	asrs	r0, r0, #1
 800e5a6:	b003      	add	sp, #12
 800e5a8:	f85d fb04 	ldr.w	pc, [sp], #4

0800e5ac <SUBGRF_GetPacketStatus>:
{
 800e5ac:	b513      	push	{r0, r1, r4, lr}
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 800e5ae:	2203      	movs	r2, #3
{
 800e5b0:	4604      	mov	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 800e5b2:	a901      	add	r1, sp, #4
 800e5b4:	2014      	movs	r0, #20
 800e5b6:	f7ff fe9d 	bl	800e2f4 <SUBGRF_ReadCommand>
    return PacketType;
 800e5ba:	4b18      	ldr	r3, [pc, #96]	; (800e61c <SUBGRF_GetPacketStatus+0x70>)
 800e5bc:	781a      	ldrb	r2, [r3, #0]
    pktStatus->packetType = SUBGRF_GetPacketType( );
 800e5be:	7022      	strb	r2, [r4, #0]
    switch( pktStatus->packetType )
 800e5c0:	b14a      	cbz	r2, 800e5d6 <SUBGRF_GetPacketStatus+0x2a>
 800e5c2:	2a01      	cmp	r2, #1
 800e5c4:	d017      	beq.n	800e5f6 <SUBGRF_GetPacketStatus+0x4a>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 800e5c6:	2214      	movs	r2, #20
 800e5c8:	2100      	movs	r1, #0
 800e5ca:	4620      	mov	r0, r4
 800e5cc:	f000 fdb0 	bl	800f130 <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 800e5d0:	230f      	movs	r3, #15
 800e5d2:	7023      	strb	r3, [r4, #0]
}
 800e5d4:	e00d      	b.n	800e5f2 <SUBGRF_GetPacketStatus+0x46>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 800e5d6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800e5da:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 800e5dc:	f89d 3005 	ldrb.w	r3, [sp, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 800e5e0:	60a2      	str	r2, [r4, #8]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 800e5e2:	425b      	negs	r3, r3
 800e5e4:	105b      	asrs	r3, r3, #1
 800e5e6:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 800e5e8:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800e5ec:	425b      	negs	r3, r3
 800e5ee:	105b      	asrs	r3, r3, #1
 800e5f0:	7163      	strb	r3, [r4, #5]
}
 800e5f2:	b002      	add	sp, #8
 800e5f4:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 800e5f6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800e5fa:	425b      	negs	r3, r3
 800e5fc:	105b      	asrs	r3, r3, #1
 800e5fe:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 800e600:	f99d 3005 	ldrsb.w	r3, [sp, #5]
 800e604:	3302      	adds	r3, #2
 800e606:	109b      	asrs	r3, r3, #2
 800e608:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 800e60a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800e60e:	425b      	negs	r3, r3
 800e610:	105b      	asrs	r3, r3, #1
 800e612:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 800e614:	4b02      	ldr	r3, [pc, #8]	; (800e620 <SUBGRF_GetPacketStatus+0x74>)
 800e616:	681b      	ldr	r3, [r3, #0]
 800e618:	6123      	str	r3, [r4, #16]
            break;
 800e61a:	e7ea      	b.n	800e5f2 <SUBGRF_GetPacketStatus+0x46>
 800e61c:	2000120f 	.word	0x2000120f
 800e620:	20001208 	.word	0x20001208

0800e624 <SUBGRF_WriteRegister>:
{
 800e624:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 800e626:	2301      	movs	r3, #1
{
 800e628:	f88d 1007 	strb.w	r1, [sp, #7]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 800e62c:	f10d 0207 	add.w	r2, sp, #7
 800e630:	4601      	mov	r1, r0
 800e632:	4803      	ldr	r0, [pc, #12]	; (800e640 <SUBGRF_WriteRegister+0x1c>)
 800e634:	f7f6 fe08 	bl	8005248 <HAL_SUBGHZ_WriteRegisters>
}
 800e638:	b003      	add	sp, #12
 800e63a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e63e:	bf00      	nop
 800e640:	200019c8 	.word	0x200019c8

0800e644 <SUBGRF_SetRxBoosted>:
{
 800e644:	b513      	push	{r0, r1, r4, lr}
    OperatingMode = MODE_RX;
 800e646:	4b0c      	ldr	r3, [pc, #48]	; (800e678 <SUBGRF_SetRxBoosted+0x34>)
{
 800e648:	4604      	mov	r4, r0
    OperatingMode = MODE_RX;
 800e64a:	2205      	movs	r2, #5
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 800e64c:	2197      	movs	r1, #151	; 0x97
 800e64e:	f640 00ac 	movw	r0, #2220	; 0x8ac
    OperatingMode = MODE_RX;
 800e652:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 800e654:	f7ff ffe6 	bl	800e624 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 800e658:	0c23      	lsrs	r3, r4, #16
 800e65a:	f88d 3004 	strb.w	r3, [sp, #4]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e65e:	2203      	movs	r2, #3
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e660:	0a23      	lsrs	r3, r4, #8
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e662:	a901      	add	r1, sp, #4
 800e664:	2082      	movs	r0, #130	; 0x82
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 800e666:	f88d 3005 	strb.w	r3, [sp, #5]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 800e66a:	f88d 4006 	strb.w	r4, [sp, #6]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 800e66e:	f7ff fe31 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e672:	b002      	add	sp, #8
 800e674:	bd10      	pop	{r4, pc}
 800e676:	bf00      	nop
 800e678:	2000120e 	.word	0x2000120e

0800e67c <SUBGRF_SetLoRaSymbNumTimeout>:
{
 800e67c:	b507      	push	{r0, r1, r2, lr}
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 800e67e:	2201      	movs	r2, #1
{
 800e680:	f88d 0007 	strb.w	r0, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 800e684:	f10d 0107 	add.w	r1, sp, #7
 800e688:	20a0      	movs	r0, #160	; 0xa0
 800e68a:	f7ff fe23 	bl	800e2d4 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 800e68e:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800e692:	293f      	cmp	r1, #63	; 0x3f
 800e694:	d907      	bls.n	800e6a6 <SUBGRF_SetLoRaSymbNumTimeout+0x2a>
        reg = exp + ( mant << 3 );
 800e696:	f001 01f8 	and.w	r1, r1, #248	; 0xf8
 800e69a:	3101      	adds	r1, #1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 800e69c:	b2c9      	uxtb	r1, r1
 800e69e:	f240 7006 	movw	r0, #1798	; 0x706
 800e6a2:	f7ff ffbf 	bl	800e624 <SUBGRF_WriteRegister>
}
 800e6a6:	b003      	add	sp, #12
 800e6a8:	f85d fb04 	ldr.w	pc, [sp], #4

0800e6ac <SUBGRF_SetPacketType>:
{
 800e6ac:	b507      	push	{r0, r1, r2, lr}
    PacketType = packetType;
 800e6ae:	4b09      	ldr	r3, [pc, #36]	; (800e6d4 <SUBGRF_SetPacketType+0x28>)
{
 800e6b0:	f88d 0007 	strb.w	r0, [sp, #7]
 800e6b4:	4601      	mov	r1, r0
    PacketType = packetType;
 800e6b6:	7018      	strb	r0, [r3, #0]
    if( packetType == PACKET_TYPE_GFSK )
 800e6b8:	b918      	cbnz	r0, 800e6c2 <SUBGRF_SetPacketType+0x16>
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 800e6ba:	f240 60ac 	movw	r0, #1708	; 0x6ac
 800e6be:	f7ff ffb1 	bl	800e624 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 800e6c2:	2201      	movs	r2, #1
 800e6c4:	f10d 0107 	add.w	r1, sp, #7
 800e6c8:	208a      	movs	r0, #138	; 0x8a
 800e6ca:	f7ff fe03 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e6ce:	b003      	add	sp, #12
 800e6d0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6d4:	2000120f 	.word	0x2000120f

0800e6d8 <SUBGRF_SetModulationParams>:
{
 800e6d8:	b513      	push	{r0, r1, r4, lr}
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 800e6da:	4a31      	ldr	r2, [pc, #196]	; (800e7a0 <SUBGRF_SetModulationParams+0xc8>)
{
 800e6dc:	4604      	mov	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 800e6de:	6851      	ldr	r1, [r2, #4]
 800e6e0:	6810      	ldr	r0, [r2, #0]
 800e6e2:	466b      	mov	r3, sp
 800e6e4:	c303      	stmia	r3!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 800e6e6:	4b2f      	ldr	r3, [pc, #188]	; (800e7a4 <SUBGRF_SetModulationParams+0xcc>)
 800e6e8:	7820      	ldrb	r0, [r4, #0]
 800e6ea:	781b      	ldrb	r3, [r3, #0]
 800e6ec:	4283      	cmp	r3, r0
 800e6ee:	d001      	beq.n	800e6f4 <SUBGRF_SetModulationParams+0x1c>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 800e6f0:	f7ff ffdc 	bl	800e6ac <SUBGRF_SetPacketType>
    switch( modulationParams->PacketType )
 800e6f4:	7823      	ldrb	r3, [r4, #0]
 800e6f6:	2b03      	cmp	r3, #3
 800e6f8:	d827      	bhi.n	800e74a <SUBGRF_SetModulationParams+0x72>
 800e6fa:	e8df f003 	tbb	[pc, r3]
 800e6fe:	3902      	.short	0x3902
 800e700:	3c28      	.short	0x3c28
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 800e702:	6862      	ldr	r2, [r4, #4]
 800e704:	4b28      	ldr	r3, [pc, #160]	; (800e7a8 <SUBGRF_SetModulationParams+0xd0>)
 800e706:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 800e70a:	0c1a      	lsrs	r2, r3, #16
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 800e70c:	68a1      	ldr	r1, [r4, #8]
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 800e70e:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 800e712:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e716:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 800e718:	7b23      	ldrb	r3, [r4, #12]
 800e71a:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 800e71e:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e720:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 800e724:	f88d 3004 	strb.w	r3, [sp, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 800e728:	4a20      	ldr	r2, [pc, #128]	; (800e7ac <SUBGRF_SetModulationParams+0xd4>)
 800e72a:	2300      	movs	r3, #0
 800e72c:	0648      	lsls	r0, r1, #25
 800e72e:	09c9      	lsrs	r1, r1, #7
 800e730:	f7f2 f93e 	bl	80009b0 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 800e734:	0c03      	lsrs	r3, r0, #16
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 800e736:	ba40      	rev16	r0, r0
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 800e738:	f88d 3005 	strb.w	r3, [sp, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 800e73c:	f8ad 0006 	strh.w	r0, [sp, #6]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 800e740:	2208      	movs	r2, #8
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 800e742:	4669      	mov	r1, sp
 800e744:	208b      	movs	r0, #139	; 0x8b
 800e746:	f7ff fdc5 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e74a:	b002      	add	sp, #8
 800e74c:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 800e74e:	6922      	ldr	r2, [r4, #16]
 800e750:	4b15      	ldr	r3, [pc, #84]	; (800e7a8 <SUBGRF_SetModulationParams+0xd0>)
 800e752:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 800e756:	0c1a      	lsrs	r2, r3, #16
 800e758:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 800e75c:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e760:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 800e762:	7d23      	ldrb	r3, [r4, #20]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e764:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 800e768:	f88d 3003 	strb.w	r3, [sp, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 800e76c:	2204      	movs	r2, #4
 800e76e:	e7e8      	b.n	800e742 <SUBGRF_SetModulationParams+0x6a>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 800e770:	69a3      	ldr	r3, [r4, #24]
 800e772:	9300      	str	r3, [sp, #0]
 800e774:	e7fa      	b.n	800e76c <SUBGRF_SetModulationParams+0x94>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 800e776:	6862      	ldr	r2, [r4, #4]
 800e778:	4b0b      	ldr	r3, [pc, #44]	; (800e7a8 <SUBGRF_SetModulationParams+0xd0>)
 800e77a:	fbb3 f3f2 	udiv	r3, r3, r2
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 800e77e:	0c1a      	lsrs	r2, r3, #16
 800e780:	f88d 2000 	strb.w	r2, [sp]
        buf[2] = tempVal & 0xFF;
 800e784:	f88d 3002 	strb.w	r3, [sp, #2]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e788:	0a1a      	lsrs	r2, r3, #8
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 800e78a:	7b23      	ldrb	r3, [r4, #12]
 800e78c:	f88d 3003 	strb.w	r3, [sp, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 800e790:	7b63      	ldrb	r3, [r4, #13]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 800e792:	f88d 2001 	strb.w	r2, [sp, #1]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 800e796:	f88d 3004 	strb.w	r3, [sp, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 800e79a:	2205      	movs	r2, #5
 800e79c:	e7d1      	b.n	800e742 <SUBGRF_SetModulationParams+0x6a>
 800e79e:	bf00      	nop
 800e7a0:	080103c8 	.word	0x080103c8
 800e7a4:	2000120f 	.word	0x2000120f
 800e7a8:	3d090000 	.word	0x3d090000
 800e7ac:	01e84800 	.word	0x01e84800

0800e7b0 <SUBGRF_ReadRegister>:
{
 800e7b0:	b507      	push	{r0, r1, r2, lr}
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 800e7b2:	2301      	movs	r3, #1
{
 800e7b4:	4601      	mov	r1, r0
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 800e7b6:	f10d 0207 	add.w	r2, sp, #7
 800e7ba:	4804      	ldr	r0, [pc, #16]	; (800e7cc <SUBGRF_ReadRegister+0x1c>)
 800e7bc:	f7f6 fd7d 	bl	80052ba <HAL_SUBGHZ_ReadRegisters>
}
 800e7c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800e7c4:	b003      	add	sp, #12
 800e7c6:	f85d fb04 	ldr.w	pc, [sp], #4
 800e7ca:	bf00      	nop
 800e7cc:	200019c8 	.word	0x200019c8

0800e7d0 <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
}

static void Radio_SMPS_Set(uint8_t level)
{
 800e7d0:	b510      	push	{r4, lr}
 800e7d2:	4604      	mov	r4, r0
  if ( 1U == RBI_IsDCDC() )
 800e7d4:	f7f3 fd2a 	bl	800222c <RBI_IsDCDC>
 800e7d8:	2801      	cmp	r0, #1
 800e7da:	d10c      	bne.n	800e7f6 <Radio_SMPS_Set+0x26>
  {
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 800e7dc:	f640 1023 	movw	r0, #2339	; 0x923
 800e7e0:	f7ff ffe6 	bl	800e7b0 <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 800e7e4:	f000 01f9 	and.w	r1, r0, #249	; 0xf9
 800e7e8:	4321      	orrs	r1, r4
 800e7ea:	f640 1023 	movw	r0, #2339	; 0x923
  }
}
 800e7ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 800e7f2:	f7ff bf17 	b.w	800e624 <SUBGRF_WriteRegister>
}
 800e7f6:	bd10      	pop	{r4, pc}

0800e7f8 <SUBGRF_Init>:
{
 800e7f8:	b510      	push	{r4, lr}
    if ( dioIrq != NULL)
 800e7fa:	b108      	cbz	r0, 800e800 <SUBGRF_Init+0x8>
        RadioOnDioIrqCb = dioIrq;
 800e7fc:	4b16      	ldr	r3, [pc, #88]	; (800e858 <SUBGRF_Init+0x60>)
 800e7fe:	6018      	str	r0, [r3, #0]
    RADIO_INIT();
 800e800:	f7f2 fd48 	bl	8001294 <MX_SUBGHZ_Init>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 800e804:	2002      	movs	r0, #2
 800e806:	f7ff ffe3 	bl	800e7d0 <Radio_SMPS_Set>
    ImageCalibrated = false;
 800e80a:	2400      	movs	r4, #0
 800e80c:	4b13      	ldr	r3, [pc, #76]	; (800e85c <SUBGRF_Init+0x64>)
    SUBGRF_SetStandby( STDBY_RC );
 800e80e:	4620      	mov	r0, r4
    ImageCalibrated = false;
 800e810:	701c      	strb	r4, [r3, #0]
    SUBGRF_SetStandby( STDBY_RC );
 800e812:	f7ff fd85 	bl	800e320 <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 800e816:	f7f3 fd07 	bl	8002228 <RBI_IsTCXO>
 800e81a:	2801      	cmp	r0, #1
 800e81c:	d111      	bne.n	800e842 <SUBGRF_Init+0x4a>
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 800e81e:	2140      	movs	r1, #64	; 0x40
 800e820:	f7ff fe77 	bl	800e512 <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 800e824:	f640 1011 	movw	r0, #2321	; 0x911
 800e828:	4621      	mov	r1, r4
 800e82a:	f7ff fefb 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 800e82e:	f04f 007f 	mov.w	r0, #127	; 0x7f
 800e832:	f7ff fe06 	bl	800e442 <SUBGRF_Calibrate>
    RBI_Init();
 800e836:	f7f3 fcf1 	bl	800221c <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 800e83a:	4b09      	ldr	r3, [pc, #36]	; (800e860 <SUBGRF_Init+0x68>)
 800e83c:	2201      	movs	r2, #1
 800e83e:	701a      	strb	r2, [r3, #0]
}
 800e840:	bd10      	pop	{r4, pc}
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 800e842:	2120      	movs	r1, #32
 800e844:	f640 1011 	movw	r0, #2321	; 0x911
 800e848:	f7ff feec 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 800e84c:	2120      	movs	r1, #32
 800e84e:	f640 1012 	movw	r0, #2322	; 0x912
 800e852:	f7ff fee7 	bl	800e624 <SUBGRF_WriteRegister>
 800e856:	e7ee      	b.n	800e836 <SUBGRF_Init+0x3e>
 800e858:	20001210 	.word	0x20001210
 800e85c:	2000120c 	.word	0x2000120c
 800e860:	2000120e 	.word	0x2000120e

0800e864 <SUBGRF_SetSleep>:
{
 800e864:	b513      	push	{r0, r1, r4, lr}
 800e866:	4604      	mov	r4, r0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 800e868:	2000      	movs	r0, #0
 800e86a:	f7f3 fcd9 	bl	8002220 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 800e86e:	2002      	movs	r0, #2
 800e870:	f7ff ffae 	bl	800e7d0 <Radio_SMPS_Set>
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 800e874:	f004 0407 	and.w	r4, r4, #7
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 800e878:	2201      	movs	r2, #1
 800e87a:	f10d 0107 	add.w	r1, sp, #7
 800e87e:	2084      	movs	r0, #132	; 0x84
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 800e880:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 800e884:	f7ff fd26 	bl	800e2d4 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 800e888:	4b02      	ldr	r3, [pc, #8]	; (800e894 <SUBGRF_SetSleep+0x30>)
 800e88a:	2200      	movs	r2, #0
 800e88c:	701a      	strb	r2, [r3, #0]
}
 800e88e:	b002      	add	sp, #8
 800e890:	bd10      	pop	{r4, pc}
 800e892:	bf00      	nop
 800e894:	2000120e 	.word	0x2000120e

0800e898 <SUBGRF_SetWhiteningSeed>:
{
 800e898:	b510      	push	{r4, lr}
    return PacketType;
 800e89a:	4b0c      	ldr	r3, [pc, #48]	; (800e8cc <SUBGRF_SetWhiteningSeed+0x34>)
    switch( SUBGRF_GetPacketType( ) )
 800e89c:	781b      	ldrb	r3, [r3, #0]
{
 800e89e:	4604      	mov	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 800e8a0:	b99b      	cbnz	r3, 800e8ca <SUBGRF_SetWhiteningSeed+0x32>
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 800e8a2:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 800e8a6:	f7ff ff83 	bl	800e7b0 <SUBGRF_ReadRegister>
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 800e8aa:	f3c4 2100 	ubfx	r1, r4, #8, #1
 800e8ae:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 800e8b2:	4301      	orrs	r1, r0
 800e8b4:	f44f 60d7 	mov.w	r0, #1720	; 0x6b8
 800e8b8:	f7ff feb4 	bl	800e624 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 800e8bc:	b2e1      	uxtb	r1, r4
 800e8be:	f240 60b9 	movw	r0, #1721	; 0x6b9
}
 800e8c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 800e8c6:	f7ff bead 	b.w	800e624 <SUBGRF_WriteRegister>
}
 800e8ca:	bd10      	pop	{r4, pc}
 800e8cc:	2000120f 	.word	0x2000120f

0800e8d0 <SUBGRF_SetTxParams>:
    if( paSelect == RFO_LP )
 800e8d0:	2801      	cmp	r0, #1
{
 800e8d2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800e8d4:	4603      	mov	r3, r0
 800e8d6:	460c      	mov	r4, r1
 800e8d8:	4615      	mov	r5, r2
    if( paSelect == RFO_LP )
 800e8da:	d120      	bne.n	800e91e <SUBGRF_SetTxParams+0x4e>
        if( power == 15 )
 800e8dc:	2c0f      	cmp	r4, #15
            SUBGRF_SetPaConfig( 0x06, 0x00, 0x01, 0x01 );
 800e8de:	4602      	mov	r2, r0
 800e8e0:	f04f 0100 	mov.w	r1, #0
 800e8e4:	bf0c      	ite	eq
 800e8e6:	2006      	moveq	r0, #6
            SUBGRF_SetPaConfig( 0x04, 0x00, 0x01, 0x01 );
 800e8e8:	2004      	movne	r0, #4
 800e8ea:	f7ff fdeb 	bl	800e4c4 <SUBGRF_SetPaConfig>
        if( power >= 14 )
 800e8ee:	f06f 0110 	mvn.w	r1, #16
 800e8f2:	428c      	cmp	r4, r1
 800e8f4:	bfb8      	it	lt
 800e8f6:	460c      	movlt	r4, r1
 800e8f8:	2c0e      	cmp	r4, #14
 800e8fa:	bfa8      	it	ge
 800e8fc:	240e      	movge	r4, #14
        SUBGRF_WriteRegister( REG_OCP, 0x18 ); // current max is 80 mA for the whole device
 800e8fe:	2118      	movs	r1, #24
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 800e900:	f640 00e7 	movw	r0, #2279	; 0x8e7
 800e904:	f7ff fe8e 	bl	800e624 <SUBGRF_WriteRegister>
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 800e908:	2202      	movs	r2, #2
 800e90a:	a901      	add	r1, sp, #4
 800e90c:	208e      	movs	r0, #142	; 0x8e
    buf[0] = power;
 800e90e:	f88d 4004 	strb.w	r4, [sp, #4]
    buf[1] = ( uint8_t )rampTime;
 800e912:	f88d 5005 	strb.w	r5, [sp, #5]
    SUBGRF_WriteCommand( RADIO_SET_TXPARAMS, buf, 2 );
 800e916:	f7ff fcdd 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800e91a:	b003      	add	sp, #12
 800e91c:	bd30      	pop	{r4, r5, pc}
        SUBGRF_WriteRegister( REG_TX_CLAMP, SUBGRF_ReadRegister( REG_TX_CLAMP ) | ( 0x0F << 1 ) );
 800e91e:	f640 00d8 	movw	r0, #2264	; 0x8d8
 800e922:	f7ff ff45 	bl	800e7b0 <SUBGRF_ReadRegister>
 800e926:	f040 011e 	orr.w	r1, r0, #30
 800e92a:	b2c9      	uxtb	r1, r1
 800e92c:	f640 00d8 	movw	r0, #2264	; 0x8d8
 800e930:	f7ff fe78 	bl	800e624 <SUBGRF_WriteRegister>
        SUBGRF_SetPaConfig( 0x04, 0x07, 0x00, 0x01 );
 800e934:	2107      	movs	r1, #7
 800e936:	2301      	movs	r3, #1
 800e938:	2200      	movs	r2, #0
 800e93a:	2004      	movs	r0, #4
 800e93c:	f7ff fdc2 	bl	800e4c4 <SUBGRF_SetPaConfig>
        if( power > 22 )
 800e940:	f06f 0108 	mvn.w	r1, #8
 800e944:	428c      	cmp	r4, r1
 800e946:	bfb8      	it	lt
 800e948:	460c      	movlt	r4, r1
 800e94a:	2c16      	cmp	r4, #22
 800e94c:	bfa8      	it	ge
 800e94e:	2416      	movge	r4, #22
        SUBGRF_WriteRegister( REG_OCP, 0x38 ); // current max 160mA for the whole device
 800e950:	2138      	movs	r1, #56	; 0x38
 800e952:	e7d5      	b.n	800e900 <SUBGRF_SetTxParams+0x30>

0800e954 <SUBGRF_GetRxBufferStatus>:
{
 800e954:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800e956:	4604      	mov	r4, r0
 800e958:	460d      	mov	r5, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 800e95a:	2202      	movs	r2, #2
 800e95c:	a901      	add	r1, sp, #4
 800e95e:	2013      	movs	r0, #19
 800e960:	f7ff fcc8 	bl	800e2f4 <SUBGRF_ReadCommand>
    return PacketType;
 800e964:	4b0a      	ldr	r3, [pc, #40]	; (800e990 <SUBGRF_GetRxBufferStatus+0x3c>)
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 800e966:	781b      	ldrb	r3, [r3, #0]
 800e968:	2b01      	cmp	r3, #1
 800e96a:	d10d      	bne.n	800e988 <SUBGRF_GetRxBufferStatus+0x34>
 800e96c:	4b09      	ldr	r3, [pc, #36]	; (800e994 <SUBGRF_GetRxBufferStatus+0x40>)
 800e96e:	781b      	ldrb	r3, [r3, #0]
 800e970:	2b01      	cmp	r3, #1
 800e972:	d109      	bne.n	800e988 <SUBGRF_GetRxBufferStatus+0x34>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 800e974:	f240 7002 	movw	r0, #1794	; 0x702
 800e978:	f7ff ff1a 	bl	800e7b0 <SUBGRF_ReadRegister>
 800e97c:	7020      	strb	r0, [r4, #0]
    *rxStartBufferPointer = status[1];
 800e97e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800e982:	702b      	strb	r3, [r5, #0]
}
 800e984:	b003      	add	sp, #12
 800e986:	bd30      	pop	{r4, r5, pc}
        *payloadLength = status[0];
 800e988:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800e98c:	7023      	strb	r3, [r4, #0]
 800e98e:	e7f6      	b.n	800e97e <SUBGRF_GetRxBufferStatus+0x2a>
 800e990:	2000120f 	.word	0x2000120f
 800e994:	2000120d 	.word	0x2000120d

0800e998 <SUBGRF_WriteRegisters>:
{
 800e998:	b510      	push	{r4, lr}
 800e99a:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800e99c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800e9a0:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 800e9a2:	460a      	mov	r2, r1
 800e9a4:	4601      	mov	r1, r0
 800e9a6:	4803      	ldr	r0, [pc, #12]	; (800e9b4 <SUBGRF_WriteRegisters+0x1c>)
 800e9a8:	f7f6 fc4e 	bl	8005248 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800e9ac:	f384 8810 	msr	PRIMASK, r4
}
 800e9b0:	bd10      	pop	{r4, pc}
 800e9b2:	bf00      	nop
 800e9b4:	200019c8 	.word	0x200019c8

0800e9b8 <SUBGRF_SetSyncWord>:
{
 800e9b8:	b508      	push	{r3, lr}
 800e9ba:	4601      	mov	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 800e9bc:	2208      	movs	r2, #8
 800e9be:	f44f 60d8 	mov.w	r0, #1728	; 0x6c0
 800e9c2:	f7ff ffe9 	bl	800e998 <SUBGRF_WriteRegisters>
}
 800e9c6:	2000      	movs	r0, #0
 800e9c8:	bd08      	pop	{r3, pc}
	...

0800e9cc <SUBGRF_SetCrcSeed>:
{
 800e9cc:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 800e9ce:	4b07      	ldr	r3, [pc, #28]	; (800e9ec <SUBGRF_SetCrcSeed+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 800e9d0:	781b      	ldrb	r3, [r3, #0]
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 800e9d2:	ba40      	rev16	r0, r0
 800e9d4:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 800e9d8:	b92b      	cbnz	r3, 800e9e6 <SUBGRF_SetCrcSeed+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 800e9da:	2202      	movs	r2, #2
 800e9dc:	a901      	add	r1, sp, #4
 800e9de:	f240 60bc 	movw	r0, #1724	; 0x6bc
 800e9e2:	f7ff ffd9 	bl	800e998 <SUBGRF_WriteRegisters>
}
 800e9e6:	b003      	add	sp, #12
 800e9e8:	f85d fb04 	ldr.w	pc, [sp], #4
 800e9ec:	2000120f 	.word	0x2000120f

0800e9f0 <SUBGRF_SetCrcPolynomial>:
{
 800e9f0:	b507      	push	{r0, r1, r2, lr}
    return PacketType;
 800e9f2:	4b07      	ldr	r3, [pc, #28]	; (800ea10 <SUBGRF_SetCrcPolynomial+0x20>)
    switch( SUBGRF_GetPacketType( ) )
 800e9f4:	781b      	ldrb	r3, [r3, #0]
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 800e9f6:	ba40      	rev16	r0, r0
 800e9f8:	f8ad 0004 	strh.w	r0, [sp, #4]
    switch( SUBGRF_GetPacketType( ) )
 800e9fc:	b92b      	cbnz	r3, 800ea0a <SUBGRF_SetCrcPolynomial+0x1a>
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 800e9fe:	2202      	movs	r2, #2
 800ea00:	a901      	add	r1, sp, #4
 800ea02:	f240 60be 	movw	r0, #1726	; 0x6be
 800ea06:	f7ff ffc7 	bl	800e998 <SUBGRF_WriteRegisters>
}
 800ea0a:	b003      	add	sp, #12
 800ea0c:	f85d fb04 	ldr.w	pc, [sp], #4
 800ea10:	2000120f 	.word	0x2000120f

0800ea14 <SUBGRF_SetPacketParams>:
{
 800ea14:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 800ea16:	4a2e      	ldr	r2, [pc, #184]	; (800ead0 <SUBGRF_SetPacketParams+0xbc>)
{
 800ea18:	4604      	mov	r4, r0
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 800ea1a:	6851      	ldr	r1, [r2, #4]
 800ea1c:	6810      	ldr	r0, [r2, #0]
 800ea1e:	7a12      	ldrb	r2, [r2, #8]
 800ea20:	ab01      	add	r3, sp, #4
 800ea22:	c303      	stmia	r3!, {r0, r1}
 800ea24:	701a      	strb	r2, [r3, #0]
    if( PacketType != packetParams->PacketType )
 800ea26:	4b2b      	ldr	r3, [pc, #172]	; (800ead4 <SUBGRF_SetPacketParams+0xc0>)
 800ea28:	7820      	ldrb	r0, [r4, #0]
 800ea2a:	781b      	ldrb	r3, [r3, #0]
 800ea2c:	4283      	cmp	r3, r0
 800ea2e:	d001      	beq.n	800ea34 <SUBGRF_SetPacketParams+0x20>
        SUBGRF_SetPacketType( packetParams->PacketType );
 800ea30:	f7ff fe3c 	bl	800e6ac <SUBGRF_SetPacketType>
    switch( packetParams->PacketType )
 800ea34:	7823      	ldrb	r3, [r4, #0]
 800ea36:	2b03      	cmp	r3, #3
 800ea38:	d826      	bhi.n	800ea88 <SUBGRF_SetPacketParams+0x74>
 800ea3a:	e8df f003 	tbb	[pc, r3]
 800ea3e:	3802      	.short	0x3802
 800ea40:	0233      	.short	0x0233
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 800ea42:	7a63      	ldrb	r3, [r4, #9]
 800ea44:	2bf1      	cmp	r3, #241	; 0xf1
 800ea46:	d121      	bne.n	800ea8c <SUBGRF_SetPacketParams+0x78>
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 800ea48:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ea4c:	f7ff ffbe 	bl	800e9cc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 800ea50:	f248 0005 	movw	r0, #32773	; 0x8005
 800ea54:	f7ff ffcc 	bl	800e9f0 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 800ea58:	2302      	movs	r3, #2
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 800ea5a:	8862      	ldrh	r2, [r4, #2]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 800ea5c:	88a1      	ldrh	r1, [r4, #4]
 800ea5e:	f8ad 1006 	strh.w	r1, [sp, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 800ea62:	ba52      	rev16	r2, r2
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 800ea64:	88e1      	ldrh	r1, [r4, #6]
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 800ea66:	f8ad 2004 	strh.w	r2, [sp, #4]
        buf[7] = crcVal;
 800ea6a:	f88d 300b 	strb.w	r3, [sp, #11]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 800ea6e:	7a22      	ldrb	r2, [r4, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 800ea70:	7aa3      	ldrb	r3, [r4, #10]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 800ea72:	f88d 200a 	strb.w	r2, [sp, #10]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 800ea76:	f8ad 1008 	strh.w	r1, [sp, #8]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 800ea7a:	f88d 300c 	strb.w	r3, [sp, #12]
        n = 9;
 800ea7e:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 800ea80:	a901      	add	r1, sp, #4
 800ea82:	208c      	movs	r0, #140	; 0x8c
 800ea84:	f7ff fc26 	bl	800e2d4 <SUBGRF_WriteCommand>
}
 800ea88:	b004      	add	sp, #16
 800ea8a:	bd10      	pop	{r4, pc}
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 800ea8c:	2bf2      	cmp	r3, #242	; 0xf2
 800ea8e:	d1e4      	bne.n	800ea5a <SUBGRF_SetPacketParams+0x46>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 800ea90:	f641 500f 	movw	r0, #7439	; 0x1d0f
 800ea94:	f7ff ff9a 	bl	800e9cc <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 800ea98:	f241 0021 	movw	r0, #4129	; 0x1021
 800ea9c:	f7ff ffa8 	bl	800e9f0 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 800eaa0:	2306      	movs	r3, #6
 800eaa2:	e7da      	b.n	800ea5a <SUBGRF_SetPacketParams+0x46>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 800eaa4:	7b23      	ldrb	r3, [r4, #12]
 800eaa6:	f88d 3004 	strb.w	r3, [sp, #4]
        n = 1;
 800eaaa:	2201      	movs	r2, #1
        break;
 800eaac:	e7e8      	b.n	800ea80 <SUBGRF_SetPacketParams+0x6c>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 800eaae:	89e3      	ldrh	r3, [r4, #14]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 800eab0:	4a09      	ldr	r2, [pc, #36]	; (800ead8 <SUBGRF_SetPacketParams+0xc4>)
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 800eab2:	ba5b      	rev16	r3, r3
 800eab4:	f8ad 3004 	strh.w	r3, [sp, #4]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 800eab8:	7c23      	ldrb	r3, [r4, #16]
 800eaba:	7013      	strb	r3, [r2, #0]
 800eabc:	f88d 3006 	strb.w	r3, [sp, #6]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 800eac0:	7c63      	ldrb	r3, [r4, #17]
 800eac2:	f88d 3007 	strb.w	r3, [sp, #7]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 800eac6:	8a63      	ldrh	r3, [r4, #18]
 800eac8:	f8ad 3008 	strh.w	r3, [sp, #8]
        n = 6;
 800eacc:	2206      	movs	r2, #6
        break;
 800eace:	e7d7      	b.n	800ea80 <SUBGRF_SetPacketParams+0x6c>
 800ead0:	080103d0 	.word	0x080103d0
 800ead4:	2000120f 	.word	0x2000120f
 800ead8:	2000120d 	.word	0x2000120d

0800eadc <SUBGRF_ReadRegisters>:
{
 800eadc:	b510      	push	{r4, lr}
 800eade:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800eae0:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800eae4:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 800eae6:	460a      	mov	r2, r1
 800eae8:	4601      	mov	r1, r0
 800eaea:	4803      	ldr	r0, [pc, #12]	; (800eaf8 <SUBGRF_ReadRegisters+0x1c>)
 800eaec:	f7f6 fbe5 	bl	80052ba <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eaf0:	f384 8810 	msr	PRIMASK, r4
}
 800eaf4:	bd10      	pop	{r4, pc}
 800eaf6:	bf00      	nop
 800eaf8:	200019c8 	.word	0x200019c8

0800eafc <SUBGRF_GetRandom>:
{
 800eafc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    uint32_t number = 0;
 800eafe:	2600      	movs	r6, #0
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 800eb00:	f640 00e2 	movw	r0, #2274	; 0x8e2
    uint32_t number = 0;
 800eb04:	9601      	str	r6, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 800eb06:	f7ff fe53 	bl	800e7b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 800eb0a:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 800eb0e:	4605      	mov	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 800eb10:	f640 00e2 	movw	r0, #2274	; 0x8e2
 800eb14:	f7ff fd86 	bl	800e624 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 800eb18:	f640 00e5 	movw	r0, #2277	; 0x8e5
 800eb1c:	f7ff fe48 	bl	800e7b0 <SUBGRF_ReadRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 800eb20:	f000 017f 	and.w	r1, r0, #127	; 0x7f
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 800eb24:	4604      	mov	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 800eb26:	f640 00e5 	movw	r0, #2277	; 0x8e5
 800eb2a:	f7ff fd7b 	bl	800e624 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 800eb2e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 800eb32:	f7ff fc21 	bl	800e378 <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 800eb36:	2204      	movs	r2, #4
 800eb38:	eb0d 0102 	add.w	r1, sp, r2
 800eb3c:	f640 0019 	movw	r0, #2073	; 0x819
 800eb40:	f7ff ffcc 	bl	800eadc <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 800eb44:	4630      	mov	r0, r6
 800eb46:	f7ff fbeb 	bl	800e320 <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 800eb4a:	4629      	mov	r1, r5
 800eb4c:	f640 00e2 	movw	r0, #2274	; 0x8e2
 800eb50:	f7ff fd68 	bl	800e624 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 800eb54:	4621      	mov	r1, r4
 800eb56:	f640 00e5 	movw	r0, #2277	; 0x8e5
 800eb5a:	f7ff fd63 	bl	800e624 <SUBGRF_WriteRegister>
}
 800eb5e:	9801      	ldr	r0, [sp, #4]
 800eb60:	b002      	add	sp, #8
 800eb62:	bd70      	pop	{r4, r5, r6, pc}

0800eb64 <SUBGRF_WriteBuffer>:
{
 800eb64:	b510      	push	{r4, lr}
 800eb66:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800eb68:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800eb6c:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 800eb6e:	460a      	mov	r2, r1
 800eb70:	4601      	mov	r1, r0
 800eb72:	4803      	ldr	r0, [pc, #12]	; (800eb80 <SUBGRF_WriteBuffer+0x1c>)
 800eb74:	f7f6 fc14 	bl	80053a0 <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eb78:	f384 8810 	msr	PRIMASK, r4
}
 800eb7c:	bd10      	pop	{r4, pc}
 800eb7e:	bf00      	nop
 800eb80:	200019c8 	.word	0x200019c8

0800eb84 <SUBGRF_SetPayload>:
{
 800eb84:	460a      	mov	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 800eb86:	4601      	mov	r1, r0
 800eb88:	2000      	movs	r0, #0
 800eb8a:	f7ff bfeb 	b.w	800eb64 <SUBGRF_WriteBuffer>

0800eb8e <SUBGRF_SendPayload>:
{
 800eb8e:	b510      	push	{r4, lr}
 800eb90:	4614      	mov	r4, r2
    SUBGRF_SetPayload( payload, size );
 800eb92:	f7ff fff7 	bl	800eb84 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 800eb96:	4620      	mov	r0, r4
}
 800eb98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    SUBGRF_SetTx( timeout );
 800eb9c:	f7ff bbd6 	b.w	800e34c <SUBGRF_SetTx>

0800eba0 <SUBGRF_ReadBuffer>:
{
 800eba0:	b510      	push	{r4, lr}
 800eba2:	4613      	mov	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800eba4:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800eba8:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 800ebaa:	460a      	mov	r2, r1
 800ebac:	4601      	mov	r1, r0
 800ebae:	4803      	ldr	r0, [pc, #12]	; (800ebbc <SUBGRF_ReadBuffer+0x1c>)
 800ebb0:	f7f6 fc29 	bl	8005406 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ebb4:	f384 8810 	msr	PRIMASK, r4
}
 800ebb8:	bd10      	pop	{r4, pc}
 800ebba:	bf00      	nop
 800ebbc:	200019c8 	.word	0x200019c8

0800ebc0 <SUBGRF_GetPayload>:
{
 800ebc0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800ebc2:	460d      	mov	r5, r1
 800ebc4:	4606      	mov	r6, r0
    uint8_t offset = 0;
 800ebc6:	2400      	movs	r4, #0
    SUBGRF_GetRxBufferStatus( size, &offset );
 800ebc8:	f10d 0107 	add.w	r1, sp, #7
 800ebcc:	4628      	mov	r0, r5
{
 800ebce:	4617      	mov	r7, r2
    uint8_t offset = 0;
 800ebd0:	f88d 4007 	strb.w	r4, [sp, #7]
    SUBGRF_GetRxBufferStatus( size, &offset );
 800ebd4:	f7ff febe 	bl	800e954 <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 800ebd8:	782a      	ldrb	r2, [r5, #0]
 800ebda:	42ba      	cmp	r2, r7
 800ebdc:	d807      	bhi.n	800ebee <SUBGRF_GetPayload+0x2e>
    SUBGRF_ReadBuffer( offset, buffer, *size );
 800ebde:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800ebe2:	4631      	mov	r1, r6
 800ebe4:	f7ff ffdc 	bl	800eba0 <SUBGRF_ReadBuffer>
    return 0;
 800ebe8:	4620      	mov	r0, r4
}
 800ebea:	b003      	add	sp, #12
 800ebec:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return 1;
 800ebee:	2001      	movs	r0, #1
 800ebf0:	e7fb      	b.n	800ebea <SUBGRF_GetPayload+0x2a>

0800ebf2 <SUBGRF_SetSwitch>:
    if (rxtx == RFSWITCH_TX)
 800ebf2:	2901      	cmp	r1, #1
{
 800ebf4:	b508      	push	{r3, lr}
 800ebf6:	4603      	mov	r3, r0
 800ebf8:	4608      	mov	r0, r1
    if (rxtx == RFSWITCH_TX)
 800ebfa:	d10e      	bne.n	800ec1a <SUBGRF_SetSwitch+0x28>
        if (paSelect == RFO_LP)
 800ebfc:	2b01      	cmp	r3, #1
 800ebfe:	d107      	bne.n	800ec10 <SUBGRF_SetSwitch+0x1e>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 800ec00:	2004      	movs	r0, #4
 800ec02:	f7ff fde5 	bl	800e7d0 <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 800ec06:	2002      	movs	r0, #2
}
 800ec08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RBI_ConfigRFSwitch(state);
 800ec0c:	f7f3 bb08 	b.w	8002220 <RBI_ConfigRFSwitch>
        if (paSelect == RFO_HP)
 800ec10:	2b02      	cmp	r3, #2
            state = RBI_SWITCH_RFO_HP;
 800ec12:	bf14      	ite	ne
 800ec14:	4608      	movne	r0, r1
 800ec16:	2003      	moveq	r0, #3
 800ec18:	e7f6      	b.n	800ec08 <SUBGRF_SetSwitch+0x16>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 800ec1a:	2001      	movs	r0, #1
 800ec1c:	e7f4      	b.n	800ec08 <SUBGRF_SetSwitch+0x16>

0800ec1e <SUBGRF_SetRfTxPower>:
{
 800ec1e:	b538      	push	{r3, r4, r5, lr}
 800ec20:	4604      	mov	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 800ec22:	f7f3 faff 	bl	8002224 <RBI_GetTxConfig>
    switch (TxConfig)
 800ec26:	b150      	cbz	r0, 800ec3e <SUBGRF_SetRfTxPower+0x20>
 800ec28:	2802      	cmp	r0, #2
 800ec2a:	bf14      	ite	ne
 800ec2c:	2501      	movne	r5, #1
 800ec2e:	2502      	moveq	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 800ec30:	4628      	mov	r0, r5
 800ec32:	2202      	movs	r2, #2
 800ec34:	4621      	mov	r1, r4
 800ec36:	f7ff fe4b 	bl	800e8d0 <SUBGRF_SetTxParams>
}
 800ec3a:	4628      	mov	r0, r5
 800ec3c:	bd38      	pop	{r3, r4, r5, pc}
            if (power > 15)
 800ec3e:	2c0f      	cmp	r4, #15
                paSelect = RFO_LP;
 800ec40:	bfcc      	ite	gt
 800ec42:	2502      	movgt	r5, #2
 800ec44:	2501      	movle	r5, #1
 800ec46:	e7f3      	b.n	800ec30 <SUBGRF_SetRfTxPower+0x12>

0800ec48 <SUBGRF_GetRadioWakeUpTime>:
}
 800ec48:	2001      	movs	r0, #1
 800ec4a:	4770      	bx	lr

0800ec4c <HAL_SUBGHZ_TxCpltCallback>:
    RadioOnDioIrqCb( IRQ_TX_DONE );
 800ec4c:	4b01      	ldr	r3, [pc, #4]	; (800ec54 <HAL_SUBGHZ_TxCpltCallback+0x8>)
 800ec4e:	2001      	movs	r0, #1
 800ec50:	681b      	ldr	r3, [r3, #0]
 800ec52:	4718      	bx	r3
 800ec54:	20001210 	.word	0x20001210

0800ec58 <HAL_SUBGHZ_RxCpltCallback>:
    RadioOnDioIrqCb( IRQ_RX_DONE );
 800ec58:	4b01      	ldr	r3, [pc, #4]	; (800ec60 <HAL_SUBGHZ_RxCpltCallback+0x8>)
 800ec5a:	2002      	movs	r0, #2
 800ec5c:	681b      	ldr	r3, [r3, #0]
 800ec5e:	4718      	bx	r3
 800ec60:	20001210 	.word	0x20001210

0800ec64 <HAL_SUBGHZ_CRCErrorCallback>:
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 800ec64:	4b01      	ldr	r3, [pc, #4]	; (800ec6c <HAL_SUBGHZ_CRCErrorCallback+0x8>)
 800ec66:	2040      	movs	r0, #64	; 0x40
 800ec68:	681b      	ldr	r3, [r3, #0]
 800ec6a:	4718      	bx	r3
 800ec6c:	20001210 	.word	0x20001210

0800ec70 <HAL_SUBGHZ_CADStatusCallback>:
    switch (cadstatus)
 800ec70:	b111      	cbz	r1, 800ec78 <HAL_SUBGHZ_CADStatusCallback+0x8>
 800ec72:	2901      	cmp	r1, #1
 800ec74:	d004      	beq.n	800ec80 <HAL_SUBGHZ_CADStatusCallback+0x10>
 800ec76:	4770      	bx	lr
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 800ec78:	4b04      	ldr	r3, [pc, #16]	; (800ec8c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 800ec7a:	681b      	ldr	r3, [r3, #0]
 800ec7c:	2080      	movs	r0, #128	; 0x80
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 800ec7e:	4718      	bx	r3
 800ec80:	4b02      	ldr	r3, [pc, #8]	; (800ec8c <HAL_SUBGHZ_CADStatusCallback+0x1c>)
 800ec82:	f44f 7080 	mov.w	r0, #256	; 0x100
 800ec86:	681b      	ldr	r3, [r3, #0]
 800ec88:	e7f9      	b.n	800ec7e <HAL_SUBGHZ_CADStatusCallback+0xe>
 800ec8a:	bf00      	nop
 800ec8c:	20001210 	.word	0x20001210

0800ec90 <HAL_SUBGHZ_RxTxTimeoutCallback>:
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 800ec90:	4b02      	ldr	r3, [pc, #8]	; (800ec9c <HAL_SUBGHZ_RxTxTimeoutCallback+0xc>)
 800ec92:	f44f 7000 	mov.w	r0, #512	; 0x200
 800ec96:	681b      	ldr	r3, [r3, #0]
 800ec98:	4718      	bx	r3
 800ec9a:	bf00      	nop
 800ec9c:	20001210 	.word	0x20001210

0800eca0 <HAL_SUBGHZ_HeaderErrorCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 800eca0:	4b01      	ldr	r3, [pc, #4]	; (800eca8 <HAL_SUBGHZ_HeaderErrorCallback+0x8>)
 800eca2:	2020      	movs	r0, #32
 800eca4:	681b      	ldr	r3, [r3, #0]
 800eca6:	4718      	bx	r3
 800eca8:	20001210 	.word	0x20001210

0800ecac <HAL_SUBGHZ_PreambleDetectedCallback>:
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 800ecac:	4b01      	ldr	r3, [pc, #4]	; (800ecb4 <HAL_SUBGHZ_PreambleDetectedCallback+0x8>)
 800ecae:	2004      	movs	r0, #4
 800ecb0:	681b      	ldr	r3, [r3, #0]
 800ecb2:	4718      	bx	r3
 800ecb4:	20001210 	.word	0x20001210

0800ecb8 <HAL_SUBGHZ_SyncWordValidCallback>:
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 800ecb8:	4b01      	ldr	r3, [pc, #4]	; (800ecc0 <HAL_SUBGHZ_SyncWordValidCallback+0x8>)
 800ecba:	2008      	movs	r0, #8
 800ecbc:	681b      	ldr	r3, [r3, #0]
 800ecbe:	4718      	bx	r3
 800ecc0:	20001210 	.word	0x20001210

0800ecc4 <HAL_SUBGHZ_HeaderValidCallback>:
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 800ecc4:	4b01      	ldr	r3, [pc, #4]	; (800eccc <HAL_SUBGHZ_HeaderValidCallback+0x8>)
 800ecc6:	2010      	movs	r0, #16
 800ecc8:	681b      	ldr	r3, [r3, #0]
 800ecca:	4718      	bx	r3
 800eccc:	20001210 	.word	0x20001210

0800ecd0 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
    uint8_t i;

    if( bandwidth == 0 )
 800ecd0:	b168      	cbz	r0, 800ecee <SUBGRF_GetFskBandwidthRegValue+0x1e>
    }

    /* ST_WORKAROUND_BEGIN: Simplified loop */
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 800ecd2:	4a08      	ldr	r2, [pc, #32]	; (800ecf4 <SUBGRF_GetFskBandwidthRegValue+0x24>)
 800ecd4:	2300      	movs	r3, #0
 800ecd6:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 800ecda:	4281      	cmp	r1, r0
 800ecdc:	d903      	bls.n	800ece6 <SUBGRF_GetFskBandwidthRegValue+0x16>
        {
            return FskBandwidths[i].RegValue;
 800ecde:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800ece2:	7918      	ldrb	r0, [r3, #4]
 800ece4:	4770      	bx	lr
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 800ece6:	3301      	adds	r3, #1
 800ece8:	2b16      	cmp	r3, #22
 800ecea:	d1f4      	bne.n	800ecd6 <SUBGRF_GetFskBandwidthRegValue+0x6>
        }
    }
    /* ST_WORKAROUND_END */
    // ERROR: Value not found
    while( 1 );
 800ecec:	e7fe      	b.n	800ecec <SUBGRF_GetFskBandwidthRegValue+0x1c>
        return( 0x1F );
 800ecee:	201f      	movs	r0, #31
}
 800ecf0:	4770      	bx	lr
 800ecf2:	bf00      	nop
 800ecf4:	08011068 	.word	0x08011068

0800ecf8 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 800ecf8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t BwMant[] = {4, 8, 10, 12};
 800ecfa:	4b1d      	ldr	r3, [pc, #116]	; (800ed70 <SUBGRF_GetCFO+0x78>)
 800ecfc:	9301      	str	r3, [sp, #4]
{
 800ecfe:	4604      	mov	r4, r0
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 800ed00:	f640 0007 	movw	r0, #2055	; 0x807
{
 800ed04:	460d      	mov	r5, r1
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSEL ));
 800ed06:	f7ff fd53 	bl	800e7b0 <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 800ed0a:	aa02      	add	r2, sp, #8
 800ed0c:	f3c0 03c1 	ubfx	r3, r0, #3, #2
 800ed10:	4413      	add	r3, r2
  uint8_t bandwidth_exp = reg & 0x7;
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp - 1 )));
 800ed12:	f813 2c04 	ldrb.w	r2, [r3, #-4]
 800ed16:	f000 0307 	and.w	r3, r0, #7
 800ed1a:	3b01      	subs	r3, #1
 800ed1c:	fa02 f003 	lsl.w	r0, r2, r3
 800ed20:	4b14      	ldr	r3, [pc, #80]	; (800ed74 <SUBGRF_GetCFO+0x7c>)
 800ed22:	fbb3 f3f0 	udiv	r3, r3, r0
  uint32_t cf_osr = cf_fs / bitRate;
 800ed26:	fbb3 f0f4 	udiv	r0, r3, r4
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 800ed2a:	2807      	cmp	r0, #7
 800ed2c:	d81d      	bhi.n	800ed6a <SUBGRF_GetCFO+0x72>
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 800ed2e:	0040      	lsls	r0, r0, #1
  {
    interp = 4;
 800ed30:	2803      	cmp	r0, #3
 800ed32:	bf8c      	ite	hi
 800ed34:	2402      	movhi	r4, #2
 800ed36:	2404      	movls	r4, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 800ed38:	f44f 60d6 	mov.w	r0, #1712	; 0x6b0
  uint32_t fs = cf_fs* interp;
 800ed3c:	435c      	muls	r4, r3
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_CFO_H ) & 0xF ) << 8;
 800ed3e:	f7ff fd37 	bl	800e7b0 <SUBGRF_ReadRegister>
 800ed42:	0200      	lsls	r0, r0, #8
 800ed44:	f400 6670 	and.w	r6, r0, #3840	; 0xf00
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_CFO_L );
 800ed48:	f240 60b1 	movw	r0, #1713	; 0x6b1
 800ed4c:	f7ff fd30 	bl	800e7b0 <SUBGRF_ReadRegister>
 800ed50:	4330      	orrs	r0, r6
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 800ed52:	0503      	lsls	r3, r0, #20
  {
    cfo_bin |= 0xFFFFF000;
 800ed54:	bf44      	itt	mi
 800ed56:	ea6f 5000 	mvnmi.w	r0, r0, lsl #20
 800ed5a:	ea6f 5010 	mvnmi.w	r0, r0, lsr #20
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 800ed5e:	0963      	lsrs	r3, r4, #5
 800ed60:	4358      	muls	r0, r3
 800ed62:	11c0      	asrs	r0, r0, #7
 800ed64:	6028      	str	r0, [r5, #0]
}
 800ed66:	b002      	add	sp, #8
 800ed68:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t interp = 1;
 800ed6a:	2401      	movs	r4, #1
 800ed6c:	e7e4      	b.n	800ed38 <SUBGRF_GetCFO+0x40>
 800ed6e:	bf00      	nop
 800ed70:	0c0a0804 	.word	0x0c0a0804
 800ed74:	01e84800 	.word	0x01e84800

0800ed78 <RFW_TransmitLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 800ed78:	f04f 30ff 	mov.w	r0, #4294967295
 800ed7c:	4770      	bx	lr

0800ed7e <RFW_ReceiveLongPacket>:
  }
#else
  status= -1;
#endif
  return status;
}
 800ed7e:	f04f 30ff 	mov.w	r0, #4294967295
 800ed82:	4770      	bx	lr

0800ed84 <RFW_Init>:
  TimerInit( &RFWPacket.Timer, RFW_GetPayloadTimerEvent );
  return 0;
#else
  return -1;
#endif
}
 800ed84:	f04f 30ff 	mov.w	r0, #4294967295
 800ed88:	4770      	bx	lr

0800ed8a <RFW_DeInit>:
void RFW_DeInit( void)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Enable=0; /*Disable the RFWPacket decoding*/
#endif
}
 800ed8a:	4770      	bx	lr

0800ed8c <RFW_Is_Init>:
#if (RFW_ENABLE ==1 )
  return RFWPacket.Init.Enable;
#else
  return 0;
#endif
}
 800ed8c:	2000      	movs	r0, #0
 800ed8e:	4770      	bx	lr

0800ed90 <RFW_Is_LongPacketModeEnabled>:
 800ed90:	2000      	movs	r0, #0
 800ed92:	4770      	bx	lr

0800ed94 <RFW_SetAntSwitch>:
 800ed94:	4770      	bx	lr

0800ed96 <RFW_TransmitInit>:
    
    status= 0;
  }
#endif
  return status;
}
 800ed96:	f04f 30ff 	mov.w	r0, #4294967295
 800ed9a:	4770      	bx	lr

0800ed9c <RFW_ReceiveInit>:
  RFWPacket.LongPacketModeEnable=0;
  return 0;
#else
  return -1;
#endif
}
 800ed9c:	f04f 30ff 	mov.w	r0, #4294967295
 800eda0:	4770      	bx	lr

0800eda2 <RFW_DeInit_TxLongPacket>:
 800eda2:	4770      	bx	lr

0800eda4 <RFW_ReceivePayload>:
 800eda4:	4770      	bx	lr

0800eda6 <RFW_SetRadioModem>:
void RFW_SetRadioModem(RadioModems_t Modem)
{
#if (RFW_ENABLE ==1 )
  RFWPacket.Init.Modem= Modem;
#endif
}
 800eda6:	4770      	bx	lr

0800eda8 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 800eda8:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800edaa:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800edae:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 800edb0:	4b14      	ldr	r3, [pc, #80]	; (800ee04 <TRACE_AllocateBufer+0x5c>)
 800edb2:	8a5c      	ldrh	r4, [r3, #18]
 800edb4:	8a1a      	ldrh	r2, [r3, #16]
 800edb6:	4294      	cmp	r4, r2
 800edb8:	d113      	bne.n	800ede2 <TRACE_AllocateBufer+0x3a>
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 800edba:	f5c4 6280 	rsb	r2, r4, #1024	; 0x400
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 800edbe:	b292      	uxth	r2, r2
 800edc0:	4290      	cmp	r0, r2
 800edc2:	d306      	bcc.n	800edd2 <TRACE_AllocateBufer+0x2a>
 800edc4:	4284      	cmp	r4, r0
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 800edc6:	d918      	bls.n	800edfa <TRACE_AllocateBufer+0x52>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 800edc8:	2201      	movs	r2, #1
 800edca:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 800edcc:	2200      	movs	r2, #0
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 800edce:	801c      	strh	r4, [r3, #0]
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 800edd0:	825a      	strh	r2, [r3, #18]
#endif
  }

  if(freesize > Size)
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 800edd2:	8a5a      	ldrh	r2, [r3, #18]
 800edd4:	800a      	strh	r2, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 800edd6:	4410      	add	r0, r2
 800edd8:	f3c0 0009 	ubfx	r0, r0, #0, #10
 800eddc:	8258      	strh	r0, [r3, #18]
    ret = 0;
 800edde:	2000      	movs	r0, #0
 800ede0:	e00d      	b.n	800edfe <TRACE_AllocateBufer+0x56>
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 800ede2:	d906      	bls.n	800edf2 <TRACE_AllocateBufer+0x4a>
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 800ede4:	f5c4 6580 	rsb	r5, r4, #1024	; 0x400
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 800ede8:	b2ad      	uxth	r5, r5
 800edea:	4285      	cmp	r5, r0
 800edec:	d8f1      	bhi.n	800edd2 <TRACE_AllocateBufer+0x2a>
 800edee:	4282      	cmp	r2, r0
 800edf0:	e7e9      	b.n	800edc6 <TRACE_AllocateBufer+0x1e>
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 800edf2:	1b12      	subs	r2, r2, r4
  if(freesize > Size)
 800edf4:	b292      	uxth	r2, r2
 800edf6:	4282      	cmp	r2, r0
 800edf8:	d8eb      	bhi.n	800edd2 <TRACE_AllocateBufer+0x2a>
  int16_t ret = -1;
 800edfa:	f04f 30ff 	mov.w	r0, #4294967295
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800edfe:	f386 8810 	msr	PRIMASK, r6
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 800ee02:	bd70      	pop	{r4, r5, r6, pc}
 800ee04:	20001614 	.word	0x20001614

0800ee08 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ee08:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800ee0c:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 800ee0e:	4a03      	ldr	r2, [pc, #12]	; (800ee1c <TRACE_Lock+0x14>)
 800ee10:	8ad3      	ldrh	r3, [r2, #22]
 800ee12:	3301      	adds	r3, #1
 800ee14:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ee16:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 800ee1a:	4770      	bx	lr
 800ee1c:	20001614 	.word	0x20001614

0800ee20 <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ee20:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800ee24:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 800ee26:	4a03      	ldr	r2, [pc, #12]	; (800ee34 <TRACE_UnLock+0x14>)
 800ee28:	8ad3      	ldrh	r3, [r2, #22]
 800ee2a:	3b01      	subs	r3, #1
 800ee2c:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800ee2e:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 800ee32:	4770      	bx	lr
 800ee34:	20001614 	.word	0x20001614

0800ee38 <UTIL_ADV_TRACE_Init>:
{
 800ee38:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 800ee3a:	4808      	ldr	r0, [pc, #32]	; (800ee5c <UTIL_ADV_TRACE_Init+0x24>)
 800ee3c:	2218      	movs	r2, #24
 800ee3e:	2100      	movs	r1, #0
 800ee40:	f000 f976 	bl	800f130 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 800ee44:	4806      	ldr	r0, [pc, #24]	; (800ee60 <UTIL_ADV_TRACE_Init+0x28>)
 800ee46:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ee4a:	2100      	movs	r1, #0
 800ee4c:	f000 f970 	bl	800f130 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 800ee50:	4b04      	ldr	r3, [pc, #16]	; (800ee64 <UTIL_ADV_TRACE_Init+0x2c>)
 800ee52:	4805      	ldr	r0, [pc, #20]	; (800ee68 <UTIL_ADV_TRACE_Init+0x30>)
 800ee54:	681b      	ldr	r3, [r3, #0]
}
 800ee56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 800ee5a:	4718      	bx	r3
 800ee5c:	20001614 	.word	0x20001614
 800ee60:	20001214 	.word	0x20001214
 800ee64:	08010490 	.word	0x08010490
 800ee68:	0800efd5 	.word	0x0800efd5

0800ee6c <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 800ee6c:	4b01      	ldr	r3, [pc, #4]	; (800ee74 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 800ee6e:	6058      	str	r0, [r3, #4]
}
 800ee70:	4770      	bx	lr
 800ee72:	bf00      	nop
 800ee74:	20001614 	.word	0x20001614

0800ee78 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 800ee78:	4b01      	ldr	r3, [pc, #4]	; (800ee80 <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 800ee7a:	7218      	strb	r0, [r3, #8]
}
 800ee7c:	4770      	bx	lr
 800ee7e:	bf00      	nop
 800ee80:	20001614 	.word	0x20001614

0800ee84 <TRACE_Send>:
{
 800ee84:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800ee86:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800ee8a:	b672      	cpsid	i
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 800ee8c:	4c1b      	ldr	r4, [pc, #108]	; (800eefc <TRACE_Send+0x78>)
  if(TRACE_IsLocked() == 0u)
 800ee8e:	8ae0      	ldrh	r0, [r4, #22]
 800ee90:	2800      	cmp	r0, #0
 800ee92:	d12e      	bne.n	800eef2 <TRACE_Send+0x6e>
    TRACE_Lock();
 800ee94:	f7ff ffb8 	bl	800ee08 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 800ee98:	8a26      	ldrh	r6, [r4, #16]
 800ee9a:	8a62      	ldrh	r2, [r4, #18]
 800ee9c:	4296      	cmp	r6, r2
 800ee9e:	d026      	beq.n	800eeee <TRACE_Send+0x6a>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 800eea0:	78a1      	ldrb	r1, [r4, #2]
 800eea2:	2901      	cmp	r1, #1
 800eea4:	d111      	bne.n	800eeca <TRACE_Send+0x46>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 800eea6:	8823      	ldrh	r3, [r4, #0]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 800eea8:	8020      	strh	r0, [r4, #0]
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 800eeaa:	1b9b      	subs	r3, r3, r6
 800eeac:	b29b      	uxth	r3, r3
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 800eeae:	2102      	movs	r1, #2
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 800eeb0:	82a3      	strh	r3, [r4, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 800eeb2:	70a1      	strb	r1, [r4, #2]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 800eeb4:	b95b      	cbnz	r3, 800eece <TRACE_Send+0x4a>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 800eeb6:	70a3      	strb	r3, [r4, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 800eeb8:	8223      	strh	r3, [r4, #16]
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 800eeba:	8a23      	ldrh	r3, [r4, #16]
 800eebc:	429a      	cmp	r2, r3
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 800eebe:	bf8c      	ite	hi
 800eec0:	1ad3      	subhi	r3, r2, r3
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 800eec2:	f5c3 6380 	rsbls	r3, r3, #1024	; 0x400
 800eec6:	82a3      	strh	r3, [r4, #20]
 800eec8:	e001      	b.n	800eece <TRACE_Send+0x4a>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 800eeca:	2900      	cmp	r1, #0
 800eecc:	d0f5      	beq.n	800eeba <TRACE_Send+0x36>
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 800eece:	8a20      	ldrh	r0, [r4, #16]
 800eed0:	4e0b      	ldr	r6, [pc, #44]	; (800ef00 <TRACE_Send+0x7c>)
 800eed2:	4406      	add	r6, r0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800eed4:	f385 8810 	msr	PRIMASK, r5
      UTIL_ADV_TRACE_PreSendHook();
 800eed8:	f7f2 faf2 	bl	80014c0 <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 800eedc:	4b09      	ldr	r3, [pc, #36]	; (800ef04 <TRACE_Send+0x80>)
 800eede:	8aa1      	ldrh	r1, [r4, #20]
 800eee0:	68db      	ldr	r3, [r3, #12]
 800eee2:	9301      	str	r3, [sp, #4]
 800eee4:	4630      	mov	r0, r6
}
 800eee6:	b002      	add	sp, #8
 800eee8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 800eeec:	4718      	bx	r3
      TRACE_UnLock();
 800eeee:	f7ff ff97 	bl	800ee20 <TRACE_UnLock>
 800eef2:	f385 8810 	msr	PRIMASK, r5
}
 800eef6:	2000      	movs	r0, #0
 800eef8:	b002      	add	sp, #8
 800eefa:	bd70      	pop	{r4, r5, r6, pc}
 800eefc:	20001614 	.word	0x20001614
 800ef00:	20001214 	.word	0x20001214
 800ef04:	08010490 	.word	0x08010490

0800ef08 <UTIL_ADV_TRACE_COND_FSend>:
{
 800ef08:	b408      	push	{r3}
 800ef0a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ef0c:	b086      	sub	sp, #24
  uint16_t timestamp_size = 0u;
 800ef0e:	2300      	movs	r3, #0
 800ef10:	f8ad 3000 	strh.w	r3, [sp]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 800ef14:	4b2c      	ldr	r3, [pc, #176]	; (800efc8 <UTIL_ADV_TRACE_COND_FSend+0xc0>)
{
 800ef16:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 800ef18:	7a1d      	ldrb	r5, [r3, #8]
 800ef1a:	4285      	cmp	r5, r0
 800ef1c:	d34d      	bcc.n	800efba <UTIL_ADV_TRACE_COND_FSend+0xb2>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 800ef1e:	68d8      	ldr	r0, [r3, #12]
 800ef20:	4381      	bics	r1, r0
 800ef22:	d14d      	bne.n	800efc0 <UTIL_ADV_TRACE_COND_FSend+0xb8>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 800ef24:	685b      	ldr	r3, [r3, #4]
 800ef26:	b11b      	cbz	r3, 800ef30 <UTIL_ADV_TRACE_COND_FSend+0x28>
 800ef28:	b112      	cbz	r2, 800ef30 <UTIL_ADV_TRACE_COND_FSend+0x28>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 800ef2a:	4669      	mov	r1, sp
 800ef2c:	a802      	add	r0, sp, #8
 800ef2e:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 800ef30:	ab0c      	add	r3, sp, #48	; 0x30
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 800ef32:	4622      	mov	r2, r4
 800ef34:	f44f 7100 	mov.w	r1, #512	; 0x200
 800ef38:	4824      	ldr	r0, [pc, #144]	; (800efcc <UTIL_ADV_TRACE_COND_FSend+0xc4>)
  va_start( vaArgs, strFormat);
 800ef3a:	9301      	str	r3, [sp, #4]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 800ef3c:	f000 fc06 	bl	800f74c <tiny_vsnprintf_like>
  TRACE_Lock();
 800ef40:	f7ff ff62 	bl	800ee08 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 800ef44:	f8bd 3000 	ldrh.w	r3, [sp]
 800ef48:	4418      	add	r0, r3
 800ef4a:	f10d 0102 	add.w	r1, sp, #2
 800ef4e:	b280      	uxth	r0, r0
 800ef50:	f7ff ff2a 	bl	800eda8 <TRACE_AllocateBufer>
 800ef54:	3001      	adds	r0, #1
 800ef56:	d02b      	beq.n	800efb0 <UTIL_ADV_TRACE_COND_FSend+0xa8>
    for (idx = 0u; idx < timestamp_size; idx++)
 800ef58:	2200      	movs	r2, #0
 800ef5a:	f8bd 3000 	ldrh.w	r3, [sp]
 800ef5e:	f8bd 7002 	ldrh.w	r7, [sp, #2]
 800ef62:	481b      	ldr	r0, [pc, #108]	; (800efd0 <UTIL_ADV_TRACE_COND_FSend+0xc8>)
 800ef64:	4616      	mov	r6, r2
      ADV_TRACE_Buffer[writepos] = buf[idx];
 800ef66:	f10d 0c08 	add.w	ip, sp, #8
 800ef6a:	b291      	uxth	r1, r2
 800ef6c:	fa17 f582 	uxtah	r5, r7, r2
    for (idx = 0u; idx < timestamp_size; idx++)
 800ef70:	428b      	cmp	r3, r1
 800ef72:	b2ad      	uxth	r5, r5
 800ef74:	d816      	bhi.n	800efa4 <UTIL_ADV_TRACE_COND_FSend+0x9c>
 800ef76:	443b      	add	r3, r7
 800ef78:	b29b      	uxth	r3, r3
 800ef7a:	b10e      	cbz	r6, 800ef80 <UTIL_ADV_TRACE_COND_FSend+0x78>
 800ef7c:	f8ad 3002 	strh.w	r3, [sp, #2]
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 800ef80:	f8bd 5002 	ldrh.w	r5, [sp, #2]
 800ef84:	9b01      	ldr	r3, [sp, #4]
 800ef86:	4622      	mov	r2, r4
 800ef88:	f44f 7100 	mov.w	r1, #512	; 0x200
 800ef8c:	4428      	add	r0, r5
 800ef8e:	f000 fbdd 	bl	800f74c <tiny_vsnprintf_like>
    TRACE_UnLock();
 800ef92:	f7ff ff45 	bl	800ee20 <TRACE_UnLock>
    return TRACE_Send();
 800ef96:	f7ff ff75 	bl	800ee84 <TRACE_Send>
}
 800ef9a:	b006      	add	sp, #24
 800ef9c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800efa0:	b001      	add	sp, #4
 800efa2:	4770      	bx	lr
      ADV_TRACE_Buffer[writepos] = buf[idx];
 800efa4:	f812 100c 	ldrb.w	r1, [r2, ip]
 800efa8:	5541      	strb	r1, [r0, r5]
    for (idx = 0u; idx < timestamp_size; idx++)
 800efaa:	3201      	adds	r2, #1
      ADV_TRACE_Buffer[writepos] = buf[idx];
 800efac:	2601      	movs	r6, #1
 800efae:	e7dc      	b.n	800ef6a <UTIL_ADV_TRACE_COND_FSend+0x62>
  TRACE_UnLock();
 800efb0:	f7ff ff36 	bl	800ee20 <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 800efb4:	f06f 0002 	mvn.w	r0, #2
 800efb8:	e7ef      	b.n	800ef9a <UTIL_ADV_TRACE_COND_FSend+0x92>
    return UTIL_ADV_TRACE_GIVEUP;
 800efba:	f06f 0004 	mvn.w	r0, #4
 800efbe:	e7ec      	b.n	800ef9a <UTIL_ADV_TRACE_COND_FSend+0x92>
    return UTIL_ADV_TRACE_REGIONMASKED;
 800efc0:	f06f 0005 	mvn.w	r0, #5
 800efc4:	e7e9      	b.n	800ef9a <UTIL_ADV_TRACE_COND_FSend+0x92>
 800efc6:	bf00      	nop
 800efc8:	20001614 	.word	0x20001614
 800efcc:	2000162c 	.word	0x2000162c
 800efd0:	20001214 	.word	0x20001214

0800efd4 <TRACE_TxCpltCallback>:
{
 800efd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800efd6:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800efda:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 800efdc:	4b21      	ldr	r3, [pc, #132]	; (800f064 <TRACE_TxCpltCallback+0x90>)
 800efde:	789a      	ldrb	r2, [r3, #2]
 800efe0:	2a02      	cmp	r2, #2
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 800efe2:	bf1d      	ittte	ne
 800efe4:	8a1a      	ldrhne	r2, [r3, #16]
 800efe6:	8a99      	ldrhne	r1, [r3, #20]
 800efe8:	1852      	addne	r2, r2, r1
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 800efea:	2200      	moveq	r2, #0
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 800efec:	bf18      	it	ne
 800efee:	f3c2 0209 	ubfxne	r2, r2, #0, #10
 800eff2:	821a      	strh	r2, [r3, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 800eff4:	8a1d      	ldrh	r5, [r3, #16]
 800eff6:	8a59      	ldrh	r1, [r3, #18]
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 800eff8:	bf08      	it	eq
 800effa:	709a      	strbeq	r2, [r3, #2]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 800effc:	428d      	cmp	r5, r1
 800effe:	d027      	beq.n	800f050 <TRACE_TxCpltCallback+0x7c>
 800f000:	8ada      	ldrh	r2, [r3, #22]
 800f002:	2a01      	cmp	r2, #1
 800f004:	d124      	bne.n	800f050 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 800f006:	7898      	ldrb	r0, [r3, #2]
 800f008:	2801      	cmp	r0, #1
 800f00a:	d112      	bne.n	800f032 <TRACE_TxCpltCallback+0x5e>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 800f00c:	881a      	ldrh	r2, [r3, #0]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 800f00e:	2002      	movs	r0, #2
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 800f010:	1b52      	subs	r2, r2, r5
 800f012:	b292      	uxth	r2, r2
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 800f014:	7098      	strb	r0, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 800f016:	2000      	movs	r0, #0
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 800f018:	829a      	strh	r2, [r3, #20]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 800f01a:	8018      	strh	r0, [r3, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 800f01c:	b95a      	cbnz	r2, 800f036 <TRACE_TxCpltCallback+0x62>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 800f01e:	709a      	strb	r2, [r3, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 800f020:	821a      	strh	r2, [r3, #16]
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 800f022:	8a1a      	ldrh	r2, [r3, #16]
 800f024:	4291      	cmp	r1, r2
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 800f026:	bf8c      	ite	hi
 800f028:	1a8a      	subhi	r2, r1, r2
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 800f02a:	f5c2 6280 	rsbls	r2, r2, #1024	; 0x400
 800f02e:	829a      	strh	r2, [r3, #20]
 800f030:	e001      	b.n	800f036 <TRACE_TxCpltCallback+0x62>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 800f032:	2800      	cmp	r0, #0
 800f034:	d0f5      	beq.n	800f022 <TRACE_TxCpltCallback+0x4e>
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 800f036:	8a1a      	ldrh	r2, [r3, #16]
 800f038:	480b      	ldr	r0, [pc, #44]	; (800f068 <TRACE_TxCpltCallback+0x94>)
 800f03a:	4410      	add	r0, r2
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f03c:	f384 8810 	msr	PRIMASK, r4
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 800f040:	4a0a      	ldr	r2, [pc, #40]	; (800f06c <TRACE_TxCpltCallback+0x98>)
 800f042:	8a99      	ldrh	r1, [r3, #20]
 800f044:	68d3      	ldr	r3, [r2, #12]
 800f046:	9301      	str	r3, [sp, #4]
}
 800f048:	b003      	add	sp, #12
 800f04a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 800f04e:	4718      	bx	r3
 800f050:	f384 8810 	msr	PRIMASK, r4
    UTIL_ADV_TRACE_PostSendHook();
 800f054:	f7f2 fa38 	bl	80014c8 <UTIL_ADV_TRACE_PostSendHook>
}
 800f058:	b003      	add	sp, #12
 800f05a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    TRACE_UnLock();
 800f05e:	f7ff bedf 	b.w	800ee20 <TRACE_UnLock>
 800f062:	bf00      	nop
 800f064:	20001614 	.word	0x20001614
 800f068:	20001214 	.word	0x20001214
 800f06c:	08010490 	.word	0x08010490

0800f070 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 800f070:	4a02      	ldr	r2, [pc, #8]	; (800f07c <UTIL_LPM_Init+0xc>)
 800f072:	2300      	movs	r3, #0
 800f074:	6013      	str	r3, [r2, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 800f076:	4a02      	ldr	r2, [pc, #8]	; (800f080 <UTIL_LPM_Init+0x10>)
 800f078:	6013      	str	r3, [r2, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 800f07a:	4770      	bx	lr
 800f07c:	20001830 	.word	0x20001830
 800f080:	2000182c 	.word	0x2000182c

0800f084 <UTIL_LPM_SetStopMode>:
void UTIL_LPM_DeInit( void )
{
}

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 800f084:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f086:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f08a:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 800f08c:	b141      	cbz	r1, 800f0a0 <UTIL_LPM_SetStopMode+0x1c>
 800f08e:	2901      	cmp	r1, #1
 800f090:	d103      	bne.n	800f09a <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 800f092:	4a06      	ldr	r2, [pc, #24]	; (800f0ac <UTIL_LPM_SetStopMode+0x28>)
 800f094:	6813      	ldr	r3, [r2, #0]
 800f096:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      StopModeDisable &= ( ~lpm_id_bm );
 800f098:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f09a:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 800f09e:	bd10      	pop	{r4, pc}
      StopModeDisable &= ( ~lpm_id_bm );
 800f0a0:	4a02      	ldr	r2, [pc, #8]	; (800f0ac <UTIL_LPM_SetStopMode+0x28>)
 800f0a2:	6813      	ldr	r3, [r2, #0]
 800f0a4:	ea23 0000 	bic.w	r0, r3, r0
 800f0a8:	e7f6      	b.n	800f098 <UTIL_LPM_SetStopMode+0x14>
 800f0aa:	bf00      	nop
 800f0ac:	20001830 	.word	0x20001830

0800f0b0 <UTIL_LPM_SetOffMode>:

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
 800f0b0:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f0b2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f0b6:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 800f0b8:	b141      	cbz	r1, 800f0cc <UTIL_LPM_SetOffMode+0x1c>
 800f0ba:	2901      	cmp	r1, #1
 800f0bc:	d103      	bne.n	800f0c6 <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 800f0be:	4a06      	ldr	r2, [pc, #24]	; (800f0d8 <UTIL_LPM_SetOffMode+0x28>)
 800f0c0:	6813      	ldr	r3, [r2, #0]
 800f0c2:	4318      	orrs	r0, r3
      break;
    }
  case UTIL_LPM_ENABLE:
    {
      OffModeDisable &= ( ~lpm_id_bm );
 800f0c4:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f0c6:	f384 8810 	msr	PRIMASK, r4
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 800f0ca:	bd10      	pop	{r4, pc}
      OffModeDisable &= ( ~lpm_id_bm );
 800f0cc:	4a02      	ldr	r2, [pc, #8]	; (800f0d8 <UTIL_LPM_SetOffMode+0x28>)
 800f0ce:	6813      	ldr	r3, [r2, #0]
 800f0d0:	ea23 0000 	bic.w	r0, r3, r0
 800f0d4:	e7f6      	b.n	800f0c4 <UTIL_LPM_SetOffMode+0x14>
 800f0d6:	bf00      	nop
 800f0d8:	2000182c 	.word	0x2000182c

0800f0dc <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 800f0dc:	b538      	push	{r3, r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f0de:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f0e2:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 800f0e4:	4b0a      	ldr	r3, [pc, #40]	; (800f110 <UTIL_LPM_EnterLowPower+0x34>)
 800f0e6:	4c0b      	ldr	r4, [pc, #44]	; (800f114 <UTIL_LPM_EnterLowPower+0x38>)
 800f0e8:	681b      	ldr	r3, [r3, #0]
 800f0ea:	b133      	cbz	r3, 800f0fa <UTIL_LPM_EnterLowPower+0x1e>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 800f0ec:	6823      	ldr	r3, [r4, #0]
 800f0ee:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 800f0f0:	6863      	ldr	r3, [r4, #4]
    {
      /**
       * OFF mode is required
       */
      UTIL_PowerDriver.EnterOffMode( );
      UTIL_PowerDriver.ExitOffMode( );
 800f0f2:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f0f4:	f385 8810 	msr	PRIMASK, r5
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 800f0f8:	bd38      	pop	{r3, r4, r5, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 800f0fa:	4b07      	ldr	r3, [pc, #28]	; (800f118 <UTIL_LPM_EnterLowPower+0x3c>)
 800f0fc:	681b      	ldr	r3, [r3, #0]
 800f0fe:	b11b      	cbz	r3, 800f108 <UTIL_LPM_EnterLowPower+0x2c>
        UTIL_PowerDriver.EnterStopMode( );
 800f100:	68a3      	ldr	r3, [r4, #8]
 800f102:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 800f104:	68e3      	ldr	r3, [r4, #12]
 800f106:	e7f4      	b.n	800f0f2 <UTIL_LPM_EnterLowPower+0x16>
      UTIL_PowerDriver.EnterOffMode( );
 800f108:	6923      	ldr	r3, [r4, #16]
 800f10a:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 800f10c:	6963      	ldr	r3, [r4, #20]
 800f10e:	e7f0      	b.n	800f0f2 <UTIL_LPM_EnterLowPower+0x16>
 800f110:	20001830 	.word	0x20001830
 800f114:	080103e4 	.word	0x080103e4
 800f118:	2000182c 	.word	0x2000182c

0800f11c <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 800f11c:	3801      	subs	r0, #1
 800f11e:	440a      	add	r2, r1
 800f120:	4291      	cmp	r1, r2
 800f122:	d100      	bne.n	800f126 <UTIL_MEM_cpy_8+0xa>
    {
        *dst8++ = *src8++;
    }
}
 800f124:	4770      	bx	lr
        *dst8++ = *src8++;
 800f126:	f811 3b01 	ldrb.w	r3, [r1], #1
 800f12a:	f800 3f01 	strb.w	r3, [r0, #1]!
 800f12e:	e7f7      	b.n	800f120 <UTIL_MEM_cpy_8+0x4>

0800f130 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 800f130:	4402      	add	r2, r0
 800f132:	4290      	cmp	r0, r2
 800f134:	d100      	bne.n	800f138 <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
  }
}
 800f136:	4770      	bx	lr
    *dst8++ = value;
 800f138:	f800 1b01 	strb.w	r1, [r0], #1
 800f13c:	e7f9      	b.n	800f132 <UTIL_MEM_set_8+0x2>
	...

0800f140 <UTIL_SEQ_SetTask>:

  return;
}

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
 800f140:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f142:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f146:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 800f148:	4a06      	ldr	r2, [pc, #24]	; (800f164 <UTIL_SEQ_SetTask+0x24>)
 800f14a:	6813      	ldr	r3, [r2, #0]
 800f14c:	4303      	orrs	r3, r0
 800f14e:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 800f150:	4a05      	ldr	r2, [pc, #20]	; (800f168 <UTIL_SEQ_SetTask+0x28>)
 800f152:	f852 3031 	ldr.w	r3, [r2, r1, lsl #3]
 800f156:	4318      	orrs	r0, r3
 800f158:	f842 0031 	str.w	r0, [r2, r1, lsl #3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f15c:	f384 8810 	msr	PRIMASK, r4

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 800f160:	bd10      	pop	{r4, pc}
 800f162:	bf00      	nop
 800f164:	200018d0 	.word	0x200018d0
 800f168:	200018c0 	.word	0x200018c0

0800f16c <UTIL_SEQ_PreIdle>:
 800f16c:	4770      	bx	lr

0800f16e <UTIL_SEQ_PostIdle>:
 800f16e:	4770      	bx	lr

0800f170 <SEQ_BitPosition>:
 */
uint8_t SEQ_BitPosition(uint32_t Value)
{
  uint8_t n = 0U;

  if ((Value & 0xFFFF0000U) == 0U)  { n  = 16U; Value <<= 16U;  }
 800f170:	0c03      	lsrs	r3, r0, #16
 800f172:	041b      	lsls	r3, r3, #16
 800f174:	b9c3      	cbnz	r3, 800f1a8 <SEQ_BitPosition+0x38>
 800f176:	0400      	lsls	r0, r0, #16
 800f178:	2310      	movs	r3, #16
  if ((Value & 0xFF000000U) == 0U)  { n +=  8U; Value <<=  8U;  }
 800f17a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 800f17e:	bf02      	ittt	eq
 800f180:	3308      	addeq	r3, #8
 800f182:	0200      	lsleq	r0, r0, #8
 800f184:	b2db      	uxtbeq	r3, r3
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 800f186:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 800f18a:	bf08      	it	eq
 800f18c:	0100      	lsleq	r0, r0, #4

  n += SEQ_clz_table_4bit[Value >> (32-4)];

  return (uint8_t)(31U-n);
 800f18e:	4a07      	ldr	r2, [pc, #28]	; (800f1ac <SEQ_BitPosition+0x3c>)
  n += SEQ_clz_table_4bit[Value >> (32-4)];
 800f190:	ea4f 7010 	mov.w	r0, r0, lsr #28
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 800f194:	bf08      	it	eq
 800f196:	3304      	addeq	r3, #4
  return (uint8_t)(31U-n);
 800f198:	5c10      	ldrb	r0, [r2, r0]
  if ((Value & 0xF0000000U) == 0U)  { n +=  4U; Value <<=  4U;  }
 800f19a:	bf08      	it	eq
 800f19c:	b2db      	uxtbeq	r3, r3
  return (uint8_t)(31U-n);
 800f19e:	f1c3 031f 	rsb	r3, r3, #31
 800f1a2:	1a18      	subs	r0, r3, r0
}
 800f1a4:	b2c0      	uxtb	r0, r0
 800f1a6:	4770      	bx	lr
  uint8_t n = 0U;
 800f1a8:	2300      	movs	r3, #0
 800f1aa:	e7e6      	b.n	800f17a <SEQ_BitPosition+0xa>
 800f1ac:	08011118 	.word	0x08011118

0800f1b0 <UTIL_SEQ_Run>:
{
 800f1b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  super_mask_backup = SuperMask;
 800f1b4:	4c3b      	ldr	r4, [pc, #236]	; (800f2a4 <UTIL_SEQ_Run+0xf4>)
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 800f1b6:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 800f2b4 <UTIL_SEQ_Run+0x104>
  super_mask_backup = SuperMask;
 800f1ba:	6826      	ldr	r6, [r4, #0]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 800f1bc:	4f3a      	ldr	r7, [pc, #232]	; (800f2a8 <UTIL_SEQ_Run+0xf8>)
  SuperMask &= Mask_bm;
 800f1be:	4030      	ands	r0, r6
 800f1c0:	6020      	str	r0, [r4, #0]
  while(((TaskSet & TaskMask & SuperMask) != 0U) && ((EvtSet & EvtWaited)==0U))
 800f1c2:	464d      	mov	r5, r9
 800f1c4:	683a      	ldr	r2, [r7, #0]
 800f1c6:	f8d9 3000 	ldr.w	r3, [r9]
 800f1ca:	6820      	ldr	r0, [r4, #0]
 800f1cc:	f8df 80e8 	ldr.w	r8, [pc, #232]	; 800f2b8 <UTIL_SEQ_Run+0x108>
 800f1d0:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 800f2bc <UTIL_SEQ_Run+0x10c>
 800f1d4:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 800f2c0 <UTIL_SEQ_Run+0x110>
 800f1d8:	4013      	ands	r3, r2
 800f1da:	4203      	tst	r3, r0
 800f1dc:	d044      	beq.n	800f268 <UTIL_SEQ_Run+0xb8>
 800f1de:	f8db 1000 	ldr.w	r1, [fp]
 800f1e2:	f8da 3000 	ldr.w	r3, [sl]
 800f1e6:	400b      	ands	r3, r1
 800f1e8:	d13e      	bne.n	800f268 <UTIL_SEQ_Run+0xb8>
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 800f1ea:	4930      	ldr	r1, [pc, #192]	; (800f2ac <UTIL_SEQ_Run+0xfc>)
 800f1ec:	4002      	ands	r2, r0
 800f1ee:	6808      	ldr	r0, [r1, #0]
 800f1f0:	4010      	ands	r0, r2
 800f1f2:	468a      	mov	sl, r1
 800f1f4:	d102      	bne.n	800f1fc <UTIL_SEQ_Run+0x4c>
 800f1f6:	6888      	ldr	r0, [r1, #8]
      counter++;
 800f1f8:	2301      	movs	r3, #1
    while((TaskPrio[counter].priority & TaskMask & SuperMask)== 0U)
 800f1fa:	4010      	ands	r0, r2
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 800f1fc:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 800f200:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 800f204:	44e2      	add	sl, ip
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 800f206:	685a      	ldr	r2, [r3, #4]
 800f208:	4210      	tst	r0, r2
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 800f20a:	bf04      	itt	eq
 800f20c:	f04f 32ff 	moveq.w	r2, #4294967295
 800f210:	605a      	streq	r2, [r3, #4]
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 800f212:	f8da b004 	ldr.w	fp, [sl, #4]
 800f216:	ea0b 0000 	and.w	r0, fp, r0
 800f21a:	f7ff ffa9 	bl	800f170 <SEQ_BitPosition>
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 800f21e:	2201      	movs	r2, #1
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 800f220:	f8c8 0000 	str.w	r0, [r8]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 800f224:	fa02 f000 	lsl.w	r0, r2, r0
 800f228:	ea2b 0000 	bic.w	r0, fp, r0
 800f22c:	f8ca 0004 	str.w	r0, [sl, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f230:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f234:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 800f236:	f8d8 3000 	ldr.w	r3, [r8]
 800f23a:	fa02 f003 	lsl.w	r0, r2, r3
 800f23e:	682a      	ldr	r2, [r5, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 800f240:	680b      	ldr	r3, [r1, #0]
    TaskSet &= ~(1U << CurrentTaskIdx);
 800f242:	ea22 0200 	bic.w	r2, r2, r0
 800f246:	602a      	str	r2, [r5, #0]
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 800f248:	688a      	ldr	r2, [r1, #8]
 800f24a:	ea23 0300 	bic.w	r3, r3, r0
 800f24e:	ea22 0200 	bic.w	r2, r2, r0
 800f252:	608a      	str	r2, [r1, #8]
 800f254:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f256:	f38c 8810 	msr	PRIMASK, ip
    TaskCb[CurrentTaskIdx]( );
 800f25a:	4b15      	ldr	r3, [pc, #84]	; (800f2b0 <UTIL_SEQ_Run+0x100>)
 800f25c:	f8d8 2000 	ldr.w	r2, [r8]
 800f260:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f264:	4798      	blx	r3
 800f266:	e7ad      	b.n	800f1c4 <UTIL_SEQ_Run+0x14>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 800f268:	f04f 33ff 	mov.w	r3, #4294967295
 800f26c:	f8c8 3000 	str.w	r3, [r8]
  UTIL_SEQ_PreIdle( );
 800f270:	f7ff ff7c 	bl	800f16c <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f274:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f278:	b672      	cpsid	i
  if (!(((TaskSet & TaskMask & SuperMask) != 0U) || ((EvtSet & EvtWaited)!= 0U))) 
 800f27a:	683a      	ldr	r2, [r7, #0]
 800f27c:	682b      	ldr	r3, [r5, #0]
 800f27e:	f8da 1000 	ldr.w	r1, [sl]
 800f282:	4013      	ands	r3, r2
 800f284:	6822      	ldr	r2, [r4, #0]
 800f286:	4013      	ands	r3, r2
 800f288:	f8db 2000 	ldr.w	r2, [fp]
 800f28c:	400a      	ands	r2, r1
 800f28e:	4313      	orrs	r3, r2
 800f290:	d101      	bne.n	800f296 <UTIL_SEQ_Run+0xe6>
	UTIL_SEQ_Idle( );
 800f292:	f7f2 f89f 	bl	80013d4 <UTIL_SEQ_Idle>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f296:	f388 8810 	msr	PRIMASK, r8
  UTIL_SEQ_PostIdle( );
 800f29a:	f7ff ff68 	bl	800f16e <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 800f29e:	6026      	str	r6, [r4, #0]
}
 800f2a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f2a4:	200000d4 	.word	0x200000d4
 800f2a8:	200000d8 	.word	0x200000d8
 800f2ac:	200018c0 	.word	0x200018c0
 800f2b0:	20001840 	.word	0x20001840
 800f2b4:	200018d0 	.word	0x200018d0
 800f2b8:	20001834 	.word	0x20001834
 800f2bc:	20001838 	.word	0x20001838
 800f2c0:	2000183c 	.word	0x2000183c

0800f2c4 <UTIL_SEQ_RegTask>:
{
 800f2c4:	b510      	push	{r4, lr}
 800f2c6:	4611      	mov	r1, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f2c8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f2cc:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 800f2ce:	f7ff ff4f 	bl	800f170 <SEQ_BitPosition>
 800f2d2:	4b03      	ldr	r3, [pc, #12]	; (800f2e0 <UTIL_SEQ_RegTask+0x1c>)
 800f2d4:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f2d8:	f384 8810 	msr	PRIMASK, r4
}
 800f2dc:	bd10      	pop	{r4, pc}
 800f2de:	bf00      	nop
 800f2e0:	20001840 	.word	0x20001840

0800f2e4 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 800f2e4:	b082      	sub	sp, #8
 800f2e6:	b082      	sub	sp, #8
 800f2e8:	f10d 0c08 	add.w	ip, sp, #8
 800f2ec:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds + b.Seconds;
 800f2f0:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 800f2f2:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 800f2f6:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds + b.Seconds;
 800f2f8:	4413      	add	r3, r2
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 800f2fa:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800f2fe:	440a      	add	r2, r1
 800f300:	b291      	uxth	r1, r2
 800f302:	b212      	sxth	r2, r2
  if( c.SubSeconds >= 1000 )
 800f304:	f5b2 7f7a 	cmp.w	r2, #1000	; 0x3e8
  {
    c.Seconds++;
    c.SubSeconds -= 1000;
 800f308:	bfa2      	ittt	ge
 800f30a:	f5a1 727a 	subge.w	r2, r1, #1000	; 0x3e8
    c.Seconds++;
 800f30e:	3301      	addge	r3, #1
    c.SubSeconds -= 1000;
 800f310:	b212      	sxthge	r2, r2
  }
  return c;
 800f312:	6003      	str	r3, [r0, #0]
 800f314:	8082      	strh	r2, [r0, #4]
}
 800f316:	b002      	add	sp, #8
 800f318:	b002      	add	sp, #8
 800f31a:	4770      	bx	lr

0800f31c <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 800f31c:	b082      	sub	sp, #8
 800f31e:	b082      	sub	sp, #8
 800f320:	f10d 0c08 	add.w	ip, sp, #8
 800f324:	e90c 0006 	stmdb	ip, {r1, r2}
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };

  c.Seconds = a.Seconds - b.Seconds;
 800f328:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f32a:	f8bd 1010 	ldrh.w	r1, [sp, #16]
{
 800f32e:	9303      	str	r3, [sp, #12]
  c.Seconds = a.Seconds - b.Seconds;
 800f330:	1ad3      	subs	r3, r2, r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f332:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 800f336:	1a52      	subs	r2, r2, r1
 800f338:	b291      	uxth	r1, r2
 800f33a:	b212      	sxth	r2, r2
  if( c.SubSeconds < 0 )
 800f33c:	2a00      	cmp	r2, #0
  {
    c.Seconds--;
    c.SubSeconds += 1000;
 800f33e:	bfbe      	ittt	lt
 800f340:	f501 727a 	addlt.w	r2, r1, #1000	; 0x3e8
    c.Seconds--;
 800f344:	f103 33ff 	addlt.w	r3, r3, #4294967295
    c.SubSeconds += 1000;
 800f348:	b212      	sxthlt	r2, r2
  }
  return c;
 800f34a:	6003      	str	r3, [r0, #0]
 800f34c:	8082      	strh	r2, [r0, #4]
}
 800f34e:	b002      	add	sp, #8
 800f350:	b002      	add	sp, #8
 800f352:	4770      	bx	lr

0800f354 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 800f354:	b530      	push	{r4, r5, lr}
 800f356:	b085      	sub	sp, #20
  SysTime_t DeltaTime;
  
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f358:	4d11      	ldr	r5, [pc, #68]	; (800f3a0 <SysTimeSet+0x4c>)
{
 800f35a:	466b      	mov	r3, sp
 800f35c:	e883 0003 	stmia.w	r3, {r0, r1}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 800f360:	2300      	movs	r3, #0
 800f362:	9302      	str	r3, [sp, #8]
 800f364:	f8ad 300c 	strh.w	r3, [sp, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f368:	a803      	add	r0, sp, #12
 800f36a:	692b      	ldr	r3, [r5, #16]
 800f36c:	4798      	blx	r3
  c.Seconds = a.Seconds - b.Seconds;
 800f36e:	9b00      	ldr	r3, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f370:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f374:	9002      	str	r0, [sp, #8]
  c.Seconds = a.Seconds - b.Seconds;
 800f376:	1a18      	subs	r0, r3, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f378:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 800f37c:	1ae4      	subs	r4, r4, r3
 800f37e:	b2a3      	uxth	r3, r4
 800f380:	b224      	sxth	r4, r4
  if( c.SubSeconds < 0 )
 800f382:	2c00      	cmp	r4, #0
    c.SubSeconds += 1000;
 800f384:	bfbe      	ittt	lt
 800f386:	f503 747a 	addlt.w	r4, r3, #1000	; 0x3e8
    c.Seconds--;
 800f38a:	f100 30ff 	addlt.w	r0, r0, #4294967295
    c.SubSeconds += 1000;
 800f38e:	b224      	sxthlt	r4, r4

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 800f390:	682b      	ldr	r3, [r5, #0]
 800f392:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 800f394:	68ab      	ldr	r3, [r5, #8]
 800f396:	4620      	mov	r0, r4
 800f398:	4798      	blx	r3
}
 800f39a:	b005      	add	sp, #20
 800f39c:	bd30      	pop	{r4, r5, pc}
 800f39e:	bf00      	nop
 800f3a0:	08010450 	.word	0x08010450

0800f3a4 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 800f3a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f3a6:	4e11      	ldr	r6, [pc, #68]	; (800f3ec <SysTimeGet+0x48>)
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 800f3a8:	2300      	movs	r3, #0
{
 800f3aa:	4605      	mov	r5, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 800f3ac:	9300      	str	r3, [sp, #0]
 800f3ae:	f8ad 3004 	strh.w	r3, [sp, #4]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f3b2:	a801      	add	r0, sp, #4
 800f3b4:	6933      	ldr	r3, [r6, #16]
 800f3b6:	4798      	blx	r3

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f3b8:	68f3      	ldr	r3, [r6, #12]
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f3ba:	9000      	str	r0, [sp, #0]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f3bc:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f3be:	6873      	ldr	r3, [r6, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f3c0:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f3c2:	4798      	blx	r3
  c.Seconds = a.Seconds + b.Seconds;
 800f3c4:	9b00      	ldr	r3, [sp, #0]
 800f3c6:	4418      	add	r0, r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 800f3c8:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800f3cc:	4423      	add	r3, r4
 800f3ce:	b29a      	uxth	r2, r3
 800f3d0:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 800f3d2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    c.Seconds++;
 800f3d6:	bfa2      	ittt	ge
 800f3d8:	3001      	addge	r0, #1
    c.SubSeconds -= 1000;
 800f3da:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
 800f3de:	b21b      	sxthge	r3, r3

  sysTime = SysTimeAdd( DeltaTime, calendarTime );

  return sysTime;
 800f3e0:	6028      	str	r0, [r5, #0]
}
 800f3e2:	4628      	mov	r0, r5
  return sysTime;
 800f3e4:	80ab      	strh	r3, [r5, #4]
}
 800f3e6:	b002      	add	sp, #8
 800f3e8:	bd70      	pop	{r4, r5, r6, pc}
 800f3ea:	bf00      	nop
 800f3ec:	08010450 	.word	0x08010450

0800f3f0 <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 800f3f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 800f3f2:	2300      	movs	r3, #0
 800f3f4:	9300      	str	r3, [sp, #0]
 800f3f6:	f8ad 3004 	strh.w	r3, [sp, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f3fa:	4b07      	ldr	r3, [pc, #28]	; (800f418 <SysTimeGetMcuTime+0x28>)
{
 800f3fc:	4604      	mov	r4, r0
  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 800f3fe:	691b      	ldr	r3, [r3, #16]
 800f400:	a801      	add	r0, sp, #4
 800f402:	4798      	blx	r3
 800f404:	466d      	mov	r5, sp
 800f406:	9000      	str	r0, [sp, #0]
  
  return calendarTime;
 800f408:	e895 0003 	ldmia.w	r5, {r0, r1}
 800f40c:	e884 0003 	stmia.w	r4, {r0, r1}
}
 800f410:	4620      	mov	r0, r4
 800f412:	b003      	add	sp, #12
 800f414:	bd30      	pop	{r4, r5, pc}
 800f416:	bf00      	nop
 800f418:	08010450 	.word	0x08010450

0800f41c <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 800f41c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f41e:	4d0e      	ldr	r5, [pc, #56]	; (800f458 <SysTimeToMs+0x3c>)
{
 800f420:	ab02      	add	r3, sp, #8
 800f422:	e903 0003 	stmdb	r3, {r0, r1}
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f426:	68eb      	ldr	r3, [r5, #12]
 800f428:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f42a:	686b      	ldr	r3, [r5, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f42c:	4604      	mov	r4, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f42e:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f430:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  c.Seconds = a.Seconds - b.Seconds;
 800f434:	9a00      	ldr	r2, [sp, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f436:	1b1b      	subs	r3, r3, r4
  c.Seconds = a.Seconds - b.Seconds;
 800f438:	1a12      	subs	r2, r2, r0
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 800f43a:	b298      	uxth	r0, r3
 800f43c:	b21b      	sxth	r3, r3
  if( c.SubSeconds < 0 )
 800f43e:	2b00      	cmp	r3, #0
    c.SubSeconds += 1000;
 800f440:	bfbe      	ittt	lt
 800f442:	f500 707a 	addlt.w	r0, r0, #1000	; 0x3e8
 800f446:	b203      	sxthlt	r3, r0
    c.Seconds--;
 800f448:	f102 32ff 	addlt.w	r2, r2, #4294967295
  
  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
}
 800f44c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f450:	fb00 3002 	mla	r0, r0, r2, r3
 800f454:	b003      	add	sp, #12
 800f456:	bd30      	pop	{r4, r5, pc}
 800f458:	08010450 	.word	0x08010450

0800f45c <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 800f45c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t seconds = timeMs / 1000;
 800f460:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
 800f464:	fbb1 f5f5 	udiv	r5, r1, r5
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 800f468:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  SysTime_t DeltaTime = { 0 };

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f46c:	f8df 803c 	ldr.w	r8, [pc, #60]	; 800f4ac <SysTimeFromMs+0x50>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 800f470:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800f474:	eba1 03c3 	sub.w	r3, r1, r3, lsl #3
 800f478:	b29c      	uxth	r4, r3
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f47a:	f8d8 300c 	ldr.w	r3, [r8, #12]
{
 800f47e:	4606      	mov	r6, r0
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f480:	4798      	blx	r3
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f482:	f8d8 3004 	ldr.w	r3, [r8, #4]
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 800f486:	4607      	mov	r7, r0
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 800f488:	4798      	blx	r3
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 800f48a:	19e3      	adds	r3, r4, r7
 800f48c:	b29a      	uxth	r2, r3
 800f48e:	b21b      	sxth	r3, r3
  if( c.SubSeconds >= 1000 )
 800f490:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  c.Seconds = a.Seconds + b.Seconds;
 800f494:	4405      	add	r5, r0
    c.SubSeconds -= 1000;
 800f496:	bfa2      	ittt	ge
 800f498:	f5a2 737a 	subge.w	r3, r2, #1000	; 0x3e8
    c.Seconds++;
 800f49c:	3501      	addge	r5, #1
    c.SubSeconds -= 1000;
 800f49e:	b21b      	sxthge	r3, r3
  return c;
 800f4a0:	6035      	str	r5, [r6, #0]
 800f4a2:	80b3      	strh	r3, [r6, #4]
  return SysTimeAdd( sysTime, DeltaTime );
}
 800f4a4:	4630      	mov	r0, r6
 800f4a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f4aa:	bf00      	nop
 800f4ac:	08010450 	.word	0x08010450

0800f4b0 <UTIL_TIMER_Init>:
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 800f4b0:	4b02      	ldr	r3, [pc, #8]	; (800f4bc <UTIL_TIMER_Init+0xc>)
 800f4b2:	2200      	movs	r2, #0
 800f4b4:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 800f4b6:	4b02      	ldr	r3, [pc, #8]	; (800f4c0 <UTIL_TIMER_Init+0x10>)
 800f4b8:	681b      	ldr	r3, [r3, #0]
 800f4ba:	4718      	bx	r3
 800f4bc:	200018d4 	.word	0x200018d4
 800f4c0:	08010464 	.word	0x08010464

0800f4c4 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 800f4c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f4c6:	4604      	mov	r4, r0
 800f4c8:	4617      	mov	r7, r2
 800f4ca:	4608      	mov	r0, r1
 800f4cc:	461e      	mov	r6, r3
  if((TimerObject != NULL) && (Callback != NULL))
 800f4ce:	b17c      	cbz	r4, 800f4f0 <UTIL_TIMER_Create+0x2c>
 800f4d0:	b173      	cbz	r3, 800f4f0 <UTIL_TIMER_Create+0x2c>
  {
    TimerObject->Timestamp = 0U;
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 800f4d2:	4b08      	ldr	r3, [pc, #32]	; (800f4f4 <UTIL_TIMER_Create+0x30>)
    TimerObject->Timestamp = 0U;
 800f4d4:	2500      	movs	r5, #0
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 800f4d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    TimerObject->Timestamp = 0U;
 800f4d8:	6025      	str	r5, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 800f4da:	4798      	blx	r3
    TimerObject->IsPending = 0U;
    TimerObject->IsRunning = 0U;
    TimerObject->IsReloadStopped = 0U;
    TimerObject->Callback = Callback;
    TimerObject->argument = Argument;
 800f4dc:	9b06      	ldr	r3, [sp, #24]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 800f4de:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 800f4e0:	8125      	strh	r5, [r4, #8]
    TimerObject->IsReloadStopped = 0U;
 800f4e2:	72a5      	strb	r5, [r4, #10]
    TimerObject->Callback = Callback;
 800f4e4:	60e6      	str	r6, [r4, #12]
    TimerObject->argument = Argument;
 800f4e6:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 800f4e8:	72e7      	strb	r7, [r4, #11]
    TimerObject->Next = NULL;
 800f4ea:	6165      	str	r5, [r4, #20]
    return UTIL_TIMER_OK;
 800f4ec:	4628      	mov	r0, r5
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 800f4ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 800f4f0:	2001      	movs	r0, #1
 800f4f2:	e7fc      	b.n	800f4ee <UTIL_TIMER_Create+0x2a>
 800f4f4:	08010464 	.word	0x08010464

0800f4f8 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 800f4f8:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 800f4fa:	4c03      	ldr	r4, [pc, #12]	; (800f508 <UTIL_TIMER_GetCurrentTime+0x10>)
 800f4fc:	69e3      	ldr	r3, [r4, #28]
 800f4fe:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 800f500:	6aa3      	ldr	r3, [r4, #40]	; 0x28
}
 800f502:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return  UTIL_TimerDriver.Tick2ms(now);
 800f506:	4718      	bx	r3
 800f508:	08010464 	.word	0x08010464

0800f50c <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 800f50c:	b570      	push	{r4, r5, r6, lr}
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 800f50e:	4d06      	ldr	r5, [pc, #24]	; (800f528 <UTIL_TIMER_GetElapsedTime+0x1c>)
 800f510:	69eb      	ldr	r3, [r5, #28]
{
 800f512:	4606      	mov	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 800f514:	4798      	blx	r3
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 800f516:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 800f518:	4604      	mov	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 800f51a:	4630      	mov	r0, r6
 800f51c:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 800f51e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800f520:	1a20      	subs	r0, r4, r0
}
 800f522:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 800f526:	4718      	bx	r3
 800f528:	08010464 	.word	0x08010464

0800f52c <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 800f52c:	4a05      	ldr	r2, [pc, #20]	; (800f544 <TimerExists+0x18>)
{
 800f52e:	4603      	mov	r3, r0
  UTIL_TIMER_Object_t* cur = TimerListHead;
 800f530:	6810      	ldr	r0, [r2, #0]

  while( cur != NULL )
 800f532:	b900      	cbnz	r0, 800f536 <TimerExists+0xa>
 800f534:	4770      	bx	lr
  {
    if( cur == TimerObject )
 800f536:	4298      	cmp	r0, r3
 800f538:	d001      	beq.n	800f53e <TimerExists+0x12>
    {
      return true;
    }
    cur = cur->Next;
 800f53a:	6940      	ldr	r0, [r0, #20]
 800f53c:	e7f9      	b.n	800f532 <TimerExists+0x6>
      return true;
 800f53e:	2001      	movs	r0, #1
  }
  return false;
}
 800f540:	4770      	bx	lr
 800f542:	bf00      	nop
 800f544:	200018d4 	.word	0x200018d4

0800f548 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 800f548:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 800f54c:	4d0b      	ldr	r5, [pc, #44]	; (800f57c <TimerSetTimeout+0x34>)
 800f54e:	6a2b      	ldr	r3, [r5, #32]
{
 800f550:	4604      	mov	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 800f552:	4798      	blx	r3
  TimerObject->IsPending = 1;
 800f554:	2301      	movs	r3, #1

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 800f556:	69af      	ldr	r7, [r5, #24]
  TimerObject->IsPending = 1;
 800f558:	7223      	strb	r3, [r4, #8]
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 800f55a:	f8d4 8000 	ldr.w	r8, [r4]
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 800f55e:	4606      	mov	r6, r0
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 800f560:	47b8      	blx	r7
 800f562:	4430      	add	r0, r6
 800f564:	4580      	cmp	r8, r0
 800f566:	d202      	bcs.n	800f56e <TimerSetTimeout+0x26>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 800f568:	47b8      	blx	r7
 800f56a:	4406      	add	r6, r0
 800f56c:	6026      	str	r6, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 800f56e:	68ab      	ldr	r3, [r5, #8]
 800f570:	6820      	ldr	r0, [r4, #0]
 800f572:	9301      	str	r3, [sp, #4]
}
 800f574:	b002      	add	sp, #8
 800f576:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 800f57a:	4718      	bx	r3
 800f57c:	08010464 	.word	0x08010464

0800f580 <UTIL_TIMER_Stop>:
{
 800f580:	b570      	push	{r4, r5, r6, lr}
  if (NULL != TimerObject)
 800f582:	b320      	cbz	r0, 800f5ce <UTIL_TIMER_Stop+0x4e>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f584:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f588:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 800f58a:	4d12      	ldr	r5, [pc, #72]	; (800f5d4 <UTIL_TIMER_Stop+0x54>)
 800f58c:	682b      	ldr	r3, [r5, #0]
    TimerObject->IsReloadStopped = 1U;
 800f58e:	2201      	movs	r2, #1
 800f590:	7282      	strb	r2, [r0, #10]
    if(NULL != TimerListHead)
 800f592:	b153      	cbz	r3, 800f5aa <UTIL_TIMER_Stop+0x2a>
      TimerObject->IsRunning = 0U;
 800f594:	2200      	movs	r2, #0
      if( TimerListHead == TimerObject ) /* Stop the Head */
 800f596:	4298      	cmp	r0, r3
      TimerObject->IsRunning = 0U;
 800f598:	7242      	strb	r2, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 800f59a:	d10f      	bne.n	800f5bc <UTIL_TIMER_Stop+0x3c>
 800f59c:	6944      	ldr	r4, [r0, #20]
          TimerListHead->IsPending = 0;
 800f59e:	7202      	strb	r2, [r0, #8]
          if( TimerListHead->Next != NULL )
 800f5a0:	b13c      	cbz	r4, 800f5b2 <UTIL_TIMER_Stop+0x32>
            TimerSetTimeout( TimerListHead );
 800f5a2:	4620      	mov	r0, r4
            TimerListHead = TimerListHead->Next;
 800f5a4:	602c      	str	r4, [r5, #0]
            TimerSetTimeout( TimerListHead );
 800f5a6:	f7ff ffcf 	bl	800f548 <TimerSetTimeout>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f5aa:	f386 8810 	msr	PRIMASK, r6
}
 800f5ae:	2000      	movs	r0, #0
}
 800f5b0:	bd70      	pop	{r4, r5, r6, pc}
            UTIL_TimerDriver.StopTimerEvt( );
 800f5b2:	4b09      	ldr	r3, [pc, #36]	; (800f5d8 <UTIL_TIMER_Stop+0x58>)
 800f5b4:	68db      	ldr	r3, [r3, #12]
 800f5b6:	4798      	blx	r3
            TimerListHead = NULL;
 800f5b8:	602c      	str	r4, [r5, #0]
 800f5ba:	e7f6      	b.n	800f5aa <UTIL_TIMER_Stop+0x2a>
            cur = cur->Next;
 800f5bc:	461a      	mov	r2, r3
 800f5be:	695b      	ldr	r3, [r3, #20]
        while( cur != NULL )
 800f5c0:	2b00      	cmp	r3, #0
 800f5c2:	d0f2      	beq.n	800f5aa <UTIL_TIMER_Stop+0x2a>
          if( cur == TimerObject )
 800f5c4:	4298      	cmp	r0, r3
 800f5c6:	d1f9      	bne.n	800f5bc <UTIL_TIMER_Stop+0x3c>
            if( cur->Next != NULL )
 800f5c8:	6943      	ldr	r3, [r0, #20]
              prev->Next = cur;
 800f5ca:	6153      	str	r3, [r2, #20]
 800f5cc:	e7ed      	b.n	800f5aa <UTIL_TIMER_Stop+0x2a>
    ret = UTIL_TIMER_INVALID_PARAM;
 800f5ce:	2001      	movs	r0, #1
 800f5d0:	e7ee      	b.n	800f5b0 <UTIL_TIMER_Stop+0x30>
 800f5d2:	bf00      	nop
 800f5d4:	200018d4 	.word	0x200018d4
 800f5d8:	08010464 	.word	0x08010464

0800f5dc <TimerInsertTimer>:
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 800f5dc:	4b09      	ldr	r3, [pc, #36]	; (800f604 <TimerInsertTimer+0x28>)
{
 800f5de:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 800f5e0:	681b      	ldr	r3, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 800f5e2:	695a      	ldr	r2, [r3, #20]

  while (cur->Next != NULL )
 800f5e4:	6959      	ldr	r1, [r3, #20]
 800f5e6:	b911      	cbnz	r1, 800f5ee <TimerInsertTimer+0x12>
        TimerObject->Next = next;
        return;

    }
  }
  cur->Next = TimerObject;
 800f5e8:	6158      	str	r0, [r3, #20]
  TimerObject->Next = NULL;
 800f5ea:	6141      	str	r1, [r0, #20]
 800f5ec:	e008      	b.n	800f600 <TimerInsertTimer+0x24>
    if( TimerObject->Timestamp  > next->Timestamp )
 800f5ee:	6804      	ldr	r4, [r0, #0]
 800f5f0:	6811      	ldr	r1, [r2, #0]
 800f5f2:	428c      	cmp	r4, r1
 800f5f4:	d902      	bls.n	800f5fc <TimerInsertTimer+0x20>
        next = next->Next;
 800f5f6:	4613      	mov	r3, r2
 800f5f8:	6952      	ldr	r2, [r2, #20]
 800f5fa:	e7f3      	b.n	800f5e4 <TimerInsertTimer+0x8>
        cur->Next = TimerObject;
 800f5fc:	6158      	str	r0, [r3, #20]
        TimerObject->Next = next;
 800f5fe:	6142      	str	r2, [r0, #20]
}
 800f600:	bd10      	pop	{r4, pc}
 800f602:	bf00      	nop
 800f604:	200018d4 	.word	0x200018d4

0800f608 <TimerInsertNewHeadTimer>:
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 800f608:	4b04      	ldr	r3, [pc, #16]	; (800f61c <TimerInsertNewHeadTimer+0x14>)
 800f60a:	681a      	ldr	r2, [r3, #0]

  if( cur != NULL )
 800f60c:	b10a      	cbz	r2, 800f612 <TimerInsertNewHeadTimer+0xa>
  {
    cur->IsPending = 0;
 800f60e:	2100      	movs	r1, #0
 800f610:	7211      	strb	r1, [r2, #8]
  }

  TimerObject->Next = cur;
 800f612:	6142      	str	r2, [r0, #20]
  TimerListHead = TimerObject;
 800f614:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 800f616:	f7ff bf97 	b.w	800f548 <TimerSetTimeout>
 800f61a:	bf00      	nop
 800f61c:	200018d4 	.word	0x200018d4

0800f620 <UTIL_TIMER_Start>:
{
 800f620:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 800f624:	4604      	mov	r4, r0
 800f626:	2800      	cmp	r0, #0
 800f628:	d02d      	beq.n	800f686 <UTIL_TIMER_Start+0x66>
 800f62a:	f7ff ff7f 	bl	800f52c <TimerExists>
 800f62e:	bb50      	cbnz	r0, 800f686 <UTIL_TIMER_Start+0x66>
 800f630:	7a65      	ldrb	r5, [r4, #9]
 800f632:	bb45      	cbnz	r5, 800f686 <UTIL_TIMER_Start+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f634:	f3ef 8810 	mrs	r8, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f638:	b672      	cpsid	i
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 800f63a:	4e14      	ldr	r6, [pc, #80]	; (800f68c <UTIL_TIMER_Start+0x6c>)
    ticks = TimerObject->ReloadValue;
 800f63c:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 800f63e:	6a33      	ldr	r3, [r6, #32]
 800f640:	4798      	blx	r3
    TimerObject->Timestamp = ticks;
 800f642:	4287      	cmp	r7, r0
 800f644:	bf2c      	ite	cs
 800f646:	6027      	strcs	r7, [r4, #0]
 800f648:	6020      	strcc	r0, [r4, #0]
    if( TimerListHead == NULL )
 800f64a:	4f11      	ldr	r7, [pc, #68]	; (800f690 <UTIL_TIMER_Start+0x70>)
    TimerObject->IsReloadStopped = 0U;
 800f64c:	72a5      	strb	r5, [r4, #10]
    TimerObject->IsPending = 0U;
 800f64e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800f652:	8123      	strh	r3, [r4, #8]
    if( TimerListHead == NULL )
 800f654:	683b      	ldr	r3, [r7, #0]
 800f656:	b94b      	cbnz	r3, 800f66c <UTIL_TIMER_Start+0x4c>
      UTIL_TimerDriver.SetTimerContext();
 800f658:	6933      	ldr	r3, [r6, #16]
 800f65a:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 800f65c:	4620      	mov	r0, r4
        TimerInsertNewHeadTimer( TimerObject);
 800f65e:	f7ff ffd3 	bl	800f608 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f662:	f388 8810 	msr	PRIMASK, r8
}
 800f666:	4628      	mov	r0, r5
 800f668:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 800f66c:	69b3      	ldr	r3, [r6, #24]
 800f66e:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 800f670:	6823      	ldr	r3, [r4, #0]
 800f672:	4418      	add	r0, r3
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 800f674:	683b      	ldr	r3, [r7, #0]
      TimerObject->Timestamp += elapsedTime;
 800f676:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 800f678:	681b      	ldr	r3, [r3, #0]
 800f67a:	4298      	cmp	r0, r3
        TimerInsertNewHeadTimer( TimerObject);
 800f67c:	4620      	mov	r0, r4
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 800f67e:	d3ee      	bcc.n	800f65e <UTIL_TIMER_Start+0x3e>
        TimerInsertTimer( TimerObject);
 800f680:	f7ff ffac 	bl	800f5dc <TimerInsertTimer>
 800f684:	e7ed      	b.n	800f662 <UTIL_TIMER_Start+0x42>
    ret =  UTIL_TIMER_INVALID_PARAM;
 800f686:	2501      	movs	r5, #1
 800f688:	e7ed      	b.n	800f666 <UTIL_TIMER_Start+0x46>
 800f68a:	bf00      	nop
 800f68c:	08010464 	.word	0x08010464
 800f690:	200018d4 	.word	0x200018d4

0800f694 <UTIL_TIMER_SetPeriod>:
{
 800f694:	b510      	push	{r4, lr}
 800f696:	4604      	mov	r4, r0
 800f698:	4608      	mov	r0, r1
  if(NULL == TimerObject)
 800f69a:	b17c      	cbz	r4, 800f6bc <UTIL_TIMER_SetPeriod+0x28>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 800f69c:	4b08      	ldr	r3, [pc, #32]	; (800f6c0 <UTIL_TIMER_SetPeriod+0x2c>)
 800f69e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800f6a0:	4798      	blx	r3
 800f6a2:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 800f6a4:	4620      	mov	r0, r4
 800f6a6:	f7ff ff41 	bl	800f52c <TimerExists>
 800f6aa:	b140      	cbz	r0, 800f6be <UTIL_TIMER_SetPeriod+0x2a>
      (void)UTIL_TIMER_Stop(TimerObject);
 800f6ac:	4620      	mov	r0, r4
 800f6ae:	f7ff ff67 	bl	800f580 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 800f6b2:	4620      	mov	r0, r4
}
 800f6b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      ret = UTIL_TIMER_Start(TimerObject);
 800f6b8:	f7ff bfb2 	b.w	800f620 <UTIL_TIMER_Start>
	  ret = UTIL_TIMER_INVALID_PARAM;
 800f6bc:	2001      	movs	r0, #1
}
 800f6be:	bd10      	pop	{r4, pc}
 800f6c0:	08010464 	.word	0x08010464

0800f6c4 <UTIL_TIMER_IRQ_Handler>:
{
 800f6c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800f6c8:	f3ef 8710 	mrs	r7, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 800f6cc:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 800f6ce:	4e1d      	ldr	r6, [pc, #116]	; (800f744 <UTIL_TIMER_IRQ_Handler+0x80>)
  if ( TimerListHead != NULL )
 800f6d0:	4c1d      	ldr	r4, [pc, #116]	; (800f748 <UTIL_TIMER_IRQ_Handler+0x84>)
  old  =  UTIL_TimerDriver.GetTimerContext( );
 800f6d2:	6973      	ldr	r3, [r6, #20]
 800f6d4:	4798      	blx	r3
  now  =  UTIL_TimerDriver.SetTimerContext( );
 800f6d6:	6933      	ldr	r3, [r6, #16]
  old  =  UTIL_TimerDriver.GetTimerContext( );
 800f6d8:	4605      	mov	r5, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 800f6da:	4798      	blx	r3
  if ( TimerListHead != NULL )
 800f6dc:	6823      	ldr	r3, [r4, #0]
 800f6de:	b94b      	cbnz	r3, 800f6f4 <UTIL_TIMER_IRQ_Handler+0x30>
      cur->IsPending = 0;
 800f6e0:	f04f 0800 	mov.w	r8, #0
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 800f6e4:	6823      	ldr	r3, [r4, #0]
 800f6e6:	b98b      	cbnz	r3, 800f70c <UTIL_TIMER_IRQ_Handler+0x48>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 800f6e8:	6820      	ldr	r0, [r4, #0]
 800f6ea:	bb28      	cbnz	r0, 800f738 <UTIL_TIMER_IRQ_Handler+0x74>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800f6ec:	f387 8810 	msr	PRIMASK, r7
}
 800f6f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DeltaContext = now  - old; /*intentional wrap around */
 800f6f4:	1b41      	subs	r1, r0, r5
        cur->Timestamp -= DeltaContext;
 800f6f6:	1a2d      	subs	r5, r5, r0
      if (cur->Timestamp > DeltaContext)
 800f6f8:	681a      	ldr	r2, [r3, #0]
 800f6fa:	428a      	cmp	r2, r1
        cur->Timestamp -= DeltaContext;
 800f6fc:	bf8c      	ite	hi
 800f6fe:	1952      	addhi	r2, r2, r5
        cur->Timestamp = 0;
 800f700:	2200      	movls	r2, #0
 800f702:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 800f704:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 800f706:	2b00      	cmp	r3, #0
 800f708:	d1f6      	bne.n	800f6f8 <UTIL_TIMER_IRQ_Handler+0x34>
 800f70a:	e7e9      	b.n	800f6e0 <UTIL_TIMER_IRQ_Handler+0x1c>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 800f70c:	681d      	ldr	r5, [r3, #0]
 800f70e:	b11d      	cbz	r5, 800f718 <UTIL_TIMER_IRQ_Handler+0x54>
 800f710:	69b3      	ldr	r3, [r6, #24]
 800f712:	4798      	blx	r3
 800f714:	4285      	cmp	r5, r0
 800f716:	d2e7      	bcs.n	800f6e8 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 800f718:	6825      	ldr	r5, [r4, #0]
      TimerListHead = TimerListHead->Next;
 800f71a:	696b      	ldr	r3, [r5, #20]
 800f71c:	6023      	str	r3, [r4, #0]
      cur->IsPending = 0;
 800f71e:	f8a5 8008 	strh.w	r8, [r5, #8]
      cur->Callback(cur->argument);
 800f722:	e9d5 3003 	ldrd	r3, r0, [r5, #12]
 800f726:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 800f728:	896b      	ldrh	r3, [r5, #10]
 800f72a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800f72e:	d1d9      	bne.n	800f6e4 <UTIL_TIMER_IRQ_Handler+0x20>
        (void)UTIL_TIMER_Start(cur);
 800f730:	4628      	mov	r0, r5
 800f732:	f7ff ff75 	bl	800f620 <UTIL_TIMER_Start>
 800f736:	e7d5      	b.n	800f6e4 <UTIL_TIMER_IRQ_Handler+0x20>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 800f738:	7a03      	ldrb	r3, [r0, #8]
 800f73a:	2b00      	cmp	r3, #0
 800f73c:	d1d6      	bne.n	800f6ec <UTIL_TIMER_IRQ_Handler+0x28>
    TimerSetTimeout( TimerListHead );
 800f73e:	f7ff ff03 	bl	800f548 <TimerSetTimeout>
 800f742:	e7d3      	b.n	800f6ec <UTIL_TIMER_IRQ_Handler+0x28>
 800f744:	08010464 	.word	0x08010464
 800f748:	200018d4 	.word	0x200018d4

0800f74c <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 800f74c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f750:	b099      	sub	sp, #100	; 0x64

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 800f752:	2900      	cmp	r1, #0
{
 800f754:	4683      	mov	fp, r0
  if (size <= 0)
 800f756:	9105      	str	r1, [sp, #20]
 800f758:	f340 8109 	ble.w	800f96e <tiny_vsnprintf_like+0x222>
  {
    return 0;
  }
  
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 800f75c:	4604      	mov	r4, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 800f75e:	f04f 0920 	mov.w	r9, #32
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 800f762:	9905      	ldr	r1, [sp, #20]
 800f764:	7815      	ldrb	r5, [r2, #0]
 800f766:	eba4 000b 	sub.w	r0, r4, fp
 800f76a:	3901      	subs	r1, #1
 800f76c:	b925      	cbnz	r5, 800f778 <tiny_vsnprintf_like+0x2c>
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
  }

  *str = '\0';
 800f76e:	2300      	movs	r3, #0
 800f770:	7023      	strb	r3, [r4, #0]
  return str - buf;
}
 800f772:	b019      	add	sp, #100	; 0x64
 800f774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CHECK_STR_SIZE(buf, str, size);
 800f778:	4288      	cmp	r0, r1
 800f77a:	daf8      	bge.n	800f76e <tiny_vsnprintf_like+0x22>
    if (*fmt != '%')
 800f77c:	2d25      	cmp	r5, #37	; 0x25
 800f77e:	d004      	beq.n	800f78a <tiny_vsnprintf_like+0x3e>
      *str++ = *fmt;
 800f780:	f804 5b01 	strb.w	r5, [r4], #1
      continue;
 800f784:	4616      	mov	r6, r2
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 800f786:	1c72      	adds	r2, r6, #1
 800f788:	e7eb      	b.n	800f762 <tiny_vsnprintf_like+0x16>
    if (*fmt == '0')
 800f78a:	f892 e001 	ldrb.w	lr, [r2, #1]
 800f78e:	1c56      	adds	r6, r2, #1
 800f790:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 800f794:	4250      	negs	r0, r2
 800f796:	4150      	adcs	r0, r2
    if (is_digit(*fmt))
 800f798:	f1ae 0230 	sub.w	r2, lr, #48	; 0x30
 800f79c:	2a09      	cmp	r2, #9
 800f79e:	d828      	bhi.n	800f7f2 <tiny_vsnprintf_like+0xa6>
 800f7a0:	4637      	mov	r7, r6
  int i = 0;
 800f7a2:	2500      	movs	r5, #0
 800f7a4:	463e      	mov	r6, r7
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 800f7a6:	f817 2b01 	ldrb.w	r2, [r7], #1
 800f7aa:	f1a2 0c30 	sub.w	ip, r2, #48	; 0x30
 800f7ae:	f1bc 0f09 	cmp.w	ip, #9
 800f7b2:	d919      	bls.n	800f7e8 <tiny_vsnprintf_like+0x9c>
    switch (*fmt)
 800f7b4:	7832      	ldrb	r2, [r6, #0]
 800f7b6:	2a69      	cmp	r2, #105	; 0x69
 800f7b8:	f000 8097 	beq.w	800f8ea <tiny_vsnprintf_like+0x19e>
 800f7bc:	d81c      	bhi.n	800f7f8 <tiny_vsnprintf_like+0xac>
 800f7be:	2a63      	cmp	r2, #99	; 0x63
 800f7c0:	d028      	beq.n	800f814 <tiny_vsnprintf_like+0xc8>
 800f7c2:	2a64      	cmp	r2, #100	; 0x64
 800f7c4:	f000 8091 	beq.w	800f8ea <tiny_vsnprintf_like+0x19e>
 800f7c8:	2a58      	cmp	r2, #88	; 0x58
 800f7ca:	d059      	beq.n	800f880 <tiny_vsnprintf_like+0x134>
        if (*fmt != '%') *str++ = '%';
 800f7cc:	2a25      	cmp	r2, #37	; 0x25
 800f7ce:	d119      	bne.n	800f804 <tiny_vsnprintf_like+0xb8>
        if (*fmt)
 800f7d0:	7832      	ldrb	r2, [r6, #0]
 800f7d2:	2a00      	cmp	r2, #0
 800f7d4:	f000 808d 	beq.w	800f8f2 <tiny_vsnprintf_like+0x1a6>
          *str++ = *fmt;
 800f7d8:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 800f7dc:	eba4 020b 	sub.w	r2, r4, fp
 800f7e0:	428a      	cmp	r2, r1
 800f7e2:	f280 8084 	bge.w	800f8ee <tiny_vsnprintf_like+0x1a2>
 800f7e6:	e7ce      	b.n	800f786 <tiny_vsnprintf_like+0x3a>
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 800f7e8:	260a      	movs	r6, #10
 800f7ea:	fb06 2505 	mla	r5, r6, r5, r2
 800f7ee:	3d30      	subs	r5, #48	; 0x30
 800f7f0:	e7d8      	b.n	800f7a4 <tiny_vsnprintf_like+0x58>
    field_width = -1;
 800f7f2:	f04f 35ff 	mov.w	r5, #4294967295
 800f7f6:	e7dd      	b.n	800f7b4 <tiny_vsnprintf_like+0x68>
    switch (*fmt)
 800f7f8:	2a75      	cmp	r2, #117	; 0x75
 800f7fa:	d078      	beq.n	800f8ee <tiny_vsnprintf_like+0x1a2>
 800f7fc:	2a78      	cmp	r2, #120	; 0x78
 800f7fe:	d041      	beq.n	800f884 <tiny_vsnprintf_like+0x138>
 800f800:	2a73      	cmp	r2, #115	; 0x73
 800f802:	d01c      	beq.n	800f83e <tiny_vsnprintf_like+0xf2>
        if (*fmt != '%') *str++ = '%';
 800f804:	2225      	movs	r2, #37	; 0x25
 800f806:	f804 2b01 	strb.w	r2, [r4], #1
        CHECK_STR_SIZE(buf, str, size);
 800f80a:	eba4 020b 	sub.w	r2, r4, fp
 800f80e:	428a      	cmp	r2, r1
 800f810:	da6d      	bge.n	800f8ee <tiny_vsnprintf_like+0x1a2>
 800f812:	e7dd      	b.n	800f7d0 <tiny_vsnprintf_like+0x84>
 800f814:	1e61      	subs	r1, r4, #1
    switch (*fmt)
 800f816:	462a      	mov	r2, r5
          while (--field_width > 0) *str++ = ' ';
 800f818:	3a01      	subs	r2, #1
 800f81a:	2a00      	cmp	r2, #0
 800f81c:	dc0c      	bgt.n	800f838 <tiny_vsnprintf_like+0xec>
 800f81e:	2d00      	cmp	r5, #0
 800f820:	f105 32ff 	add.w	r2, r5, #4294967295
 800f824:	bfd8      	it	le
 800f826:	2200      	movle	r2, #0
 800f828:	4422      	add	r2, r4
        *str++ = (unsigned char) va_arg(args, int);
 800f82a:	f853 1b04 	ldr.w	r1, [r3], #4
 800f82e:	7011      	strb	r1, [r2, #0]
 800f830:	bfd8      	it	le
 800f832:	2501      	movle	r5, #1
 800f834:	442c      	add	r4, r5
        continue;
 800f836:	e7a6      	b.n	800f786 <tiny_vsnprintf_like+0x3a>
          while (--field_width > 0) *str++ = ' ';
 800f838:	f801 9f01 	strb.w	r9, [r1, #1]!
 800f83c:	e7ec      	b.n	800f818 <tiny_vsnprintf_like+0xcc>
        s = va_arg(args, char *);
 800f83e:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 800f840:	4b4c      	ldr	r3, [pc, #304]	; (800f974 <tiny_vsnprintf_like+0x228>)
        s = va_arg(args, char *);
 800f842:	f858 7b04 	ldr.w	r7, [r8], #4
        if (!s) s = "<NULL>";
 800f846:	2f00      	cmp	r7, #0
 800f848:	bf08      	it	eq
 800f84a:	461f      	moveq	r7, r3
        len = strlen(s);
 800f84c:	4638      	mov	r0, r7
 800f84e:	f7f0 fc97 	bl	8000180 <strlen>
          while (len < field_width--) *str++ = ' ';
 800f852:	4623      	mov	r3, r4
 800f854:	1961      	adds	r1, r4, r5
 800f856:	1aca      	subs	r2, r1, r3
 800f858:	4290      	cmp	r0, r2
 800f85a:	db0a      	blt.n	800f872 <tiny_vsnprintf_like+0x126>
 800f85c:	1a2b      	subs	r3, r5, r0
 800f85e:	4285      	cmp	r5, r0
 800f860:	bfb8      	it	lt
 800f862:	2300      	movlt	r3, #0
 800f864:	441c      	add	r4, r3
        for (i = 0; i < len; ++i) *str++ = *s++;
 800f866:	2300      	movs	r3, #0
 800f868:	4283      	cmp	r3, r0
 800f86a:	db05      	blt.n	800f878 <tiny_vsnprintf_like+0x12c>
 800f86c:	4404      	add	r4, r0
        s = va_arg(args, char *);
 800f86e:	4643      	mov	r3, r8
 800f870:	e789      	b.n	800f786 <tiny_vsnprintf_like+0x3a>
          while (len < field_width--) *str++ = ' ';
 800f872:	f803 9b01 	strb.w	r9, [r3], #1
 800f876:	e7ee      	b.n	800f856 <tiny_vsnprintf_like+0x10a>
        for (i = 0; i < len; ++i) *str++ = *s++;
 800f878:	5cfa      	ldrb	r2, [r7, r3]
 800f87a:	54e2      	strb	r2, [r4, r3]
 800f87c:	3301      	adds	r3, #1
 800f87e:	e7f3      	b.n	800f868 <tiny_vsnprintf_like+0x11c>
        flags |= UPPERCASE;
 800f880:	f040 0040 	orr.w	r0, r0, #64	; 0x40
    switch (*fmt)
 800f884:	2710      	movs	r7, #16
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 800f886:	eba4 020b 	sub.w	r2, r4, fp
 800f88a:	9302      	str	r3, [sp, #8]
 800f88c:	1a8b      	subs	r3, r1, r2
 800f88e:	9301      	str	r3, [sp, #4]
 800f890:	9b02      	ldr	r3, [sp, #8]
  char *dig = lower_digits;
 800f892:	4a39      	ldr	r2, [pc, #228]	; (800f978 <tiny_vsnprintf_like+0x22c>)
    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 800f894:	f853 1b04 	ldr.w	r1, [r3], #4
 800f898:	9302      	str	r3, [sp, #8]
  char *dig = lower_digits;
 800f89a:	f010 0f40 	tst.w	r0, #64	; 0x40
 800f89e:	4b37      	ldr	r3, [pc, #220]	; (800f97c <tiny_vsnprintf_like+0x230>)
 800f8a0:	bf08      	it	eq
 800f8a2:	4613      	moveq	r3, r2
  c = (type & ZEROPAD) ? '0' : ' ';
 800f8a4:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  char *dig = lower_digits;
 800f8a8:	9303      	str	r3, [sp, #12]
  c = (type & ZEROPAD) ? '0' : ' ';
 800f8aa:	bf0c      	ite	eq
 800f8ac:	2330      	moveq	r3, #48	; 0x30
 800f8ae:	2320      	movne	r3, #32
 800f8b0:	9304      	str	r3, [sp, #16]
  if (type & SIGN)
 800f8b2:	0783      	lsls	r3, r0, #30
 800f8b4:	d51f      	bpl.n	800f8f6 <tiny_vsnprintf_like+0x1aa>
    if (num < 0)
 800f8b6:	2900      	cmp	r1, #0
 800f8b8:	da1d      	bge.n	800f8f6 <tiny_vsnprintf_like+0x1aa>
      num = -num;
 800f8ba:	4249      	negs	r1, r1
      size--;
 800f8bc:	3d01      	subs	r5, #1
      sign = '-';
 800f8be:	f04f 0c2d 	mov.w	ip, #45	; 0x2d
    while (num != 0)
 800f8c2:	ab07      	add	r3, sp, #28
 800f8c4:	461a      	mov	r2, r3
  i = 0;
 800f8c6:	2000      	movs	r0, #0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 800f8c8:	4688      	mov	r8, r1
 800f8ca:	9b03      	ldr	r3, [sp, #12]
 800f8cc:	fbb1 f1f7 	udiv	r1, r1, r7
 800f8d0:	fb07 8a11 	mls	sl, r7, r1, r8
    while (num != 0)
 800f8d4:	4547      	cmp	r7, r8
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 800f8d6:	f813 a00a 	ldrb.w	sl, [r3, sl]
 800f8da:	4613      	mov	r3, r2
 800f8dc:	f100 0001 	add.w	r0, r0, #1
 800f8e0:	f803 ab01 	strb.w	sl, [r3], #1
 800f8e4:	461a      	mov	r2, r3
    while (num != 0)
 800f8e6:	d9ef      	bls.n	800f8c8 <tiny_vsnprintf_like+0x17c>
 800f8e8:	e00e      	b.n	800f908 <tiny_vsnprintf_like+0x1bc>
        flags |= SIGN;
 800f8ea:	f040 0002 	orr.w	r0, r0, #2
    base = 10;
 800f8ee:	270a      	movs	r7, #10
 800f8f0:	e7c9      	b.n	800f886 <tiny_vsnprintf_like+0x13a>
          --fmt;
 800f8f2:	3e01      	subs	r6, #1
        CHECK_STR_SIZE(buf, str, size);
 800f8f4:	e747      	b.n	800f786 <tiny_vsnprintf_like+0x3a>
  if (num == 0)
 800f8f6:	b111      	cbz	r1, 800f8fe <tiny_vsnprintf_like+0x1b2>
 800f8f8:	f04f 0c00 	mov.w	ip, #0
 800f8fc:	e7e1      	b.n	800f8c2 <tiny_vsnprintf_like+0x176>
    tmp[i++] = '0';
 800f8fe:	2030      	movs	r0, #48	; 0x30
 800f900:	f88d 001c 	strb.w	r0, [sp, #28]
 800f904:	468c      	mov	ip, r1
 800f906:	2001      	movs	r0, #1
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 800f908:	f1be 0f30 	cmp.w	lr, #48	; 0x30
  size -= precision;
 800f90c:	eba5 0500 	sub.w	r5, r5, r0
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 800f910:	d110      	bne.n	800f934 <tiny_vsnprintf_like+0x1e8>
  if (sign) ASSIGN_STR(sign);
 800f912:	f1bc 0f00 	cmp.w	ip, #0
 800f916:	d028      	beq.n	800f96a <tiny_vsnprintf_like+0x21e>
 800f918:	9b01      	ldr	r3, [sp, #4]
 800f91a:	f804 cb01 	strb.w	ip, [r4], #1
 800f91e:	3b01      	subs	r3, #1
 800f920:	9301      	str	r3, [sp, #4]
 800f922:	d122      	bne.n	800f96a <tiny_vsnprintf_like+0x21e>
 800f924:	9b02      	ldr	r3, [sp, #8]
 800f926:	e72e      	b.n	800f786 <tiny_vsnprintf_like+0x3a>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 800f928:	9b01      	ldr	r3, [sp, #4]
 800f92a:	f804 9b01 	strb.w	r9, [r4], #1
 800f92e:	3b01      	subs	r3, #1
 800f930:	9301      	str	r3, [sp, #4]
 800f932:	d0f7      	beq.n	800f924 <tiny_vsnprintf_like+0x1d8>
 800f934:	2d00      	cmp	r5, #0
 800f936:	f105 35ff 	add.w	r5, r5, #4294967295
 800f93a:	dcf5      	bgt.n	800f928 <tiny_vsnprintf_like+0x1dc>
 800f93c:	e7e9      	b.n	800f912 <tiny_vsnprintf_like+0x1c6>
  while (size-- > 0) ASSIGN_STR(c);
 800f93e:	9b04      	ldr	r3, [sp, #16]
 800f940:	f804 3b01 	strb.w	r3, [r4], #1
 800f944:	9b01      	ldr	r3, [sp, #4]
 800f946:	3b01      	subs	r3, #1
 800f948:	9301      	str	r3, [sp, #4]
 800f94a:	d0eb      	beq.n	800f924 <tiny_vsnprintf_like+0x1d8>
 800f94c:	1b29      	subs	r1, r5, r4
 800f94e:	2900      	cmp	r1, #0
 800f950:	dcf5      	bgt.n	800f93e <tiny_vsnprintf_like+0x1f2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 800f952:	9b01      	ldr	r3, [sp, #4]
 800f954:	4423      	add	r3, r4
 800f956:	461a      	mov	r2, r3
 800f958:	3801      	subs	r0, #1
 800f95a:	d3e3      	bcc.n	800f924 <tiny_vsnprintf_like+0x1d8>
 800f95c:	ab07      	add	r3, sp, #28
 800f95e:	5c19      	ldrb	r1, [r3, r0]
 800f960:	f804 1b01 	strb.w	r1, [r4], #1
 800f964:	4294      	cmp	r4, r2
 800f966:	d1f7      	bne.n	800f958 <tiny_vsnprintf_like+0x20c>
 800f968:	e7dc      	b.n	800f924 <tiny_vsnprintf_like+0x1d8>
 800f96a:	4425      	add	r5, r4
 800f96c:	e7ee      	b.n	800f94c <tiny_vsnprintf_like+0x200>
    return 0;
 800f96e:	2000      	movs	r0, #0
 800f970:	e6ff      	b.n	800f772 <tiny_vsnprintf_like+0x26>
 800f972:	bf00      	nop
 800f974:	08011128 	.word	0x08011128
 800f978:	08011154 	.word	0x08011154
 800f97c:	0801112f 	.word	0x0801112f

0800f980 <__errno>:
 800f980:	4b01      	ldr	r3, [pc, #4]	; (800f988 <__errno+0x8>)
 800f982:	6818      	ldr	r0, [r3, #0]
 800f984:	4770      	bx	lr
 800f986:	bf00      	nop
 800f988:	200000dc 	.word	0x200000dc

0800f98c <__libc_init_array>:
 800f98c:	b570      	push	{r4, r5, r6, lr}
 800f98e:	4d0d      	ldr	r5, [pc, #52]	; (800f9c4 <__libc_init_array+0x38>)
 800f990:	4c0d      	ldr	r4, [pc, #52]	; (800f9c8 <__libc_init_array+0x3c>)
 800f992:	1b64      	subs	r4, r4, r5
 800f994:	10a4      	asrs	r4, r4, #2
 800f996:	2600      	movs	r6, #0
 800f998:	42a6      	cmp	r6, r4
 800f99a:	d109      	bne.n	800f9b0 <__libc_init_array+0x24>
 800f99c:	4d0b      	ldr	r5, [pc, #44]	; (800f9cc <__libc_init_array+0x40>)
 800f99e:	4c0c      	ldr	r4, [pc, #48]	; (800f9d0 <__libc_init_array+0x44>)
 800f9a0:	f000 fcce 	bl	8010340 <_init>
 800f9a4:	1b64      	subs	r4, r4, r5
 800f9a6:	10a4      	asrs	r4, r4, #2
 800f9a8:	2600      	movs	r6, #0
 800f9aa:	42a6      	cmp	r6, r4
 800f9ac:	d105      	bne.n	800f9ba <__libc_init_array+0x2e>
 800f9ae:	bd70      	pop	{r4, r5, r6, pc}
 800f9b0:	f855 3b04 	ldr.w	r3, [r5], #4
 800f9b4:	4798      	blx	r3
 800f9b6:	3601      	adds	r6, #1
 800f9b8:	e7ee      	b.n	800f998 <__libc_init_array+0xc>
 800f9ba:	f855 3b04 	ldr.w	r3, [r5], #4
 800f9be:	4798      	blx	r3
 800f9c0:	3601      	adds	r6, #1
 800f9c2:	e7f2      	b.n	800f9aa <__libc_init_array+0x1e>
 800f9c4:	080111b4 	.word	0x080111b4
 800f9c8:	080111b4 	.word	0x080111b4
 800f9cc:	080111b4 	.word	0x080111b4
 800f9d0:	080111b8 	.word	0x080111b8

0800f9d4 <memset>:
 800f9d4:	4402      	add	r2, r0
 800f9d6:	4603      	mov	r3, r0
 800f9d8:	4293      	cmp	r3, r2
 800f9da:	d100      	bne.n	800f9de <memset+0xa>
 800f9dc:	4770      	bx	lr
 800f9de:	f803 1b01 	strb.w	r1, [r3], #1
 800f9e2:	e7f9      	b.n	800f9d8 <memset+0x4>

0800f9e4 <_vsiprintf_r>:
 800f9e4:	b500      	push	{lr}
 800f9e6:	b09b      	sub	sp, #108	; 0x6c
 800f9e8:	9100      	str	r1, [sp, #0]
 800f9ea:	9104      	str	r1, [sp, #16]
 800f9ec:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800f9f0:	9105      	str	r1, [sp, #20]
 800f9f2:	9102      	str	r1, [sp, #8]
 800f9f4:	4905      	ldr	r1, [pc, #20]	; (800fa0c <_vsiprintf_r+0x28>)
 800f9f6:	9103      	str	r1, [sp, #12]
 800f9f8:	4669      	mov	r1, sp
 800f9fa:	f000 f86f 	bl	800fadc <_svfiprintf_r>
 800f9fe:	9b00      	ldr	r3, [sp, #0]
 800fa00:	2200      	movs	r2, #0
 800fa02:	701a      	strb	r2, [r3, #0]
 800fa04:	b01b      	add	sp, #108	; 0x6c
 800fa06:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa0a:	bf00      	nop
 800fa0c:	ffff0208 	.word	0xffff0208

0800fa10 <vsiprintf>:
 800fa10:	4613      	mov	r3, r2
 800fa12:	460a      	mov	r2, r1
 800fa14:	4601      	mov	r1, r0
 800fa16:	4802      	ldr	r0, [pc, #8]	; (800fa20 <vsiprintf+0x10>)
 800fa18:	6800      	ldr	r0, [r0, #0]
 800fa1a:	f7ff bfe3 	b.w	800f9e4 <_vsiprintf_r>
 800fa1e:	bf00      	nop
 800fa20:	200000dc 	.word	0x200000dc

0800fa24 <__ssputs_r>:
 800fa24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800fa28:	688e      	ldr	r6, [r1, #8]
 800fa2a:	429e      	cmp	r6, r3
 800fa2c:	4682      	mov	sl, r0
 800fa2e:	460c      	mov	r4, r1
 800fa30:	4690      	mov	r8, r2
 800fa32:	461f      	mov	r7, r3
 800fa34:	d838      	bhi.n	800faa8 <__ssputs_r+0x84>
 800fa36:	898a      	ldrh	r2, [r1, #12]
 800fa38:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800fa3c:	d032      	beq.n	800faa4 <__ssputs_r+0x80>
 800fa3e:	6825      	ldr	r5, [r4, #0]
 800fa40:	6909      	ldr	r1, [r1, #16]
 800fa42:	eba5 0901 	sub.w	r9, r5, r1
 800fa46:	6965      	ldr	r5, [r4, #20]
 800fa48:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800fa4c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 800fa50:	3301      	adds	r3, #1
 800fa52:	444b      	add	r3, r9
 800fa54:	106d      	asrs	r5, r5, #1
 800fa56:	429d      	cmp	r5, r3
 800fa58:	bf38      	it	cc
 800fa5a:	461d      	movcc	r5, r3
 800fa5c:	0553      	lsls	r3, r2, #21
 800fa5e:	d531      	bpl.n	800fac4 <__ssputs_r+0xa0>
 800fa60:	4629      	mov	r1, r5
 800fa62:	f000 fb45 	bl	80100f0 <_malloc_r>
 800fa66:	4606      	mov	r6, r0
 800fa68:	b950      	cbnz	r0, 800fa80 <__ssputs_r+0x5c>
 800fa6a:	230c      	movs	r3, #12
 800fa6c:	f8ca 3000 	str.w	r3, [sl]
 800fa70:	89a3      	ldrh	r3, [r4, #12]
 800fa72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800fa76:	81a3      	strh	r3, [r4, #12]
 800fa78:	f04f 30ff 	mov.w	r0, #4294967295
 800fa7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fa80:	6921      	ldr	r1, [r4, #16]
 800fa82:	464a      	mov	r2, r9
 800fa84:	f000 fabe 	bl	8010004 <memcpy>
 800fa88:	89a3      	ldrh	r3, [r4, #12]
 800fa8a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800fa8e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800fa92:	81a3      	strh	r3, [r4, #12]
 800fa94:	6126      	str	r6, [r4, #16]
 800fa96:	6165      	str	r5, [r4, #20]
 800fa98:	444e      	add	r6, r9
 800fa9a:	eba5 0509 	sub.w	r5, r5, r9
 800fa9e:	6026      	str	r6, [r4, #0]
 800faa0:	60a5      	str	r5, [r4, #8]
 800faa2:	463e      	mov	r6, r7
 800faa4:	42be      	cmp	r6, r7
 800faa6:	d900      	bls.n	800faaa <__ssputs_r+0x86>
 800faa8:	463e      	mov	r6, r7
 800faaa:	4632      	mov	r2, r6
 800faac:	6820      	ldr	r0, [r4, #0]
 800faae:	4641      	mov	r1, r8
 800fab0:	f000 fab6 	bl	8010020 <memmove>
 800fab4:	68a3      	ldr	r3, [r4, #8]
 800fab6:	6822      	ldr	r2, [r4, #0]
 800fab8:	1b9b      	subs	r3, r3, r6
 800faba:	4432      	add	r2, r6
 800fabc:	60a3      	str	r3, [r4, #8]
 800fabe:	6022      	str	r2, [r4, #0]
 800fac0:	2000      	movs	r0, #0
 800fac2:	e7db      	b.n	800fa7c <__ssputs_r+0x58>
 800fac4:	462a      	mov	r2, r5
 800fac6:	f000 fb6d 	bl	80101a4 <_realloc_r>
 800faca:	4606      	mov	r6, r0
 800facc:	2800      	cmp	r0, #0
 800face:	d1e1      	bne.n	800fa94 <__ssputs_r+0x70>
 800fad0:	6921      	ldr	r1, [r4, #16]
 800fad2:	4650      	mov	r0, sl
 800fad4:	f000 fabe 	bl	8010054 <_free_r>
 800fad8:	e7c7      	b.n	800fa6a <__ssputs_r+0x46>
	...

0800fadc <_svfiprintf_r>:
 800fadc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fae0:	4698      	mov	r8, r3
 800fae2:	898b      	ldrh	r3, [r1, #12]
 800fae4:	061b      	lsls	r3, r3, #24
 800fae6:	b09d      	sub	sp, #116	; 0x74
 800fae8:	4607      	mov	r7, r0
 800faea:	460d      	mov	r5, r1
 800faec:	4614      	mov	r4, r2
 800faee:	d50e      	bpl.n	800fb0e <_svfiprintf_r+0x32>
 800faf0:	690b      	ldr	r3, [r1, #16]
 800faf2:	b963      	cbnz	r3, 800fb0e <_svfiprintf_r+0x32>
 800faf4:	2140      	movs	r1, #64	; 0x40
 800faf6:	f000 fafb 	bl	80100f0 <_malloc_r>
 800fafa:	6028      	str	r0, [r5, #0]
 800fafc:	6128      	str	r0, [r5, #16]
 800fafe:	b920      	cbnz	r0, 800fb0a <_svfiprintf_r+0x2e>
 800fb00:	230c      	movs	r3, #12
 800fb02:	603b      	str	r3, [r7, #0]
 800fb04:	f04f 30ff 	mov.w	r0, #4294967295
 800fb08:	e0d1      	b.n	800fcae <_svfiprintf_r+0x1d2>
 800fb0a:	2340      	movs	r3, #64	; 0x40
 800fb0c:	616b      	str	r3, [r5, #20]
 800fb0e:	2300      	movs	r3, #0
 800fb10:	9309      	str	r3, [sp, #36]	; 0x24
 800fb12:	2320      	movs	r3, #32
 800fb14:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800fb18:	f8cd 800c 	str.w	r8, [sp, #12]
 800fb1c:	2330      	movs	r3, #48	; 0x30
 800fb1e:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 800fcc8 <_svfiprintf_r+0x1ec>
 800fb22:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800fb26:	f04f 0901 	mov.w	r9, #1
 800fb2a:	4623      	mov	r3, r4
 800fb2c:	469a      	mov	sl, r3
 800fb2e:	f813 2b01 	ldrb.w	r2, [r3], #1
 800fb32:	b10a      	cbz	r2, 800fb38 <_svfiprintf_r+0x5c>
 800fb34:	2a25      	cmp	r2, #37	; 0x25
 800fb36:	d1f9      	bne.n	800fb2c <_svfiprintf_r+0x50>
 800fb38:	ebba 0b04 	subs.w	fp, sl, r4
 800fb3c:	d00b      	beq.n	800fb56 <_svfiprintf_r+0x7a>
 800fb3e:	465b      	mov	r3, fp
 800fb40:	4622      	mov	r2, r4
 800fb42:	4629      	mov	r1, r5
 800fb44:	4638      	mov	r0, r7
 800fb46:	f7ff ff6d 	bl	800fa24 <__ssputs_r>
 800fb4a:	3001      	adds	r0, #1
 800fb4c:	f000 80aa 	beq.w	800fca4 <_svfiprintf_r+0x1c8>
 800fb50:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800fb52:	445a      	add	r2, fp
 800fb54:	9209      	str	r2, [sp, #36]	; 0x24
 800fb56:	f89a 3000 	ldrb.w	r3, [sl]
 800fb5a:	2b00      	cmp	r3, #0
 800fb5c:	f000 80a2 	beq.w	800fca4 <_svfiprintf_r+0x1c8>
 800fb60:	2300      	movs	r3, #0
 800fb62:	f04f 32ff 	mov.w	r2, #4294967295
 800fb66:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800fb6a:	f10a 0a01 	add.w	sl, sl, #1
 800fb6e:	9304      	str	r3, [sp, #16]
 800fb70:	9307      	str	r3, [sp, #28]
 800fb72:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800fb76:	931a      	str	r3, [sp, #104]	; 0x68
 800fb78:	4654      	mov	r4, sl
 800fb7a:	2205      	movs	r2, #5
 800fb7c:	f814 1b01 	ldrb.w	r1, [r4], #1
 800fb80:	4851      	ldr	r0, [pc, #324]	; (800fcc8 <_svfiprintf_r+0x1ec>)
 800fb82:	f7f0 fb05 	bl	8000190 <memchr>
 800fb86:	9a04      	ldr	r2, [sp, #16]
 800fb88:	b9d8      	cbnz	r0, 800fbc2 <_svfiprintf_r+0xe6>
 800fb8a:	06d0      	lsls	r0, r2, #27
 800fb8c:	bf44      	itt	mi
 800fb8e:	2320      	movmi	r3, #32
 800fb90:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800fb94:	0711      	lsls	r1, r2, #28
 800fb96:	bf44      	itt	mi
 800fb98:	232b      	movmi	r3, #43	; 0x2b
 800fb9a:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 800fb9e:	f89a 3000 	ldrb.w	r3, [sl]
 800fba2:	2b2a      	cmp	r3, #42	; 0x2a
 800fba4:	d015      	beq.n	800fbd2 <_svfiprintf_r+0xf6>
 800fba6:	9a07      	ldr	r2, [sp, #28]
 800fba8:	4654      	mov	r4, sl
 800fbaa:	2000      	movs	r0, #0
 800fbac:	f04f 0c0a 	mov.w	ip, #10
 800fbb0:	4621      	mov	r1, r4
 800fbb2:	f811 3b01 	ldrb.w	r3, [r1], #1
 800fbb6:	3b30      	subs	r3, #48	; 0x30
 800fbb8:	2b09      	cmp	r3, #9
 800fbba:	d94e      	bls.n	800fc5a <_svfiprintf_r+0x17e>
 800fbbc:	b1b0      	cbz	r0, 800fbec <_svfiprintf_r+0x110>
 800fbbe:	9207      	str	r2, [sp, #28]
 800fbc0:	e014      	b.n	800fbec <_svfiprintf_r+0x110>
 800fbc2:	eba0 0308 	sub.w	r3, r0, r8
 800fbc6:	fa09 f303 	lsl.w	r3, r9, r3
 800fbca:	4313      	orrs	r3, r2
 800fbcc:	9304      	str	r3, [sp, #16]
 800fbce:	46a2      	mov	sl, r4
 800fbd0:	e7d2      	b.n	800fb78 <_svfiprintf_r+0x9c>
 800fbd2:	9b03      	ldr	r3, [sp, #12]
 800fbd4:	1d19      	adds	r1, r3, #4
 800fbd6:	681b      	ldr	r3, [r3, #0]
 800fbd8:	9103      	str	r1, [sp, #12]
 800fbda:	2b00      	cmp	r3, #0
 800fbdc:	bfbb      	ittet	lt
 800fbde:	425b      	neglt	r3, r3
 800fbe0:	f042 0202 	orrlt.w	r2, r2, #2
 800fbe4:	9307      	strge	r3, [sp, #28]
 800fbe6:	9307      	strlt	r3, [sp, #28]
 800fbe8:	bfb8      	it	lt
 800fbea:	9204      	strlt	r2, [sp, #16]
 800fbec:	7823      	ldrb	r3, [r4, #0]
 800fbee:	2b2e      	cmp	r3, #46	; 0x2e
 800fbf0:	d10c      	bne.n	800fc0c <_svfiprintf_r+0x130>
 800fbf2:	7863      	ldrb	r3, [r4, #1]
 800fbf4:	2b2a      	cmp	r3, #42	; 0x2a
 800fbf6:	d135      	bne.n	800fc64 <_svfiprintf_r+0x188>
 800fbf8:	9b03      	ldr	r3, [sp, #12]
 800fbfa:	1d1a      	adds	r2, r3, #4
 800fbfc:	681b      	ldr	r3, [r3, #0]
 800fbfe:	9203      	str	r2, [sp, #12]
 800fc00:	2b00      	cmp	r3, #0
 800fc02:	bfb8      	it	lt
 800fc04:	f04f 33ff 	movlt.w	r3, #4294967295
 800fc08:	3402      	adds	r4, #2
 800fc0a:	9305      	str	r3, [sp, #20]
 800fc0c:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 800fcd8 <_svfiprintf_r+0x1fc>
 800fc10:	7821      	ldrb	r1, [r4, #0]
 800fc12:	2203      	movs	r2, #3
 800fc14:	4650      	mov	r0, sl
 800fc16:	f7f0 fabb 	bl	8000190 <memchr>
 800fc1a:	b140      	cbz	r0, 800fc2e <_svfiprintf_r+0x152>
 800fc1c:	2340      	movs	r3, #64	; 0x40
 800fc1e:	eba0 000a 	sub.w	r0, r0, sl
 800fc22:	fa03 f000 	lsl.w	r0, r3, r0
 800fc26:	9b04      	ldr	r3, [sp, #16]
 800fc28:	4303      	orrs	r3, r0
 800fc2a:	3401      	adds	r4, #1
 800fc2c:	9304      	str	r3, [sp, #16]
 800fc2e:	f814 1b01 	ldrb.w	r1, [r4], #1
 800fc32:	4826      	ldr	r0, [pc, #152]	; (800fccc <_svfiprintf_r+0x1f0>)
 800fc34:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800fc38:	2206      	movs	r2, #6
 800fc3a:	f7f0 faa9 	bl	8000190 <memchr>
 800fc3e:	2800      	cmp	r0, #0
 800fc40:	d038      	beq.n	800fcb4 <_svfiprintf_r+0x1d8>
 800fc42:	4b23      	ldr	r3, [pc, #140]	; (800fcd0 <_svfiprintf_r+0x1f4>)
 800fc44:	bb1b      	cbnz	r3, 800fc8e <_svfiprintf_r+0x1b2>
 800fc46:	9b03      	ldr	r3, [sp, #12]
 800fc48:	3307      	adds	r3, #7
 800fc4a:	f023 0307 	bic.w	r3, r3, #7
 800fc4e:	3308      	adds	r3, #8
 800fc50:	9303      	str	r3, [sp, #12]
 800fc52:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fc54:	4433      	add	r3, r6
 800fc56:	9309      	str	r3, [sp, #36]	; 0x24
 800fc58:	e767      	b.n	800fb2a <_svfiprintf_r+0x4e>
 800fc5a:	fb0c 3202 	mla	r2, ip, r2, r3
 800fc5e:	460c      	mov	r4, r1
 800fc60:	2001      	movs	r0, #1
 800fc62:	e7a5      	b.n	800fbb0 <_svfiprintf_r+0xd4>
 800fc64:	2300      	movs	r3, #0
 800fc66:	3401      	adds	r4, #1
 800fc68:	9305      	str	r3, [sp, #20]
 800fc6a:	4619      	mov	r1, r3
 800fc6c:	f04f 0c0a 	mov.w	ip, #10
 800fc70:	4620      	mov	r0, r4
 800fc72:	f810 2b01 	ldrb.w	r2, [r0], #1
 800fc76:	3a30      	subs	r2, #48	; 0x30
 800fc78:	2a09      	cmp	r2, #9
 800fc7a:	d903      	bls.n	800fc84 <_svfiprintf_r+0x1a8>
 800fc7c:	2b00      	cmp	r3, #0
 800fc7e:	d0c5      	beq.n	800fc0c <_svfiprintf_r+0x130>
 800fc80:	9105      	str	r1, [sp, #20]
 800fc82:	e7c3      	b.n	800fc0c <_svfiprintf_r+0x130>
 800fc84:	fb0c 2101 	mla	r1, ip, r1, r2
 800fc88:	4604      	mov	r4, r0
 800fc8a:	2301      	movs	r3, #1
 800fc8c:	e7f0      	b.n	800fc70 <_svfiprintf_r+0x194>
 800fc8e:	ab03      	add	r3, sp, #12
 800fc90:	9300      	str	r3, [sp, #0]
 800fc92:	462a      	mov	r2, r5
 800fc94:	4b0f      	ldr	r3, [pc, #60]	; (800fcd4 <_svfiprintf_r+0x1f8>)
 800fc96:	a904      	add	r1, sp, #16
 800fc98:	4638      	mov	r0, r7
 800fc9a:	f3af 8000 	nop.w
 800fc9e:	1c42      	adds	r2, r0, #1
 800fca0:	4606      	mov	r6, r0
 800fca2:	d1d6      	bne.n	800fc52 <_svfiprintf_r+0x176>
 800fca4:	89ab      	ldrh	r3, [r5, #12]
 800fca6:	065b      	lsls	r3, r3, #25
 800fca8:	f53f af2c 	bmi.w	800fb04 <_svfiprintf_r+0x28>
 800fcac:	9809      	ldr	r0, [sp, #36]	; 0x24
 800fcae:	b01d      	add	sp, #116	; 0x74
 800fcb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800fcb4:	ab03      	add	r3, sp, #12
 800fcb6:	9300      	str	r3, [sp, #0]
 800fcb8:	462a      	mov	r2, r5
 800fcba:	4b06      	ldr	r3, [pc, #24]	; (800fcd4 <_svfiprintf_r+0x1f8>)
 800fcbc:	a904      	add	r1, sp, #16
 800fcbe:	4638      	mov	r0, r7
 800fcc0:	f000 f87a 	bl	800fdb8 <_printf_i>
 800fcc4:	e7eb      	b.n	800fc9e <_svfiprintf_r+0x1c2>
 800fcc6:	bf00      	nop
 800fcc8:	08011179 	.word	0x08011179
 800fccc:	08011183 	.word	0x08011183
 800fcd0:	00000000 	.word	0x00000000
 800fcd4:	0800fa25 	.word	0x0800fa25
 800fcd8:	0801117f 	.word	0x0801117f

0800fcdc <_printf_common>:
 800fcdc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800fce0:	4616      	mov	r6, r2
 800fce2:	4699      	mov	r9, r3
 800fce4:	688a      	ldr	r2, [r1, #8]
 800fce6:	690b      	ldr	r3, [r1, #16]
 800fce8:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800fcec:	4293      	cmp	r3, r2
 800fcee:	bfb8      	it	lt
 800fcf0:	4613      	movlt	r3, r2
 800fcf2:	6033      	str	r3, [r6, #0]
 800fcf4:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800fcf8:	4607      	mov	r7, r0
 800fcfa:	460c      	mov	r4, r1
 800fcfc:	b10a      	cbz	r2, 800fd02 <_printf_common+0x26>
 800fcfe:	3301      	adds	r3, #1
 800fd00:	6033      	str	r3, [r6, #0]
 800fd02:	6823      	ldr	r3, [r4, #0]
 800fd04:	0699      	lsls	r1, r3, #26
 800fd06:	bf42      	ittt	mi
 800fd08:	6833      	ldrmi	r3, [r6, #0]
 800fd0a:	3302      	addmi	r3, #2
 800fd0c:	6033      	strmi	r3, [r6, #0]
 800fd0e:	6825      	ldr	r5, [r4, #0]
 800fd10:	f015 0506 	ands.w	r5, r5, #6
 800fd14:	d106      	bne.n	800fd24 <_printf_common+0x48>
 800fd16:	f104 0a19 	add.w	sl, r4, #25
 800fd1a:	68e3      	ldr	r3, [r4, #12]
 800fd1c:	6832      	ldr	r2, [r6, #0]
 800fd1e:	1a9b      	subs	r3, r3, r2
 800fd20:	42ab      	cmp	r3, r5
 800fd22:	dc26      	bgt.n	800fd72 <_printf_common+0x96>
 800fd24:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 800fd28:	1e13      	subs	r3, r2, #0
 800fd2a:	6822      	ldr	r2, [r4, #0]
 800fd2c:	bf18      	it	ne
 800fd2e:	2301      	movne	r3, #1
 800fd30:	0692      	lsls	r2, r2, #26
 800fd32:	d42b      	bmi.n	800fd8c <_printf_common+0xb0>
 800fd34:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800fd38:	4649      	mov	r1, r9
 800fd3a:	4638      	mov	r0, r7
 800fd3c:	47c0      	blx	r8
 800fd3e:	3001      	adds	r0, #1
 800fd40:	d01e      	beq.n	800fd80 <_printf_common+0xa4>
 800fd42:	6823      	ldr	r3, [r4, #0]
 800fd44:	68e5      	ldr	r5, [r4, #12]
 800fd46:	6832      	ldr	r2, [r6, #0]
 800fd48:	f003 0306 	and.w	r3, r3, #6
 800fd4c:	2b04      	cmp	r3, #4
 800fd4e:	bf08      	it	eq
 800fd50:	1aad      	subeq	r5, r5, r2
 800fd52:	68a3      	ldr	r3, [r4, #8]
 800fd54:	6922      	ldr	r2, [r4, #16]
 800fd56:	bf0c      	ite	eq
 800fd58:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800fd5c:	2500      	movne	r5, #0
 800fd5e:	4293      	cmp	r3, r2
 800fd60:	bfc4      	itt	gt
 800fd62:	1a9b      	subgt	r3, r3, r2
 800fd64:	18ed      	addgt	r5, r5, r3
 800fd66:	2600      	movs	r6, #0
 800fd68:	341a      	adds	r4, #26
 800fd6a:	42b5      	cmp	r5, r6
 800fd6c:	d11a      	bne.n	800fda4 <_printf_common+0xc8>
 800fd6e:	2000      	movs	r0, #0
 800fd70:	e008      	b.n	800fd84 <_printf_common+0xa8>
 800fd72:	2301      	movs	r3, #1
 800fd74:	4652      	mov	r2, sl
 800fd76:	4649      	mov	r1, r9
 800fd78:	4638      	mov	r0, r7
 800fd7a:	47c0      	blx	r8
 800fd7c:	3001      	adds	r0, #1
 800fd7e:	d103      	bne.n	800fd88 <_printf_common+0xac>
 800fd80:	f04f 30ff 	mov.w	r0, #4294967295
 800fd84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fd88:	3501      	adds	r5, #1
 800fd8a:	e7c6      	b.n	800fd1a <_printf_common+0x3e>
 800fd8c:	18e1      	adds	r1, r4, r3
 800fd8e:	1c5a      	adds	r2, r3, #1
 800fd90:	2030      	movs	r0, #48	; 0x30
 800fd92:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800fd96:	4422      	add	r2, r4
 800fd98:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800fd9c:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800fda0:	3302      	adds	r3, #2
 800fda2:	e7c7      	b.n	800fd34 <_printf_common+0x58>
 800fda4:	2301      	movs	r3, #1
 800fda6:	4622      	mov	r2, r4
 800fda8:	4649      	mov	r1, r9
 800fdaa:	4638      	mov	r0, r7
 800fdac:	47c0      	blx	r8
 800fdae:	3001      	adds	r0, #1
 800fdb0:	d0e6      	beq.n	800fd80 <_printf_common+0xa4>
 800fdb2:	3601      	adds	r6, #1
 800fdb4:	e7d9      	b.n	800fd6a <_printf_common+0x8e>
	...

0800fdb8 <_printf_i>:
 800fdb8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800fdbc:	460c      	mov	r4, r1
 800fdbe:	4691      	mov	r9, r2
 800fdc0:	7e27      	ldrb	r7, [r4, #24]
 800fdc2:	990c      	ldr	r1, [sp, #48]	; 0x30
 800fdc4:	2f78      	cmp	r7, #120	; 0x78
 800fdc6:	4680      	mov	r8, r0
 800fdc8:	469a      	mov	sl, r3
 800fdca:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800fdce:	d807      	bhi.n	800fde0 <_printf_i+0x28>
 800fdd0:	2f62      	cmp	r7, #98	; 0x62
 800fdd2:	d80a      	bhi.n	800fdea <_printf_i+0x32>
 800fdd4:	2f00      	cmp	r7, #0
 800fdd6:	f000 80d8 	beq.w	800ff8a <_printf_i+0x1d2>
 800fdda:	2f58      	cmp	r7, #88	; 0x58
 800fddc:	f000 80a3 	beq.w	800ff26 <_printf_i+0x16e>
 800fde0:	f104 0642 	add.w	r6, r4, #66	; 0x42
 800fde4:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 800fde8:	e03a      	b.n	800fe60 <_printf_i+0xa8>
 800fdea:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 800fdee:	2b15      	cmp	r3, #21
 800fdf0:	d8f6      	bhi.n	800fde0 <_printf_i+0x28>
 800fdf2:	a001      	add	r0, pc, #4	; (adr r0, 800fdf8 <_printf_i+0x40>)
 800fdf4:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 800fdf8:	0800fe51 	.word	0x0800fe51
 800fdfc:	0800fe65 	.word	0x0800fe65
 800fe00:	0800fde1 	.word	0x0800fde1
 800fe04:	0800fde1 	.word	0x0800fde1
 800fe08:	0800fde1 	.word	0x0800fde1
 800fe0c:	0800fde1 	.word	0x0800fde1
 800fe10:	0800fe65 	.word	0x0800fe65
 800fe14:	0800fde1 	.word	0x0800fde1
 800fe18:	0800fde1 	.word	0x0800fde1
 800fe1c:	0800fde1 	.word	0x0800fde1
 800fe20:	0800fde1 	.word	0x0800fde1
 800fe24:	0800ff71 	.word	0x0800ff71
 800fe28:	0800fe95 	.word	0x0800fe95
 800fe2c:	0800ff53 	.word	0x0800ff53
 800fe30:	0800fde1 	.word	0x0800fde1
 800fe34:	0800fde1 	.word	0x0800fde1
 800fe38:	0800ff93 	.word	0x0800ff93
 800fe3c:	0800fde1 	.word	0x0800fde1
 800fe40:	0800fe95 	.word	0x0800fe95
 800fe44:	0800fde1 	.word	0x0800fde1
 800fe48:	0800fde1 	.word	0x0800fde1
 800fe4c:	0800ff5b 	.word	0x0800ff5b
 800fe50:	680b      	ldr	r3, [r1, #0]
 800fe52:	1d1a      	adds	r2, r3, #4
 800fe54:	681b      	ldr	r3, [r3, #0]
 800fe56:	600a      	str	r2, [r1, #0]
 800fe58:	f104 0642 	add.w	r6, r4, #66	; 0x42
 800fe5c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800fe60:	2301      	movs	r3, #1
 800fe62:	e0a3      	b.n	800ffac <_printf_i+0x1f4>
 800fe64:	6825      	ldr	r5, [r4, #0]
 800fe66:	6808      	ldr	r0, [r1, #0]
 800fe68:	062e      	lsls	r6, r5, #24
 800fe6a:	f100 0304 	add.w	r3, r0, #4
 800fe6e:	d50a      	bpl.n	800fe86 <_printf_i+0xce>
 800fe70:	6805      	ldr	r5, [r0, #0]
 800fe72:	600b      	str	r3, [r1, #0]
 800fe74:	2d00      	cmp	r5, #0
 800fe76:	da03      	bge.n	800fe80 <_printf_i+0xc8>
 800fe78:	232d      	movs	r3, #45	; 0x2d
 800fe7a:	426d      	negs	r5, r5
 800fe7c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800fe80:	485e      	ldr	r0, [pc, #376]	; (800fffc <_printf_i+0x244>)
 800fe82:	230a      	movs	r3, #10
 800fe84:	e019      	b.n	800feba <_printf_i+0x102>
 800fe86:	f015 0f40 	tst.w	r5, #64	; 0x40
 800fe8a:	6805      	ldr	r5, [r0, #0]
 800fe8c:	600b      	str	r3, [r1, #0]
 800fe8e:	bf18      	it	ne
 800fe90:	b22d      	sxthne	r5, r5
 800fe92:	e7ef      	b.n	800fe74 <_printf_i+0xbc>
 800fe94:	680b      	ldr	r3, [r1, #0]
 800fe96:	6825      	ldr	r5, [r4, #0]
 800fe98:	1d18      	adds	r0, r3, #4
 800fe9a:	6008      	str	r0, [r1, #0]
 800fe9c:	0628      	lsls	r0, r5, #24
 800fe9e:	d501      	bpl.n	800fea4 <_printf_i+0xec>
 800fea0:	681d      	ldr	r5, [r3, #0]
 800fea2:	e002      	b.n	800feaa <_printf_i+0xf2>
 800fea4:	0669      	lsls	r1, r5, #25
 800fea6:	d5fb      	bpl.n	800fea0 <_printf_i+0xe8>
 800fea8:	881d      	ldrh	r5, [r3, #0]
 800feaa:	4854      	ldr	r0, [pc, #336]	; (800fffc <_printf_i+0x244>)
 800feac:	2f6f      	cmp	r7, #111	; 0x6f
 800feae:	bf0c      	ite	eq
 800feb0:	2308      	moveq	r3, #8
 800feb2:	230a      	movne	r3, #10
 800feb4:	2100      	movs	r1, #0
 800feb6:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 800feba:	6866      	ldr	r6, [r4, #4]
 800febc:	60a6      	str	r6, [r4, #8]
 800febe:	2e00      	cmp	r6, #0
 800fec0:	bfa2      	ittt	ge
 800fec2:	6821      	ldrge	r1, [r4, #0]
 800fec4:	f021 0104 	bicge.w	r1, r1, #4
 800fec8:	6021      	strge	r1, [r4, #0]
 800feca:	b90d      	cbnz	r5, 800fed0 <_printf_i+0x118>
 800fecc:	2e00      	cmp	r6, #0
 800fece:	d04d      	beq.n	800ff6c <_printf_i+0x1b4>
 800fed0:	4616      	mov	r6, r2
 800fed2:	fbb5 f1f3 	udiv	r1, r5, r3
 800fed6:	fb03 5711 	mls	r7, r3, r1, r5
 800feda:	5dc7      	ldrb	r7, [r0, r7]
 800fedc:	f806 7d01 	strb.w	r7, [r6, #-1]!
 800fee0:	462f      	mov	r7, r5
 800fee2:	42bb      	cmp	r3, r7
 800fee4:	460d      	mov	r5, r1
 800fee6:	d9f4      	bls.n	800fed2 <_printf_i+0x11a>
 800fee8:	2b08      	cmp	r3, #8
 800feea:	d10b      	bne.n	800ff04 <_printf_i+0x14c>
 800feec:	6823      	ldr	r3, [r4, #0]
 800feee:	07df      	lsls	r7, r3, #31
 800fef0:	d508      	bpl.n	800ff04 <_printf_i+0x14c>
 800fef2:	6923      	ldr	r3, [r4, #16]
 800fef4:	6861      	ldr	r1, [r4, #4]
 800fef6:	4299      	cmp	r1, r3
 800fef8:	bfde      	ittt	le
 800fefa:	2330      	movle	r3, #48	; 0x30
 800fefc:	f806 3c01 	strble.w	r3, [r6, #-1]
 800ff00:	f106 36ff 	addle.w	r6, r6, #4294967295
 800ff04:	1b92      	subs	r2, r2, r6
 800ff06:	6122      	str	r2, [r4, #16]
 800ff08:	f8cd a000 	str.w	sl, [sp]
 800ff0c:	464b      	mov	r3, r9
 800ff0e:	aa03      	add	r2, sp, #12
 800ff10:	4621      	mov	r1, r4
 800ff12:	4640      	mov	r0, r8
 800ff14:	f7ff fee2 	bl	800fcdc <_printf_common>
 800ff18:	3001      	adds	r0, #1
 800ff1a:	d14c      	bne.n	800ffb6 <_printf_i+0x1fe>
 800ff1c:	f04f 30ff 	mov.w	r0, #4294967295
 800ff20:	b004      	add	sp, #16
 800ff22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ff26:	4835      	ldr	r0, [pc, #212]	; (800fffc <_printf_i+0x244>)
 800ff28:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800ff2c:	6823      	ldr	r3, [r4, #0]
 800ff2e:	680e      	ldr	r6, [r1, #0]
 800ff30:	061f      	lsls	r7, r3, #24
 800ff32:	f856 5b04 	ldr.w	r5, [r6], #4
 800ff36:	600e      	str	r6, [r1, #0]
 800ff38:	d514      	bpl.n	800ff64 <_printf_i+0x1ac>
 800ff3a:	07d9      	lsls	r1, r3, #31
 800ff3c:	bf44      	itt	mi
 800ff3e:	f043 0320 	orrmi.w	r3, r3, #32
 800ff42:	6023      	strmi	r3, [r4, #0]
 800ff44:	b91d      	cbnz	r5, 800ff4e <_printf_i+0x196>
 800ff46:	6823      	ldr	r3, [r4, #0]
 800ff48:	f023 0320 	bic.w	r3, r3, #32
 800ff4c:	6023      	str	r3, [r4, #0]
 800ff4e:	2310      	movs	r3, #16
 800ff50:	e7b0      	b.n	800feb4 <_printf_i+0xfc>
 800ff52:	6823      	ldr	r3, [r4, #0]
 800ff54:	f043 0320 	orr.w	r3, r3, #32
 800ff58:	6023      	str	r3, [r4, #0]
 800ff5a:	2378      	movs	r3, #120	; 0x78
 800ff5c:	4828      	ldr	r0, [pc, #160]	; (8010000 <_printf_i+0x248>)
 800ff5e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 800ff62:	e7e3      	b.n	800ff2c <_printf_i+0x174>
 800ff64:	065e      	lsls	r6, r3, #25
 800ff66:	bf48      	it	mi
 800ff68:	b2ad      	uxthmi	r5, r5
 800ff6a:	e7e6      	b.n	800ff3a <_printf_i+0x182>
 800ff6c:	4616      	mov	r6, r2
 800ff6e:	e7bb      	b.n	800fee8 <_printf_i+0x130>
 800ff70:	680b      	ldr	r3, [r1, #0]
 800ff72:	6826      	ldr	r6, [r4, #0]
 800ff74:	6960      	ldr	r0, [r4, #20]
 800ff76:	1d1d      	adds	r5, r3, #4
 800ff78:	600d      	str	r5, [r1, #0]
 800ff7a:	0635      	lsls	r5, r6, #24
 800ff7c:	681b      	ldr	r3, [r3, #0]
 800ff7e:	d501      	bpl.n	800ff84 <_printf_i+0x1cc>
 800ff80:	6018      	str	r0, [r3, #0]
 800ff82:	e002      	b.n	800ff8a <_printf_i+0x1d2>
 800ff84:	0671      	lsls	r1, r6, #25
 800ff86:	d5fb      	bpl.n	800ff80 <_printf_i+0x1c8>
 800ff88:	8018      	strh	r0, [r3, #0]
 800ff8a:	2300      	movs	r3, #0
 800ff8c:	6123      	str	r3, [r4, #16]
 800ff8e:	4616      	mov	r6, r2
 800ff90:	e7ba      	b.n	800ff08 <_printf_i+0x150>
 800ff92:	680b      	ldr	r3, [r1, #0]
 800ff94:	1d1a      	adds	r2, r3, #4
 800ff96:	600a      	str	r2, [r1, #0]
 800ff98:	681e      	ldr	r6, [r3, #0]
 800ff9a:	6862      	ldr	r2, [r4, #4]
 800ff9c:	2100      	movs	r1, #0
 800ff9e:	4630      	mov	r0, r6
 800ffa0:	f7f0 f8f6 	bl	8000190 <memchr>
 800ffa4:	b108      	cbz	r0, 800ffaa <_printf_i+0x1f2>
 800ffa6:	1b80      	subs	r0, r0, r6
 800ffa8:	6060      	str	r0, [r4, #4]
 800ffaa:	6863      	ldr	r3, [r4, #4]
 800ffac:	6123      	str	r3, [r4, #16]
 800ffae:	2300      	movs	r3, #0
 800ffb0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800ffb4:	e7a8      	b.n	800ff08 <_printf_i+0x150>
 800ffb6:	6923      	ldr	r3, [r4, #16]
 800ffb8:	4632      	mov	r2, r6
 800ffba:	4649      	mov	r1, r9
 800ffbc:	4640      	mov	r0, r8
 800ffbe:	47d0      	blx	sl
 800ffc0:	3001      	adds	r0, #1
 800ffc2:	d0ab      	beq.n	800ff1c <_printf_i+0x164>
 800ffc4:	6823      	ldr	r3, [r4, #0]
 800ffc6:	079b      	lsls	r3, r3, #30
 800ffc8:	d413      	bmi.n	800fff2 <_printf_i+0x23a>
 800ffca:	68e0      	ldr	r0, [r4, #12]
 800ffcc:	9b03      	ldr	r3, [sp, #12]
 800ffce:	4298      	cmp	r0, r3
 800ffd0:	bfb8      	it	lt
 800ffd2:	4618      	movlt	r0, r3
 800ffd4:	e7a4      	b.n	800ff20 <_printf_i+0x168>
 800ffd6:	2301      	movs	r3, #1
 800ffd8:	4632      	mov	r2, r6
 800ffda:	4649      	mov	r1, r9
 800ffdc:	4640      	mov	r0, r8
 800ffde:	47d0      	blx	sl
 800ffe0:	3001      	adds	r0, #1
 800ffe2:	d09b      	beq.n	800ff1c <_printf_i+0x164>
 800ffe4:	3501      	adds	r5, #1
 800ffe6:	68e3      	ldr	r3, [r4, #12]
 800ffe8:	9903      	ldr	r1, [sp, #12]
 800ffea:	1a5b      	subs	r3, r3, r1
 800ffec:	42ab      	cmp	r3, r5
 800ffee:	dcf2      	bgt.n	800ffd6 <_printf_i+0x21e>
 800fff0:	e7eb      	b.n	800ffca <_printf_i+0x212>
 800fff2:	2500      	movs	r5, #0
 800fff4:	f104 0619 	add.w	r6, r4, #25
 800fff8:	e7f5      	b.n	800ffe6 <_printf_i+0x22e>
 800fffa:	bf00      	nop
 800fffc:	0801118a 	.word	0x0801118a
 8010000:	0801119b 	.word	0x0801119b

08010004 <memcpy>:
 8010004:	440a      	add	r2, r1
 8010006:	4291      	cmp	r1, r2
 8010008:	f100 33ff 	add.w	r3, r0, #4294967295
 801000c:	d100      	bne.n	8010010 <memcpy+0xc>
 801000e:	4770      	bx	lr
 8010010:	b510      	push	{r4, lr}
 8010012:	f811 4b01 	ldrb.w	r4, [r1], #1
 8010016:	f803 4f01 	strb.w	r4, [r3, #1]!
 801001a:	4291      	cmp	r1, r2
 801001c:	d1f9      	bne.n	8010012 <memcpy+0xe>
 801001e:	bd10      	pop	{r4, pc}

08010020 <memmove>:
 8010020:	4288      	cmp	r0, r1
 8010022:	b510      	push	{r4, lr}
 8010024:	eb01 0402 	add.w	r4, r1, r2
 8010028:	d902      	bls.n	8010030 <memmove+0x10>
 801002a:	4284      	cmp	r4, r0
 801002c:	4623      	mov	r3, r4
 801002e:	d807      	bhi.n	8010040 <memmove+0x20>
 8010030:	1e43      	subs	r3, r0, #1
 8010032:	42a1      	cmp	r1, r4
 8010034:	d008      	beq.n	8010048 <memmove+0x28>
 8010036:	f811 2b01 	ldrb.w	r2, [r1], #1
 801003a:	f803 2f01 	strb.w	r2, [r3, #1]!
 801003e:	e7f8      	b.n	8010032 <memmove+0x12>
 8010040:	4402      	add	r2, r0
 8010042:	4601      	mov	r1, r0
 8010044:	428a      	cmp	r2, r1
 8010046:	d100      	bne.n	801004a <memmove+0x2a>
 8010048:	bd10      	pop	{r4, pc}
 801004a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 801004e:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8010052:	e7f7      	b.n	8010044 <memmove+0x24>

08010054 <_free_r>:
 8010054:	b538      	push	{r3, r4, r5, lr}
 8010056:	4605      	mov	r5, r0
 8010058:	2900      	cmp	r1, #0
 801005a:	d045      	beq.n	80100e8 <_free_r+0x94>
 801005c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8010060:	1f0c      	subs	r4, r1, #4
 8010062:	2b00      	cmp	r3, #0
 8010064:	bfb8      	it	lt
 8010066:	18e4      	addlt	r4, r4, r3
 8010068:	f000 f8d2 	bl	8010210 <__malloc_lock>
 801006c:	4a1f      	ldr	r2, [pc, #124]	; (80100ec <_free_r+0x98>)
 801006e:	6813      	ldr	r3, [r2, #0]
 8010070:	4610      	mov	r0, r2
 8010072:	b933      	cbnz	r3, 8010082 <_free_r+0x2e>
 8010074:	6063      	str	r3, [r4, #4]
 8010076:	6014      	str	r4, [r2, #0]
 8010078:	4628      	mov	r0, r5
 801007a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801007e:	f000 b8cd 	b.w	801021c <__malloc_unlock>
 8010082:	42a3      	cmp	r3, r4
 8010084:	d90b      	bls.n	801009e <_free_r+0x4a>
 8010086:	6821      	ldr	r1, [r4, #0]
 8010088:	1862      	adds	r2, r4, r1
 801008a:	4293      	cmp	r3, r2
 801008c:	bf04      	itt	eq
 801008e:	681a      	ldreq	r2, [r3, #0]
 8010090:	685b      	ldreq	r3, [r3, #4]
 8010092:	6063      	str	r3, [r4, #4]
 8010094:	bf04      	itt	eq
 8010096:	1852      	addeq	r2, r2, r1
 8010098:	6022      	streq	r2, [r4, #0]
 801009a:	6004      	str	r4, [r0, #0]
 801009c:	e7ec      	b.n	8010078 <_free_r+0x24>
 801009e:	461a      	mov	r2, r3
 80100a0:	685b      	ldr	r3, [r3, #4]
 80100a2:	b10b      	cbz	r3, 80100a8 <_free_r+0x54>
 80100a4:	42a3      	cmp	r3, r4
 80100a6:	d9fa      	bls.n	801009e <_free_r+0x4a>
 80100a8:	6811      	ldr	r1, [r2, #0]
 80100aa:	1850      	adds	r0, r2, r1
 80100ac:	42a0      	cmp	r0, r4
 80100ae:	d10b      	bne.n	80100c8 <_free_r+0x74>
 80100b0:	6820      	ldr	r0, [r4, #0]
 80100b2:	4401      	add	r1, r0
 80100b4:	1850      	adds	r0, r2, r1
 80100b6:	4283      	cmp	r3, r0
 80100b8:	6011      	str	r1, [r2, #0]
 80100ba:	d1dd      	bne.n	8010078 <_free_r+0x24>
 80100bc:	6818      	ldr	r0, [r3, #0]
 80100be:	685b      	ldr	r3, [r3, #4]
 80100c0:	6053      	str	r3, [r2, #4]
 80100c2:	4401      	add	r1, r0
 80100c4:	6011      	str	r1, [r2, #0]
 80100c6:	e7d7      	b.n	8010078 <_free_r+0x24>
 80100c8:	d902      	bls.n	80100d0 <_free_r+0x7c>
 80100ca:	230c      	movs	r3, #12
 80100cc:	602b      	str	r3, [r5, #0]
 80100ce:	e7d3      	b.n	8010078 <_free_r+0x24>
 80100d0:	6820      	ldr	r0, [r4, #0]
 80100d2:	1821      	adds	r1, r4, r0
 80100d4:	428b      	cmp	r3, r1
 80100d6:	bf04      	itt	eq
 80100d8:	6819      	ldreq	r1, [r3, #0]
 80100da:	685b      	ldreq	r3, [r3, #4]
 80100dc:	6063      	str	r3, [r4, #4]
 80100de:	bf04      	itt	eq
 80100e0:	1809      	addeq	r1, r1, r0
 80100e2:	6021      	streq	r1, [r4, #0]
 80100e4:	6054      	str	r4, [r2, #4]
 80100e6:	e7c7      	b.n	8010078 <_free_r+0x24>
 80100e8:	bd38      	pop	{r3, r4, r5, pc}
 80100ea:	bf00      	nop
 80100ec:	200018d8 	.word	0x200018d8

080100f0 <_malloc_r>:
 80100f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80100f2:	1ccd      	adds	r5, r1, #3
 80100f4:	f025 0503 	bic.w	r5, r5, #3
 80100f8:	3508      	adds	r5, #8
 80100fa:	2d0c      	cmp	r5, #12
 80100fc:	bf38      	it	cc
 80100fe:	250c      	movcc	r5, #12
 8010100:	2d00      	cmp	r5, #0
 8010102:	4606      	mov	r6, r0
 8010104:	db01      	blt.n	801010a <_malloc_r+0x1a>
 8010106:	42a9      	cmp	r1, r5
 8010108:	d903      	bls.n	8010112 <_malloc_r+0x22>
 801010a:	230c      	movs	r3, #12
 801010c:	6033      	str	r3, [r6, #0]
 801010e:	2000      	movs	r0, #0
 8010110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8010112:	f000 f87d 	bl	8010210 <__malloc_lock>
 8010116:	4921      	ldr	r1, [pc, #132]	; (801019c <_malloc_r+0xac>)
 8010118:	680a      	ldr	r2, [r1, #0]
 801011a:	4614      	mov	r4, r2
 801011c:	b99c      	cbnz	r4, 8010146 <_malloc_r+0x56>
 801011e:	4f20      	ldr	r7, [pc, #128]	; (80101a0 <_malloc_r+0xb0>)
 8010120:	683b      	ldr	r3, [r7, #0]
 8010122:	b923      	cbnz	r3, 801012e <_malloc_r+0x3e>
 8010124:	4621      	mov	r1, r4
 8010126:	4630      	mov	r0, r6
 8010128:	f000 f862 	bl	80101f0 <_sbrk_r>
 801012c:	6038      	str	r0, [r7, #0]
 801012e:	4629      	mov	r1, r5
 8010130:	4630      	mov	r0, r6
 8010132:	f000 f85d 	bl	80101f0 <_sbrk_r>
 8010136:	1c43      	adds	r3, r0, #1
 8010138:	d123      	bne.n	8010182 <_malloc_r+0x92>
 801013a:	230c      	movs	r3, #12
 801013c:	6033      	str	r3, [r6, #0]
 801013e:	4630      	mov	r0, r6
 8010140:	f000 f86c 	bl	801021c <__malloc_unlock>
 8010144:	e7e3      	b.n	801010e <_malloc_r+0x1e>
 8010146:	6823      	ldr	r3, [r4, #0]
 8010148:	1b5b      	subs	r3, r3, r5
 801014a:	d417      	bmi.n	801017c <_malloc_r+0x8c>
 801014c:	2b0b      	cmp	r3, #11
 801014e:	d903      	bls.n	8010158 <_malloc_r+0x68>
 8010150:	6023      	str	r3, [r4, #0]
 8010152:	441c      	add	r4, r3
 8010154:	6025      	str	r5, [r4, #0]
 8010156:	e004      	b.n	8010162 <_malloc_r+0x72>
 8010158:	6863      	ldr	r3, [r4, #4]
 801015a:	42a2      	cmp	r2, r4
 801015c:	bf0c      	ite	eq
 801015e:	600b      	streq	r3, [r1, #0]
 8010160:	6053      	strne	r3, [r2, #4]
 8010162:	4630      	mov	r0, r6
 8010164:	f000 f85a 	bl	801021c <__malloc_unlock>
 8010168:	f104 000b 	add.w	r0, r4, #11
 801016c:	1d23      	adds	r3, r4, #4
 801016e:	f020 0007 	bic.w	r0, r0, #7
 8010172:	1ac2      	subs	r2, r0, r3
 8010174:	d0cc      	beq.n	8010110 <_malloc_r+0x20>
 8010176:	1a1b      	subs	r3, r3, r0
 8010178:	50a3      	str	r3, [r4, r2]
 801017a:	e7c9      	b.n	8010110 <_malloc_r+0x20>
 801017c:	4622      	mov	r2, r4
 801017e:	6864      	ldr	r4, [r4, #4]
 8010180:	e7cc      	b.n	801011c <_malloc_r+0x2c>
 8010182:	1cc4      	adds	r4, r0, #3
 8010184:	f024 0403 	bic.w	r4, r4, #3
 8010188:	42a0      	cmp	r0, r4
 801018a:	d0e3      	beq.n	8010154 <_malloc_r+0x64>
 801018c:	1a21      	subs	r1, r4, r0
 801018e:	4630      	mov	r0, r6
 8010190:	f000 f82e 	bl	80101f0 <_sbrk_r>
 8010194:	3001      	adds	r0, #1
 8010196:	d1dd      	bne.n	8010154 <_malloc_r+0x64>
 8010198:	e7cf      	b.n	801013a <_malloc_r+0x4a>
 801019a:	bf00      	nop
 801019c:	200018d8 	.word	0x200018d8
 80101a0:	200018dc 	.word	0x200018dc

080101a4 <_realloc_r>:
 80101a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80101a6:	4607      	mov	r7, r0
 80101a8:	4614      	mov	r4, r2
 80101aa:	460e      	mov	r6, r1
 80101ac:	b921      	cbnz	r1, 80101b8 <_realloc_r+0x14>
 80101ae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80101b2:	4611      	mov	r1, r2
 80101b4:	f7ff bf9c 	b.w	80100f0 <_malloc_r>
 80101b8:	b922      	cbnz	r2, 80101c4 <_realloc_r+0x20>
 80101ba:	f7ff ff4b 	bl	8010054 <_free_r>
 80101be:	4625      	mov	r5, r4
 80101c0:	4628      	mov	r0, r5
 80101c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80101c4:	f000 f830 	bl	8010228 <_malloc_usable_size_r>
 80101c8:	42a0      	cmp	r0, r4
 80101ca:	d20f      	bcs.n	80101ec <_realloc_r+0x48>
 80101cc:	4621      	mov	r1, r4
 80101ce:	4638      	mov	r0, r7
 80101d0:	f7ff ff8e 	bl	80100f0 <_malloc_r>
 80101d4:	4605      	mov	r5, r0
 80101d6:	2800      	cmp	r0, #0
 80101d8:	d0f2      	beq.n	80101c0 <_realloc_r+0x1c>
 80101da:	4631      	mov	r1, r6
 80101dc:	4622      	mov	r2, r4
 80101de:	f7ff ff11 	bl	8010004 <memcpy>
 80101e2:	4631      	mov	r1, r6
 80101e4:	4638      	mov	r0, r7
 80101e6:	f7ff ff35 	bl	8010054 <_free_r>
 80101ea:	e7e9      	b.n	80101c0 <_realloc_r+0x1c>
 80101ec:	4635      	mov	r5, r6
 80101ee:	e7e7      	b.n	80101c0 <_realloc_r+0x1c>

080101f0 <_sbrk_r>:
 80101f0:	b538      	push	{r3, r4, r5, lr}
 80101f2:	4d06      	ldr	r5, [pc, #24]	; (801020c <_sbrk_r+0x1c>)
 80101f4:	2300      	movs	r3, #0
 80101f6:	4604      	mov	r4, r0
 80101f8:	4608      	mov	r0, r1
 80101fa:	602b      	str	r3, [r5, #0]
 80101fc:	f7f1 f9d6 	bl	80015ac <_sbrk>
 8010200:	1c43      	adds	r3, r0, #1
 8010202:	d102      	bne.n	801020a <_sbrk_r+0x1a>
 8010204:	682b      	ldr	r3, [r5, #0]
 8010206:	b103      	cbz	r3, 801020a <_sbrk_r+0x1a>
 8010208:	6023      	str	r3, [r4, #0]
 801020a:	bd38      	pop	{r3, r4, r5, pc}
 801020c:	20001b7c 	.word	0x20001b7c

08010210 <__malloc_lock>:
 8010210:	4801      	ldr	r0, [pc, #4]	; (8010218 <__malloc_lock+0x8>)
 8010212:	f000 b811 	b.w	8010238 <__retarget_lock_acquire_recursive>
 8010216:	bf00      	nop
 8010218:	20001b84 	.word	0x20001b84

0801021c <__malloc_unlock>:
 801021c:	4801      	ldr	r0, [pc, #4]	; (8010224 <__malloc_unlock+0x8>)
 801021e:	f000 b80c 	b.w	801023a <__retarget_lock_release_recursive>
 8010222:	bf00      	nop
 8010224:	20001b84 	.word	0x20001b84

08010228 <_malloc_usable_size_r>:
 8010228:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801022c:	1f18      	subs	r0, r3, #4
 801022e:	2b00      	cmp	r3, #0
 8010230:	bfbc      	itt	lt
 8010232:	580b      	ldrlt	r3, [r1, r0]
 8010234:	18c0      	addlt	r0, r0, r3
 8010236:	4770      	bx	lr

08010238 <__retarget_lock_acquire_recursive>:
 8010238:	4770      	bx	lr

0801023a <__retarget_lock_release_recursive>:
 801023a:	4770      	bx	lr
 801023c:	0000      	movs	r0, r0
	...

08010240 <floor>:
 8010240:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010244:	f3c1 580a 	ubfx	r8, r1, #20, #11
 8010248:	f2a8 36ff 	subw	r6, r8, #1023	; 0x3ff
 801024c:	2e13      	cmp	r6, #19
 801024e:	4602      	mov	r2, r0
 8010250:	460b      	mov	r3, r1
 8010252:	4607      	mov	r7, r0
 8010254:	460c      	mov	r4, r1
 8010256:	4605      	mov	r5, r0
 8010258:	dc34      	bgt.n	80102c4 <floor+0x84>
 801025a:	2e00      	cmp	r6, #0
 801025c:	da15      	bge.n	801028a <floor+0x4a>
 801025e:	a334      	add	r3, pc, #208	; (adr r3, 8010330 <floor+0xf0>)
 8010260:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010264:	f7ef ffea 	bl	800023c <__adddf3>
 8010268:	2200      	movs	r2, #0
 801026a:	2300      	movs	r3, #0
 801026c:	f7f0 fa1a 	bl	80006a4 <__aeabi_dcmpgt>
 8010270:	b140      	cbz	r0, 8010284 <floor+0x44>
 8010272:	2c00      	cmp	r4, #0
 8010274:	da59      	bge.n	801032a <floor+0xea>
 8010276:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 801027a:	ea57 0503 	orrs.w	r5, r7, r3
 801027e:	d001      	beq.n	8010284 <floor+0x44>
 8010280:	4c2d      	ldr	r4, [pc, #180]	; (8010338 <floor+0xf8>)
 8010282:	2500      	movs	r5, #0
 8010284:	4623      	mov	r3, r4
 8010286:	462f      	mov	r7, r5
 8010288:	e025      	b.n	80102d6 <floor+0x96>
 801028a:	4a2c      	ldr	r2, [pc, #176]	; (801033c <floor+0xfc>)
 801028c:	fa42 f806 	asr.w	r8, r2, r6
 8010290:	ea01 0208 	and.w	r2, r1, r8
 8010294:	4302      	orrs	r2, r0
 8010296:	d01e      	beq.n	80102d6 <floor+0x96>
 8010298:	a325      	add	r3, pc, #148	; (adr r3, 8010330 <floor+0xf0>)
 801029a:	e9d3 2300 	ldrd	r2, r3, [r3]
 801029e:	f7ef ffcd 	bl	800023c <__adddf3>
 80102a2:	2200      	movs	r2, #0
 80102a4:	2300      	movs	r3, #0
 80102a6:	f7f0 f9fd 	bl	80006a4 <__aeabi_dcmpgt>
 80102aa:	2800      	cmp	r0, #0
 80102ac:	d0ea      	beq.n	8010284 <floor+0x44>
 80102ae:	2c00      	cmp	r4, #0
 80102b0:	bfbe      	ittt	lt
 80102b2:	f44f 1380 	movlt.w	r3, #1048576	; 0x100000
 80102b6:	fa43 f606 	asrlt.w	r6, r3, r6
 80102ba:	19a4      	addlt	r4, r4, r6
 80102bc:	ea24 0408 	bic.w	r4, r4, r8
 80102c0:	2500      	movs	r5, #0
 80102c2:	e7df      	b.n	8010284 <floor+0x44>
 80102c4:	2e33      	cmp	r6, #51	; 0x33
 80102c6:	dd0a      	ble.n	80102de <floor+0x9e>
 80102c8:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 80102cc:	d103      	bne.n	80102d6 <floor+0x96>
 80102ce:	f7ef ffb5 	bl	800023c <__adddf3>
 80102d2:	4607      	mov	r7, r0
 80102d4:	460b      	mov	r3, r1
 80102d6:	4638      	mov	r0, r7
 80102d8:	4619      	mov	r1, r3
 80102da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80102de:	f2a8 4813 	subw	r8, r8, #1043	; 0x413
 80102e2:	f04f 32ff 	mov.w	r2, #4294967295
 80102e6:	fa22 f808 	lsr.w	r8, r2, r8
 80102ea:	ea18 0f00 	tst.w	r8, r0
 80102ee:	d0f2      	beq.n	80102d6 <floor+0x96>
 80102f0:	a30f      	add	r3, pc, #60	; (adr r3, 8010330 <floor+0xf0>)
 80102f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80102f6:	f7ef ffa1 	bl	800023c <__adddf3>
 80102fa:	2200      	movs	r2, #0
 80102fc:	2300      	movs	r3, #0
 80102fe:	f7f0 f9d1 	bl	80006a4 <__aeabi_dcmpgt>
 8010302:	2800      	cmp	r0, #0
 8010304:	d0be      	beq.n	8010284 <floor+0x44>
 8010306:	2c00      	cmp	r4, #0
 8010308:	da02      	bge.n	8010310 <floor+0xd0>
 801030a:	2e14      	cmp	r6, #20
 801030c:	d103      	bne.n	8010316 <floor+0xd6>
 801030e:	3401      	adds	r4, #1
 8010310:	ea25 0508 	bic.w	r5, r5, r8
 8010314:	e7b6      	b.n	8010284 <floor+0x44>
 8010316:	2301      	movs	r3, #1
 8010318:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
 801031c:	fa03 f606 	lsl.w	r6, r3, r6
 8010320:	4435      	add	r5, r6
 8010322:	42bd      	cmp	r5, r7
 8010324:	bf38      	it	cc
 8010326:	18e4      	addcc	r4, r4, r3
 8010328:	e7f2      	b.n	8010310 <floor+0xd0>
 801032a:	2500      	movs	r5, #0
 801032c:	462c      	mov	r4, r5
 801032e:	e7a9      	b.n	8010284 <floor+0x44>
 8010330:	8800759c 	.word	0x8800759c
 8010334:	7e37e43c 	.word	0x7e37e43c
 8010338:	bff00000 	.word	0xbff00000
 801033c:	000fffff 	.word	0x000fffff

08010340 <_init>:
 8010340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010342:	bf00      	nop
 8010344:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8010346:	bc08      	pop	{r3}
 8010348:	469e      	mov	lr, r3
 801034a:	4770      	bx	lr

0801034c <_fini>:
 801034c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801034e:	bf00      	nop
 8010350:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8010352:	bc08      	pop	{r3}
 8010354:	469e      	mov	lr, r3
 8010356:	4770      	bx	lr
